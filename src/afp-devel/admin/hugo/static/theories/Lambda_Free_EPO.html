<div id="Embeddings">
<div class="head"><h1>Theory Embeddings</h1>
<span class="command">theory</span> <span class="name">Embeddings</span><br/>
<span class="keyword">imports</span> <a href="Lambda_Free_Term.html"><span class="name">Lambda_Free_Term</span></a> <a href="Extension_Orders.html"><span class="name">Extension_Orders</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       The Embedding Relation for Lambda-Free Higher-Order Terms
    Author:      Alexander Bentkamp &lt;a.bentkamp at vu.nl&gt;, 2018
    Maintainer:  Alexander Bentkamp &lt;a.bentkamp at vu.nl&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Embedding Relation for Lambda-Free Higher-Order Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Embeddings</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Lambda_Free_RPOs.Lambda_Free_Term</span><span> </span><span>Lambda_Free_RPOs.Extension_Orders</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Positions of terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>dir</span><span> </span><span class="delimiter">=</span><span> </span><span>Left</span><span> </span><span class="delimiter">|</span><span> </span><span>Right</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>position_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s,'v) tm ⇒ dir list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>position_of_Nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of _ [] = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>position_of_Hd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of (Hd _) (_#_) = False"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>position_of_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of (App t s) (Left # ds) = position_of t ds"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>position_of_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of (App t s) (Right # ds) = position_of s ds"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>opp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"dir ⇒ dir"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"opp d = (if d = Right then Left else Right)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>opp_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"opp Right = Left"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"opp Left = Right"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>opp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shallower_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of t (p @ q @ [dq]) ⟹ position_of t (p @ [dp])"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>position_of_Hd</span><span> </span><span>Nil_is_append_conv</span><span> </span><span>list.exhaust</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>position_of_Nil</span><span> </span><span>position_of_left</span><span>
</span><span>        </span><span>position_of_right</span><span> </span><span>dir.exhaust</span><span> </span><span>self_append_conv2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>position_of_Hd</span><span> </span><span>position_of_left</span><span> </span><span>append_Cons</span><span> </span><span>args.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>position_of_Hd</span><span> </span><span>position_of_right</span><span> </span><span>append_Cons</span><span> </span><span>args.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_position_replicate_num_args</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ position_of t (replicate (num_args t) Left @ [d])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args t"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Hd t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0.hyps"</span></span></span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>position_of.elims</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>snoc_eq_iff_butlast</span><span> </span><span>tm.discI</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ position_of (fun t) (replicate (num_args (fun t)) dir.Left @ [d])"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"fun t"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc</span><span> </span><span>Suc_inject</span><span> </span><span>args.elims</span><span> </span><span>length_0_conv</span><span> </span><span>length_append_singleton</span><span> </span><span>nat.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ds. replicate (num_args t) dir.Left @ [d] ≠ dir.Right # ds"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>dir.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>hd_append</span><span> </span><span>hd_replicate</span><span> </span><span>length_0_conv</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>replicate_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>position_of.elims</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"(replicate (num_args t) dir.Left @ [d])"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>position_of_left</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ position_of (fun t) (replicate (num_args (fun t)) dir.Left @ [d])›</span></span></span><span> 
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>append_Cons</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>length_append_singleton</span><span> </span><span>replicate_Suc</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shorten_position</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"position_of t (p @ q) ⟹ position_of t p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>position_of_Nil</span><span> </span><span>append_assoc</span><span> </span><span>append_butlast_last_id</span><span> </span><span>shallower_pos</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Embedding step›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Embedding step at a given position. If the position is not present, default to identity.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>emb_step_at</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"dir list ⇒ dir ⇒ ('s, 'v) tm  ⇒ ('s, 'v) tm"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>emb_step_at_left</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"emb_step_at [] Left (App t s) = t"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>emb_step_at_right</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"emb_step_at [] Right (App t s) = s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>emb_step_at_left_context</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"emb_step_at (Left # p) dir (App t s) = App (emb_step_at p dir t) s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>emb_step_at_right_context</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"emb_step_at (Right # p) dir (App t s) = App t (emb_step_at p dir s)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>emb_step_at_head</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"emb_step_at _ _ (Hd h) = Hd h"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at' p t == emb_step_at (butlast p) (last p) t"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>emb_step_at_induct</span><span> </span><span class="delimiter">=</span><span> </span><span>emb_step_at.induct</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>left</span><span> </span><span>right</span><span> </span><span>left_context</span><span> </span><span>right_context</span><span> </span><span>head</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_at_is_App</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"emb_step_at p d u ≠ u ⟹ is_App u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_at.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>is_Hd_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of an embedding step without using positions.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>emb_step</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"→<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span>left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(App t1 t2) →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> t1"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(App t1 t2) →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> t2"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>context_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ (App t u) →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> (App s u)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>context_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ (App u t) →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> (App u s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The two definitions of an embedding step are equivalent:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step t s ⟷ (∃p d. emb_step_at p d t = s) ∧ t ≠ s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ (∃p d. emb_step_at p d t = s) ∧ t ≠ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span>emb_step.induct</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>left</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_Suc_right</span><span> </span><span>emb_step_at.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>leD</span><span> </span><span>le_add_same_cancel1</span><span> </span><span>le_imp_less_Suc</span><span> </span><span>tm.size</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>zero_order</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>right</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.right_neutral</span><span> </span><span>add_le_cancel_left</span><span> </span><span>antisym</span><span> </span><span>emb_step_at.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>le_add_same_cancel2</span><span> </span><span>le_imp_less_Suc</span><span> </span><span>length_greater_0_conv</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>tm.size</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>zero_order</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>context_left</span><span> </span><span>t</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at p d t = s"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>context_left.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. emb_step_at (Left # p) d (App t u) = App s u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_at.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>context_left.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>context_right</span><span> </span><span>t</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at p d t = s"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>context_right.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. emb_step_at (Right # p) d (App u t) = App u s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_at.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>context_right.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃p d. emb_step_at p d t = s) ∧ t ≠ s ⟹ t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃p d. emb_step_at p d t = s) ∧ t ≠ s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at p d t = s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span>emb_step_at_induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>left</span><span> </span><span>u1</span><span> </span><span>u2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>left</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>emb_step_at.elims</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step.left</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>right</span><span> </span><span>u1</span><span> </span><span>u2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>right</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>emb_step_at.elims</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step.right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>left_context</span><span> </span><span>u1</span><span> </span><span>u2</span><span> </span><span>t'</span><span> </span><span>s'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_at_left_context</span><span> </span><span>emb_step.simps</span><span> </span><span>emb_step_at_is_App</span><span> </span><span>left_context.hyps</span><span> </span><span>left_context.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>left_context.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>            </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.inject</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>right_context</span><span> </span><span>u1</span><span> </span><span>u2</span><span> </span><span>t'</span><span> </span><span>s'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_at_right_context</span><span> </span><span>emb_step.simps</span><span> </span><span>emb_step_at_is_App</span><span> </span><span>right_context.hyps</span><span> </span><span>right_context.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>right_context.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.inject</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>          
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>head</span><span> </span><span>uu</span><span> </span><span>uv</span><span> </span><span>h</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>head</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>emb_step_at.elims</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step.left</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step.right</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>head.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_fun</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t ⟹ t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> (fun t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step.intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_arg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t ⟹ t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> (arg t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_hsize</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ hsize t &gt; hsize s"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>emb_step.induct</span><span class="delimiter">;</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_vars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ vars s ⊆ vars t"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>emb_step.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_equiv'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step t s ⟷ (∃p. p ≠ [] ∧ emb_step_at' p t = s) ∧ t ≠ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>butlast_snoc</span><span> </span><span>emb_step_equiv</span><span> </span><span>last_snoc</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>snoc_eq_iff_butlast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>position_if_emb_step_at</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at p d t = u ⟹ t ≠ u ⟹ position_of t (p @ [d])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_at_head</span><span> </span><span>position_of_Nil</span><span> </span><span>append_self_conv2</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>position_of.elims</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>t1</span><span> </span><span>t2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_at_if_position</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"position_of t (p @ [d])"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> emb_step_at p d t"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">;</span><span>cases</span><span> </span><span>t</span><span class="delimiter">;</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>emb_step.left</span><span> </span><span>emb_step.right</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>context_left</span><span> </span><span>context_right</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>context_left</span><span> </span><span>context_right</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Embedding relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of an embedding as a sequence of embedding steps at given positions:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>emb_at</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(dir list × dir) list ⇒ ('s, 'v) tm  ⇒ ('s, 'v) tm"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>emb_at_Nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_at [] t = t"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>emb_at_Cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_at ((p,d) # ps) t = emb_step_at p d (emb_at ps t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of an embedding without using positions:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>emb</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> t"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u ⟹ u →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>emb_neq</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊳<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_neq t s ≡ t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ∧ t ≠ s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The two definitions coincide:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s) = (∃ps. emb_at ps t = s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ps. emb_at ps t = s ⟹ t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ps. emb_at ps t = s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ps</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_at ps t = s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ps</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>s</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>emb.refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>ps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>emb_at.elims</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.hyps</span><span> </span><span>emb.simps</span><span> </span><span>emb_step_equiv</span><span> </span><span>list.inject</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ ∃ps. emb_at ps t = s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>emb.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>refl</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_at_Nil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>t</span><span> </span><span>u</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_at_Cons</span><span> </span><span>emb_step_equiv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_at_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_at ps t = u ⟹ emb_at qs u = s ⟹ emb_at (qs @ ps) t = s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>qs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>s</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u ⟹ u ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_at_trans</span><span> </span><span>emb_equiv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_is_emb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>emb.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_hsize</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ hsize t ≥ hsize s"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>emb.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_hsize</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_prepend_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u ⟹ u ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_is_emb</span><span> </span><span>emb_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sub_emb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sub s t ⟹ t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span>sub.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>sub_refl</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>emb.refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>sub_fun</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_prepend_step</span><span> </span><span>right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>sub_arg</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_prepend_step</span><span> </span><span>left</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sequence_emb_steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟷ (∃us. us≠[] ∧ hd us = t ∧ last us = s ∧ (∀i. Suc i &lt; length us ⟶ us ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> us ! Suc i))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ ∃us. us≠[] ∧ hd us = t ∧ last us = s ∧ (∀i. Suc i &lt; length us ⟶ us ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> us ! Suc i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>emb.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>refl</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_less_eq</span><span> </span><span>add.right_neutral</span><span> </span><span>add_Suc_right</span><span> </span><span>append_Nil</span><span> </span><span>last_snoc</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>not_less_zero</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>t</span><span> </span><span>u</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>us</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"us ≠ []"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"hd us = t"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"last us = u"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀i. Suc i &lt; length us ⟶ us ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> us ! Suc i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (us @ [s]) = t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last (us @ [s]) = s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀i. Suc i &lt; length (us @ [s]) ⟶ (us @ [s]) ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> (us @ [s]) ! Suc i)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Suc_less_eq</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀i. Suc i &lt; length us ⟶ us ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> us ! Suc i›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹last us = u›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹us ≠ []›</span></span></span><span> 
</span><span>           </span><span>append_butlast_last_id</span><span> </span><span>length_append_singleton</span><span> </span><span>less_antisym</span><span> </span><span>nth_append</span><span> </span><span>nth_append_length</span><span> </span><span>step.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃us. us ≠ [] ∧ hd us = t ∧ last us = s ∧ (∀i. Suc i &lt; length us ⟶ us ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> us ! Suc i) ⟹ t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃us. us ≠ [] ∧ hd us = t ∧ last us = s ∧ (∀i. Suc i &lt; length us ⟶ us ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> us ! Suc i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>us</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"us ≠ []"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd us = t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last us = s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. Suc i &lt; length us ⟶ us ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> us ! Suc i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>us</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>us</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb.refl</span><span> </span><span>emb_step_is_emb</span><span> </span><span>emb_trans</span><span> </span><span>hd_conv_nth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_induct_reverse</span><span> </span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>refl</span><span> </span><span>step</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>emb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀t. P t t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀t u s. t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u ⟹ u ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ P u s ⟹ P t s"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">"P t s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>us</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"us≠[]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd us = t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last us = s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. Suc i &lt; length us ⟶ us ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> us ! Suc i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb</span><span> </span><span>sequence_emb_steps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>us'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"us' == tl us"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last ([t] @ us') = s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. i &lt; length us' ⟶ ([t] @ us') ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> ([t] @ us') ! Suc i"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹hd us = t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹last us = s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹us ≠ []›</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀i. Suc i &lt; length us ⟶ us ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> us ! Suc i›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹hd us = t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹us ≠ []›</span></span></span><span> </span><span>us'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>us'</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>us'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P a s"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_mono</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>last.simps</span><span> </span><span>length_Cons</span><span> </span><span>list.discI</span><span> </span><span>nth_Cons_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> a"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sequence_emb_steps</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>last_append</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>local.Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>local.Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>nth_Cons_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P a s›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_cases_reverse</span><span> </span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>refl</span><span> </span><span>step</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ (⋀t'. t = t' ⟹ s = t' ⟹ P) ⟹ (⋀t' u s'. t = t' ⟹ s = s' ⟹ t' →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u ⟹ u ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s' ⟹ P) ⟹ P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>emb_induct_reverse</span><span class="delimiter">;</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_vars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ vars s ⊆ vars t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>emb.induct</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_vars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_emb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ ground t ⟹ ground s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_vars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arg_emb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ set (args t) ⟹ t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sub_args</span><span> </span><span>sub_emb</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_at_subst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"position_of t (p @ [d])"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"emb_step_at p d (subst ρ t) = subst ρ (emb_step_at p d t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t1</span><span> </span><span>t2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = App t1 t2"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>position_of_Hd</span><span> </span><span>append_Nil</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t = App t1 t2›</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t1</span><span> </span><span>t2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = App t1 t2"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>position_of.elims</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.IH</span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ subst ρ t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> subst ρ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>emb_step.induct</span><span class="delimiter">;</span><span>
</span><span>      </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>emb_step.left</span><span> </span><span>emb_step.right</span><span> </span><span>context_left</span><span> </span><span>context_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t  ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ subst ρ t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> subst ρ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>emb.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>emb.refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb.step</span><span> </span><span>emb_step_subst</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_hsize_neq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"hsize t &gt; hsize s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>emb_cases_reverse</span><span> </span><span>emb_hsize</span><span> </span><span>emb_step_hsize</span><span> </span><span>leD</span><span> </span><span>le_imp_less_or_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹How are positions preserved under embedding steps?›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Disjunct positions are preserved: For example, [L,R] is a position of f a (g b). When performing
an embedding step at [R,R] to obtain f a b, the position [L,R] still exists. (More precisely, it even
contains the same subterm, namely a.)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pos_emb_step_at_disjunct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"take (length q) p ≠ q"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"take (length p) q ≠ p"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"position_of t (p @ [d1]) ⟷ position_of  (emb_step_at q d2 t) (p @ [d1])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"length p + length q"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span>rule</span><span class="delimiter">:</span><span>less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>less</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Hd t ∨ p = [] ∨ q = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_at_is_App</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>take_eq_Nil</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t1</span><span> </span><span>t2</span><span> </span><span>p0</span><span> </span><span>p'</span><span> </span><span>q0</span><span> </span><span>q'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = App t1 t2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = p0 # p'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q = q0 # q'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.collapse</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p0</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>q0</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less.hyps</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Even if only the last element of a position differs from the position of an embedding step, that
position is preserved. For example, [L] is a position of f (g b). After performing an embedding step
at [R,R] to obtain f b, the position [L] still exists. (More precisely, it even
contains the same subterm, namely f.)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pos_emb_step_at_opp</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"position_of t (p@[d1]) ⟷ position_of (emb_step_at (p @ [opp d1] @ q) d2 t) (p@[d1])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>d1</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_at_left_context</span><span> </span><span>position_of_left</span><span> </span><span>append_Cons</span><span> </span><span>emb_step_at_is_App</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_at_right_context</span><span> </span><span>position_of_right</span><span> </span><span>append_Cons</span><span> </span><span>emb_step_at_is_App</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Positions are preserved under embedding steps below them:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pos_emb_step_at_nested</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of (emb_step_at (p @ [d1] @ q) d2 t) (p @ [d1]) ⟷ position_of t (p @ [d1])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>d1</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.hyps</span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Swapping embedding steps"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The order of embedding steps at disjunct position can be changed freely:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swap_disjunct_emb_step_at</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"length p ≤ length q ⟹ take (length p) q ≠ p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length q ≤ length p ⟹take (length q) p ≠ q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"emb_step_at q d2 (emb_step_at p d1 t) = emb_step_at p d1 (emb_step_at q d2 t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"length p + length q"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span>rule</span><span class="delimiter">:</span><span>less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>less</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Hd t ∨ p = [] ∨ q = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_at_is_App</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>take_eq_Nil</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_zero_eq</span><span> </span><span>nat_le_linear</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t1</span><span> </span><span>t2</span><span> </span><span>p0</span><span> </span><span>p'</span><span> </span><span>q0</span><span> </span><span>q'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = App t1 t2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = p0 # p'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q = q0 # q'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.collapse</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p0</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>q0</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less.hyps</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An embedding step inside the branch that is removed in a second embedding step is useless. 
For example, the embedding f (g b) -&gt;emb f b -&gt;emb f can achieved using a single step f (g b) -&gt;emb f.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_emb_step_at</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"emb_step_at p d1 (emb_step_at (p @ [opp d1] @ q) d2 t) = emb_step_at p d1 t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>d1</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>emb_step_at_left_context</span><span> </span><span>append_Cons</span><span> </span><span>emb_step_at_is_App</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>emb_step_at_right_context</span><span> </span><span>append_Cons</span><span> </span><span>emb_step_at_is_App</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹When swapping two embedding steps of a position below another, one of the positions has to be
slightly changed:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swap_nested_emb_step_at</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"emb_step_at (p @ q) d2 (emb_step_at p d1 t) = emb_step_at p d1 (emb_step_at (p @ [d1] @ q) d2 t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>d1</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.hyps</span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Performing embedding steps in order of a given priority"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We want to perform all embedding steps first that modify the head or the number of arguments
of a term. To this end we define the function prio\_emb\_step that performs the embedding step with
the highest priority possible. The priority is given by a function "prio" from positions to nats, where 
the lowest number has the highest priority.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prio_emb_pos</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(dir list ⇒ nat) ⇒ ('s,'v) tm ⇒ ('s,'v) tm ⇒ dir list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prio_emb_pos prio t s = (ARG_MIN prio p. p ≠ [] ∧ position_of t p ∧ emb_step_at' p t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prio_emb_step</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(dir list ⇒ nat) ⇒ ('s,'v) tm ⇒ ('s,'v) tm ⇒ ('s,'v) tm"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prio_emb_step prio t s = emb_step_at' (prio_emb_pos prio t s) t"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prio_emb_posI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ t ≠ s ⟹ prio_emb_pos prio t s ≠ [] ∧ position_of t (prio_emb_pos prio t s) ∧ emb_step_at' (prio_emb_pos prio t s) t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>emb_induct_reverse</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>refl</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>t</span><span> </span><span>u</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"p ≠ [] ∧ position_of t p ∧ emb_step_at' p t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_equiv'</span><span> </span><span>step.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>append_butlast_last_id</span><span> </span><span>position_if_emb_step_at</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>step.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio_emb_pos prio t s ≠ [] ∧ position_of t (prio_emb_pos prio t s) ∧ emb_step_at' (prio_emb_pos prio t s) t  ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prio_emb_pos_def</span><span> </span><span>step.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>arg_min_natI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prio_emb_pos_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≠ []"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of t p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at' p t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio (prio_emb_pos prio t s) ≤ prio p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>arg_min_nat_le</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>prio_emb_pos_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We want an embedding step sequence in which the priority numbers monotonely increase. We can
get such a sequence if the priority function assigns greater values to deeper positions.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prio_emb_pos_increase</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio_emb_step prio t s ≠ s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid_prio</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p q dp dq. prio (p @ [dp]) &gt; prio (q @ [dq]) ⟹ take (length p) q ≠ p"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"prio (prio_emb_pos prio t s) ≤ prio (prio_emb_pos prio (prio_emb_step prio t s) s)"</span></span></span><span> 
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio ?p1 ≤ prio ?p2"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>contr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prio ?p1 ≤ prio ?p2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take (length (butlast ?p1)) (butlast ?p2) ≠ (butlast ?p1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>contr</span><span> </span><span>valid_prio</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_butlast_last_id</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>not_le_imp_less</span><span> </span><span>prio_emb_posI</span><span> </span><span>prio_emb_step_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>butlast_neq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"butlast ?p2 ≠ butlast ?p1"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u = prio_emb_step prio (prio_emb_step prio t s) s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>prio_emb_posI</span><span> </span><span>prio_emb_step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = butlast ?p2"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q = drop (Suc (length (butlast ?p2))) (butlast ?p1)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>dp</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dp = last ?p2"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>dq</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dq = last ?p1"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f = butlast ?p1 ! length (butlast ?p2)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>position</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of (prio_emb_step prio t s) ?p2"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>prio_emb_posI</span><span> </span><span>prio_emb_step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"take (length p) (butlast ?p1) = p"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (butlast ?p1) ≠ length p"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>butlast_neq</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>p_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (butlast ?p1) &gt; length p"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nat_le_linear</span><span> </span><span>True</span><span> </span><span>nat_neq_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"p @ f # q = butlast ?p1"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>True</span><span> </span><span>f_def</span><span> </span><span>id_take_nth_drop</span><span> </span><span>p_def</span><span> </span><span>q_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u = emb_step_at p dp (emb_step_at (p @ f # q) dq t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p_def</span><span> </span><span>u_def</span><span> </span><span>dp_def</span><span> </span><span>dq_def</span><span> </span><span>prio_emb_step_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f = dp"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u = emb_step_at (p @ q) dq (emb_step_at p dp t)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>swap_nested_emb_step_at</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span>dq</span><span> </span><span>dp</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>u1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at p dp t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u ∨ emb_step_at p dp t = u"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_equiv</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at p dp t"</span></span></span><span> </span><span>u</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at p dp t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s›</span></span></span><span> </span><span>emb_prepend_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of t ?p2"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>position</span><span> </span><span class="string"><span class="delete"><span class="delete">"0"</span></span></span><span> </span><span>position_of_Nil</span><span> </span><span>True</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil2</span><span> </span><span>append_butlast_last_id</span><span> 
</span><span>        </span><span>append_eq_append_conv_if</span><span> </span><span>append_eq_conv_conj</span><span> </span><span>dp_def</span><span> </span><span>dq_def</span><span> </span><span>p_def</span><span> </span><span>pos_emb_step_at_nested</span><span> </span><span>prio_emb_step_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>contr</span><span> </span><span>dp_def</span><span> </span><span>p_def</span><span> </span><span>prio_emb_posI</span><span> 
</span><span>         </span><span>prio_emb_pos_le</span><span> </span><span>prio_emb_step_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p dp t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opp dp = f"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dir.exhaust</span><span> </span><span>opp_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u = emb_step_at p dp t"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>merge_emb_step_at</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>dp</span><span> </span><span>q</span><span> </span><span>dq</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of t ?p2"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_nth_drop_Suc</span><span> </span><span>position_of_Nil</span><span> </span><span>True</span><span> </span><span>dp_def</span><span> 
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹length p &lt; length (butlast ?p1)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹opp dp = f›</span></span></span><span> </span><span>append.assoc</span><span> </span><span>append_butlast_last_id</span><span> 
</span><span>            </span><span>append_take_drop_id</span><span> </span><span>f_def</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>p_def</span><span> </span><span>pos_emb_step_at_opp</span><span> </span><span>position</span><span> </span><span>take_hd_drop</span><span> </span><span>prio_emb_step_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dp_def</span><span> </span><span>p_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u = emb_step_at p dp t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s›</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>contr</span><span> 
</span><span>         </span><span>prio_emb_posI</span><span> </span><span>prio_emb_pos_le</span><span> </span><span>prio_emb_step_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>p'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p' = butlast ?p1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take (length p') p ≠ p'"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹take (length (butlast ?p1)) (butlast ?p2) ≠ butlast ?p1›</span></span></span><span> </span><span>p'_def</span><span> </span><span>p_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take (length p) p' ≠ p"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>p'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u = emb_step_at p dp (emb_step_at p' dq t)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>u_def</span><span> </span><span>prio_emb_step_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dp_def</span><span> </span><span>dq_def</span><span> </span><span>p'_def</span><span> </span><span>p_def</span><span> </span><span>prio_emb_step_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u = emb_step_at p' dq (emb_step_at p dp t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>swap_disjunct_emb_step_at</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>p'</span><span> </span><span>dq</span><span> </span><span>dp</span><span> </span><span>t</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹take (length p') p ≠ p'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹take (length p) p' ≠ p›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at p dp t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s›</span></span></span><span> </span><span>emb_prepend_step</span><span> </span><span>emb_step_equiv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of t (p @ [dp])"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pos_emb_step_at_disjunct</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹take (length p') p ≠ p'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹take (length p) p' ≠ p›</span></span></span><span> </span><span>append_butlast_last_id</span><span> </span><span>butlast.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>      </span><span>dp_def</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>p'_def</span><span> </span><span>p_def</span><span> </span><span>position</span><span> </span><span>take_eq_Nil</span><span> </span><span>prio_emb_step_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>False</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p dp t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s›</span></span></span><span> </span><span>append_butlast_last_id</span><span> </span><span>butlast.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>contr</span><span> 
</span><span>      </span><span>dp_def</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>p_def</span><span> </span><span>take_eq_Nil</span><span> </span><span>prio_emb_pos_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sequence_prio_emb_steps</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃us. us≠[] ∧ hd us = t ∧ last us = s ∧ 
    (∀i. Suc i &lt; length us ⟶ (prio_emb_step prio (us ! i) s = us ! Suc i ∧ us ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> us ! Suc i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>   
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span>hsize</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>less</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = s"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio_emb_pos prio t s ≠ []"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at' (prio_emb_pos prio t s) t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prio_emb_posI</span><span> </span><span>less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>emb_step1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> emb_step_at' (prio_emb_pos prio t s) t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>False</span><span> </span><span>emb_step_at_if_position</span><span> </span><span>less.prems</span><span> </span><span>prio_emb_posI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hsize (emb_step_at' (prio_emb_pos prio t s) t) &lt; hsize t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>False</span><span> </span><span>emb_step_at_if_position</span><span> </span><span>emb_step_hsize</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>prio_emb_posI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>us</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>us_def</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"us ≠ []"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"hd us = emb_step_at' (prio_emb_pos prio t s) t"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"last us = s"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀i. Suc i &lt; length us ⟶ prio_emb_step prio (us ! i) s = us ! Suc i ∧ us ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> us ! Suc i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at' (prio_emb_pos prio t s) t"</span></span></span><span class="delimiter">]</span><span> </span><span>emb_step_hsize</span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at' (prio_emb_pos prio t s) t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t # us ≠ []"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">" hd (t # us) = t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last (t # us) = s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>us_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀i. Suc i &lt; length (t # us) ⟶ (prio_emb_step prio ((t # us) ! i) s = (t # us) ! Suc i ∧ (t # us) ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> (t # us) ! Suc i)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" Suc i &lt; length (t # us)"</span></span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio_emb_step prio ((t # us) ! i) s = (t # us) ! Suc i ∧ (t # us) ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> (t # us) ! Suc i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0"</span></span></span><span> </span><span>emb_step1</span><span> </span><span>hd_conv_nth</span><span> </span><span>prio_emb_step_def</span><span> </span><span>us_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>us_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Suc i &lt; length (t # us)›</span></span></span><span> </span><span>us_def</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹hd (t # us) = t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹last (t # us) = s›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Embedding steps under arguments"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We want to perform positions that modify the head and the umber of arguments first. Formally these
positions can be characterized as "list\_all (op = Left) p". We show here that embeddings at other positions
do not modify the head, the number of arguments. Moreover, for each argument, the argument after the step
is an embedding of the argument before the step. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_under_args_head</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ list_all (λx. x = Left) p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"head (emb_step_at p d t) = head t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_at_head</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>t1</span><span> </span><span>t2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Left</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>App</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Right</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>App</span><span> </span><span>emb_step_at_right_context</span><span> </span><span>head_App</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_under_args_num_args</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ list_all (λx. x = Left) p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"num_args (emb_step_at p d t) = num_args t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list_all_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>x1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_at_head</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>t1</span><span> </span><span>t2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>App</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>App</span><span> </span><span>Cons.IH</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_under_args_emb_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"¬ list_all (λx. x = Left) p"</span></span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"position_of t (p @ [d])"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"i &lt; num_args t"</span></span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"args t ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> args (emb_step_at p d t) ! i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"⋀j. j &lt; num_args t ⟹ i ≠ j ⟹ args t ! j = args (emb_step_at p d t) ! j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span> </span><span>thesis</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t1</span><span> </span><span>t2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>App</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"t = App t1 t2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>emb_step_at_if_position</span><span> </span><span>emb_step_at_is_App</span><span> </span><span>emb_step_equiv'</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Left</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH_cond1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ list_all (λx. x = dir.Left) p"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Left</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH_cond2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of t1 (p @ [d])"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>App</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Left</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i'_def</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"i' &lt; num_args t1"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"args t1 ! i' →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> args (emb_step_at p d t1) ! i'"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"⋀j. j &lt; num_args t1 ⟹ i' ≠ j ⟹ args t1 ! j = args (emb_step_at p d t1) ! j"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>IH_cond1</span><span> </span><span>IH_cond2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>num_args</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"num_args (emb_step_at p d t1) = num_args t1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>App</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Left</span><span> </span><span>emb_step_under_args_num_args</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>emb_step_under_args_num_args</span><span> </span><span>IH_cond1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i' &lt; num_args t"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>App</span><span> </span><span>i'_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>less_SucI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"args t ! i' →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> args (emb_step_at (a # p) d t) ! i'"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>App</span><span> </span><span>Left</span><span> </span><span>i'_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>i'_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>nth_append</span><span> </span><span>num_args</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⋀j. j &lt; num_args t ⟹ i' ≠ j ⟹ args t ! j = args (emb_step_at (a # p) d t) ! j"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>App</span><span> </span><span>Left</span><span> </span><span>i'_def</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>nth_append</span><span> </span><span>num_args</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Right</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⋀j. j &lt; num_args t ⟹ num_args t - 1 ≠ j ⟹ args t ! j = args (emb_step_at (a # p) d t) ! j"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>App</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>emb_step_at_right_context</span><span> </span><span>Nitpick.size_list_simp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Right</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>butlast_snoc</span><span> </span><span>emb_step_under_args_num_args</span><span> </span><span>length_butlast</span><span> </span><span>length_tl</span><span> </span><span>less_antisym</span><span> </span><span>nth_butlast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args t - 1"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>App</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Right</span><span> </span><span>emb_step_at_if_position</span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_under_args_emb</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ list_all (λx. x = Left) p"</span></span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"position_of t (p @ [d])"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀i. i &lt; num_args t ⟶ args t ! i ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> args (emb_step_at p d t) ! i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>emb.simps</span><span> </span><span>emb_step_under_args_emb_step</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>position_Left_only_subst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all (λx. x = Left) p"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of (subst ρ w) (p @ [d])"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args (subst ρ w)  = num_args w"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of w (p @ [d])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>w</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>position_of_Hd</span><span> </span><span>position_of_Nil</span><span> </span><span>Hd_head_id</span><span> </span><span>append_self_conv2</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>length_0_conv</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>position_of.elims</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>w</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>position_of_Hd</span><span> </span><span>Hd_head_id</span><span> </span><span>append_Cons</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>w1</span><span> </span><span>w2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args (subst ρ w1) = num_args w1"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>App</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>App</span><span> </span><span>Cons.hyps</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>position_of_left</span><span> 
</span><span>          </span><span>append_Cons</span><span> </span><span>list.pred_inject</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>subst.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rearranging embedding steps: first above, then below arguments›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>perform_emb_above_vars0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"subst ρ s ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>w</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"s ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> w"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"subst ρ w ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀w'. w →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> w' ⟶ ¬ subst ρ w' ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>   
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span>hsize</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>less</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀w'. s →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> w' ⟶ ¬ subst ρ w' ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb.refl</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>emb_step_is_emb</span><span> </span><span>emb_step_hsize</span><span> </span><span>emb_trans</span><span> </span><span>less.hyps</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_only_below_vars</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"subst ρ s ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"s ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> w"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_Sym (head w)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"subst ρ w ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀w'. w →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> w' ⟶ ¬ subst ρ w' ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>ws</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ws ≠ []"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"hd ws = subst ρ w"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"last ws = u"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀i. Suc i &lt; length ws ⟶ 
      (∃p d. emb_step_at p d (ws ! i) = ws ! Suc i ∧ ¬ list_all (λx. x = Left) p)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀i. i &lt; length ws ⟶ head (ws ! i) = head w ∧ num_args (ws ! i) = num_args w"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀i. i &lt; length ws ⟶ (∀k. k &lt; num_args w ⟶ args (subst ρ w) ! k ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> args (ws ! i) ! k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>prio</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"dir list ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio = (λp. if list_all (λx. x = Left) (butlast p) then 0 else 1)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ws</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ws_def</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ws ≠ []"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"hd ws = subst ρ w"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"last ws = u"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀i. Suc i &lt; length ws ⟶ prio_emb_step prio (ws ! i) u = ws ! Suc i ∧ ws ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> ws ! Suc i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹subst ρ w ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u›</span></span></span><span> </span><span>sequence_prio_emb_steps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ws_emb_u</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀i. Suc i &lt; length ws ⟶ ws ! i ≠ u ∧ ws ! i ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc j &lt; length ws"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ws ! (length ws - (Suc (Suc j))) ≠ u  ∧ ws ! (length ws - (Suc (Suc j))) ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio_emb_step prio (ws ! (length ws - Suc (Suc 0))) u = ws ! (length ws - (Suc 0))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0.prems"</span></span></span><span> </span><span>Suc_diff_Suc</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0.prems"</span></span></span><span> </span><span>One_nat_def</span><span> </span><span>Suc_diff_Suc</span><span> </span><span>Suc_lessD</span><span> </span><span>diff_Suc_less</span><span> </span><span>emb_step_equiv</span><span> </span><span>last_conv_nth</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_is_emb</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ws ! (length ws - (Suc (Suc (Suc j)))) →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> ws ! (length ws - Suc (Suc j))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_diff_Suc</span><span> </span><span>diff_Suc_less</span><span> </span><span>length_greater_0_conv</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_hsize_neq</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc.IH</span><span> </span><span>Suc.prems</span><span> </span><span>Suc_lessD</span><span> </span><span>emb_hsize</span><span> </span><span>emb_step_is_emb</span><span> </span><span>emb_trans</span><span> </span><span>leD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>0</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc i &lt; length ws ⟶ ws ! i ≠ u ∧ ws ! i ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ws - Suc (Suc i)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_diff_Suc</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ws"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head (ws ! i) = head w 
             ∧ num_args (ws ! i) = num_args w
             ∧ (∀k. k &lt; num_args w ⟶ args (subst ρ w) ! k ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> args (ws ! i) ! k)
             ∧ (Suc i &lt; length ws ⟶ prio (prio_emb_pos prio (ws ! i) u) = 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"head (ws ! 0) = head w"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>ground_imp_subst_iden</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hd.simps</span><span class="delimiter">(</span><span>18</span><span class="delimiter">)</span><span> </span><span>hd_conv_nth</span><span> </span><span>head_subst</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.simps</span><span class="delimiter">(</span><span>17</span><span class="delimiter">)</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"num_args (ws ! 0) = num_args w"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>append_self_conv2</span><span> </span><span>args_subst</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>hd.case_eq_if</span><span> </span><span>hd_conv_nth</span><span> </span><span>length_map</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀k. k &lt; num_args w ⟶ args (subst ρ w) ! k ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> args (ws ! 0) ! k"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb.refl</span><span> </span><span>hd_conv_nth</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(Suc 0 &lt; length ws ⟶ prio (prio_emb_pos prio (ws ! 0) u) = 1)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹num_args (ws ! 0) = num_args w›</span></span></span><span> </span><span>prio_def</span><span> </span><span>append_butlast_last_id</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>emb_step_at_if_position</span><span> 
</span><span>        </span><span>emb_step_at_subst</span><span> </span><span>hd_conv_nth</span><span> </span><span>position_Left_only_subst</span><span> </span><span>prio_emb_posI</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ws_emb_u</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"prio (prio_emb_pos prio (ws ! i) u) = 1"</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"head (ws ! i) = head w"</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"num_args (ws ! i) = num_args w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"head (ws ! Suc i) = head w"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc.prems</span><span> </span><span>prio_def</span><span> </span><span>emb_step_under_args_head</span><span> </span><span>ih</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ih</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>prio_emb_step_def</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"num_args (ws ! Suc i) = num_args w"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc.prems</span><span> </span><span>emb_step_under_args_num_args</span><span> </span><span>ih</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ih</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>prio_def</span><span> </span><span>prio_emb_step_def</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀k&lt;num_args (ws ! i). args (ws ! i) ! k ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> args (ws ! Suc i) ! k"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.prems</span><span> </span><span>emb_step_under_args_emb</span><span> </span><span>ih</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>prio_def</span><span> </span><span>prio_emb_step_def</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>zero_neq_one</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>append_butlast_last_id</span><span> </span><span>prio_emb_posI</span><span> </span><span>ws_emb_u</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀k. k &lt; num_args w ⟶ args (subst ρ w) ! k ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> args (ws ! Suc i) ! k"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.hyps</span><span> </span><span>Suc.prems</span><span> </span><span>emb_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p q dp dq. prio (q @ [dq]) &lt; prio (p @ [dp]) ⟹ take (length p) q ≠ p"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prio_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>append_take_drop_id</span><span> </span><span>list_all_append</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>butlast_snoc</span><span> </span><span>gr_implies_not0</span><span> </span><span>less_not_refl2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Suc (Suc i) &lt; length ws ⟶ prio (prio_emb_pos prio (ws ! Suc i) u) = 1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc.prems</span><span> </span><span>ih</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>not_one_le_zero</span><span> </span><span>prio_def</span><span> </span><span>prio_emb_pos_increase</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>ws_emb_u</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>1</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. Suc i &lt; length ws ⟶ 
      (∃p d. emb_step_at p d (ws ! i) = ws ! Suc i ∧ ¬ list_all (λx. x = Left) p)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span>Suc_lessD</span><span> </span><span>prio_def</span><span> </span><span>prio_emb_step_def</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>perform_emb_above_vars</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"subst ρ s ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>w</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"s ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> w"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"subst ρ w ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_Sym (head w) ⟹ head w = head u ∧ num_args w = num_args u ∧ (∀k. k&lt;num_args w ⟶ args (subst ρ w) ! k ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> args u ! k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>w</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>w_def</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"s ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> w"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"subst ρ w ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀w'. w →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> w' ⟶ ¬ subst ρ w' ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>perform_emb_above_vars0</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹subst ρ s ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Sym (head w)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ws</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ws_def</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"ws ≠ []"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"hd ws = subst ρ w"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"last ws = u"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀i. Suc i &lt; length ws ⟶ (∃p d. emb_step_at p d (ws ! i) = ws ! Suc i ∧ ¬ list_all (λx. x = Left) p)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀i&lt;length ws. head (ws ! i) = head w ∧ num_args (ws ! i) = num_args w"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀i&lt;length ws. ∀k&lt;num_args w. args (subst ρ w) ! k ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> args (ws ! i) ! k"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_only_below_vars</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹subst ρ s ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> w›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_Sym (head w)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹subst ρ w ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u›</span></span></span><span> </span><span>w_def</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head w = head u ∧ num_args w = num_args u ∧ (∀k. k&lt;num_args w ⟶ args (subst ρ w) ! k ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> args u ! k)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>append_butlast_last_id</span><span> </span><span>diff_Suc_1</span><span> </span><span>diff_Suc_less</span><span> </span><span>length_append_singleton</span><span> </span><span>length_greater_0_conv</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>w_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>w_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Chop">
<div class="head"><h1>Theory Chop</h1>
<span class="command">theory</span> <span class="name">Chop</span><br/>
<span class="keyword">imports</span> <a href="Embeddings.html"><span class="name">Embeddings</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       The Chop Operation on Lambda-Free Higher-Order Terms
    Author:      Alexander Bentkamp &lt;a.bentkamp at vu.nl&gt;, 2018
    Maintainer:  Alexander Bentkamp &lt;a.bentkamp at vu.nl&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Chop Operation on Lambda-Free Higher-Order Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Chop</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Embeddings</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>chop</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"chop t = apps (hd (args t)) (tl (args t))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chop_App_Hd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Hd s ⟹ chop (App s t) = t"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chop_def</span><span> </span><span>args.simps</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chop_apps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t ⟹ chop (apps t ts) = apps (chop t) ts"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chop_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>args_Nil_iff_is_Hd</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_chop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t ⟹ vars (chop t) ∪ vars_hd (head t) = vars t"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>tm_induct_apps</span><span class="delimiter">;</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>chop_def</span><span> </span><span>UN_insert</span><span> </span><span>Un_commute</span><span> </span><span>list.exhaust_sel</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>15</span><span class="delimiter">)</span><span>
</span><span>      </span><span>args_Nil_iff_is_Hd</span><span> </span><span>tm.simps</span><span class="delimiter">(</span><span>17</span><span class="delimiter">)</span><span> </span><span>tm_exhaust_apps_sel</span><span> </span><span>vars_apps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_chop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t ⟹ ground t ⟹ ground (chop t)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_chop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hsize_chop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t ⟹ (Suc (hsize (chop t))) = hsize t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hsize_args</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>chop_def</span><span> </span><span>hsize_apps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nil_is_map_conv</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>list.exhaust_sel</span><span> </span><span>list.map_sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>map_tl</span><span> </span><span>plus_1_eq_Suc</span><span> </span><span>sum_list.Cons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hsize_chop_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t ⟹ hsize (chop t) &lt; hsize t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Suc_le_lessD</span><span> </span><span>less_or_eq_imp_le</span><span> </span><span>hsize_chop</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chop_fun</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App (fun t)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App (chop (fun t)) (arg t) = chop t"</span></span></span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"args (fun t) ≠ []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chop_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>App_apps</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hd_append2</span><span> </span><span>tl_append2</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Chop and the Embedding Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_chop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t ⟹ t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> chop t"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args t - 1"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args t = 0 ⟹ t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> chop t"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chop_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>single</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a. args t = [a] ⟹ t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> chop t"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chop_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">"0.prems"</span></span></span><span> </span><span>apps.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>args.elims</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>emb_step_arg</span><span> </span><span>last.simps</span><span> </span><span>last_snoc</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nil</span><span> </span><span>single</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">"0.hyps"</span></span></span><span> </span><span>length_0_conv</span><span> </span><span>length_tl</span><span> </span><span>list.exhaust_sel</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"apps (Hd (head t)) (butlast (args t)) →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> chop (apps (Hd (head t)) (butlast (args t)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"apps (Hd (head t)) (butlast (args t))"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>add_diff_cancel_right'</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>length_butlast</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>nat.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm_exhaust_apps_sel</span><span> </span><span>tm_inject_apps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"App (apps (Hd (head t)) (butlast (args t))) (last (args t)) = t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>App_apps</span><span> </span><span>Suc.prems</span><span> </span><span>args_Nil_iff_is_Hd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"App (chop (apps (Hd (head t)) (butlast (args t)))) (last (args t)) = chop t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (args t) = hd (butlast (args t))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Suc.prems</span><span> </span><span>append_butlast_last_id</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>hd_append2</span><span> </span><span>length_0_conv</span><span> </span><span>length_butlast</span><span> </span><span>nat.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tl (args t) = tl (butlast (args t)) @ [last (args t)]"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Suc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Suc.prems</span><span> </span><span>append_butlast_last_id</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>length_0_conv</span><span> </span><span>length_butlast</span><span> </span><span>nat.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>tl_append2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>chop_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>App_apps</span><span> </span><span>append_Nil</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>args_apps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>context_left</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chop_emb_step_at</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t = emb_step_at (replicate (num_args (fun t)) Left) Right t"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args (fun t)"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rep_Nil</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"replicate (num_args (fun t)) dir.Left = []"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rep_Nil</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">"0.hyps"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0.prems"</span></span></span><span> </span><span>emb_step_at_right</span><span> </span><span>append_Nil</span><span> </span><span>apps.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>chop_def</span><span> </span><span>length_0_conv</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"fun t"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_at_left_context</span><span> </span><span>args.elims</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>chop_fun</span><span> </span><span>butlast_snoc</span><span> </span><span>diff_Suc_1</span><span> </span><span>length_0_conv</span><span> </span><span>length_butlast</span><span> </span><span>nat.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>replicate_Suc</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_at_chop</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>emb_step_at</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at p Right t = s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pos</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"position_of t (p @ [Right])"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>all_Left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all (λx. x = Left) p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t = s ∨ chop t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_at_if_position</span><span> </span><span>emb_step_at_is_App</span><span> </span><span>emb_step_equiv</span><span> </span><span>pos</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p_replicate</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"replicate (length p) Left = p"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>replicate_length_same</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>Left</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Ball_set</span><span> </span><span>all_Left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc (length p) = num_args t"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = replicate (num_args (fun t)) Left"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_replicate</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_inject</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>args.elims</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>length_append_singleton</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t = s"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chop_emb_step_at</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pos</span><span> </span><span>emb_step_at</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc (length p) &lt; num_args t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pos</span><span> </span><span>emb_step_at</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹list_all (λx. x = dir.Left) p›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>t</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_lessI</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>length_greater_0_conv</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = Left"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Suc (length p) ≠ num_args (fun t)"</span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>args.elims</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>length_Cons</span><span> </span><span>length_append_singleton</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"position_of (fun t) (p @ [Right])"</span></span></span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹position_of t ((a # p) @ [Right])›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>position_of_left</span><span> </span><span>append_Cons</span><span> </span><span>list_all_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at p dir.Right (fun t) = emb_step_at p dir.Right (fun t)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_at_left_context</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>Right</span><span> </span><span class="string"><span class="delete"><span class="delete">"fun t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg t"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc (length p) &lt; num_args (fun t)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.hyps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">"2"</span></span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Nil_is_append_conv</span><span> </span><span>list_all_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>not_Cons_self2</span><span> </span><span>position_of.elims</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.discI</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Suc_less_eq2</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>length_Cons</span><span> </span><span>length_append_singleton</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q = replicate (num_args (fun t) - Suc (length p)) dir.Left"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t = emb_step_at (p @ [Left] @ q) dir.Right t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length p + (num_args (fun t) - length p) = num_args (fun t)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Suc (length p) &lt; num_args t›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_less_eq2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>diff_Suc_1</span><span> </span><span>leD</span><span> </span><span>length_butlast</span><span> </span><span>nat_le_linear</span><span> 
</span><span>            </span><span>ordered_cancel_comm_monoid_diff_class.add_diff_inverse</span><span> </span><span>snoc_eq_iff_butlast</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"replicate (num_args (fun t)) dir.Left = p @ replicate (num_args (fun t) - length p) dir.Left"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>p_replicate</span><span> </span><span>replicate_add</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; num_args (fun t) - length p"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>False</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length p + (num_args (fun t) - length p) = num_args (fun t)›</span></span></span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>length_append_singleton</span><span> </span><span>less_Suc_eq</span><span> </span><span>less_add_Suc1</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>zero_less_diff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"replicate (num_args (fun t) - length p) dir.Left = [Left] @ q"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>q_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Cons_replicate_eq</span><span> </span><span>Nat.diff_cancel</span><span> </span><span>Suc_eq_plus1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length p + (num_args (fun t) - length p) = num_args (fun t)›</span></span></span><span> </span><span>append_Cons</span><span> </span><span>self_append_conv2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chop_emb_step_at</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>1</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>chop_emb_step_at</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pos</span><span> </span><span>merge_emb_step_at</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>Right</span><span> </span><span>q</span><span> </span><span>Right</span><span> </span><span>t</span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_at_if_position</span><span> </span><span>opp_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>emb_step_at</span><span> </span><span>pos_emb_step_at_opp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_at_remove_arg</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>emb_step_at</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at p Left t = s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pos</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"position_of t (p @ [Left])"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>all_Left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all (λx. x = Left) p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"let i = num_args t - Suc (length p) in 
  head t = head s ∧ i &lt; num_args t ∧ args s = take i (args t) @ drop (Suc i) (args t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_at_if_position</span><span> </span><span>emb_step_at_is_App</span><span> </span><span>emb_step_equiv</span><span> </span><span>pos</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t = head s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_Left</span><span> </span><span>emb_step_at</span><span> </span><span>pos</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = emb_step_at [] dir.Left (App (fun t) (arg t))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>position_of.elims</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>snoc_eq_iff_butlast</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.discI</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = fun t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = Left"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head (emb_step_at p Left (fun t)) = head t"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.hyps</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>head_fun</span><span> </span><span>list.pred_inject</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>position_if_emb_step_at</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_at_left_context</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>a</span><span> </span><span class="string"><span class="delete"><span class="delete">"fun t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg t"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = Left›</span></span></span><span> </span><span>emb_step_at_is_App</span><span> </span><span>head_App</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args t - Suc (length p)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"?i &lt; num_args t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>args_Nil_iff_is_Hd</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"args s = take ?i (args t) @ drop (Suc ?i) (args t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_Left</span><span> </span><span>pos</span><span> </span><span>emb_step_at</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_at_left</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"fun t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg t"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>butlast_conv_take</span><span> </span><span>butlast_snoc</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of (fun t) (p @ [Left])"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>position_of_left</span><span> 
</span><span>          </span><span>append_Cons</span><span> </span><span>list.pred_inject</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"args (emb_step_at p Left (fun t))
                   = take (num_args (fun t) - Suc (length p)) (args (fun t)) 
                   @ drop (Suc (num_args (fun t) - Suc (length p))) (args (fun t))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.hyps</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"fun t"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>append_Nil</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>drop_Nil</span><span> 
</span><span>          </span><span>emb_step_at_is_App</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list_all_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>take_0</span><span> </span><span>zero_diff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"s = App (emb_step_at p Left (fun t)) (arg t)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_at_left_context</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>Left</span><span> </span><span class="string"><span class="delete"><span class="delete">"fun t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg t"</span></span></span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"k = (num_args (fun t) - Suc (length p))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"take k (args (fun t)) = take (num_args t - Suc (length (a # p))) (args t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>k_def</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>args.elims</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>butlast_snoc</span><span> </span><span>diff_Suc_eq_diff_pred</span><span> 
</span><span>          </span><span>diff_Suc_less</span><span> </span><span>length_Cons</span><span> </span><span>length_butlast</span><span> </span><span>length_greater_0_conv</span><span> </span><span>take_butlast</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>k_def'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k = num_args t - Suc (Suc (length p))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>diff_Suc_Suc</span><span> </span><span>length_append_singleton</span><span> </span><span>local.Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"args (fun t) @ [arg t] = args t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args t &gt; 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹position_of t ((a # p) @ [Left])›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">"3"</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹position_of (fun t) (p @ [dir.Left])›</span></span></span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>butlast_snoc</span><span> </span><span>emb_step.simps</span><span> </span><span>emb_step_at_if_position</span><span> </span><span>length_butlast</span><span> </span><span>length_greater_0_conv</span><span> </span><span>tm.discI</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>zero_less_diff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc k&lt;num_args t"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def'</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹1 &lt; num_args t›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀k&lt; num_args t. drop k (args (fun t)) @ [arg t] = drop k (args t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹args (fun t) @ [arg t] = args t›</span></span></span><span> </span><span>drop_butlast</span><span> </span><span>drop_eq_Nil</span><span> </span><span>last_drop</span><span> </span><span>leD</span><span> </span><span>snoc_eq_iff_butlast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>k_def'</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Suc k &lt; num_args t›</span></span></span><span> </span><span>k_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C1</span><span> </span><span>C2</span><span> </span><span>C3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emb_step_cases</span><span> </span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>chop</span><span> </span><span>extended_chop</span><span> </span><span>remove_arg</span><span> </span><span>under_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>emb</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>chop</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"chop t = s ⟹ P"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>extended_chop</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"chop t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟹ P"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>remove_arg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⋀i. head t = head s ⟹ i&lt;num_args t ⟹ args s = take i (args t) @ drop (Suc i) (args t) ⟹ P"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>under_arg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⋀i. head t = head s ⟹ num_args t = num_args s ⟹ args t ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> args s ! i ⟹
         (⋀j. j&lt;num_args t ⟹ i ≠ j ⟹ args t ! j = args s ! j) ⟹ P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>P</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>pd_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"emb_step_at p d t = s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of t (p @ [d])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb</span><span> </span><span>emb_step_equiv'</span><span> </span><span>position_if_emb_step_at</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb</span><span> </span><span>emb_step_at_is_App</span><span> </span><span>emb_step_equiv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all (λx. x = Left) p"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Left</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_at_remove_arg</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>True</span><span> </span><span>pd_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>pd_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>remove_arg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Right</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>P</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>chop</span><span> </span><span>emb_step_at_chop</span><span> </span><span>extended_chop</span><span> </span><span>pd_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>pd_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"num_args t = num_args s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_under_args_num_args</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>False</span><span> </span><span>pd_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"head t = head s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_under_args_head</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>False</span><span> </span><span>pd_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>under_arg</span><span> </span><span>emb_step_under_args_emb_step</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>False</span><span> </span><span>pd_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>pd_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chop_position_of</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of s (replicate (num_args (fun s)) dir.Left @ [Right])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_n_not_le_n</span><span> </span><span>assms</span><span> </span><span>chop_emb_step_at</span><span> </span><span>lessI</span><span> </span><span>less_imp_le_nat</span><span> </span><span>position_if_emb_step_at</span><span> </span><span>hsize_chop</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Chop and Substitutions›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: move *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Suc_num_args</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t ⟹ Suc (num_args (fun t)) = num_args t"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>length_append_singleton</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: move *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fun_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App s ⟹ subst ρ (fun s) = fun (subst ρ s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subst.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: move *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>args_subst_Hd</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Hd (subst ρ (Hd (head s)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"args (subst ρ s) = map (subst ρ) (args s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Nil</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>args_apps</span><span> </span><span>subst_apps</span><span> </span><span>tm_exhaust_apps_sel</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chop_subst_emb0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop (subst ρ s) ≠ subst ρ (chop s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at (replicate (num_args (fun s)) Left) Right (chop (subst ρ s)) = subst ρ (chop s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App (subst ρ s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>subst.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subst ρ (chop s) = emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (subst ρ  s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chop_emb_step_at</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_at_subst</span><span> </span><span>chop_position_of</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args (fun s) ≤ num_args (fun (subst ρ s))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_subst</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args_subst</span><span> </span><span>leI</span><span> </span><span>length_append</span><span> </span><span>length_map</span><span> </span><span>not_add_less2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args (fun s) &lt; num_args (fun (subst ρ s))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App (subst ρ s)›</span></span></span><span> </span><span>chop_emb_step_at</span><span> </span><span>le_imp_less_or_eq</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args s ≤ num_args (fun (subst ρ s))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_num_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"replicate (num_args (fun s)) dir.Left @
        [opp dir.Right] @ replicate (num_args (fun (subst ρ s)) - num_args s) dir.Left =
        replicate (num_args (fun (subst ρ s))) dir.Left"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append.simps</span><span> </span><span>opp_simps</span><span> </span><span>replicate_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>replicate_add</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_num_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_Suc_shift</span><span> </span><span>ordered_cancel_comm_monoid_diff_class.add_diff_inverse</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>chop_emb_step_at</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App (subst ρ s)›</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>merge_emb_step_at</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chop_subst_emb</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop (subst ρ s) ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> subst ρ (chop s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chop_subst_emb0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>emb.refl</span><span> </span><span>emb_step_equiv</span><span> </span><span>emb_step_is_emb</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chop_subst_Hd</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Hd (subst ρ (Hd (head s)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop (subst ρ s) = subst ρ (chop s)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App (subst ρ s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>subst.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args (fun s) = num_args (fun (subst ρ s))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fun_subst</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span class="delimiter">,</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>args_subst_Hd</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chop_emb_step_at</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>chop_emb_step_at</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App (subst ρ s)›</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_at_subst</span><span class="delimiter">[</span><span>OF</span><span> </span><span>chop_position_of</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chop_subst_Sym</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Sym (head s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop (subst ρ s) = subst ρ (chop s)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>chop_subst_Hd</span><span> </span><span>ground_imp_subst_iden</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hd.simps</span><span class="delimiter">(</span><span>18</span><span class="delimiter">)</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.simps</span><span class="delimiter">(</span><span>17</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Lambda_Free_EPO">
<div class="head"><h1>Theory Lambda_Free_EPO</h1>
<span class="command">theory</span> <span class="name">Lambda_Free_EPO</span><br/>
<span class="keyword">imports</span> <a href="Chop.html"><span class="name">Chop</span></a> <a href="Multiset_More.html"><span class="name">Multiset_More</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       The Embedding Path Order for Lambda-Free Higher-Order Terms
    Author:      Alexander Bentkamp &lt;a.bentkamp at vu.nl&gt;, 2018
    Maintainer:  Alexander Bentkamp &lt;a.bentkamp at vu.nl&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Embedding Path Order for Lambda-Free Higher-Order Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lambda_Free_EPO</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Chop</span><span> </span><span>Nested_Multisets_Ordinals.Multiset_More</span><span>
</span><span class="keyword2"><span class="keyword">abbrevs</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;t"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≥t"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"≥<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This theory defines the embedding path order for ‹λ›-free
higher-order terms.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Setup›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>epo</span><span> </span><span class="delimiter">=</span><span> </span><span>ground_heads</span><span> </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>s</sub>)"</span></span></span><span> </span><span>arity_sym</span><span> </span><span>arity_var</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>      </span><span>gt_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ 's ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>s</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>arity_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ enat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>arity_var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v ⇒ enat"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>    </span><span>extf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ (('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool) ⇒ ('s, 'v) tm list ⇒ ('s, 'v) tm list ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>extf_ext_trans_before_irrefl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_trans_before_irrefl (extf f)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>extf_ext_compat_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_compat_list (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>extf_ext_compat_snoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_compat_snoc (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>extf_ext_compat_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_compat_cons (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>extf_ext_snoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_snoc (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>extf_min_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ extf f gt [] ss"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: seperate definition? *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extf_ext_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_trans (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext_trans_before_irrefl.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_trans_before_irrefl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extf_ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext_trans.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_mono_strong</span><span> </span><span class="delimiter">=</span><span> </span><span>ext.mono_strong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_mono</span><span> </span><span class="delimiter">=</span><span> </span><span>ext.mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext</span><span class="delimiter">,</span><span> </span><span>mono</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_map</span><span> </span><span class="delimiter">=</span><span> </span><span>ext.map</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_trans</span><span> </span><span class="delimiter">=</span><span> </span><span>ext_trans.trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_trans</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_irrefl_from_trans</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>ext_trans_before_irrefl.irrefl_from_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_trans_before_irrefl</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_compat_list</span><span> </span><span class="delimiter">=</span><span> </span><span>ext_compat_list.compat_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_compat_list</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_snoc</span><span> </span><span class="delimiter">=</span><span> </span><span>ext_snoc.snoc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_snoc</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_compat_append_right</span><span> </span><span class="delimiter">=</span><span> </span><span>ext_compat_snoc.compat_append_right</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_compat_snoc</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_compat_append_left</span><span> </span><span class="delimiter">=</span><span> </span><span>ext_compat_cons.compat_append_left</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_compat_cons</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extf_ext_insert_arg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f gt (xs @ z # ys) (xs @ ys)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_compat_append_left</span><span> </span><span>extf_compat_append_right</span><span> </span><span>extf_snoc</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>gt</span><span> </span><span>Nil</span><span> </span><span>z</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive Definitions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>chkchop</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool) ⇒ ('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop gt t s ⟷ is_Hd s ∨ gt t (chop s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>chkchop_same</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool) ⇒ ('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop_same gt t s ⟷ 
            (if is_Var (head t) 
            then is_Hd t ∨ chkchop gt (chop t) s 
            else chkchop gt t s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chkchop_mono</span><span class="delimiter">[</span><span>mono</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gt ≤ gt' ⟹ chkchop gt ≤ chkchop gt'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chkchop_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chkchop_same_mono</span><span class="delimiter">[</span><span>mono</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gt ≤ gt' ⟹ chkchop_same gt ≤ chkchop_same gt'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chkchop_same_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_chop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t ⟹ chop t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ chop t = s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>gt_diff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s ⟹ is_Sym (head s) ⟹ chkchop (&gt;<span class="hidden">⇩</span><sub>t</sub>) t s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>gt_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t = head s ⟹ chkchop_same (&gt;<span class="hidden">⇩</span><sub>t</sub>) t s ⟹
    (∀f ∈ ground_heads (head t). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)) ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≥<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ≥<span class="hidden">⇩</span><sub>t</sub> s ≡ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ t = s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt_chop</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_chopI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t ⟹ chop t ≥<span class="hidden">⇩</span><sub>t</sub> s ⟹ gt_chop t s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt_diff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_diffI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s ⟹ is_Sym (head s) ⟹ chkchop (&gt;<span class="hidden">⇩</span><sub>t</sub>) t s ⟹ gt_diff t s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt_same</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_sameI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t = head s ⟹ chkchop_same (&gt;<span class="hidden">⇩</span><sub>t</sub>) t s ⟹
    (∀f ∈ ground_heads (head t). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)) ⟹ gt_same t s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_iff_chop_diff_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟷ gt_chop t s ∨ gt_diff t s ∨ gt_same t s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>gt.simps</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gt_chop.simps</span><span> </span><span>gt_diff.simps</span><span> </span><span>gt_same.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Transitivity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>t_gt_chop_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> chop t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_chop</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_imp_vars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ vars t ⊇ vars s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>atomize_imp</span><span class="delimiter">,</span><span>
</span><span>    </span><span>rule</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). hsize t + hsize s"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟶ vars t ⊇ vars s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, s)"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>prod.case</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span> </span><span>prod.case</span><span> </span><span>atomize_imp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>    </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ta sa. hsize ta + hsize sa &lt; hsize t + hsize s ⟹ ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa ⟹ vars ta ⊇ vars sa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>t_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars t ⊇ vars s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_gt_s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>gt_chop</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_mono_thms_linordered_field</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>le_supI1</span><span> </span><span>order_refl</span><span> </span><span>hsize_chop_lt</span><span> </span><span>vars_chop</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Hd</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>empty_iff</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hd.simps</span><span class="delimiter">(</span><span>18</span><span class="delimiter">)</span><span> </span><span>subsetI</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.simps</span><span class="delimiter">(</span><span>17</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>s1</span><span> </span><span>s2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars (chop s) ⊆ vars t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>App</span><span> </span><span>chkchop_def</span><span> </span><span>local.gt_diff</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>nat_add_left_cancel_less</span><span> </span><span>hsize_chop_lt</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>App</span><span>  </span><span>le_sup_iff</span><span> </span><span>local.gt_diff</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>vars_chop</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>empty_iff</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hd.simps</span><span class="delimiter">(</span><span>18</span><span class="delimiter">)</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_same</span><span> </span><span>extf_min_empty</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>t</sub>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"args s"</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>t1</span><span> </span><span>t2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.gt_same</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>vars_head_subseteq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>s1</span><span> </span><span>s2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t &gt;<span class="hidden">⇩</span><sub>t</sub> chop s"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Var</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>chkchop_def</span><span> </span><span>chkchop_same_def</span><span> </span><span>epo.extf_min_empty</span><span> 
</span><span>                </span><span>epo_axioms</span><span> </span><span>gt_hd_def</span><span> </span><span>gt_hd_irrefl</span><span> </span><span>hd.disc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>local.gt_same</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>local.gt_same</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars (chop s) ⊆ vars (chop t)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹chop t &gt;<span class="hidden">⇩</span><sub>t</sub> chop s›</span></span></span><span class="delimiter">]</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>App</span><span> </span><span>add_mono_thms_linordered_field</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>extf_min_empty</span><span> </span><span>gt_hd_def</span><span> </span><span>gt_hd_irrefl</span><span> </span><span>local.gt_same</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>hsize_chop_lt</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>gt_same</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>vars_chop</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>vars_chop</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>App</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>extf_min_empty</span><span> </span><span>gt_hd_def</span><span> </span><span>gt_hd_irrefl</span><span> </span><span>le_sup_iff</span><span> </span><span>local.gt_same</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>order_refl</span><span> </span><span>sup.coboundedI1</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Sym</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop (&gt;<span class="hidden">⇩</span><sub>t</sub>) t s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_same</span><span> </span><span>chkchop_same_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.gt_same</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>vars_head_subseteq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>s1</span><span> </span><span>s2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_chop</span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s"</span></span></span><span class="delimiter">]</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹chkchop (&gt;<span class="hidden">⇩</span><sub>t</sub>) t s›</span></span></span><span> </span><span>chkchop_def</span><span> </span><span>le_sup_iff</span><span> </span><span>local.gt_same</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>nat_add_left_cancel_less</span><span> </span><span>hsize_chop_lt</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>vars_head_subseteq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u &gt;<span class="hidden">⇩</span><sub>t</sub> t ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>atomize_imp</span><span class="delimiter">,</span><span>
</span><span>    </span><span>rule</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(u, t, s). {#hsize u, hsize t, hsize s#}"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"λ(u, t, s). u &gt;<span class="hidden">⇩</span><sub>t</sub> t ⟶ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟶ u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, t, s)"</span></span></span><span class="delimiter">,</span><span>
</span><span>      </span><span>simplified</span><span> </span><span>prod.case</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span> </span><span>prod.case</span><span> </span><span>atomize_imp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>    </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ua ta sa. {#hsize ua, hsize ta, hsize sa#} &lt; {#hsize u, hsize t, hsize s#} ⟹
      ua &gt;<span class="hidden">⇩</span><sub>t</sub> ta ⟹ ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa ⟹ ua &gt;<span class="hidden">⇩</span><sub>t</sub> sa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>u_gt_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u_gt_s_if_ui</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop u ≥<span class="hidden">⇩</span><sub>t</sub> t ⟹ u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>ui_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App u"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop u"</span></span></span><span> </span><span>t</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>t_gt_s</span><span> </span><span>gt_chop</span><span> </span><span>hsize_chop_lt</span><span> </span><span>ui_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_gt_s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_chop</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u_gt_s_if_chk_u_t</span><span class="delimiter">:</span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>chk_u_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop (&gt;<span class="hidden">⇩</span><sub>t</sub>) u t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop u"</span></span></span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>gt_chop</span><span> </span><span>chk_u_t</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_mset_lt_left_lt</span><span> </span><span>add_mset_lt_right_lt</span><span> </span><span>chkchop_def</span><span> </span><span>ih</span><span> </span><span>hsize_chop_lt</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>chkchop_def</span><span> </span><span>chkchop_same_def</span><span> 
</span><span>          </span><span>epo.extf_min_empty</span><span> </span><span>epo_axioms</span><span> </span><span>gt.simps</span><span> </span><span>gt_hd_def</span><span> </span><span>gt_hd_irrefl</span><span>
</span><span>          </span><span>u_gt_s_if_chk_u_t</span><span> </span><span>u_gt_s_if_ui</span><span> </span><span>u_gt_t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff_t_s</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_gt_t</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_chop</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_gt_s_if_ui</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>gt_diff_t_s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gt_hd_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_mset_lt_left_lt</span><span> </span><span>add_mset_lt_right_lt</span><span> </span><span>chkchop_def</span><span>  </span><span>gt_diff</span><span> </span><span>gt_diff_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>ih</span><span> </span><span>hsize_chop_lt</span><span> </span><span>u_gt_t</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>gt_diff_t_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same_u_t</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_t_s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_mset_lt_left_lt</span><span> </span><span>add_mset_lt_right_lt</span><span> </span><span>chkchop_def</span><span> </span><span>gt_diff</span><span> </span><span>gt_diff_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>ih</span><span> </span><span>hsize_chop_lt</span><span> </span><span>u_gt_t</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>gt_diff_t_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same_t_s</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_gt_t</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_chop</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_gt_s_if_ui</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_mset_lt_left_lt</span><span> </span><span>add_mset_lt_right_lt</span><span> </span><span>chkchop_def</span><span> </span><span>gt_diff</span><span> </span><span>gt_same_t_s</span><span> </span><span>ih</span><span> </span><span>hsize_chop_lt</span><span> </span><span>u_gt_t</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>chkchop_same_def</span><span> </span><span>gt_diff_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same_u_t</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_u_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head u = head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (args u) ∪ set (args t) ∪ set (args s)"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gt_trans_args</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ua ∈ ?S. ∀ta ∈ ?S. ∀sa ∈ ?S. ua &gt;<span class="hidden">⇩</span><sub>t</sub> ta ⟶ ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa ⟶ ua &gt;<span class="hidden">⇩</span><sub>t</sub> sa"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>ta</span><span> </span><span>ua</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>          </span><span>ua_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ua ∈ ?S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ta_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ta ∈ ?S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sa_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sa ∈ ?S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>ua_gt_ta</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ua &gt;<span class="hidden">⇩</span><sub>t</sub> ta"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ta_gt_sa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ua &gt;<span class="hidden">⇩</span><sub>t</sub> sa"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Max_lt_imp_lt_mset</span><span> </span><span>ua_gt_ta</span><span> </span><span>ta_gt_sa</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="delimiter">(</span><span>meson</span><span> </span><span>ua_in</span><span> </span><span>ta_in</span><span> </span><span>sa_in</span><span> </span><span>Un_iff</span><span> </span><span>max.strict_coboundedI1</span><span> </span><span>max.strict_coboundedI2</span><span>
</span><span>               </span><span>hsize_in_args</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f ∈ ground_heads (head u). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args u) (args s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>extf_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>gt_trans_args</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>f_in_grounds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ ground_heads (head u)"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args u) (args t)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_in_grounds</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_in_grounds</span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop_same (&gt;<span class="hidden">⇩</span><sub>t</sub>) u s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"head u"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>u1</span><span> </span><span>u2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop u &gt;<span class="hidden">⇩</span><sub>t</sub> chop t"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Var</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>chkchop_def</span><span> </span><span>chkchop_same_def</span><span> </span><span>epo.extf_min_empty</span><span> </span><span>epo_axioms</span><span> </span><span>gt_hd_def</span><span> </span><span>gt_hd_irrefl</span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hd.disc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_min_empty</span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t_App</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>t1</span><span> </span><span>t2</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App s ⟹ chop t &gt;<span class="hidden">⇩</span><sub>t</sub> chop s"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_same_t_s</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_same_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Var</span><span> </span><span>hd_u_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop (&gt;<span class="hidden">⇩</span><sub>t</sub>) (chop u) s"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s"</span></span></span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>App</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹chop u &gt;<span class="hidden">⇩</span><sub>t</sub> chop t›</span></span></span><span> </span><span>t_App</span><span> </span><span>add_mset_lt_lt_le</span><span> </span><span>less_imp_le</span><span> </span><span>mset_lt_single_iff</span><span> </span><span>hsize_chop_lt</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_same_def</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Sym</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop (&gt;<span class="hidden">⇩</span><sub>t</sub>) u s"</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>         </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>           </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>s1</span><span> </span><span>s2</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> chop s"</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sym</span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hd_u_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>           </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u &gt;<span class="hidden">⇩</span><sub>t</sub> chop s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s"</span></span></span><span class="delimiter">]</span><span> 
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>App</span><span> </span><span>add_mset_lt_right_lt</span><span> </span><span>mset_lt_single_iff</span><span> </span><span>hsize_chop_lt</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>u_gt_t</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_def</span><span>
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Sym</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀f∈local.ground_heads (head u). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args u) (args s)›</span></span></span><span> </span><span>gt_same</span><span> </span><span>hd_u_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Irreflexivity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_irrefl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ s &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span>hsize</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>less</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s_gt_s</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_gt_s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_chop</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>gt.gt_chop</span><span> </span><span>gt_trans</span><span> </span><span>hsize_chop_lt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"head s"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gt_hd_irrefl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>in_grounds</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>si</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>si_in_args</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"si ∈ set (args s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>si_gt_si</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"si &gt;<span class="hidden">⇩</span><sub>t</sub> si"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_grounds</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>all_not_in_conv</span><span> </span><span>extf_irrefl_from_trans</span><span> </span><span>ground_heads_nonempty</span><span> </span><span>gt_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hsize si &lt; hsize s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hsize_in_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span>si_in_args</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>si_gt_si</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_antisym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ ¬ s &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_irrefl</span><span> </span><span>gt_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Compatibility with Embedding Relation"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: move? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_drop_lemma</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = length ys"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≤ length xs"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i &lt; length xs ⟶ i ≥ k ⟶ xs ! i = ys ! i"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"drop k xs = drop k ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>k</span><span> </span><span>rule</span><span class="delimiter">:</span><span>list_induct2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>y</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x # xs =  y # ys"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>leI</span><span> </span><span>length_Cons</span><span> </span><span>not_less_zero</span><span> </span><span>nth_equalityI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"drop m xs = drop m ys"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Suc_le_mono</span><span> </span><span>Suc_mono</span><span> </span><span>length_Cons</span><span> </span><span>nth_Cons_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Suc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_embedding_step_property</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>atomize_imp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). hsize t + hsize s"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s ⟶ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, s)"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>prod.case</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span> </span><span>prod.case</span><span> </span><span>atomize_imp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s,'v) tm"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀tt ss. hsize tt + hsize ss &lt; hsize t + hsize s ⟹ tt →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> ss ⟹ tt &gt;<span class="hidden">⇩</span><sub>t</sub> ss"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s›</span></span></span><span> </span><span>emb_step_at_is_App</span><span> </span><span>emb_step_equiv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at p d t = s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"position_of t (p @ [d])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s›</span></span></span><span> </span><span>emb_step_equiv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>position_if_emb_step_at</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>q_rep_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q = replicate (num_args (fun t)) Left"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all (λx. x = Left) p"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Embedding removes an argument i›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Left</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = num_args t - Suc (length p)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" head t = head s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; num_args t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"args s = take i (args t) @ drop (Suc i) (args t)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_at_remove_arg</span><span> </span><span>Left</span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p d t = s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹position_of t (p @ [d])›</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App s ⟹ chop t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> chop s"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = q"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App s"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>          
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc (num_args (fun s)) = num_args (fun t)"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_num_args</span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹args s = take i (args t) @ drop (Suc i) (args t)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>append_self_conv2</span><span> </span><span>cancel_comm_monoid_add_class.diff_cancel</span><span> </span><span>diff_Suc_1</span><span> </span><span>i_def</span><span> </span><span>length_drop</span><span> </span><span>length_replicate</span><span> </span><span>q_rep_t</span><span> </span><span>take_eq_Nil</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at (replicate (num_args (fun s)) Left) Right (chop t) =
                emb_step_at (replicate (num_args (fun s)) Left) Right t"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>merge_emb_step_at</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"replicate (num_args (fun s)) Left"</span></span></span><span> </span><span>Right</span><span> </span><span>Nil</span><span> </span><span>Right</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>append_Nil2</span><span> </span><span>opp_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>replicate_append_same</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Suc (num_args (fun s)) = num_args (fun t)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>chop_emb_step_at</span><span> </span><span>replicate_Suc</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) = chop s"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chop_emb_step_at</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>merge_emb_step_at</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"replicate (num_args (fun s)) Left"</span></span></span><span> </span><span>Right</span><span> </span><span>Nil</span><span> </span><span>Left</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>append_Nil2</span><span> </span><span>opp_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>replicate_append_same</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Left</span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Suc (num_args (fun s)) = num_args (fun t)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p d t = s›</span></span></span><span> </span><span>q_rep_t</span><span> </span><span>replicate_Suc</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> chop s"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s›</span></span></span><span> </span><span>emb_step_equiv</span><span> </span><span>emb_step_hsize</span><span> </span><span>nat_neq_iff</span><span> </span><span>hsize_chop</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App s"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p_rep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = replicate (length p) Left"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹list_all (λx. x = Left) p›</span></span></span><span> </span><span>list_all_iff</span><span> </span><span>replicate_length_same</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>length_p</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length p &lt; num_args t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_position_replicate_num_args</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹position_of t (p @ [d])›</span></span></span><span> 
</span><span>            </span><span>replicate_add</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length p - num_args t"</span></span></span><span> </span><span>Left</span><span class="delimiter">]</span><span>  </span><span>p_rep</span><span> </span><span>q_rep_t</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Left</span><span> </span><span>add_diff_inverse_nat</span><span> </span><span>replicate_app_Cons_same</span><span> </span><span>replicate_append_same</span><span> </span><span>shallower_pos</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length p ≤ length q"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_num_args</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>q_rep_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length p &lt; length q"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>le_neq_implies_less</span><span> </span><span>p_rep</span><span> </span><span>q_rep_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take (Suc (length p)) q = p @ [Left]"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length p ≤ length q›</span></span></span><span> </span><span>length_replicate</span><span> </span><span>min.orderE</span><span> </span><span>nth_replicate</span><span> </span><span>p_rep</span><span> </span><span>q_rep_t</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span>take_replicate</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q = p @ [Left] @ q'"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append.assoc</span><span> </span><span>append_take_drop_id</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc (num_args (fun s)) = num_args (fun t)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Cons_nth_drop_Suc</span><span> </span><span>Suc_num_args</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹args s = take i (args t) @ drop (Suc i) (args t)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; num_args t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>add_Suc_right</span><span> </span><span>append_take_drop_id</span><span> </span><span>diff_Suc_1</span><span> </span><span>length_Cons</span><span> </span><span>length_append</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s = emb_step_at p dir.Left (chop t)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>swap_nested_emb_step_at</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>q'</span><span> </span><span>Right</span><span> </span><span>Left</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>chop_emb_step_at</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span>chop_emb_step_at</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span class="delimiter">]</span><span>  
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Cons_replicate_eq</span><span> </span><span>Left</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p d t = s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹q = p @ [dir.Left] @ q'›</span></span></span><span> </span><span>append.assoc</span><span> </span><span>append_Cons</span><span> </span><span>diff_Suc_1</span><span> </span><span>p_rep</span><span> </span><span>q_rep_t</span><span> </span><span>replicate_append_same</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> chop s"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Left</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹position_of t (p @ [d])›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹q = p @ [dir.Left] @ q'›</span></span></span><span> </span><span>chop_emb_step_at</span><span> </span><span>emb_step_at_if_position</span><span> </span><span>pos_emb_step_at_nested</span><span> </span><span>q_rep_t</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop_same (&gt;<span class="hidden">⇩</span><sub>t</sub>) t s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Var (head t)"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_same_def</span><span> </span><span>chkchop_def</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s"</span></span></span><span class="delimiter">]</span><span> 
</span><span>           </span><span>add_less_mono</span><span> </span><span>hsize_chop_lt</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s ⟹ chop t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> chop s›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_same_def</span><span> </span><span>chkchop_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>add_less_mono</span><span> </span><span>gt_chop</span><span> </span><span>ih</span><span> </span><span>hsize_chop_lt</span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s ⟹ chop t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> chop s›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f∈local.ground_heads (head t). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_ext_insert_arg</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"take i (args t)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"args t ! i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"drop (Suc i) (args t)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹args s = take i (args t) @ drop (Suc i) (args t)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; num_args t›</span></span></span><span> </span><span>id_take_nth_drop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_same</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹head t = head s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹chkchop_same (&gt;<span class="hidden">⇩</span><sub>t</sub>) t s›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Embedding chops and might remove arguments from the left›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Right</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_at_chop</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Right</span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p d t = s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹position_of t (p @ [d])›</span></span></span><span> </span><span>add_Suc</span><span> </span><span>gt_chop</span><span> </span><span>ih</span><span> </span><span>less_Suc_eq</span><span> </span><span>hsize_chop</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Embedding operates under one of the arguments›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args t = num_args s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_under_args_num_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀t d. num_args (emb_step_at p d t) = num_args t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p d t = s›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹num_args t = num_args s›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>length_0_conv</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_rep_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q = replicate (num_args (fun s)) Left"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span>q_rep_t</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹num_args t = num_args s›</span></span></span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>butlast_snoc</span><span> </span><span>length_butlast</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> chop s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"take (num_args (fun t)) p = q"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"num_args (fun t) &lt; length p"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ num_args (fun t) &lt; length p"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args (fun t) = length p"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"q = p"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>q_rep_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list_all_length</span><span> </span><span>q_rep_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ! (num_args (fun t)) = Right"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ! num_args (fun t) ≠ Right"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ! num_args (fun t) = Left"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dir.exhaust</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take (num_args t) p = replicate (num_args t) Left"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>Suc_num_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span class="delimiter">]</span><span> </span><span>q_rep_t</span><span>
</span><span>            </span><span>take_Suc_conv_app_nth</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args (fun t)"</span></span></span><span> </span><span>p</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹num_args (fun t) &lt; length p›</span></span></span><span> </span><span>replicate_Suc</span><span> </span><span>replicate_append_same</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹num_args t = num_args s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹num_args t = num_args s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹position_of t (p @ [d])›</span></span></span><span> 
</span><span>              </span><span>append.assoc</span><span> </span><span>append_eq_Cons_conv</span><span> </span><span>append_take_drop_id</span><span> </span><span>no_position_replicate_num_args</span><span> </span><span>shallower_pos</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = q @ [Right] @ q'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_nth_drop_Suc</span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹num_args (fun t) &lt; length p›</span></span></span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>append_eq_conv_conj</span><span> </span><span>length_replicate</span><span> </span><span>q_rep_t</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emb_step_at (q @ q') d (chop t) = chop s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chop_emb_step_at</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span class="delimiter">]</span><span> </span><span>chop_emb_step_at</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>swap_nested_emb_step_at</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span> </span><span>q'</span><span> </span><span>d</span><span> </span><span>Right</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p d t = s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹p = q @ [Right] @ q'›</span></span></span><span> 
</span><span>        </span><span>q_rep_t</span><span> </span><span>q_rep_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t ≠ chop s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s›</span></span></span><span> </span><span>emb_step_hsize</span><span> </span><span>nat_less_le</span><span> </span><span>hsize_chop</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> chop s"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_equiv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>takepq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"take (length q) p ≠ q"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>q_rep_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>takeqp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length p ≤ length q ⟹ take (length p) q ≠ p"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ list_all (λx. x = Left) p›</span></span></span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>list_all_length</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>diff_diff_cancel</span><span> </span><span>take_replicate</span><span> </span><span>length_replicate</span><span>  </span><span>nth_replicate</span><span> </span><span>q_rep_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s = emb_step_at p d (chop t)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>swap_disjunct_emb_step_at</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span>Right</span><span> </span><span>d</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>takeqp</span><span> </span><span>takepq</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p d t = s›</span></span></span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>chop_emb_step_at</span><span> </span><span>q_rep_s</span><span> </span><span>q_rep_t</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>chop_emb_step_at</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>False</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹position_of t (p @ [d])›</span></span></span><span> </span><span>chop_emb_step_at</span><span> </span><span>emb_step_at_if_position</span><span> </span><span>length_replicate</span><span> </span><span>nat_le_linear</span><span> </span><span>pos_emb_step_at_disjunct</span><span> </span><span>q_rep_t</span><span> </span><span>take_all</span><span> </span><span>takeqp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gt1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"chkchop_same (&gt;<span class="hidden">⇩</span><sub>t</sub>) t s"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t &gt;<span class="hidden">⇩</span><sub>t</sub> chop s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹chop t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> chop s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>add_strict_mono</span><span> </span><span>hsize_chop_lt</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_same_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Var</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Sym</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_same_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹chop t →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> chop s›</span></span></span><span> 
</span><span>         </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>add_Suc</span><span> </span><span>add_Suc_shift</span><span> </span><span>chkchop_def</span><span> </span><span>gt_trans</span><span> </span><span>ih</span><span> 
</span><span>         </span><span>less_Suc_eq</span><span> </span><span>hsize_chop</span><span> </span><span>t_gt_chop_t</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gt2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"head t = head s"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_under_args_head</span><span> </span><span>False</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p d t = s›</span></span></span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gt3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀f∈local.ground_heads (head t). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f∈local.ground_heads (head t)"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i_def</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"i &lt; num_args t"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"args t ! i →<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> args (emb_step_at p d t) ! i"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"⋀j. j &lt; num_args t ⟹ i ≠ j ⟹ args t ! j = args (emb_step_at p d t) ! j"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_under_args_emb_step</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>t</span><span> </span><span>d</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹position_of t (p @ [d])›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>compat_list1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"args t ! i &gt;<span class="hidden">⇩</span><sub>t</sub> args s ! i"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹num_args t = num_args s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p d t = s›</span></span></span><span>  </span><span>add_less_mono</span><span> </span><span>i_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>i_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ih</span><span> </span><span>nth_mem</span><span> </span><span>hsize_in_args</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>compat_list2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"args t ! i ≠ args s ! i"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_equiv</span><span> </span><span>i_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p d t = s›</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>argst</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"args t = take i (args t) @ args t ! i # drop (Suc i) (args t)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_nth_drop_Suc</span><span> </span><span>i_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>argss</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"args s = take i (args t) @ args (emb_step_at p d t) ! i # drop (Suc i) (args t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take i (args t) = take i (args s)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nth_take_lemma</span><span class="delimiter">)</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹num_args t = num_args s›</span></span></span><span> </span><span>i_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>i_def</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p d t = s›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"drop (Suc i) (args t) = drop (Suc i) (args s)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nth_drop_lemma</span><span class="delimiter">)</span><span> 
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹num_args t = num_args s›</span></span></span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Suc_le_eq</span><span> </span><span>i_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_n_not_le_n</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p d t = s›</span></span></span><span> </span><span>i_def</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p d t = s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹num_args t = num_args s›</span></span></span><span> </span><span>i_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>id_take_nth_drop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>extf_compat_list</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"args t ! i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"args (emb_step_at p d t) ! i"</span></span></span><span> </span><span>gt</span><span> </span><span>f</span><span> </span><span class="string"><span class="delete"><span class="delete">"take i (args t)"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"drop (Suc i) (args t)"</span></span></span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹emb_step_at p d t = s›</span></span></span><span> </span><span>argss</span><span> </span><span>argst</span><span> </span><span>compat_list1</span><span> </span><span>compat_list2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_same</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt1</span><span> </span><span>gt2</span><span> </span><span>gt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_embedding_property</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊵<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>refl</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>t</span><span> </span><span>u</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_embedding_step_property</span><span> </span><span>gt_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Subterm Property›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_proper_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"proper_sub s t ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_embedding_property</span><span> </span><span>sub_emb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span>gt_emb_fun</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"App s t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>gt_emb_arg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"App s t &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_embedding_step_property</span><span> </span><span>left</span><span> </span><span>right</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Compatibility with Contexts›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_fun_imp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fun t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_fun</span><span> </span><span>gt_embedding_step_property</span><span> </span><span>gt_trans</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.exhaust_sel</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_arg_imp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emb_step_arg</span><span> </span><span>gt_embedding_step_property</span><span> </span><span>gt_trans</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.exhaust_sel</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_compat_fun</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t' &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App s t' &gt;<span class="hidden">⇩</span><sub>t</sub> App s t"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>atomize_imp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). hsize t + hsize s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). t' &gt;<span class="hidden">⇩</span><sub>t</sub> t ⟶ App s t' &gt;<span class="hidden">⇩</span><sub>t</sub> App s t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t,s)"</span></span></span><span class="delimiter">,</span><span> 
</span><span>  </span><span>simplified</span><span> </span><span>prod.case</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>  </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span> </span><span>prod.case</span><span> </span><span>atomize_imp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⋀ta sa. hsize ta + hsize sa &lt; hsize t + hsize s ⟹ t' &gt;<span class="hidden">⇩</span><sub>t</sub> ta ⟹ App sa t' &gt;<span class="hidden">⇩</span><sub>t</sub> App sa ta"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t'_gt_t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"t' &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t'_ne_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' ≠ t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_antisym</span><span> </span><span>t'_gt_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extf_args_single</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f ∈ ground_heads (head s). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args s @ [t']) (args s @ [t])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extf_compat_list</span><span> </span><span>t'_gt_t</span><span> </span><span>t'_ne_t</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"App s t' &gt;<span class="hidden">⇩</span><sub>t</sub> App s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head (App s t') = head (App s t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f∈local.ground_heads (head (App s t')). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (App s t')) (args (App s t))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extf_args_single</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop (App s t') &gt;<span class="hidden">⇩</span><sub>t</sub> chop (App s t)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chop_App_Hd</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>chop_App_Hd</span><span> </span><span>t'_gt_t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>s1</span><span> </span><span>s2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s"</span></span></span><span class="delimiter">]</span><span> </span><span>chop_fun</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nat_add_left_cancel_less</span><span> </span><span>hsize_chop_lt</span><span> </span><span>t'_gt_t</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop_same (&gt;<span class="hidden">⇩</span><sub>t</sub>) (App s t') (App s t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Var (head (App s t'))"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_same_def</span><span> </span><span>chkchop_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App s t' &gt;<span class="hidden">⇩</span><sub>t</sub> chop (App s t)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_chop</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_same_def</span><span> </span><span>chkchop_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_compat_arg</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ t' ≥<span class="hidden">⇩</span><sub>t</sub> t ⟹ App s' t' &gt;<span class="hidden">⇩</span><sub>t</sub> App s t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>atomize_imp</span><span class="delimiter">,</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span>measure_induct</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s',s,t). hsize s' + hsize s + hsize t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s',s,t). s' &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟶ t' ≥<span class="hidden">⇩</span><sub>t</sub> t ⟶ App s' t' &gt;<span class="hidden">⇩</span><sub>t</sub> App s t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s',s,t)"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>prod.case</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span> </span><span>prod.case</span><span> </span><span>atomize_imp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>atomize_all</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s'</span><span> </span><span>s</span><span> </span><span>t</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⋀ab ac ba. hsize ab + hsize ac + hsize ba &lt; hsize s' + hsize s + hsize t ⟹ ab &gt;<span class="hidden">⇩</span><sub>t</sub> ac ⟹ t' ≥<span class="hidden">⇩</span><sub>t</sub> ba ⟹ App ab t' &gt;<span class="hidden">⇩</span><sub>t</sub> App ac ba"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t' ≥<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s''</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('s,'v) tm"</span></span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hsize_s''</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"hsize s'' ≤ hsize s'"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>chkchop_s'_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop (&gt;<span class="hidden">⇩</span><sub>t</sub>) s'' s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop (&gt;<span class="hidden">⇩</span><sub>t</sub>) (App s'' t') (App s t)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Hd s"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chkchop_s'_s</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t' ≥<span class="hidden">⇩</span><sub>t</sub> t›</span></span></span><span> </span><span>chop_App_Hd</span><span> </span><span>gt_arg_imp</span><span> </span><span>gt_emb_arg</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chkchop_s'_s</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>s''</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s"</span></span></span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>hsize_s''</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t' ≥<span class="hidden">⇩</span><sub>t</sub> t›</span></span></span><span> </span><span>add_less_mono</span><span> </span><span>add_mono_thms_linordered_field</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>chop_fun</span><span> </span><span>le_eq_less_or_eq</span><span> </span><span>nat_add_left_cancel_less</span><span> </span><span>hsize_chop_lt</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>chkchop_compat_arg</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App s' t' &gt;<span class="hidden">⇩</span><sub>t</sub> App s t "</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s' &gt;<span class="hidden">⇩</span><sub>t</sub> s›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>gt.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_chop</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = t'"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>gt.gt_chop</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"App s' t'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App s t"</span></span></span><span class="delimiter">]</span><span> </span><span>gt_chop</span><span> </span><span>chkchop_compat_arg</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s'"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_strict_right_mono</span><span> </span><span>chop_fun</span><span> </span><span>ih</span><span> </span><span>hsize_chop_lt</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t' &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t' ≥<span class="hidden">⇩</span><sub>t</sub> t›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App s' t' &gt;<span class="hidden">⇩</span><sub>t</sub> App (chop s') t'"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>context_left</span><span> </span><span>emb_step_chop</span><span> </span><span>gt_embedding_step_property</span><span> </span><span>local.gt_chop</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... &gt;<span class="hidden">⇩</span><sub>t</sub> App s t"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s'"</span></span></span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t' &gt;<span class="hidden">⇩</span><sub>t</sub> t›</span></span></span><span> </span><span>gt_compat_fun</span><span> </span><span>local.gt_chop</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>local.gt_chop</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hsize_chop_lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chkchop_compat_arg</span><span> </span><span>gt.gt_diff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_s'_eq_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head s' = head s"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.gt_same</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>f_gh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ ground_heads (head s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f_s_args</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args s') (args s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.gt_same</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>f_gh</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hd_s'_eq_s</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f_compat_snoc</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"⋀xs ys x. extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) ys xs ⟹ extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (ys @ [x]) (xs @ [x])"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extf_compat_append_right</span><span class="delimiter">)</span><span>
</span><span>     
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f_st_args2</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (App s' t)) (args (App s t))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>f_compat_snoc</span><span> </span><span>f_s_args</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀z∈UNIV. ∀y∈UNIV. ∀x∈UNIV. z &gt;<span class="hidden">⇩</span><sub>t</sub> y ⟶ y &gt;<span class="hidden">⇩</span><sub>t</sub> x ⟶ z &gt;<span class="hidden">⇩</span><sub>t</sub> x"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f_trans</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⋀xs ys zs. extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) zs ys ⟹ extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) ys xs ⟹ extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) zs xs"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>extf_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>lists_UNIV</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>UNIV_I</span><span> </span><span>UNIV_I</span><span> </span><span>UNIV_I</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (App s' t')) (args (App s t))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' = t"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_st_args2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f_st_args1</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (App s' t')) (args (App s' t))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_compat_list</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t' ≥<span class="hidden">⇩</span><sub>t</sub> t›</span></span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_trans</span><span> </span><span>f_st_args1</span><span> </span><span>f_st_args2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>extf_cond</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop_same (&gt;<span class="hidden">⇩</span><sub>t</sub>) (App s' t') (App s t)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_same_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>chop_fun</span><span> </span><span>chkchop_compat_arg</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s'"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>le_eq_less_or_eq</span><span class="delimiter">]</span><span> 
</span><span>      </span><span>chkchop_compat_arg</span><span class="delimiter">[</span><span>of</span><span> </span><span>s'</span><span class="delimiter">]</span><span> </span><span>chkchop_def</span><span> </span><span>chkchop_same_def</span><span> 
</span><span>      </span><span>hsize_chop_lt</span><span>   </span><span>epo.extf_min_empty</span><span class="delimiter">[</span><span>OF</span><span> </span><span>epo_axioms</span><span class="delimiter">]</span><span> </span><span>gt.gt_same</span><span> </span><span>gt_antisym</span><span> </span><span>hd_s'_eq_s</span><span> </span><span>head_App</span><span> 
</span><span>      </span><span>leI</span><span> </span><span>less_irrefl_nat</span><span> </span><span>local.gt_same</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>local.gt_same</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_cond</span><span> </span><span>gt.gt_same</span><span> </span><span>hd_s'_eq_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_compat_fun_strong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t'_gt_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"apps s (t' # us) &gt;<span class="hidden">⇩</span><sub>t</sub> apps s (t # us)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>us</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_compat_fun</span><span> </span><span>t'_gt_t</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>App_apps</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>append_Cons</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_compat_arg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_or_eq_compat_App</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ≥<span class="hidden">⇩</span><sub>t</sub> s ⟹ t' ≥<span class="hidden">⇩</span><sub>t</sub> t ⟹ App s' t' ≥<span class="hidden">⇩</span><sub>t</sub> App s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_compat_fun</span><span> </span><span>gt_compat_arg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_compat_App</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ≥<span class="hidden">⇩</span><sub>t</sub> s ⟹ t' &gt;<span class="hidden">⇩</span><sub>t</sub> t ⟹ App s' t' &gt;<span class="hidden">⇩</span><sub>t</sub> App s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_compat_fun</span><span> </span><span>gt_compat_arg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Stability under Substitutions"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: move *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extf_map2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀y∈set ys ∪ set xs. ∀x∈set ys ∪ set xs. y &gt;<span class="hidden">⇩</span><sub>t</sub> x ⟶ (h y) &gt;<span class="hidden">⇩</span><sub>t</sub> (h x)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) ys xs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (map h ys) (map h xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>extf_map</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"set ys ∪ set xs"</span></span></span><span> </span><span>ys</span><span> </span><span>xs</span><span> </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>t</sub>)"</span></span></span><span> </span><span>h</span><span> </span><span>f</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in_listsI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in_listsI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_antisym</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_trans</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_sus</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ρ_wary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary_subst ρ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ghd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ground_heads (Var x) = UNIV"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* This condition is only needed for gt_same, not for gt_diff ! *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ subst ρ t &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>atomize_imp</span><span class="delimiter">,</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span>measure_induct</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(t,s). {# hsize t, hsize s #}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(t,s). t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟶ subst ρ t &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t,s)"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>prod.case</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span> </span><span>prod.case</span><span> </span><span>atomize_imp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>atomize_all</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⋀tt ss.
               {# hsize tt, hsize ss #} &lt; {# hsize t, hsize s #} ⟹
               tt &gt;<span class="hidden">⇩</span><sub>t</sub> ss ⟹ subst ρ tt &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ ss"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst ρ t &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t &gt;<span class="hidden">⇩</span><sub>t</sub> s›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t_gt_s_chop</span><span class="delimiter">:</span><span> </span><span>gt_chop</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_step_subst</span><span> </span><span>emb_step_chop</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t_gt_s_chop</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>gt_embedding_step_property</span><span> 
</span><span>       </span><span>emb_step_hsize</span><span> </span><span>gt_trans</span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t"</span></span></span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_mset_lt_left_lt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t_gt_s_diff</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gt_diff1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head (subst ρ t) &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head (subst ρ s)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>gt_hd_def</span><span> </span><span>subsetCE</span><span> </span><span>t_gt_s_diff</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>wary_subst_ground_heads</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gt_diff2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Sym (head (subst ρ s))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ground_imp_subst_iden</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hd.simps</span><span class="delimiter">(</span><span>18</span><span class="delimiter">)</span><span> </span><span>head_subst</span><span> </span><span>t_gt_s_diff</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.simps</span><span class="delimiter">(</span><span>17</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gt_diff3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop (&gt;<span class="hidden">⇩</span><sub>t</sub>) (subst ρ t) (subst ρ s)"</span></span></span><span>    
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_gt_s_diff</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ground_imp_subst_iden</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hd.simps</span><span class="delimiter">(</span><span>18</span><span class="delimiter">)</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.simps</span><span class="delimiter">(</span><span>17</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>s_App</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>s1</span><span> </span><span>s2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_gt_s_diff</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s"</span></span></span><span class="delimiter">]</span><span> </span><span>chop_subst_Sym</span><span> </span><span>hsize_chop_lt</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_mset_lt_left_lt</span><span> </span><span>add_mset_lt_right_lt</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff</span><span> </span><span>gt_diff1</span><span> </span><span>gt_diff2</span><span> </span><span>gt_diff3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t_gt_s_same</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gt_same1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head (subst ρ t) = head (subst ρ s)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>t_gt_s_same</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extf_map_ts</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀f∈ground_heads (head t). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (map (subst ρ) (args t)) (map (subst ρ) (args s))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih_args</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y∈set (args t) ∪ set (args s). ∀x∈set (args t) ∪ set (args s). y &gt;<span class="hidden">⇩</span><sub>t</sub> x ⟶ subst ρ y &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>less_multiset_doubletons</span><span> </span><span>hsize_in_args</span><span> </span><span>ih</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f∈ground_heads (head t). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)"</span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ghd</span><span> </span><span>t_gt_s_same</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_map</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (args t) ∪ set (args s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"args t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"args s"</span></span></span><span> </span><span>gt</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst ρ"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_irrefl</span><span> </span><span>gt_trans</span><span> </span><span>ih_args</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Var (head t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ground_heads (head u) ⊆ ground_heads (head t)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hsize u ≤ hsize (subst ρ (Hd (head t)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"apps u (map (subst ρ) (args t)) &gt;<span class="hidden">⇩</span><sub>t</sub> apps u (map (subst ρ) (args s))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"hsize u"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>u</span><span> </span><span>rule</span><span class="delimiter">:</span><span>less_induct</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>less</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>u_Hd</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"args u = []"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>s_Hd</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">)</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_map_ts</span><span>  </span><span>args_Nil_iff_is_Hd</span><span> </span><span>s_Hd</span><span> </span><span>u_Hd</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹args u = []›</span></span></span><span> </span><span>less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>s_App</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>_</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>extf_min_empty</span><span> </span><span>gt_hd_def</span><span> </span><span>gt_hd_irrefl</span><span> </span><span>t_gt_s_same</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t &gt;<span class="hidden">⇩</span><sub>t</sub> chop s"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_Var (head t)›</span></span></span><span> </span><span>s_App</span><span> </span><span>t_gt_s_same</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst ρ (chop t) &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ (chop s)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> </span><span>less_multiset_doubletons</span><span> </span><span>s_App</span><span> </span><span>hsize_chop_lt</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>              </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ut</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ut = apps u (map (subst ρ) (args t))"</span></span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>us</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"us = apps u (map (subst ρ) (args s))"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⋀ss. args (apps u ss) = ss"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹args u = []›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>chop_us</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop us = subst ρ (chop s)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chop_def</span><span> </span><span>subst_apps</span><span> </span><span>us_def</span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hd_map</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>map_tl</span><span> </span><span>s_App</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>chop_ut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop ut = subst ρ (chop t)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chop_def</span><span> </span><span>subst_apps</span><span> </span><span>ut_def</span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_App t›</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>hd_map</span><span> </span><span>map_tl</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head ut = head us"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>us_def</span><span> </span><span>ut_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop_same (&gt;<span class="hidden">⇩</span><sub>t</sub>) ut us"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_def</span><span> </span><span>chkchop_same_def</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">"0"</span></span></span><span> </span><span>UNIV_witness</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_Var (head t)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹subst ρ (chop t) &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ (chop s)›</span></span></span><span> 
</span><span>                    </span><span>args.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>chop_us</span><span> </span><span>chop_ut</span><span> </span><span>extf_map_ts</span><span> </span><span>extf_min_empty</span><span> 
</span><span>                    </span><span>ghd</span><span> </span><span>gt_chop</span><span> </span><span>is_Var_def</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ut_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f∈local.ground_heads (head ut). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args ut) (args us)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_map_ts</span><span> </span><span>less</span><span> </span><span>us_def</span><span> </span><span>ut_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ut &gt;<span class="hidden">⇩</span><sub>t</sub> us"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_same</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>u_app</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>_</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ut</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"apps u (map (subst ρ) (args t))"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?us</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"apps u (map (subst ρ) (args s))"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"head ?ut = head ?ut"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"apps (chop u) (map (subst ρ) (args t)) &gt;<span class="hidden">⇩</span><sub>t</sub> apps (chop u) (map (subst ρ) (args s))"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less.hyps</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop u"</span></span></span><span class="delimiter">]</span><span> </span><span>hsize_chop_lt</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Var</span><span> </span><span>dual_order.trans</span><span> </span><span>ghd</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>less_or_eq_imp_le</span><span> </span><span>subset_UNIV</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>u_app</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop ?ut &gt;<span class="hidden">⇩</span><sub>t</sub> chop ?us"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>chop_apps</span><span> </span><span>u_app</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"chkchop_same (&gt;<span class="hidden">⇩</span><sub>t</sub>) ?ut ?us"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_same_def</span><span> </span><span>chkchop_def</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UNIV_I</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_Var (head t)›</span></span></span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>args_apps</span><span> </span><span>extf_compat_append_left</span><span> 
</span><span>                  </span><span>extf_map_ts</span><span> </span><span>extf_min_empty</span><span> </span><span>ghd</span><span> </span><span>gt_chop</span><span> </span><span>is_Var_def</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀f∈local.ground_heads (head ?ut). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args ?ut) (args ?us)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_compat_append_left</span><span> </span><span>extf_map_ts</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_same</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inner_induction</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inner_induction</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst ρ (Hd (head t))"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>subst_apps</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Var</span><span> </span><span>ghd</span><span> </span><span>order_refl</span><span> </span><span>subset_UNIV</span><span> </span><span>t_gt_s_same</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm_collapse_apps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Sym</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Sym (head (subst ρ t))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head (subst ρ t) = head t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop_same (&gt;<span class="hidden">⇩</span><sub>t</sub>) t s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_gt_s_same</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_same_def</span><span> </span><span>chkchop_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gt_same2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop_same (&gt;<span class="hidden">⇩</span><sub>t</sub>) (subst ρ t) (subst ρ s)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_same_def</span><span> </span><span>chkchop_def</span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s"</span></span></span><span class="delimiter">]</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Sym</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹head (subst ρ t) = head t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_Sym (head (subst ρ t))›</span></span></span><span> 
</span><span>             </span><span>add_mset_commute</span><span> </span><span>add_mset_lt_left_lt</span><span> </span><span>chop_subst_Sym</span><span> </span><span>ground_imp_subst_iden</span><span> </span><span>hd.simps</span><span class="delimiter">(</span><span>18</span><span class="delimiter">)</span><span> 
</span><span>             </span><span>hsize_chop_lt</span><span> </span><span>t_gt_s_same</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.simps</span><span class="delimiter">(</span><span>17</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gt_same3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f∈local.ground_heads (head (subst ρ t)). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (subst ρ t)) (args (subst ρ s))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹head (subst ρ t) = head t›</span></span></span><span> </span><span>extf_compat_append_left</span><span> </span><span>extf_map_ts</span><span> </span><span>t_gt_s_same</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_same</span><span> </span><span>gt_same1</span><span> </span><span>gt_same2</span><span> </span><span>gt_same3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Totality on Ground Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_total_ground</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>extf_total</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀f. ext_total (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t ⟹ ground s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ s &gt;<span class="hidden">⇩</span><sub>t</sub> t ∨ t = s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>atomize_imp</span><span class="delimiter">,</span><span>
</span><span>    </span><span>rule</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). {# hsize t, hsize s #}"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). ground t ⟶ ground s ⟶ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ s &gt;<span class="hidden">⇩</span><sub>t</sub> t ∨ t = s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, s)"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>prod.case</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span> </span><span>prod.case</span><span> </span><span>atomize_imp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>    </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ta sa. {# hsize ta, hsize sa #} &lt; {# hsize t, hsize s #} ⟹ ground ta ⟹ ground sa ⟹
      ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa ∨ sa &gt;<span class="hidden">⇩</span><sub>t</sub> ta ∨ ta = sa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>gr_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gr_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground s"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ s &gt;<span class="hidden">⇩</span><sub>t</sub> t ∨ t = s"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop (&gt;<span class="hidden">⇩</span><sub>t</sub>) t s ∨ s &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_def</span><span> </span><span>tm.case_eq_if</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop s"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>add_mset_commute</span><span> </span><span>add_mset_lt_left_lt</span><span> </span><span>gr_s</span><span> </span><span>gr_t</span><span> </span><span>ground_chop</span><span> </span><span>gt_chop</span><span> </span><span>hsize_chop_lt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop (&gt;<span class="hidden">⇩</span><sub>t</sub>) s t ∨ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chkchop_def</span><span> </span><span>tm.case_eq_if</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop t"</span></span></span><span> </span><span>s</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_mset_lt_left_lt</span><span> </span><span>gr_s</span><span> </span><span>gr_t</span><span> </span><span>ground_chop</span><span> </span><span>gt_chop.intros</span><span> </span><span>gt_iff_chop_diff_same</span><span> </span><span>hsize_chop_lt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span>chkembs_t_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop (&gt;<span class="hidden">⇩</span><sub>t</sub>) t s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>chkembs_s_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chkchop (&gt;<span class="hidden">⇩</span><sub>t</sub>) s t"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t = Sym g"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ground_head</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head s = Sym f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ground_head</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g_gt_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g &gt;<span class="hidden">⇩</span><sub>s</sub> f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chkembs_t_s</span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span>g_gt_f</span><span> </span><span>gt_diff</span><span> </span><span>gt_sym_imp_hd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>f_gt_g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f &gt;<span class="hidden">⇩</span><sub>s</sub> g"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chkembs_s_t</span><span> </span><span>f</span><span> </span><span>f_gt_g</span><span> </span><span>g</span><span> </span><span>gt_diff</span><span> </span><span>gt_sym_imp_hd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g_eq_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g = f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>hd_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t = head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ts</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"args t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ss</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"args s"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ta ∈ set ?ts. ground ta"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ground_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>gr_t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀sa ∈ set ?ss. ground sa"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ground_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>gr_s</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ts_eq_ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ts = ?ss"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hd_t</span><span> </span><span>ts_eq_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>tm_expand_apps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ts_gt_ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf g (&gt;<span class="hidden">⇩</span><sub>t</sub>) ?ts ?ss"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chkembs_t_s</span><span> </span><span>g</span><span> </span><span>gt_same</span><span> </span><span>hd_t</span><span> </span><span>ts_gt_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ss_gt_ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf g (&gt;<span class="hidden">⇩</span><sub>t</sub>) ?ss ?ts"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chkembs_s_t</span><span> </span><span>f</span><span> </span><span>g_eq_f</span><span> </span><span>gt_same</span><span> </span><span>hd_t</span><span> </span><span>ss_gt_ts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span>gr_ss</span><span> </span><span>gr_ts</span><span>
</span><span>          </span><span>ext_total.total</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_total</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"set ?ts ∪ set ?ss"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>t</sub>)"</span></span></span><span> </span><span class="var">?ts</span><span> </span><span class="var">?ss</span><span> </span><span>g</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_multiset_doubletons</span><span> </span><span>epo_axioms</span><span> </span><span>hsize_in_args</span><span> </span><span>in_listsI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_sym_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Well-foundedness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>gtg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>g</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>g</sub>) ≡ λt s. ground t ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_wf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ghd_UNIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ground_heads_var x = UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>extf_wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀f. ext_wf (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. t &gt;<span class="hidden">⇩</span><sub>t</sub> s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ground_wfP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>g</sub> s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfP_iff_no_inf_chain</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. inf_chain (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>g</sub>) f"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t_bad</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>g</sub>) t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>bad_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ff</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"worst_chain (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>g</sub>) (λt s. hsize t &gt; hsize s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?U_of</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λi. {u. (?ff i) ⊳<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub> u}"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>wf_sz</span><span> </span><span class="delimiter">=</span><span> </span><span>wf_app</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wellorder_class.wf</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>hsize</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U = (⋃i. ?U_of i)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. ground (?ff i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>worst_chain_bad</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>t_bad</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>inf_chain_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. u ∈ U ⟹ ground u"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>U_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr</span><span> </span><span>ground_emb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>g</sub>) u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>u_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ ?U_of i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>u</span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ti</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ff i"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>u_bad</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>g</sub>) u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sz_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hsize u &lt; hsize ?ti"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emb_hsize_neq</span><span> </span><span>u_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sz_u</span><span> </span><span>min_worst_chain_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>u_bad</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Suc</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ff (i - 1) &gt;<span class="hidden">⇩</span><sub>t</sub> ?ff i"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>worst_chain_pred</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>t_bad</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ff i &gt;<span class="hidden">⇩</span><sub>t</sub> u"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_embedding_property</span><span> </span><span>u_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ff (i - 1) &gt;<span class="hidden">⇩</span><sub>t</sub> u"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_trans</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span>sz_u</span><span> </span><span>min_worst_chain_Suc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>u_bad</span><span class="delimiter">]</span><span> </span><span>gr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>u_good</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. u ∈ U ⟹ ¬ bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>g</sub>) u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>U_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bad_diff_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inf_chain (λt s. ground t ∧ (gt_diff t s ∨ gt_same t s)) ?ff"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ground (?ff i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gr</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ff i &gt;<span class="hidden">⇩</span><sub>t</sub> ?ff (Suc i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>worst_chain_pred</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>t_bad</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ gt_chop (?ff i) (?ff (Suc i))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gt_chop (?ff i) (?ff (Suc i))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chop (?ff i) ∈ ?U_of i"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>emb_step_chop</span><span> </span><span>emb_step_is_emb</span><span> </span><span>gt_chop</span><span> </span><span>gt_chop.cases</span><span> </span><span>gt_irrefl</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span>uij_in</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"chop (?ff i) ∈ U"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>U_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀n. ?ff n &gt;<span class="hidden">⇩</span><sub>t</sub> ?ff (Suc n)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>worst_chain_pred</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>t_bad</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>uij_gt_i_plus_3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop (?ff i) &gt;<span class="hidden">⇩</span><sub>t</sub> ?ff (Suc (Suc i))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>a</span><span> </span><span>gt_chop.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inf_chain (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>g</sub>) (λj. if j = 0 then chop (?ff i) else ?ff (Suc (i + j)))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>gr</span><span> </span><span>gr_u</span><span class="delimiter">[</span><span>OF</span><span> </span><span>uij_in</span><span class="delimiter">]</span><span> </span><span>uij_gt_i_plus_3</span><span> </span><span>worst_chain_pred</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>t_bad</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>g</sub>) (chop (?ff i))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bad_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_good</span><span class="delimiter">[</span><span>OF</span><span> </span><span>uij_in</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gt_diff (?ff i) (?ff (Suc i)) ∨ gt_same (?ff i) (?ff (Suc i))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gt_iff_chop_diff_same</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf {(s, t). ground s ∧ ground t ∧ sym (head t) &gt;<span class="hidden">⇩</span><sub>s</sub> sym (head s)}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_sym_wf</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfP_def</span><span> </span><span>wf_iff_no_infinite_down_chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{(s, t). ground t ∧ gt_diff t s}
      ⊆ {(s, t). ground s ∧ ground t ∧ sym (head t) &gt;<span class="hidden">⇩</span><sub>s</sub> sym (head s)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>t</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>gr_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gt_diff_t_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gt_diff t s"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>gr_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_iff_chop_diff_same</span><span> </span><span>gt_imp_vars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sym (head t) &gt;<span class="hidden">⇩</span><sub>s</sub> sym (head s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_t_s</span><span> </span><span>ground_head</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gr_s</span><span class="delimiter">]</span><span> </span><span>ground_head</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gr_t</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"head s"</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gt_hd_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_diff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf {(s, t). ground t ∧ gt_diff t s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>diff_O_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(s, t). ground t ∧ gt_diff t s} O {(s, t). ground t ∧ gt_same t s}
      ⊆ {(s, t). ground t ∧ gt_diff t s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gt_diff.simps</span><span> </span><span>gt_same.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>chkchop_def</span><span> </span><span>chkchop_same_def</span><span> </span><span>gt_same</span><span> </span><span>gt_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>diff_same_as_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(s, t). ground t ∧ (gt_diff t s ∨ gt_same t s)} =
      {(s, t). ground t ∧ gt_diff t s} ∪ {(s, t). ground t ∧ gt_same t s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bad_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inf_chain (λt s. ground t ∧ gt_same t s) (λi. ?ff (i + k))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_infinite_down_chain_compatible</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_diff</span><span> </span><span>_</span><span> </span><span>diff_O_same</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="var">?ff</span><span class="delimiter">]</span><span> </span><span>bad_diff_same</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>diff_same_as_union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>hd_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. is_Sym (head (?ff (i + k)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ground_head</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f = sym (head (?ff k))"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_eq_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head (?ff (i + k)) = Sym f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>f_def</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>hd_sym</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>ia</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_same</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>gt_same.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?gtu</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λt s. t ∈ U ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>UnionI</span><span> </span><span>CollectI</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ set (args (?ff i)) ⟹ t ∈ U"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span> </span><span>i</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>U_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>UnionI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"?U_of i"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arg_emb</span><span> </span><span>CollectI</span><span> </span><span>arg_emb</span><span> </span><span>hsize_in_args</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. extf f (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>g</sub>) (args (?ff (i + k))) (args (?ff (Suc i + k)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_same</span><span> </span><span>hd_eq_f</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>inf_chain_def</span><span> </span><span>gt_same.simps</span><span> </span><span>f_def</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ground_head</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>gr</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_mono_strong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>t</sub>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λt s. ground t ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub> s)"</span></span></span><span> </span><span class="delimiter">]</span><span> </span><span>ground_hd_in_ground_heads</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>ground_args</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. extf f ?gtu (args (?ff (i + k))) (args (?ff (Suc i + k)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_mono_strong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λt s. ground t ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub> s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λt s. t ∈ U ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>U_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inf_chain (extf f ?gtu) (λi. args (?ff (i + k)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>nwf_ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ wfP (λxs ys. extf f ?gtu ys xs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfP_iff_no_inf_chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gtu_le_gtg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?gtu ≤ (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>g</sub>)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>gr_u</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. ?gtu t s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfP_iff_no_inf_chain</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>notI</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>bad_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inf_chain ?gtu f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>bad_f0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bad ?gtu (f 0)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inf_chain_bad</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f 0 ∈ U"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_f</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>good_f0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ bad ?gtu (f 0)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_good</span><span> </span><span>bad_f</span><span> </span><span>inf_chain_bad</span><span> </span><span>inf_chain_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>gtu_le_gtg</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_f0</span><span> </span><span>good_f0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wf_ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λxs ys. extf f ?gtu ys xs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext_wf.wf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_wf</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nwf_ext</span><span> </span><span>wf_ext</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?subst</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst grounding_ρ"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. ?subst t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>g</sub> ?subst s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wfP_app</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ground_wfP</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. ?subst t &gt;<span class="hidden">⇩</span><sub>t</sub> ?subst s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ground_grounding_ρ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_sus</span><span> </span><span>ghd_UNIV</span><span> </span><span>ground_heads.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>wary_grounding_ρ</span><span> </span><span>wfP_eq_minimal</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>