<div id="KuratowskiClosureComplementTheorem">
<div class="head"><h1>Theory KuratowskiClosureComplementTheorem</h1>
<span class="command">theory</span> <span class="name">KuratowskiClosureComplementTheorem</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Analysis/Multivariate_Analysis.html"><span class="name">Multivariate_Analysis</span></a> <a href="../../HOL/HOL-Analysis/Continuum_Not_Denumerable.html"><span class="name">Continuum_Not_Denumerable</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>KuratowskiClosureComplementTheorem</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Analysis.Multivariate_Analysis"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Analysis.Continuum_Not_Denumerable"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Introduction ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We discuss a topological curiosity discovered by @{cite
"Kuratowski:1922"}: the fact that the number of distinct operators on
a topological space generated by compositions of closure and
complement never exceeds 14, and is exactly 14 in the case of @{term
"ℝ"}. In addition, we prove a theorem due to @{cite
"Chagrov:1982"} that classifies topological spaces according to the
number of such operators they support.

Kuratowski's result, which is exposited in @{cite
"TheoremOfTheDay:2015"} and Chapter 7 of @{cite "Chamberland:2015"},
has already been treated in Mizar --- see @{cite
"BaginskaGrabowski:2003"} and @{cite "Grabowski:2004"}. To the best of
our knowledge, we are the first to mechanize Chagrov's result.

Our work is based on a presentation of Kuratowski's and Chagrov's
results by @{cite "GardnerJackson:2008"}.

We begin with some preliminary facts pertaining to the relationship
between interiors of unions and unions of interiors
(\S\ref{sec:interiors-unions}) and the relationship between @{term
"ℚ"} and @{term "ℝ"} (\S\ref{sec:rat-real}). We then prove
Kuratowski's result (\S\ref{sec:kuratowski}) and the corollary that at
most 7 distinct operators on a topological space can be generated by
compositions of closure and interior
(\S\ref{sec:kuratowski-corollary}). Finally, we prove Chagrov's result
(\S\ref{sec:chagrov}).

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Interiors and unions \label{sec:interiors-unions} ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>boundary</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::topological_space set ⇒ 'a set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"boundary X = closure X - interior X"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>boundary_empty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"boundary {} = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>boundary_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>exterior</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::topological_space set ⇒ 'a set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"exterior X = - (interior X ∪ boundary X)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>interior_union_boundary</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"interior (X ∪ Y) = interior X ∪ interior Y
           ⟷ boundary X ∩ boundary Y ⊆ boundary (X ∪ Y)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?lhs1 = ?lhs2) ⟷ ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>subset_antisym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subsetI</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs1 = ?lhs2"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>boundary_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?lhs1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?lhs2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ interior X"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ interior Y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ boundary X ∩ boundary Y"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?rhs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ ?lhs1›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>boundary_def</span><span> </span><span>subset_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>X</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ boundary X"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>Y</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ boundary Y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>X</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>X</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∉ interior X›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ exterior X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exterior_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∉ boundary X›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ exterior X›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∉ interior X›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open U"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U ⊆ - X"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ U"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ComplI</span><span> </span><span>DiffI</span><span> </span><span>boundary_def</span><span> </span><span>closure_interior</span><span> </span><span>interior_subset</span><span> </span><span>open_interior</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ interior (X ∪ Y)›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open U'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U' ⊆ X ∪ Y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ U'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>interiorE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹U ⊆ - X›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹U' ⊆ X ∪ Y›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U ∩ U' ⊆ Y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∉ interior Y›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹open U'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹open U›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ U'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ U›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>IntI</span><span> </span><span>interiorI</span><span> </span><span>open_Int</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Y</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Y</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∉ interior Y›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ exterior Y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exterior_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∉ boundary Y›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ exterior Y›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∉ interior Y›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open U"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U ⊆ - Y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ U"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ComplI</span><span> </span><span>DiffI</span><span> </span><span>boundary_def</span><span> </span><span>closure_interior</span><span> </span><span>interior_subset</span><span> </span><span>open_interior</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ interior (X ∪ Y)›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open U'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U' ⊆ X ∪ Y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ U'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>interiorE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹U ⊆ -Y›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹U' ⊆ X ∪ Y›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U ∩ U' ⊆ X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∉ interior X›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹open U'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹open U›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ U'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ U›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>IntI</span><span> </span><span>interiorI</span><span> </span><span>open_Int</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ ?lhs1›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?lhs2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs2 ⊆ ?lhs1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>interior_mono</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>interior_union_closed_intervals</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::ordered_euclidean_space"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b &lt; c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"interior ({a..b} ∪ {c..d}) = interior {a..b} ∪ interior {c..d}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>interior_union_boundary</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>boundary_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Additional facts about the rationals and reals \label{sec:rat-real} ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rat_real_limpt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>real</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x islimpt ℚ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>islimptI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>T</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; e"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ball</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦x' - x¦ &lt; e ⟶ x' ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>open_real</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; e›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; real_of_rat q ∧ real_of_rat q &lt; x + e"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>of_rat_dense</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ball</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃y∈ℚ. y ∈ T ∧ y ≠ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rat_closure</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"closure ℚ = (UNIV :: real set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>closure_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Rat_real_limpt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rat_interval_closure</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>real</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"closure ({x&lt;..&lt;y} ∩ ℚ) = {x..y}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Rat_closure</span><span> </span><span>closure_closure</span><span> </span><span>closure_greaterThanLessThan</span><span> </span><span>closure_mono</span><span> </span><span>inf_le1</span><span> </span><span>inf_top.right_neutral</span><span> </span><span>open_Int_closure_subset</span><span> </span><span>open_real_greaterThanLessThan</span><span> </span><span>subset_antisym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rat_not_open</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>T</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open T"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬T ⊆ ℚ"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>countable_rat</span><span> </span><span>open_minus_countable</span><span> </span><span>subset_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Irrat_dense_in_real</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>real</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃r∈-ℚ. x &lt; r ∧ r &lt; y"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>Rat_not_open</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>T</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"{x&lt;..&lt;y}"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>closed_interval_Int_compl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>real</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y &lt; z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"- {x..y} ∩ - {y..z} = - {x..z}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Kuratowski's result \label{sec:kuratowski} ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We prove that at most 14 distinct operators can be generated by compositions of @{const "closure"} and complement. For convenience, we give these operators short names and try to avoid pointwise reasoning. We treat the @{const "interior"} operator at the same time.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>o_apply</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>C</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::topological_space set ⇒ 'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C X = - X"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>K</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::topological_space set ⇒ 'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K X = closure X"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>I</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::topological_space set ⇒ 'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I X = interior X"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>C_C</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∘ C = id"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>C_def</span><span> </span><span>o_apply</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>K_K</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K ∘ K = K"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>K_def</span><span> </span><span>o_apply</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>I_I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ∘ I = I"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>I_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>I_K</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I = C ∘ K ∘ C"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_def</span><span> </span><span>I_def</span><span> </span><span>K_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>interior_closure</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>K_I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K = C ∘ I ∘ C"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_def</span><span> </span><span>I_def</span><span> </span><span>K_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>interior_closure</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>K_I_K_I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K ∘ I ∘ K ∘ I = K ∘ I"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_def</span><span> </span><span>I_def</span><span> </span><span>K_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>o_apply</span><span> </span><span>closure_minimal</span><span> </span><span>closure_mono</span><span> </span><span>closure_subset</span><span> </span><span>interior_maximal</span><span> </span><span>interior_subset</span><span> </span><span>subset_antisym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>I_K_I_K</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ∘ I ∘ K = I ∘ K"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_def</span><span> </span><span>I_def</span><span> </span><span>K_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>o_apply</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>closure_closure</span><span> </span><span>closure_mono</span><span> </span><span>closure_subset</span><span> </span><span>interior_maximal</span><span> </span><span>interior_mono</span><span> </span><span>interior_subset</span><span> </span><span>open_interior</span><span> </span><span>subset_antisym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>K_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊆ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K x ⊆ K y"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>K_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>closure_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The following lemma embodies the crucial observation about compositions of @{const "C"} and @{const "K"}:

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>KCKCKCK_KCK</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K ∘ C ∘ K ∘ C ∘ K ∘ C ∘ K = K ∘ C ∘ K"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">[</span><span>OF</span><span> </span><span>equalityI</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C ∘ K ∘ C ∘ K ∘ C ∘ K) x ⊆ ?rhs x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>C_def</span><span> </span><span>K_def</span><span> </span><span>closure_def</span><span> </span><span>o_apply</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(K ∘ (C ∘ K ∘ C ∘ K ∘ C ∘ K)) x ⊆ (K ∘ ?rhs) x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>K_mono</span><span> </span><span>o_apply</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs x ⊆ ?rhs x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>K_K</span><span> </span><span>o_assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::topological_space set"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C ∘ K ∘ C ∘ K) x ⊆ K x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>C_def</span><span> </span><span>K_def</span><span> </span><span>closure_def</span><span> </span><span>o_apply</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(K ∘ (C ∘ K ∘ C ∘ K)) x ⊆ (K ∘ K) x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>K_mono</span><span> </span><span>o_apply</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C ∘ (K ∘ K)) x ⊆ (C ∘ (K ∘ (C ∘ K ∘ C ∘ K))) x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>C_def</span><span> </span><span>o_apply</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(K ∘ (C ∘ (K ∘ K))) x ⊆ (K ∘ (C ∘ (K ∘ (C ∘ K ∘ C ∘ K)))) x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>K_mono</span><span> </span><span>o_apply</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rhs x ⊆ ?lhs x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>K_K</span><span> </span><span>o_assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The inductive set ‹CK› captures all operators that can be generated by compositions of @{const "C"} and @{const "K"}. We shallowly embed the operators; that is, we identify operators up to extensional equality.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>CK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::topological_space set ⇒ 'a set) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CK C"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK K"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ CK f; CK g ⟧ ⟹ CK (f ∘ g)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>CK.intros</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CK_id</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CK id"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CK.intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>CK.intros</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>C_C</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The inductive set ‹CK_nf› captures the normal forms for the 14 distinct operators.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>CK_nf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::topological_space set ⇒ 'a set) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CK_nf id"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf C"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf K"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf (C ∘ K)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf (K ∘ C)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf (C ∘ K ∘ C)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf (K ∘ C ∘ K)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf (C ∘ K ∘ C ∘ K)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf (K ∘ C ∘ K ∘ C)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf (C ∘ K ∘ C ∘ K ∘ C)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf (K ∘ C ∘ K ∘ C ∘ K)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf (C ∘ K ∘ C ∘ K ∘ C ∘ K)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf (K ∘ C ∘ K ∘ C ∘ K ∘ C)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf (C ∘ K ∘ C ∘ K ∘ C ∘ K ∘ C)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>CK_nf.intros</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CK_nf_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{f . CK_nf f} = {id, C, K, C ∘ K, K ∘ C, C ∘ K ∘ C, K ∘ C ∘ K, C ∘ K ∘ C ∘ K, K ∘ C ∘ K ∘ C, C ∘ K ∘ C ∘ K ∘ C, K ∘ C ∘ K ∘ C ∘ K, C ∘ K ∘ C ∘ K ∘ C ∘ K, K ∘ C ∘ K ∘ C ∘ K ∘ C, C ∘ K ∘ C ∘ K ∘ C ∘ K ∘ C}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>CK_nf.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

That each operator generated by compositions of @{const "C"} and
@{const "K"} is extensionally equivalent to one of the normal forms
captured by ‹CK_nf› is demonstrated by means of an
induction over the construction of ‹CK_nf› and an appeal
to the facts proved above.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>CK_nf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CK f ⟷ CK_nf f"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CK f"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf f"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span>
</span><span>       </span><span class="delimiter">(</span><span>elim</span><span> </span><span>CK_nf.cases</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>C_C</span><span> </span><span>K_K</span><span> </span><span>KCKCKCK_KCK</span><span> </span><span>o_assoc</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>C_C</span><span> </span><span>K_K</span><span> </span><span>KCKCKCK_KCK</span><span> </span><span>o_assoc</span><span>
</span><span>      </span><span class="delimiter">|</span><span> </span><span>blast</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf f"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CK f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>CK_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f. CK f} ≤ 14"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>CK_nf</span><span> </span><span>CK_nf_set</span><span> </span><span>card_insert</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>card_Diff1_le</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We show, using the following subset of ‹ℝ› (an
example taken from @{cite "Rusin:2001"}) as a witness, that there
exist topological spaces on which all 14 operators are distinct.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>RRR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"RRR = {0&lt;..&lt;1} ∪ {1&lt;..&lt;2} ∪ {3} ∪ ({5&lt;..&lt;7} ∩ ℚ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The following facts allow the required proofs to proceed by @{method simp}:

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RRR_closure</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"closure RRR = {0..2} ∪ {3} ∪ {5..7}"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RRR_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closure_insert</span><span> </span><span>Rat_interval_closure</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RRR_interior</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"interior RRR = {0&lt;..&lt;1} ∪ {1&lt;..&lt;2}"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>equalityI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subsetI</span><span> </span><span>subsetI</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?lhs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ⊆ RRR"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>interiorE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; e"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ball x e ⊆ T"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>openE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ T›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; e›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ball x e ⊆ T›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹T ⊆ RRR›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = 3"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RRR_def</span><span> </span><span>ball_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>subsetD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"min (3 + e/2) 4"</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dist_real_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Irrat_dense_in_real</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x + e/2"</span></span></span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; e›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r∈- ℚ ∧ x &lt; r ∧ r &lt; x + e / 2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ T›</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹ball x e ⊆ T›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹T ⊆ RRR›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {5&lt;..&lt;7} ∩ ℚ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RRR_def</span><span> </span><span>ball_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dist_real_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>subsetD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">=</span><span>r</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ interior RRR›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?rhs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RRR_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>interior_subset</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?rhs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?lhs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RRR_def</span><span> </span><span>interior_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>open_real_greaterThanLessThan</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RRR_interior_closure</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"interior ({0::real..2} ∪ {3} ∪ {5..7}) = {0&lt;..&lt;2} ∪ {5&lt;..&lt;7}"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = interior ({0..2} ∪ {5..7})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Un_assoc</span><span> </span><span>Un_commute</span><span> </span><span>closed_Un</span><span> </span><span>closed_eucl_atLeastAtMost</span><span> </span><span>interior_closed_Un_empty_interior</span><span> </span><span>interior_singleton</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ?rhs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>interior_union_closed_intervals</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The operators can be distinguished by testing which of the points in
‹{1,2,3,4,6}› belong to their results.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>test</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(real set ⇒ real set) ⇒ bool list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"test f ≡ map (λx. x ∈ f RRR) [1,2,3,4,6]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RRR_test</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f RRR = g RRR"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test f = test g"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>test_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nf_RRR</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"test id = [False, False, True, False, True]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"test C = [True, True, False, True, False]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"test K = [True, True, True, False, True]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"test (K ∘ C) = [True, True, True, True, True]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"test (C ∘ K) = [False, False, False, True, False]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"test (C ∘ K ∘ C) = [False, False, False, False, False]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"test (K ∘ C ∘ K) = [False, True, True, True, False]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"test (C ∘ K ∘ C ∘ K) = [True, False, False, False, True]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"test (K ∘ C ∘ K ∘ C) = [True, True, False, False, False]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"test (C ∘ K ∘ C ∘ K ∘ C) = [False, False, True, True, True]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"test (K ∘ C ∘ K ∘ C ∘ K) = [True, True, False, False, True]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"test (C ∘ K ∘ C ∘ K ∘ C ∘ K) = [False, False, True, True, False]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"test (K ∘ C ∘ K ∘ C ∘ K ∘ C) = [False, True, True, True, True]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"test (C ∘ K ∘ C ∘ K ∘ C ∘ K ∘ C) = [True, False, False, False, False]"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>test_def</span><span> </span><span>C_def</span><span> </span><span>K_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RRR_closure</span><span> </span><span>RRR_interior</span><span> </span><span>RRR_interior_closure</span><span> </span><span>closure_complement</span><span> </span><span>closed_interval_Int_compl</span><span> </span><span>o_apply</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RRR_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>CK_nf_real_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card ((λ f. f RRR) ` {f . CK_nf f}) = 14"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CK_nf_set</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>subst</span><span> </span><span>card_insert_disjoint</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>RRR_test</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nf_RRR</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>CK_real_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f::real set ⇒ real set. CK f} = 14"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CK_card</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rhs ≤ ?lhs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CK_nf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>eq_imp_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CK_nf_real_card</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>card_image_le</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CK_nf_set</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ A corollary of Kuratowski's result \label{sec:kuratowski-corollary} ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We show that it is a corollary of @{thm [source] CK_real_card} that at
most 7 distinct operators on a topological space can be generated by
compositions of closure and interior. In the case of
‹ℝ›, exactly 7 distinct operators can be so
generated.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>IK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::topological_space set ⇒ 'a set) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"IK id"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"IK I"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"IK K"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ IK f; IK g ⟧ ⟹ IK (f ∘ g)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>IK_nf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::topological_space set ⇒ 'a set) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"IK_nf id"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"IK_nf I"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"IK_nf K"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"IK_nf (I ∘ K)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"IK_nf (K ∘ I)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"IK_nf (I ∘ K ∘ I)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"IK_nf (K ∘ I ∘ K)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>IK.intros</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>IK_nf.intros</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IK_nf_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{f . IK_nf f} = {id, I, K, I ∘ K, K ∘ I, I ∘ K ∘ I, K ∘ I ∘ K}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IK_nf.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>IK_nf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"IK f ⟷ IK_nf f"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"IK f"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"IK_nf f"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span>
</span><span>       </span><span class="delimiter">(</span><span>elim</span><span> </span><span>IK_nf.cases</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>o_assoc</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>I_I</span><span> </span><span>K_K</span><span> </span><span>o_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>K_I_K_I</span><span> </span><span>I_K_I_K</span><span> </span><span>o_assoc</span><span>
</span><span>      </span><span class="delimiter">|</span><span> </span><span>blast</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"IK_nf f"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"IK f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>IK_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f. IK f} ≤ 7"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IK_nf</span><span> </span><span>IK_nf_set</span><span> </span><span>card_insert</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>card_Diff1_le</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>IK_nf_real_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card ((λ f. f RRR) ` {f . IK_nf f}) = 7"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>IK_nf_set</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>subst</span><span> </span><span>card_insert_disjoint</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>RRR_test</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nf_RRR</span><span> </span><span>I_K</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>o_assoc</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>IK_real_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f::real set ⇒ real set. IK f} = 7"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>IK_card</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rhs ≤ ?lhs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IK_nf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>eq_refl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>IK_nf_real_card</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>card_image_le</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>IK_nf_set</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Chagrov's result \label{sec:chagrov} ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Chagrov's theorem, which is discussed in Section 2.1 of @{cite
"GardnerJackson:2008"}, states that the number of distinct operators
on a topological space that can be generated by compositions of
closure and complement is one of 2, 6, 8, 10 or 14.

We begin by observing that the set of normal forms @{const "CK_nf"}
can be split into two disjoint sets, @{term "CK_nf_pos"} and @{term
"CK_nf_neg"}, which we define in terms of interior and closure.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>CK_nf_pos</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::topological_space set ⇒ 'a set) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CK_nf_pos id"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf_pos I"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf_pos K"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf_pos (I ∘ K)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf_pos (K ∘ I)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf_pos (I ∘ K ∘ I)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf_pos (K ∘ I ∘ K)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>CK_nf_pos.intros</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CK_nf_pos_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{f . CK_nf_pos f} = {id, I, K, I ∘ K, K ∘ I, I ∘ K ∘ I, K ∘ I ∘ K}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>CK_nf_pos.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>CK_nf_neg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::topological_space set ⇒ 'a set) ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CK_nf_neg f ⟷ (∃g. CK_nf_pos g ∧ f = C ∘ g)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CK_nf_pos_neg_disjoint</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf_pos f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CK_nf_neg g"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ≠ g"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CK_nf_neg_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>CK_nf_pos.simps</span><span class="delimiter">;</span><span> </span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>metis</span><span> </span><span>comp_def</span><span> </span><span>C_def</span><span> </span><span>I_def</span><span> </span><span>K_def</span><span> </span><span>Compl_iff</span><span> </span><span>closure_UNIV</span><span> </span><span>interior_UNIV</span><span> </span><span>id_apply</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CK_nf_pos_neg_CK_nf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CK_nf f ⟷ CK_nf_pos f ∨ CK_nf_neg f"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs ⟷ ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?lhs</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CK_nf_neg_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CK_nf.cases</span><span class="delimiter">;</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>CK_nf_pos.simps</span><span> </span><span>C_C</span><span> </span><span>I_K</span><span> </span><span>K_I</span><span> </span><span>comp_id</span><span> </span><span>o_assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CK_nf_neg_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>CK_nf_pos.cases</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>I_K</span><span> </span><span>C_C</span><span> </span><span>o_assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We now focus on @{const "CK_nf_pos"}. In particular, we show that its
cardinality for any given topological space is one of 1, 3, 4, 5 or 7.

The proof consists of exhibiting normal forms for the operators
supported by each of six classes of topological spaces. These are
sublattices of the following lattice of @{const CK_nf_pos} operators:

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>K_I_K_subseteq_K</span><span> </span><span class="delimiter">=</span><span> </span><span>closure_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>interior_subset</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"closure X"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CK_nf_pos_lattice</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ≤ (id :: 'a::topological_space set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"id ≤ (K :: 'a::topological_space set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ≤ I ∘ K ∘ (I :: 'a::topological_space set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ∘ I ≤ I ∘ (K :: 'a::topological_space set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ∘ I ≤ K ∘ (I :: 'a::topological_space set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ≤ K ∘ I ∘ (K :: 'a::topological_space set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ∘ I ≤ K ∘ I ∘ (K :: 'a::topological_space set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ∘ I ∘ K ≤ (K :: 'a::topological_space set ⇒ 'a set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>I_def</span><span> </span><span>K_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>interior_subset</span><span> </span><span>closure_subset</span><span> </span><span>interior_maximal</span><span> </span><span>closure_mono</span><span> </span><span>o_apply</span><span> </span><span>interior_mono</span><span> </span><span>K_I_K_subseteq_K</span><span> </span><span>le_funI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We define the six classes of topological spaces in question, and show
that they are related by inclusion in the following way (as shown in
Figure 2.3 of @{cite "GardnerJackson:2008"}):

\begin{center}
 \begin{tikzpicture}[scale=.7]
  \node (d) at (30:5cm) {Open unresolvable spaces};
  \node (one) at (90:5cm) {Kuratowski spaces};
  \node (b) at (150:5cm) {Extremally disconnected spaces};
  \node (a) at (210:5cm) {Partition spaces};
  \node (zero) at (270:5cm) {Discrete spaces};
  \node (c) at (330:5cm) {\hspace{1cm}Extremally disconnected and open unresolvable spaces};
  \draw (zero) -- (a) -- (b) -- (one) -- (d) -- (c) -- (zero);
  \draw (c) -- (b);
 \end{tikzpicture}
\end{center}

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Discrete spaces ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"discrete (X :: 'a::topological_space set) ⟷ I = (id::'a set ⇒ 'a set)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>discrete_eqs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"discrete (X :: 'a::topological_space set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I  = (id::'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K  = (id::'a set ⇒ 'a set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>discrete_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>C_C</span><span> </span><span>K_I</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>discrete_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"discrete (X :: 'a::topological_space set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f. CK_nf_pos (f::'a set ⇒ 'a set)} = 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>discrete_eqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>CK_nf_pos_lattice</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="tfree">'a</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CK_nf_pos_set</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>discrete_discrete_topology</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::topological_space set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀Y::'a set. open Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"discrete X"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>discrete_def</span><span> </span><span>I_def</span><span> </span><span>interior_def</span><span> </span><span>islimpt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Partition spaces ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"part (X :: 'a::topological_space set) ⟷ K ∘ I = (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>discrete_part</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"discrete X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"part X"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>discrete_def</span><span> </span><span>part_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>C_C</span><span> </span><span>K_I</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_eqs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"part (X :: 'a::topological_space set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ∘ I = (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ∘ K = (K :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>part_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>assumption</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>I_I</span><span> </span><span>K_I</span><span> </span><span>o_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_not_discrete_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"part (X :: 'a::topological_space set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬discrete X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f. CK_nf_pos (f::'a set ⇒ 'a set)} = 3"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>part_eqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹part X›</span></span></span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬discrete X›</span></span></span><span> </span><span>CK_nf_pos_lattice</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="tfree">'a</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>discrete_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CK_nf_pos_set</span><span> </span><span>card_insert_if</span><span> </span><span>C_C</span><span> </span><span>I_K</span><span> </span><span>K_K</span><span> </span><span>o_assoc</span><span class="delimiter">;</span><span> </span><span>metis</span><span> </span><span>comp_id</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

A partition space is a topological space whose basis consists of the empty set and the equivalence classes of points of the space induced by some equivalence relation @{term "R"} on the underlying set of the space. Equivalently, a partition space is one in which every open set is closed. Thus, for example, the class of partition spaces includes every topological space whose open sets form a boolean algebra.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>part_witness</span><span> </span><span class="delimiter">=</span><span> </span><span>a</span><span> </span><span class="delimiter">|</span><span> </span><span>b</span><span> </span><span class="delimiter">|</span><span> </span><span>c</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_witness_UNIV</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV = set [a, b, c]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>part_witness.exhaust</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>part_witness_pow</span><span> </span><span class="delimiter">=</span><span> </span><span>subset_subseqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subset_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subset_UNIV</span><span> </span><span>Set.equalityD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>part_witness_UNIV</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>part_witness_Compl</span><span> </span><span class="delimiter">=</span><span> </span><span>Compl_eq_Diff_UNIV</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span>part_witness</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>part_witness_UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>part_witness</span><span> </span><span class="delimiter">::</span><span> </span><span>topological_space</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open_part_witness X ⟷ X ∈ {{}, {a}, {b, c}, {a, b, c}}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_witness_ball</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀s∈S. s ∈ {{}, {a}, {b, c}, {a, b, c}}) ⟷ S ⊆ set [{}, {a}, {b, c}, {a, b, c}]"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>part_witness_subsets_pow</span><span> </span><span class="delimiter">=</span><span> </span><span>subset_subseqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>part_witness_ball</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>K</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"part_witness set set"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀S∈K. open S"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open (⋃K)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>open_part_witness_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>part_witness_subsets_pow</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">;</span><span> </span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_commute</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>open_part_witness_def</span><span> </span><span>part_witness_UNIV</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_witness_interior_simps</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a} = {a}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {b} = {}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {c} = {}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, b} = {a}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, c} = {a}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {b, c} = {b, c}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, b, c} = {a, b, c}"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>interior_def</span><span> </span><span>open_part_witness_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_witness_part</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"part_witness set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"part X"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"closure (interior Y) = interior Y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Y</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"part_witness set"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>part_witness_pow</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span>Y</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closure_interior</span><span> </span><span>part_witness_interior_simps</span><span> </span><span>part_witness_Compl</span><span> </span><span>insert_Diff_if</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>part_def</span><span> </span><span>I_def</span><span> </span><span>K_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_witness_not_discrete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"part_witness set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬discrete X"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>discrete_def</span><span> </span><span>I_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>o_apply</span><span> </span><span>fun_eq_iff</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"{b}"</span></span></span><span class="delimiter">]</span><span> </span><span>part_witness_interior_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_witness_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f. CK_nf_pos (f::part_witness set ⇒ part_witness set)} = 3"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>part_not_discrete_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>part_witness_part</span><span> </span><span>part_witness_not_discrete</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Extremally disconnected and open unresolvable spaces ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ed_ou (X :: 'a::topological_space set) ⟷ I ∘ K = K ∘ (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>discrete_ed_ou</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"discrete X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ed_ou X"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>discrete_def</span><span> </span><span>ed_ou_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ed_ou_eqs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ed_ou (X :: 'a::topological_space set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ∘ I = K ∘ (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ∘ I ∘ K = K ∘ (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ∘ K = K ∘ (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ed_ou_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>I_I</span><span> </span><span>K_K</span><span> </span><span>o_assoc</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ed_ou_neqs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ed_ou (X :: 'a::topological_space set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬discrete X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ≠ (K :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ≠ K ∘ (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ≠ K ∘ (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ≠ (id :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ≠ (id :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>CK_nf_pos_lattice</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="tfree">'a</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ed_ou_def</span><span> </span><span>discrete_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>C_C</span><span> </span><span>I_K</span><span> </span><span>K_I</span><span> </span><span>comp_id</span><span> </span><span>o_assoc</span><span> </span><span>antisym</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ed_ou_not_discrete_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ed_ou (X :: 'a::topological_space set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬discrete X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f. CK_nf_pos (f::'a set ⇒ 'a set)} = 4"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ed_ou_eqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ed_ou X›</span></span></span><span class="delimiter">]</span><span> </span><span>ed_ou_neqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>CK_nf_pos_set</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>card_insert_disjoint</span><span class="delimiter">;</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We consider an example extremally disconnected and open unresolvable topological space.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ed_ou_witness</span><span> </span><span class="delimiter">=</span><span> </span><span>a</span><span> </span><span class="delimiter">|</span><span> </span><span>b</span><span> </span><span class="delimiter">|</span><span> </span><span>c</span><span> </span><span class="delimiter">|</span><span> </span><span>d</span><span> </span><span class="delimiter">|</span><span> </span><span>e</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ed_ou_witness_UNIV</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV = set [a, b, c, d, e]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ed_ou_witness.exhaust</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>ed_ou_witness_pow</span><span> </span><span class="delimiter">=</span><span> </span><span>subset_subseqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subset_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subset_UNIV</span><span> </span><span>Set.equalityD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ed_ou_witness_UNIV</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>ed_ou_witness_Compl</span><span> </span><span class="delimiter">=</span><span> </span><span>Compl_eq_Diff_UNIV</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span>ed_ou_witness</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>ed_ou_witness_UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>ed_ou_witness</span><span> </span><span class="delimiter">::</span><span> </span><span>finite</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ed_ou_witness_UNIV</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>ed_ou_witness</span><span> </span><span class="delimiter">::</span><span> </span><span>topological_space</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>open_ed_ou_witness</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ed_ou_witness set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {a}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {b}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {e}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {a, c}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {b, d}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {a, c, e}"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {a, b}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {a, e}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {b, e}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {a, b, c}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {a, b, d}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {a, b, e}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {b, d, e}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {a, b, c, d}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {a, b, c, e}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {a, b, d, e}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ed_ou_witness {a, b, c, d, e}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>open_ed_ou_witness.intros</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ed_ou_witness_inter</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ed_ou_witness set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open T"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open (S ∩ T)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>open_ed_ou_witness.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ed_ou_witness_union</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ed_ou_witness set set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈X. open x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open (⋃X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite</span><span class="delimiter">[</span><span>of</span><span> </span><span>X</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">;</span><span> </span><span>elim</span><span> </span><span>open_ed_ou_witness.cases</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>open_ed_ou_witness.simps</span><span> </span><span>subset_insertI2</span><span> </span><span>insert_commute</span><span class="delimiter">;</span><span> </span><span>metis</span><span> </span><span>Union_empty_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ed_ou_witness_UNIV</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ed_ou_witness_inter</span><span> </span><span>ed_ou_witness_union</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ed_ou_witness_interior_simps</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a} = {a}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {b} = {b}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {c} = {}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {d} = {}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {e} = {e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, b} = {a, b}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, c} = {a, c}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, d} = {a}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, e} = {a, e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {b, c} = {b}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {b, d} = {b, d}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {b, e} = {b, e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {c, d} = {}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {c, e} = {e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {d, e} = {e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, b, c} = {a, b, c}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, b, d} = {a, b, d}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, b, e} = {a, b, e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, c, d} = {a, c}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, c, e} = {a, c, e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, d, e} = {a, e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {b, c, d} = {b, d}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {b, c, e} = {b, e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {b, d, e} = {b, d, e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {c, d, e} = {e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, b, c, d} = {a, b, c, d}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, b, c, e} = {a, b, c, e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, b, d, e} = {a, b, d, e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, b, c, d, e} = {a, b, c, d, e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {a, c, d, e} = {a, c, e}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interior {b, c, d, e} = {b, d, e}"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>interior_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>safe</span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>open_ed_ou_witness.simps</span><span class="delimiter">;</span><span> </span><span>blast</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ed_ou_witness_not_discrete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ed_ou_witness set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬discrete X"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>discrete_def</span><span> </span><span>I_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ed_ou_witness_interior_simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ed_ou_witness_ed_ou</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ed_ou_witness set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ed_ou X"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ed_ou_def</span><span> </span><span>I_def</span><span> </span><span>K_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>o_apply</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ed_ou_witness set"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ed_ou_witness_pow</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"interior (closure x) = closure (interior x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>closure_interior</span><span> </span><span>ed_ou_witness_interior_simps</span><span> </span><span>ed_ou_witness_Compl</span><span> </span><span>insert_Diff_if</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ed_ou_witness_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f. CK_nf_pos (f::ed_ou_witness set ⇒ ed_ou_witness set)} = 4"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ed_ou_not_discrete_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ed_ou_witness_ed_ou</span><span> </span><span>ed_ou_witness_not_discrete</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Extremally disconnected spaces ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"extremally_disconnected (X :: 'a::topological_space set) ⟷ K ∘ I ∘ K = I ∘ (K :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ed_ou_part_extremally_disconnected</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ed_ou X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"part X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extremally_disconnected X"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extremally_disconnected_def</span><span> </span><span>ed_ou_def</span><span> </span><span>part_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extremally_disconnected_eqs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::topological_space set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extremally_disconnected X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ∘ I = K ∘ (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ∘ I ∘ K = I ∘ (K :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extremally_disconnected_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>K_I_K_I</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extremally_disconnected_not_part_not_ed_ou_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::topological_space set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extremally_disconnected X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬part X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ed_ou X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f. CK_nf_pos (f::'a set ⇒ 'a set)} = 5"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extremally_disconnected_eqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹extremally_disconnected X›</span></span></span><span class="delimiter">]</span><span> </span><span>CK_nf_pos_lattice</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="tfree">'a</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>part_def</span><span> </span><span>ed_ou_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CK_nf_pos_set</span><span> </span><span>C_C</span><span> </span><span>I_K</span><span> </span><span>K_K</span><span> </span><span>o_assoc</span><span> </span><span>card_insert_if</span><span class="delimiter">;</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>C_C</span><span> </span><span>K_I</span><span> </span><span>id_comp</span><span> </span><span>o_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Any topological space having an infinite underlying set and whose topology consists of the empty set and every cofinite subset of the underlying set is extremally disconnected. We consider an example such space having a countably infinite underlying set.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>cofinite</span><span> </span><span class="delimiter">=</span><span> </span><span>cofinite</span><span> </span><span class="tfree">'a</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>cofinite</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>type</span><span class="delimiter">)</span><span> </span><span>topological_space</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open_cofinite = (λX::'a cofinite set. finite (-X) ∨ X = {})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>open_cofinite_def</span><span> </span><span>uminus_Sup</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinite_closure_finite</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a cofinite set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"closure X = X"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>closed_open</span><span> </span><span>open_cofinite_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinite_closure_infinite</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a cofinite set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"infinite X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"closure X = UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Compl_empty_eq</span><span> </span><span>closure_subset</span><span> </span><span>double_compl</span><span> </span><span>finite_subset</span><span> </span><span>interior_complement</span><span> </span><span>open_cofinite_def</span><span> </span><span>open_interior</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinite_interior_finite</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a cofinite set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"infinite (UNIV::'a cofinite set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"interior X = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>cofinite_closure_infinite</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"-X"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>interior_closure</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinite_interior_infinite</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a cofinite set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"infinite X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"infinite (-X)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"interior X = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>cofinite_closure_infinite</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"-X"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>interior_closure</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"evens :: nat cofinite set ≡ {cofinite n | n. ∃i. n=2*i}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>evens_infinite</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"infinite evens"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffD2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>infinite_iff_countable_subset</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λn::nat. cofinite (2*n)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inj ?f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>inj_onI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range ?f ⊆ evens"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinite_nat_infinite</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"infinite (UNIV::nat cofinite set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>evens_infinite</span><span> </span><span>finite_Diff2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>evens_Compl_infinite</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"infinite (- evens)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffD2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>infinite_iff_countable_subset</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λn::nat. cofinite (2*n+1)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inj ?f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>inj_onI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range ?f ⊆ -evens"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span> </span><span>presburger</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>evens_closure</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"closure evens = UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>evens_infinite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cofinite_closure_infinite</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>evens_interior</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"interior evens = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>evens_infinite</span><span> </span><span>evens_Compl_infinite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cofinite_interior_infinite</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinite_not_part</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat cofinite set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬part X"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>part_def</span><span> </span><span>I_def</span><span> </span><span>K_def</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cofinite_nat_infinite</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>o_apply</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>cofinite_closure_finite</span><span> </span><span>cofinite_interior_finite</span><span> </span><span>double_compl</span><span> </span><span>finite.emptyI</span><span> </span><span>finite.insertI</span><span> </span><span>insert_not_empty</span><span> </span><span>interior_closure</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinite_not_ed_ou</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat cofinite set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ed_ou X"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ed_ou_def</span><span> </span><span>I_def</span><span> </span><span>K_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>o_apply</span><span> </span><span>evens_closure</span><span> </span><span>evens_interior</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"evens"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinite_extremally_disconnected_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat cofinite set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"closure (interior (closure X)) ⊆ interior (closure X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subsetI</span><span> </span><span>closure_closure</span><span> </span><span>closure_complement</span><span> </span><span>closure_def</span><span> </span><span>closure_empty</span><span> </span><span>finite_Un</span><span> </span><span>interior_eq</span><span> </span><span>open_cofinite_def</span><span> </span><span>open_interior</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinite_extremally_disconnected</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat cofinite set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extremally_disconnected X"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extremally_disconnected_def</span><span> </span><span>I_def</span><span> </span><span>K_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>o_apply</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>closure_subset</span><span class="delimiter">]</span><span> </span><span>subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>interior_subset</span><span class="delimiter">]</span><span> </span><span>subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cofinite_extremally_disconnected_aux</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinite_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f. CK_nf_pos (f::nat cofinite set ⇒ nat cofinite set)} = 5"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>extremally_disconnected_not_part_not_ed_ou_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cofinite_extremally_disconnected</span><span> </span><span>cofinite_not_part</span><span> </span><span>cofinite_not_ed_ou</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Open unresolvable spaces ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"open_unresolvable (X :: 'a::topological_space set) ⟷ K ∘ I ∘ K = K ∘ (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ed_ou_open_unresolvable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ed_ou X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open_unresolvable X"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>open_unresolvable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ed_ou_eqs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>open_unresolvable_eqs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open_unresolvable (X :: 'a::topological_space set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ∘ I = I ∘ (K :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ∘ I ∘ K = K ∘ (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>open_unresolvable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>I_K_I_K</span><span> </span><span>o_assoc</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_ed_ou_neqs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ed_ou (X :: 'a::topological_space set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ≠ I ∘ (K :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ≠ K ∘ (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ed_ou_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>I_K</span><span> </span><span>K_def</span><span> </span><span>C_def</span><span> </span><span>o_apply</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>closure_eq_empty</span><span> </span><span>disjoint_eq_subset_Compl</span><span> </span><span>double_complement</span><span> </span><span>interior_Int</span><span> </span><span>interior_complement</span><span> </span><span>set_eq_subset</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>open_unresolvable_not_ed_ou_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open_unresolvable (X :: 'a::topological_space set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ed_ou X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f. CK_nf_pos (f::'a set ⇒ 'a set)} = 5"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>open_unresolvable_eqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹open_unresolvable X›</span></span></span><span class="delimiter">]</span><span> </span><span>not_ed_ou_neqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ed_ou X›</span></span></span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ed_ou X›</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ed_ou_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>CK_nf_pos_set</span><span> </span><span>card_insert_if</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We show that the class of open unresolvable spaces is non-empty by exhibiting an example of such a space.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ou_witness</span><span> </span><span class="delimiter">=</span><span> </span><span>a</span><span> </span><span class="delimiter">|</span><span> </span><span>b</span><span> </span><span class="delimiter">|</span><span> </span><span>c</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ou_witness_UNIV</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV = set [a, b, c]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ou_witness.exhaust</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>ou_witness</span><span> </span><span class="delimiter">::</span><span> </span><span>topological_space</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open_ou_witness X ⟷ a ∉ X ∨ X = UNIV"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>open_ou_witness_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ou_witness_closure_simps</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"closure {a} = {a}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"closure {b} = {a, b}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"closure {c} = {a, c}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"closure {a, b} = {a, b}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"closure {a, c} = {a, c}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"closure {a, b, c} = {a, b, c}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"closure {b, c} = {a, b, c}"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>closure_def</span><span> </span><span>islimpt_def</span><span> </span><span>open_ou_witness_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ou_witness_open_unresolvable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ou_witness set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open_unresolvable X"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>open_unresolvable_def</span><span> </span><span>I_def</span><span> </span><span>K_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>o_apply</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Compl_iff</span><span> </span><span>K_I_K_subseteq_K</span><span> </span><span>closure_complement</span><span> </span><span>closure_interior</span><span> </span><span>closure_mono</span><span> </span><span>closure_subset</span><span> </span><span>interior_eq</span><span> </span><span>interior_maximal</span><span> </span><span>open_ou_witness_def</span><span> </span><span>subset_antisym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ou_witness_not_ed_ou</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ou_witness set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ed_ou X"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ed_ou_def</span><span> </span><span>I_def</span><span> </span><span>K_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>o_apply</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UNIV_I</span><span> </span><span>insert_iff</span><span> </span><span>interior_eq</span><span> </span><span>open_ou_witness_def</span><span> </span><span>singletonD</span><span>
</span><span>          </span><span>ou_witness.distinct</span><span class="delimiter">(</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span>ou_witness.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ou_witness_closure_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ou_witness_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f. CK_nf_pos (f::ou_witness set ⇒ ou_witness set)} = 5"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>open_unresolvable_not_ed_ou_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ou_witness_open_unresolvable</span><span> </span><span>ou_witness_not_ed_ou</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Kuratowski spaces ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"kuratowski (X :: 'a::topological_space set) ⟷
    ¬extremally_disconnected X ∧ ¬open_unresolvable X"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

A Kuratowski space distinguishes all 7 positive operators.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_closed_open</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::topological_space set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ∘ I = (I::'a set ⇒ 'a set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"closed X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open X"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Topological_Spaces.openI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"I (-{x})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?G</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"-K ?S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹I ∘ K ∘ I = I›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I (K (I ?S)) = ?S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ?S = ?S"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>I_def</span><span> </span><span>K_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K (I ?S) ≠ UNIV"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>I_def</span><span> </span><span>K_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>interior_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G ⊆ ?S ∨ x ∈ G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>G</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>I_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>interior_maximal</span><span> </span><span>subset_Compl_singleton</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>I_def</span><span> </span><span>K_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>ComplD</span><span> </span><span>Compl_empty_eq</span><span> </span><span>closure_interior</span><span> </span><span>closure_subset</span><span> </span><span>ex_in_conv</span><span> </span><span>open_interior</span><span> </span><span>subset_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹I ∘ K ∘ I = I›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open ?G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>I_def</span><span> </span><span>K_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>o_apply</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?G ⊆ X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?G ⊆ K ?G"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>K_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closure_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹I ∘ K ∘ I = I›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = K {x}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>I_def</span><span> </span><span>K_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>closure_interior</span><span> </span><span>comp_def</span><span> </span><span>double_complement</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹closed X›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ X›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⊆ X"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>K_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>closure_minimal</span><span> </span><span>contra_subsetD</span><span> </span><span>empty_subsetI</span><span> </span><span>insert_subset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃T. open T ∧ x ∈ T ∧ T ⊆ X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_I_K_I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ∘ I = (I::'a::topological_space set ⇒ 'a set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ∘ K = (K::'a set ⇒ 'a set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>interior_open</span><span class="delimiter">[</span><span>OF</span><span> </span><span>part_closed_open</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span> </span><span>closed_closure</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>I_def</span><span> </span><span>K_def</span><span> </span><span>o_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_K_I_I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ∘ I = (I::'a::topological_space set ⇒ 'a set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K ∘ I = (I::'a set ⇒ 'a set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>part_I_K_I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kuratowski_neqs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kuratowski (X :: 'a::topological_space set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ≠ I ∘ K ∘ (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ∘ I ≠ K ∘ (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ∘ I ≠ I ∘ (K :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ≠ K ∘ I ∘ (K :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ∘ I ≠ K ∘ I ∘ (K :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ∘ I ∘ K ≠ (K :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ≠ K ∘ (I :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ≠ (id :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ≠ (id :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ∘ K ∘ I ≠ (id :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ∘ I ∘ K ≠ (id :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kuratowski_def</span><span> </span><span>extremally_disconnected_def</span><span> </span><span>open_unresolvable_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>I_K</span><span> </span><span>K_K</span><span> </span><span>I_K_I_K</span><span> </span><span>K_I_K_I</span><span> </span><span>part_I_K_I</span><span> </span><span>part_K_I_I</span><span> </span><span>o_assoc</span><span> </span><span>comp_id</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kuratowski_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kuratowski (X :: 'a::topological_space set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f. CK_nf_pos (f::'a set ⇒ 'a set)} = 7"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CK_nf_pos_lattice</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="tfree">'a</span><span class="delimiter">]</span><span> </span><span>kuratowski_neqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kuratowski_def</span><span> </span><span>extremally_disconnected_def</span><span> </span><span>open_unresolvable_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>CK_nf_pos_set</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>card_insert_disjoint</span><span class="delimiter">;</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

‹ℝ› is a Kuratowski space.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kuratowski_reals</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kuratowski (ℝ :: real set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kuratowski_def</span><span> </span><span>extremally_disconnected_def</span><span> </span><span>open_unresolvable_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>I_K</span><span> </span><span>list.inject</span><span> </span><span>nf_RRR</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span>nf_RRR</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>o_assoc</span><span class="delimiter">,</span><span>
</span><span>    </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>I_K</span><span> </span><span>fun.map_comp</span><span> </span><span>list.inject</span><span> </span><span>nf_RRR</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span>nf_RRR</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Chagrov's theorem ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>chagrov</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::topological_space set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"discrete X"</span></span></span><span>
</span><span>        </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬discrete X ∧ part X"</span></span></span><span>
</span><span>        </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬discrete X ∧ ed_ou X"</span></span></span><span>
</span><span>        </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ed_ou X ∧ open_unresolvable X"</span></span></span><span>
</span><span>        </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ed_ou X ∧ ¬part X ∧ extremally_disconnected X"</span></span></span><span>
</span><span>        </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"kuratowski X"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kuratowski_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>chagrov_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {f. CK_nf_pos (f::'a::topological_space set ⇒ 'a set)} ∈ {1,3,4,5,7}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>discrete_card</span><span> </span><span>part_not_discrete_card</span><span> </span><span>ed_ou_not_discrete_card</span><span> </span><span>open_unresolvable_not_ed_ou_card</span><span>
</span><span>      </span><span>extremally_disconnected_not_part_not_ed_ou_card</span><span> </span><span>kuratowski_card</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>chagrov</span><span class="delimiter">)</span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div>