<div id="Monad_Normalisation">
<div class="head">
<h1>Theory Monad_Normalisation</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Monad_Normalisation.thy
    Author:     Manuel Eberl, TU München
    Author:     Joshua Schneider, ETH Zurich
    Author:     Andreas Lochbihler, ETH Zurich

Normalisation of monadic expressions.
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Normalisation of monadic expressions›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Monad_Normalisation
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="../../HOL/HOL-Probability/Probability.html">HOL-Probability.Probability</a>"</span>
<span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"print_monad_rules"</span> <span class="main">::</span> diag
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The standard monad laws
  \begin{gather}
    \label{eq:return:bind}
    <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>return a ⤜ f = f a›</span></span></span></span>
    \\
    \label{eq:bind:return}
    <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x ⤜ return = x›</span></span></span></span>
    \\
    \label{eq:bind:assoc}
    <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(x ⤜ f) ⤜ g = x ⤜ (λa. f a ⤜ g)›</span></span></span></span>
  \end{gather}
  yield a confluent and terminating rewrite system.
  Thus, when these equations are added to the simpset, the simplifier can normalise monadic 
  expressions and decide the equivalence of monadic programs (in the free monad).

  However, many monads satisfy additional laws.
  In some monads, it is possible to discard unused effects
  \begin{gather}
    \label{eq:discard}
    <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x ⤜ (λ_. y) = y›</span></span></span></span>
  \end{gather}
  or duplicate effects
  \begin{gather}
    \label{eq:duplicate}
    <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x ⤜ (λa. x ⤜ f a) = x ⤜ (λa. f a a)›</span></span></span></span>
  \end{gather}
  or commute independent computations
  \begin{gather}
    \label{eq:commute}
    <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x ⤜ (λa. y ⤜ f a) = y ⤜ (λb. x ⤜ (λa. f a b))›</span></span></span></span>.
  \end{gather}
  For example, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">_</span></span> option"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> satisfies \eqref{eq:duplicate} and \eqref{eq:commute},
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">_</span></span> set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> validates \eqref{eq:commute}, and
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">_</span></span> pmf"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> satisfies \eqref{eq:discard} and \eqref{eq:commute}.
  Equations \eqref{eq:discard} and \eqref{eq:duplicate} can be directly used as rewrite rules.%
  \footnote{%
    If they both hold, then \eqref{eq:commute} holds, too \cite{LochbihlerSchneider2016ITP}.
  }
  However, the simplifier does not handle \eqref{eq:commute} well because \eqref{eq:commute} is a
  higher-order permutative rewrite rule and ordered rewriting in the simplifier can only handle 
  first-order permutative rewrite rules.
  Consequently, when \eqref{eq:commute} is added to the simpset, the simplifier will loop.

  This AFP entry implements a simproc for the simplifier to simplify HOL expressions over commutative
  monads based on ordered rewriting.  This yields a decision procedure for equality of monadic 
  expressions in any (free) monad satisfying any of the laws (\ref{eq:discard}--\ref{eq:commute}).
  If further commutative operators show up in the HOL term, then the ordered rewrite system need not
  be confluent and the simproc only performs a best effort.  We do not know whether this general case
  can be solved by ordered rewriting as a complete solution would have to solve the graph isomorphism
  problem by term rewriting \cite{Basin1994IPL}.
›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹monad_rules.ML›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Usage›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The monad laws \eqref{eq:return:bind}, \eqref{eq:bind:return}, \eqref{eq:bind:assoc}, \eqref{eq:commute}
  must be registered with the attribute <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">attribute</span></span> monad_rule<span class="antiquote"><span class="antiquote">}</span></span></span></span>. 
  The simproc does not need \eqref{eq:discard} and \eqref{eq:duplicate}, so these properties need not
  be registered, but can simply be added to the simpset if needed.
  The simproc is activated by including the bundle <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>monad_normalisation›</span></span></span></span>.

  Additionally, distributivity laws for control operators like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> If<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> case_nat<span class="antiquote"><span class="antiquote">}</span></span></span></span> 
  specialised to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⤜›</span></span></span></span> can be declared with the attribute <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">attribute</span></span> monad_distrib<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Then, the simproc will also commute computations over these control operators.

  The set of registered monad laws can be inspected with the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> print_monad_rules<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Registration of the monads from the Isabelle/HOL library›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">monad_rule</span><span class="main">]</span> <span class="main">=</span> Set.bind_bind

<span class="keyword1"><span class="command">lemma</span></span> set_bind_commute <span class="main">[</span><span class="operator">monad_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">B</span> <span class="main">⤜</span> <span class="free">C</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">B</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">A</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">C</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Set.bind_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> set_return_bind <span class="main">[</span><span class="operator">monad_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> set"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">⤜</span> <span class="free">A</span> <span class="main">=</span> <span class="free">A</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Set.bind_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> set_bind_return <span class="main">[</span><span class="operator">monad_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Set.bind_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">monad_rule</span><span class="main">]</span> <span class="main">=</span> Predicate.bind_bind Predicate.bind_single Predicate.single_bind

<span class="keyword1"><span class="command">lemma</span></span> predicate_bind_commute <span class="main">[</span><span class="operator">monad_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Predicate.pred"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> Predicate.pred"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">B</span> <span class="main">⤜</span> <span class="free">C</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">B</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">A</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">C</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> pred_eqI<span class="main">)</span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">monad_rule</span><span class="main">]</span> <span class="main">=</span> Option.bind_assoc Option.bind_lunit Option.bind_runit

<span class="keyword1"><span class="command">lemma</span></span> option_bind_commute <span class="main">[</span><span class="operator">monad_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> option"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">B</span> <span class="main">⤜</span> <span class="free">C</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">B</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">A</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">C</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">A</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">monad_rule</span><span class="main">]</span> <span class="main">=</span>
  bind_assoc_pmf
  bind_commute_pmf
  bind_return_pmf
  bind_return_pmf'

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">monad_rule</span><span class="main">]</span> <span class="main">=</span>
  bind_spmf_assoc
  bind_commute_spmf
  bind_return_spmf
  return_bind_spmf


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Distributive operators›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bind_if <span class="main">[</span><span class="operator">monad_distrib</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="free">C</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">f</span> <span class="free">A</span> <span class="free">B</span> <span class="keyword1">else</span> <span class="free">f</span> <span class="free">A</span> <span class="free">C</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> bind_case_prod <span class="main">[</span><span class="operator">monad_distrib</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">y</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">B</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">y</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">f</span> <span class="free">A</span> <span class="main">(</span><span class="free">B</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bind_case_sum <span class="main">[</span><span class="operator">monad_distrib</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">y</span> <span class="keyword1">of</span> Inl <span class="bound">a</span> <span class="main">⇒</span> <span class="free">B</span> <span class="bound">a</span> <span class="bound">x</span> <span class="main">|</span> Inr <span class="bound">a</span> <span class="main">⇒</span> <span class="free">C</span> <span class="bound">a</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">y</span> <span class="keyword1">of</span> Inl <span class="bound">a</span> <span class="main">⇒</span> <span class="free">f</span> <span class="free">A</span> <span class="main">(</span><span class="free">B</span> <span class="bound">a</span><span class="main">)</span> <span class="main">|</span> Inr <span class="bound">a</span> <span class="main">⇒</span> <span class="free">f</span> <span class="free">A</span> <span class="main">(</span><span class="free">C</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bind_case_option <span class="main">[</span><span class="operator">monad_distrib</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">y</span> <span class="keyword1">of</span> Some <span class="bound">a</span> <span class="main">⇒</span> <span class="free">B</span> <span class="bound">a</span> <span class="bound">x</span> <span class="main">|</span> None <span class="main">⇒</span> <span class="free">C</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">y</span> <span class="keyword1">of</span> Some <span class="bound">a</span> <span class="main">⇒</span> <span class="free">f</span> <span class="free">A</span> <span class="main">(</span><span class="free">B</span> <span class="bound">a</span><span class="main">)</span> <span class="main">|</span> None <span class="main">⇒</span> <span class="free">f</span> <span class="free">A</span> <span class="free">C</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bind_case_list <span class="main">[</span><span class="operator">monad_distrib</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">y</span> <span class="keyword1">of</span> <span class="main">[]</span> <span class="main">⇒</span> <span class="free">B</span> <span class="bound">x</span> <span class="main">|</span> <span class="bound">y</span> <span class="main">#</span> <span class="bound">ys</span> <span class="main">⇒</span> <span class="free">C</span> <span class="bound">y</span> <span class="bound">ys</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">y</span> <span class="keyword1">of</span> <span class="main">[]</span> <span class="main">⇒</span> <span class="free">f</span> <span class="free">A</span> <span class="free">B</span> <span class="main">|</span> <span class="bound">y</span> <span class="main">#</span> <span class="bound">ys</span> <span class="main">⇒</span> <span class="free">f</span> <span class="free">A</span> <span class="main">(</span><span class="free">C</span> <span class="bound">y</span> <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> list.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bind_case_nat <span class="main">[</span><span class="operator">monad_distrib</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">y</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free">B</span> <span class="bound">x</span> <span class="main">|</span> Suc <span class="bound">n</span> <span class="main">⇒</span> <span class="free">C</span> <span class="bound">n</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">y</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free">f</span> <span class="free">A</span> <span class="free">B</span> <span class="main">|</span> Suc <span class="bound">n</span> <span class="main">⇒</span> <span class="free">f</span> <span class="free">A</span> <span class="main">(</span><span class="free">C</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.split<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Setup of the normalisation simproc›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹monad_normalisation.ML›</span>

<span class="keyword1"><span class="command">simproc_setup</span></span> monad_normalisation <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">x</span> <span class="free">y</span>"</span></span><span class="main">)</span> <span class="main">=</span> <span class="quoted">‹K <span class="entity">Monad_Normalisation.normalise_step</span>›</span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> monad_normalisation<span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The following bundle enables normalisation of monadic expressions by the simplifier.
  We use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">attribute</span></span> monad_rule_internal<span class="antiquote"><span class="antiquote">}</span></span></span></span> instead of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>monad_rule[simp]›</span></span></span></span> such that
  the theorems in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] <span class="dynamic"><span class="dynamic"><span class="dynamic"><span class="dynamic">monad_rule</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> get dynamically added to the simpset instead of
  only those that are in there when the bundle is declared.
›</span></span>

<span class="keyword1"><span class="command">bundle</span></span> monad_normalisation <span class="main">=</span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monad_normalisation<span class="main">,</span> <span class="operator">monad_rule_internal</span><span class="main">]</span><span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/monad_rules.ML">
<div class="head">
<h1>File ‹monad_rules.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      monad_rules.ML
    Author:     Manuel Eberl, TU München
    Author:     Joshua Schneider, ETH Zurich
    Author:     Andreas Lochbihler, ETH Zurich

Monad laws and distributivity of bind over control operators (if, case_x ...).
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">MONAD_RULES</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">info</span> <span class="main">=</span> <span class="main">{</span>
    bind_assoc<span class="main">:</span> thm option<span class="main">,</span>
    bind_commute<span class="main">:</span> thm option<span class="main">,</span>
    return_bind<span class="main">:</span> thm option<span class="main">,</span>
    bind_return<span class="main">:</span> thm option
  <span class="main">}</span>

  <span class="keyword1"><span class="keyword">val</span></span> get_monad<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">info</span> option
  <span class="keyword1"><span class="keyword">val</span></span> get_monad_rules<span class="main">:</span> Context.generic <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> get_distrib_rule<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> thm option
  <span class="keyword1"><span class="keyword">val</span></span> get_distrib_rules<span class="main">:</span> Context.generic <span class="main">-&gt;</span> thm list
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Monad_Rules</span> <span class="main">:</span> <span class="entity">MONAD_RULES</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">same_const</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">,</span> Const <span class="main">(</span><span class="entity">c'</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">c</span> <span class="main">=</span> <span class="entity">c'</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">same_const</span> <span class="main">_</span> <span class="main">=</span> false<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">analyze_bind_assoc</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> Thm.prop_of <span class="entity">thm</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">(</span><span class="entity">c1</span> $ <span class="main">(</span><span class="entity">c2</span> $ Var <span class="entity">x</span> $ Var <span class="entity">y</span><span class="main">)</span> $ Var <span class="entity">z</span><span class="main">,</span>
       <span class="entity">c3</span> $ Var <span class="entity">x'</span> $ Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">c4</span> $ <span class="main">(</span>Var <span class="entity">y'</span> $ Bound <span class="inner_numeral">0</span><span class="main">)</span> $ Var <span class="entity">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> forall <span class="entity">same_const</span> <span class="main">(</span><span class="main">[</span><span class="entity">c1</span><span class="main">,</span><span class="entity">c2</span><span class="main">,</span><span class="entity">c3</span><span class="main">]</span> ~~ <span class="main">[</span><span class="entity">c2</span><span class="main">,</span><span class="entity">c3</span><span class="main">,</span><span class="entity">c4</span><span class="main">]</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
            forall <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="main">[</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">,</span><span class="entity">z</span><span class="main">]</span> ~~ <span class="main">[</span><span class="entity">x'</span><span class="main">,</span><span class="entity">y'</span><span class="main">,</span><span class="entity">z'</span><span class="main">]</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="entity">c1</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"analyze_bind_assoc"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"analyze_bind_assoc"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">analyze_return_bind</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> Thm.prop_of <span class="entity">thm</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">(</span>Const <span class="main">(</span><span class="entity">c_bind</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> $ <span class="main">_</span> $ Var <span class="entity">x</span><span class="main">,</span> Var <span class="entity">x'</span> $ Var <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="entity">x'</span> <span class="keyword2"><span class="keyword">then</span></span>
          Const <span class="main">(</span><span class="entity">c_bind</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"analyze_return_bind"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"analyze_return_bind"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">analyze_bind_return</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> Thm.prop_of <span class="entity">thm</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">(</span>Const <span class="main">(</span><span class="entity">c_bind</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> $ Var <span class="entity">x</span> $ <span class="entity">ret</span><span class="main">,</span> Var <span class="entity">x'</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="entity">x'</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="main">(</span>Const <span class="main">(</span><span class="entity">c_bind</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">ret</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"analyze_bind_return"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"analyze_bind_return"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">analyze_bind_commute</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span><span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> Thm.prop_of <span class="entity">thm</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span><span class="entity">rhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">(</span><span class="entity">c1</span> $ Var <span class="entity">x</span> $ Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">,</span> <span class="entity">c2</span> $ Var <span class="entity">y</span> $ <span class="main">(</span>Var <span class="entity">z</span> $ Bound <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
       <span class="entity">c3</span> $ Var <span class="entity">y'</span> $ Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">,</span> <span class="entity">c4</span> $ Var <span class="entity">x'</span> $ Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> Var <span class="entity">z'</span> $ Bound <span class="inner_numeral">0</span> $ Bound <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
         <span class="keyword2"><span class="keyword">if</span></span> forall <span class="entity">same_const</span> <span class="main">(</span><span class="main">[</span><span class="entity">c1</span><span class="main">,</span><span class="entity">c2</span><span class="main">,</span><span class="entity">c3</span><span class="main">]</span> ~~ <span class="main">[</span><span class="entity">c2</span><span class="main">,</span><span class="entity">c3</span><span class="main">,</span><span class="entity">c4</span><span class="main">]</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
              forall <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> <span class="main">(</span><span class="main">[</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">,</span><span class="entity">z</span><span class="main">]</span> ~~ <span class="main">[</span><span class="entity">x'</span><span class="main">,</span><span class="entity">y'</span><span class="main">,</span><span class="entity">z'</span><span class="main">]</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
           <span class="entity">c1</span>
         <span class="keyword2"><span class="keyword">else</span></span>
           <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"analyze_bind_commute"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"analyze_bind_commute"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">analyze_bind_distrib</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> Thm.prop_of <span class="entity">thm</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">lhs</span> <span class="keyword2"><span class="keyword">of</span></span>
      Var <span class="main">_</span> $ Var <span class="entity">x</span> $ Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>Term.add_vars <span class="entity">y</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"analyze_bind_distrib"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">c'</span><span class="main">)</span> <span class="main">=</span> apply2 head_of <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">same_const</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">c'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">c</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"analyze_bind_distrib"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"analyze_bind_distrib"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">info</span> <span class="main">=</span> <span class="main">{</span>
  bind_assoc<span class="main">:</span> thm option<span class="main">,</span>
  bind_commute<span class="main">:</span> thm option<span class="main">,</span>
  return_bind<span class="main">:</span> thm option<span class="main">,</span>
  bind_return<span class="main">:</span> thm option
<span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">make_info</span> <span class="entity">bind_assoc</span> <span class="entity">bind_commute</span> <span class="entity">return_bind</span> <span class="entity">bind_return</span> <span class="main">=</span>
 <span class="main">{</span>bind_assoc <span class="main">=</span> <span class="entity">bind_assoc</span><span class="main">,</span> bind_commute <span class="main">=</span> <span class="entity">bind_commute</span><span class="main">,</span> return_bind <span class="main">=</span> <span class="entity">return_bind</span><span class="main">,</span>
  bind_return <span class="main">=</span> <span class="entity">bind_return</span><span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty_info</span> <span class="main">=</span> <span class="entity">make_info</span> NONE NONE NONE NONE<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_info</span> <span class="entity">f1</span> <span class="entity">f2</span> <span class="entity">f3</span> <span class="entity">f4</span> <span class="main">{</span><span class="entity">bind_assoc</span><span class="main">,</span> <span class="entity">bind_commute</span><span class="main">,</span> <span class="entity">return_bind</span><span class="main">,</span> <span class="entity">bind_return</span><span class="main">}</span> <span class="main">=</span>
 <span class="main">{</span>bind_assoc <span class="main">=</span> <span class="entity">f1</span> <span class="entity">bind_assoc</span><span class="main">,</span> bind_commute <span class="main">=</span> <span class="entity">f2</span> <span class="entity">bind_commute</span><span class="main">,</span> return_bind <span class="main">=</span> <span class="entity">f3</span> <span class="entity">return_bind</span><span class="main">,</span>
  bind_return <span class="main">=</span> <span class="entity">f4</span> <span class="entity">bind_return</span><span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_info_thms</span> <span class="entity">f</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">g</span> <span class="main">=</span> Option.map <span class="entity">f</span> <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">map_info</span> <span class="entity">g</span> <span class="entity">g</span> <span class="entity">g</span> <span class="entity">g</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge_info</span> <span class="main">(</span><span class="entity">i1</span><span class="main">,</span> <span class="entity">i2</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> pointer_eq <span class="main">(</span><span class="entity">i1</span><span class="main">,</span> <span class="entity">i2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Symtab.SAME
  <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>bind_assoc <span class="main">=</span> <span class="entity">ba1</span><span class="main">,</span> bind_commute <span class="main">=</span> <span class="entity">bc1</span><span class="main">,</span> return_bind <span class="main">=</span> <span class="entity">rb1</span><span class="main">,</span> bind_return <span class="main">=</span> <span class="entity">br1</span><span class="main">}</span> <span class="main">=</span> <span class="entity">i1</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>bind_assoc <span class="main">=</span> <span class="entity">ba2</span><span class="main">,</span> bind_commute <span class="main">=</span> <span class="entity">bc2</span><span class="main">,</span> return_bind <span class="main">=</span> <span class="entity">rb2</span><span class="main">,</span> bind_return <span class="main">=</span> <span class="entity">br2</span><span class="main">}</span> <span class="main">=</span> <span class="entity">i2</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ba</span> <span class="main">=</span> merge_options <span class="main">(</span><span class="entity">ba1</span><span class="main">,</span> <span class="entity">ba2</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bc</span> <span class="main">=</span> merge_options <span class="main">(</span><span class="entity">bc1</span><span class="main">,</span> <span class="entity">bc2</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rb</span> <span class="main">=</span> merge_options <span class="main">(</span><span class="entity">rb1</span><span class="main">,</span> <span class="entity">rb2</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">br</span> <span class="main">=</span> merge_options <span class="main">(</span><span class="entity">br1</span><span class="main">,</span> <span class="entity">br2</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">make_info</span> <span class="entity">ba</span> <span class="entity">bc</span> <span class="entity">rb</span> <span class="entity">br</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pretty_info</span> <span class="entity">ctxt</span> <span class="entity">bindc</span> <span class="main">{</span><span class="entity">bind_assoc</span><span class="main">,</span> <span class="entity">bind_commute</span><span class="main">,</span> <span class="entity">return_bind</span><span class="main">,</span> <span class="entity">bind_return</span><span class="main">}</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pretty_law</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> NONE<span class="main">)</span> <span class="main">=</span> NONE
      <span class="main">|</span> <span class="entity">pretty_law</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> SOME <span class="entity">thm</span><span class="main">)</span> <span class="main">=</span> SOME <span class="main">(</span>Pretty.block <span class="main">[</span>Pretty.str <span class="entity">name</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">,</span> Thm.pretty_thm <span class="entity">ctxt</span> <span class="entity">thm</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">list</span> <span class="main">=</span> 
      <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"return-bind:"</span><span class="main">,</span> <span class="entity">return_bind</span><span class="main">)</span><span class="main">,</span> 
       <span class="main">(</span><span class="inner_quoted">"bind-return:"</span><span class="main">,</span> <span class="entity">bind_return</span><span class="main">)</span><span class="main">,</span> 
       <span class="main">(</span><span class="inner_quoted">"bind-assoc:"</span><span class="main">,</span> <span class="entity">bind_assoc</span><span class="main">)</span><span class="main">,</span> 
       <span class="main">(</span><span class="inner_quoted">"bind-commute:"</span><span class="main">,</span> <span class="entity">bind_commute</span><span class="main">)</span><span class="main">]</span>

  <span class="keyword2"><span class="keyword">in</span></span>
    map_filter <span class="entity">pretty_law</span> <span class="entity">list</span> 
    |&gt; cons <span class="main">(</span>Syntax.pretty_term <span class="main">(</span>Config.put <span class="entity">Adhoc_Overloading.show_variants</span> true <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">bindc</span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">)</span><span class="main">)</span>
    |&gt; Pretty.fbreaks
    |&gt; Pretty.block 
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Generic_Data<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="main">{</span>
    monads<span class="main">:</span> <span class="entity">info</span> Symtab.table<span class="main">,</span>
    distribs<span class="main">:</span> thm Symtab.table
  <span class="main">}</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> <span class="main">{</span>monads <span class="main">=</span> Symtab.empty<span class="main">,</span> distribs <span class="main">=</span> Symtab.empty<span class="main">}</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="main">(</span><span class="main">{</span>monads <span class="main">=</span> <span class="entity">m1</span><span class="main">,</span> distribs <span class="main">=</span> <span class="entity">d1</span><span class="main">}</span><span class="main">,</span> <span class="main">{</span>monads <span class="main">=</span> <span class="entity">m2</span><span class="main">,</span> distribs <span class="main">=</span> <span class="entity">d2</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
   <span class="main">{</span>monads <span class="main">=</span> Symtab.join <span class="main">(</span>K <span class="entity">merge_info</span><span class="main">)</span> <span class="main">(</span><span class="entity">m1</span><span class="main">,</span> <span class="entity">m2</span><span class="main">)</span><span class="main">,</span>
    distribs <span class="main">=</span> Symtab.merge <span class="main">(</span>K true<span class="main">)</span> <span class="main">(</span><span class="entity">d1</span><span class="main">,</span> <span class="entity">d2</span><span class="main">)</span><span class="main">}</span><span class="main">;</span>
<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_data</span> <span class="entity">f1</span> <span class="entity">f2</span> <span class="main">{</span><span class="entity">monads</span><span class="main">,</span> <span class="entity">distribs</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span>monads <span class="main">=</span> <span class="entity">f1</span> <span class="entity">monads</span><span class="main">,</span> distribs <span class="main">=</span> <span class="entity">f2</span> <span class="entity">distribs</span><span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_monad_rules</span> <span class="entity">context</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_simps</span> <span class="main">{</span><span class="entity">bind_assoc</span><span class="main">,</span> <span class="entity">return_bind</span><span class="main">,</span> <span class="entity">bind_return</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
      map_filter I <span class="main">[</span><span class="entity">bind_assoc</span><span class="main">,</span> <span class="entity">return_bind</span><span class="main">,</span> <span class="entity">bind_return</span><span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">monads</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">context</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Symtab.fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span> <span class="main">=&gt;</span> append <span class="main">(</span><span class="entity">add_simps</span> <span class="entity">info</span><span class="main">)</span><span class="main">)</span> <span class="entity">monads</span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_monad</span> <span class="entity">ctxt</span> <span class="entity">bindc</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">monads</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="main">(</span>Context.Proof <span class="entity">ctxt</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Option.map <span class="main">(</span><span class="entity">map_info_thms</span> <span class="main">(</span>Thm.transfer' <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Symtab.lookup <span class="entity">monads</span> <span class="entity">bindc</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_distrib_rule</span> <span class="entity">ctxt</span> <span class="entity">controlc</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">distribs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="main">(</span>Context.Proof <span class="entity">ctxt</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Option.map <span class="main">(</span>Thm.transfer' <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span>Symtab.lookup <span class="entity">distribs</span> <span class="entity">controlc</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_distrib_rules</span> <span class="entity">context</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">distribs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">context</span>
  <span class="keyword2"><span class="keyword">in</span></span> Symtab.dest <span class="entity">distribs</span> |&gt; map snd <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_monad_rule</span> <span class="entity">thm</span> <span class="entity">context</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rule</span> <span class="main">(</span><span class="entity">analyze</span><span class="main">,</span> <span class="entity">map_info'</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">bindc</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> dest_Const <span class="main">(</span><span class="entity">analyze</span> <span class="entity">thm</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">map_data</span> <span class="main">(</span>Symtab.map_default <span class="main">(</span><span class="entity">bindc</span><span class="main">,</span> <span class="entity">empty_info</span><span class="main">)</span> <span class="entity">map_info'</span><span class="main">)</span> I <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">put_thm</span> <span class="main">_</span> <span class="main">=</span> SOME <span class="entity">thm</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_rule'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> get_first <span class="main">(</span>try <span class="entity">add_rule</span><span class="main">)</span>
        <span class="main">[</span><span class="main">(</span><span class="entity">analyze_bind_assoc</span><span class="main">,</span> <span class="entity">map_info</span> <span class="entity">put_thm</span> I I I<span class="main">)</span><span class="main">,</span>
         <span class="main">(</span><span class="entity">analyze_bind_commute</span><span class="main">,</span> <span class="entity">map_info</span> I <span class="entity">put_thm</span> I I<span class="main">)</span><span class="main">,</span>
         <span class="main">(</span><span class="entity">analyze_return_bind</span><span class="main">,</span> <span class="entity">map_info</span> I I <span class="entity">put_thm</span> I<span class="main">)</span><span class="main">,</span>
         <span class="main">(</span><span class="entity">analyze_bind_return</span> #&gt; fst<span class="main">,</span> <span class="entity">map_info</span> I I I <span class="entity">put_thm</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">of</span></span>
      SOME <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span>
    <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="inner_quoted">"Bad monad rule"</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Data.map <span class="entity">add_rule'</span> <span class="entity">context</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_distrib_rule</span> <span class="entity">thm</span> <span class="entity">context</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">controlc</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> dest_Const <span class="main">(</span><span class="entity">analyze_bind_distrib</span> <span class="entity">thm</span><span class="main">)</span>
      <span class="keyword3"><span class="keyword">handle</span></span> THM <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"Bad distributivity rule"</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Data.map <span class="main">(</span><span class="entity">map_data</span> I <span class="main">(</span>Symtab.update <span class="main">(</span><span class="entity">controlc</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">context</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pretty_monad_rules</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> Data.get <span class="main">(</span>Context.Proof <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">monads</span> <span class="main">=</span> 
      <span class="main">#</span>monads <span class="entity">info</span> 
      |&gt; Symtab.dest
      |&gt; map <span class="main">(</span>uncurry <span class="main">(</span><span class="entity">pretty_info</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
      |&gt; Pretty.big_list <span class="inner_quoted">"Monad laws"</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pretty_distrib</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span> <span class="main">=</span> Pretty.block <span class="main">[</span>
      Syntax.pretty_term <span class="entity">ctxt</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">)</span><span class="main">,</span> Pretty.str <span class="inner_quoted">": "</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">0</span><span class="main">,</span> 
      Thm.pretty_thm <span class="entity">ctxt</span> <span class="entity">thm</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">distribs</span> <span class="main">=</span>
      <span class="main">#</span>distribs <span class="entity">info</span>
      |&gt; Symtab.dest
      |&gt; map <span class="entity">pretty_distrib</span>
      |&gt; Pretty.big_list <span class="inner_quoted">"Distributivity laws"</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Pretty.blk <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span> <span class="main">[</span><span class="entity">monads</span><span class="main">,</span> Pretty.fbrk<span class="main">,</span> Pretty.fbrk<span class="main">,</span> <span class="entity">distribs</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_monad_rules_simp</span> <span class="main">=</span>
  Context.map_proof <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">ctxt</span> addsimps <span class="main">(</span><span class="entity">get_monad_rules</span> <span class="main">(</span>Context.Proof <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup
 <span class="main">(</span><span class="entity">Attrib.setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> monad_rule<span class="antiquote">}</span></span></span> <span class="main">(</span>Scan.succeed <span class="main">(</span>Thm.declaration_attribute <span class="entity">add_monad_rule</span><span class="main">)</span><span class="main">)</span>
    <span class="inner_quoted">"declaration of monad rule"</span> #&gt;
  <span class="entity">Attrib.setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> monad_distrib<span class="antiquote">}</span></span></span> <span class="main">(</span>Scan.succeed <span class="main">(</span>Thm.declaration_attribute <span class="entity">add_distrib_rule</span><span class="main">)</span><span class="main">)</span>
    <span class="inner_quoted">"declaration of distributive rule for monadic bind"</span> #&gt;
  <span class="entity">Attrib.setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> monad_rule_internal<span class="antiquote">}</span></span></span> 
    <span class="main">(</span>Scan.succeed <span class="main">(</span>Thm.declaration_attribute <span class="main">(</span>K <span class="entity">add_monad_rules_simp</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="inner_quoted">"dynamic declaration of monad rules as [simp]"</span> #&gt;
  Global_Theory.add_thms_dynamic <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> monad_rule<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="entity">get_monad_rules</span><span class="main">)</span> #&gt;
  Global_Theory.add_thms_dynamic <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> monad_distrib<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="entity">get_distrib_rules</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>


<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">print_monad_rules</span><span class="antiquote">}</span></span></span> <span class="inner_quoted">"print monad rules"</span>
    <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">Toplevel.keep</span> <span class="main">(</span>Pretty.writeln o <span class="entity">pretty_monad_rules</span> o <span class="entity">Toplevel.context_of</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
</pre>
</div><div id="files/monad_normalisation.ML">
<div class="head">
<h1>File ‹monad_normalisation.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      monad_normalisation.ML
    Author:     Joshua Schneider, ETH Zurich
    Author:     Manuel Eberl, TU München

Normalisation of monadic expressions: commutation, distribution over control operators.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">MONAD_NORMALISATION</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> normalise_step<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> thm option
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Monad_Normalisation</span> <span class="main">:</span> <span class="entity">MONAD_NORMALISATION</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(*
  Copy of term_ord from Pure/term_ord.ML, with inverse order of bound variables.
  This aims to be stable under the substitution of bound variables with free variables when
  the simplifier descends into an abstraction, but relies on the particular naming scheme of
  the new variables (see Name.bound).
*)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">hd_depth</span> <span class="main">(</span><span class="entity">t</span> $ <span class="main">_</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span> <span class="main">=</span> <span class="entity">hd_depth</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">n</span> + <span class="inner_numeral">1</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">hd_depth</span> <span class="entity">p</span> <span class="main">=</span> <span class="entity">p</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_hd</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">dest_hd</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">dest_hd</span> <span class="main">(</span>Var <span class="entity">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="inner_numeral">2</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">dest_hd</span> <span class="main">(</span>Bound <span class="entity">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="inner_quoted">""</span><span class="main">,</span> ~<span class="entity">i</span><span class="main">)</span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">dest_hd</span> <span class="main">(</span>Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="inner_quoted">""</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="inner_numeral">4</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">term_ord</span> <span class="entity">tu</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> pointer_eq <span class="entity">tu</span> <span class="keyword2"><span class="keyword">then</span></span> EQUAL
  <span class="keyword2"><span class="keyword">else</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tu</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">(</span>Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> Abs<span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">U</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">term_ord</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span> EQUAL <span class="main">=&gt;</span> Term_Ord.typ_ord <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> <span class="main">|</span> <span class="entity">ord</span> <span class="main">=&gt;</span> <span class="entity">ord</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> int_ord <span class="main">(</span>size_of_term <span class="entity">t</span><span class="main">,</span> size_of_term <span class="entity">u</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
          EQUAL <span class="main">=&gt;</span>
            <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> prod_ord <span class="entity">hd_ord</span> int_ord <span class="main">(</span><span class="entity">hd_depth</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">hd_depth</span> <span class="main">(</span><span class="entity">u</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
              EQUAL <span class="main">=&gt;</span> <span class="entity">args_ord</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">|</span> <span class="entity">ord</span> <span class="main">=&gt;</span> <span class="entity">ord</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">ord</span> <span class="main">=&gt;</span> <span class="entity">ord</span><span class="main">)</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">hd_ord</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">g</span><span class="main">)</span> <span class="main">=</span>
  prod_ord <span class="main">(</span>prod_ord Term_Ord.indexname_ord Term_Ord.typ_ord<span class="main">)</span> int_ord <span class="main">(</span><span class="entity">dest_hd</span> <span class="entity">f</span><span class="main">,</span> <span class="entity">dest_hd</span> <span class="entity">g</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">args_ord</span> <span class="main">(</span><span class="entity">f</span> $ <span class="entity">t</span><span class="main">,</span> <span class="entity">g</span> $ <span class="entity">u</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">args_ord</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">g</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span> EQUAL <span class="main">=&gt;</span> <span class="entity">term_ord</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">|</span> <span class="entity">ord</span> <span class="main">=&gt;</span> <span class="entity">ord</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">args_ord</span> <span class="main">_</span> <span class="main">=</span> EQUAL<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rename_commute_rule</span> <span class="entity">thm</span> <span class="entity">ct</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">v1</span><span class="main">,</span> <span class="entity">v2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ct</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">(</span><span class="main">_</span> $ <span class="main">_</span> $ Abs <span class="main">(</span><span class="entity">x1</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span> $ <span class="main">_</span> $ <span class="entity">y</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">x1</span><span class="main">,</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">y</span> <span class="keyword2"><span class="keyword">of</span></span>
          Abs <span class="main">(</span><span class="entity">x2</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">x2</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="inner_quoted">"x"</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Drule.rename_bvars' <span class="main">[</span>SOME <span class="entity">v1</span><span class="main">,</span> SOME <span class="entity">v2</span><span class="main">,</span> SOME <span class="entity">v1</span><span class="main">]</span> <span class="entity">thm</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_bind_term</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">bindc</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">x</span> $ <span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">bindc</span><span class="main">,</span> <span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">dest_bind_term</span> <span class="main">_</span> <span class="main">=</span> <span class="main">(</span><span class="inner_quoted">""</span><span class="main">,</span> Term.dummy<span class="main">,</span> Term.dummy<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inst_bind_distrib</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span> Drule.infer_instantiate' <span class="entity">ctxt</span> <span class="main">[</span>SOME <span class="main">(</span>Thm.dest_fun2 <span class="entity">ct</span><span class="main">)</span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalise_step</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">bindc</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_bind_term</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">search_control</span> <span class="entity">t1</span> <span class="entity">t2</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup</span> <span class="entity">i</span> <span class="entity">u</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Term.head_of <span class="entity">u</span> <span class="keyword2"><span class="keyword">of</span></span>
            Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> Option.map <span class="main">(</span>pair <span class="entity">i</span><span class="main">)</span> <span class="main">(</span><span class="entity">Monad_Rules.get_distrib_rule</span> <span class="entity">ctxt</span> <span class="entity">c</span><span class="main">)</span>
          <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">search</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">u1</span><span class="main">,</span> <span class="entity">u2</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Term.loose_bvar1 <span class="main">(</span><span class="entity">u1</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> NONE
          <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">u2</span> <span class="keyword2"><span class="keyword">of</span></span>
              Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">u2'</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">v1</span> $ <span class="entity">v2</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
                <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">bindc</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">search</span> <span class="main">(</span><span class="entity">i</span> + <span class="inner_numeral">1</span><span class="main">,</span> <span class="entity">v1</span><span class="main">,</span> <span class="entity">v2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">lookup</span> <span class="main">(</span><span class="entity">i</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">u2'</span>
            <span class="main">|</span> Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">u2'</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">lookup</span> <span class="main">(</span><span class="entity">i</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">u2'</span>
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">search</span> <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span> <span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">commute_distrib</span> <span class="entity">commute_eq</span> <span class="entity">distrib_eq</span> <span class="entity">depth</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">conv</span> <span class="entity">ctxt'</span> <span class="inner_numeral">0</span> <span class="entity">ct'</span> <span class="main">=</span> Conv.rewr_conv <span class="main">(</span><span class="entity">inst_bind_distrib</span> <span class="entity">ctxt'</span> <span class="entity">ct'</span> <span class="entity">distrib_eq</span><span class="main">)</span> <span class="entity">ct'</span>
            <span class="main">|</span> <span class="entity">conv</span> <span class="entity">ctxt'</span> <span class="entity">i</span> <span class="entity">ct'</span> <span class="main">=</span> <span class="main">(</span>Conv.rewr_conv <span class="main">(</span><span class="entity">rename_commute_rule</span> <span class="entity">commute_eq</span> <span class="entity">ct'</span><span class="main">)</span> then_conv
                Conv.arg_conv <span class="main">(</span>Conv.abs_conv <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">conv</span> <span class="entity">ctxt''</span> <span class="main">(</span><span class="entity">i</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt'</span><span class="main">)</span><span class="main">)</span> <span class="entity">ct'</span>
      <span class="keyword2"><span class="keyword">in</span></span> try <span class="main">(</span><span class="entity">conv</span> <span class="entity">ctxt</span> <span class="entity">depth</span><span class="main">)</span> <span class="entity">ct</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">commute'</span> <span class="entity">commute_eq</span> <span class="entity">u</span> <span class="entity">ct'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Term.loose_bvar1 <span class="main">(</span><span class="entity">u</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> NONE
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct''</span> <span class="main">=</span> Conv.rewr_conv <span class="entity">commute_eq</span> <span class="entity">ct'</span> |&gt; Thm.rhs_of<span class="main">;</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">if</span></span> is_less <span class="main">(</span><span class="entity">term_ord</span> <span class="main">(</span>apply2 <span class="main">(</span>Envir.beta_eta_contract o Thm.term_of<span class="main">)</span> <span class="main">(</span><span class="entity">ct''</span><span class="main">,</span> <span class="entity">ct'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="main">(</span><span class="entity">rename_commute_rule</span> <span class="entity">commute_eq</span> <span class="entity">ct'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> NONE <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">commute</span> <span class="entity">info</span> <span class="entity">u</span> <span class="entity">v</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="main">#</span>bind_commute <span class="entity">info</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> NONE
      <span class="main">|</span> SOME <span class="entity">commute_thm</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">commute_eq</span> <span class="main">=</span> <span class="entity">mk_meta_eq</span> <span class="entity">commute_thm</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">search_control</span> <span class="entity">u</span> <span class="entity">v</span> <span class="keyword2"><span class="keyword">of</span></span>
              SOME <span class="main">(</span><span class="entity">depth</span><span class="main">,</span> <span class="entity">distrib_thm</span><span class="main">)</span> <span class="main">=&gt;</span>
                <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">commute_distrib</span> <span class="entity">commute_eq</span> <span class="main">(</span><span class="entity">mk_meta_eq</span> <span class="entity">distrib_thm</span><span class="main">)</span> <span class="entity">depth</span> <span class="keyword2"><span class="keyword">of</span></span>
                  SOME <span class="entity">thm</span> <span class="main">=&gt;</span> SOME <span class="entity">thm</span>
                <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">commute'</span> <span class="entity">commute_eq</span> <span class="entity">u</span> <span class="entity">ct</span><span class="main">)</span>
            <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">commute'</span> <span class="entity">commute_eq</span> <span class="entity">u</span> <span class="entity">ct</span>
          <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">distribute</span> <span class="entity">t</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Term.head_of <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
          Option.map <span class="main">(</span><span class="entity">inst_bind_distrib</span> <span class="entity">ctxt</span> <span class="entity">ct</span> o <span class="entity">mk_meta_eq</span><span class="main">)</span> <span class="main">(</span><span class="entity">Monad_Rules.get_distrib_rule</span> <span class="entity">ctxt</span> <span class="entity">c</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">Monad_Rules.get_monad</span> <span class="entity">ctxt</span> <span class="entity">bindc</span> <span class="keyword2"><span class="keyword">of</span></span>
      NONE <span class="main">=&gt;</span> NONE
    <span class="main">|</span> SOME <span class="entity">info</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">y</span> <span class="keyword2"><span class="keyword">of</span></span>
        Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">z</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">bindc'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">u</span> $ <span class="entity">v</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">bindc</span> <span class="main">=</span> <span class="entity">bindc'</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">commute</span> <span class="entity">info</span> <span class="entity">u</span> <span class="entity">v</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="entity">distribute</span> <span class="entity">z</span>
      <span class="main">|</span> Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">distribute</span> <span class="entity">z</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
</pre>
</div><div id="Monad_Normalisation_Test">
<div class="head">
<h1>Theory Monad_Normalisation_Test</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Monad_Normalisation_Test.thy
    Author:     Manuel Eberl, TU München
    Author:     Andreas Lochbihler, ETH Zurich
    Author:     Joshua Schneider, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Monad_Normalisation_Test
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Monad_Normalisation.html">Monad_Normalisation</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Tests and examples›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> monad_normalisation
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">=</span> id"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span><span class="bound">x</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">C</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">d</span> <span class="main">←</span> <span class="free">E</span> <span class="bound">z</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">a</span> <span class="main">←</span> <span class="free">D</span> <span class="bound">z</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">y</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> return_pmf <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span>
     <span class="keyword1">do</span> <span class="main">{</span><span class="bound">y</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">x</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">C</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">a</span> <span class="main">←</span> <span class="free">D</span> <span class="bound">z</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">d</span> <span class="main">←</span> <span class="free">E</span> <span class="bound">z</span> <span class="bound">x</span><span class="main">;</span> return_pmf <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span><span class="bound">a</span> <span class="main">←</span> <span class="free">E</span><span class="main">;</span> <span class="bound">b</span> <span class="main">←</span> <span class="free">E</span><span class="main">;</span> <span class="bound">w</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">b</span> <span class="bound">a</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">;</span> return_pmf <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
       <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span><span class="bound">a</span> <span class="main">←</span> <span class="free">E</span><span class="main">;</span> <span class="bound">b</span> <span class="main">←</span> <span class="free">E</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">;</span> <span class="bound">w</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">b</span> <span class="bound">a</span><span class="main">;</span> return_pmf <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span><span class="bound">a</span> <span class="main">←</span> <span class="free">E</span><span class="main">;</span> <span class="bound">b</span> <span class="main">←</span> <span class="free">E</span><span class="main">;</span> <span class="bound">w</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">b</span> <span class="bound">a</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">;</span> return_pmf <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
       <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span><span class="bound">a</span> <span class="main">←</span> <span class="free">E</span><span class="main">;</span> <span class="bound">b</span> <span class="main">←</span> <span class="free">E</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">;</span> <span class="bound">w</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">b</span> <span class="bound">a</span><span class="main">;</span> return_pmf <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span><span class="bound">y</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">x</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">w</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span>
       <span class="keyword1">do</span> <span class="main">{</span><span class="bound">x</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">y</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">w</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">y</span><span class="main">;</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span><span class="bound">y</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">x</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">w</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> <span class="main">{</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">}</span><span class="main">}</span> <span class="main">=</span>
       <span class="keyword1">do</span> <span class="main">{</span><span class="bound">x</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">y</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">w</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">y</span><span class="main">;</span> <span class="main">{</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">}</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span><span class="bound">y</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">x</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">w</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> return_pmf <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span>
       <span class="keyword1">do</span> <span class="main">{</span><span class="bound">x</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">y</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">w</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">y</span><span class="main">;</span> return_pmf <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span><span class="bound">x</span> <span class="main">←</span> <span class="free">A</span> <span class="main">0</span><span class="main">;</span> <span class="bound">y</span> <span class="main">←</span> <span class="free">A</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">w</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">y</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">a</span> <span class="main">←</span> <span class="free">C</span><span class="main">;</span> Predicate.single <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span>
       <span class="keyword1">do</span> <span class="main">{</span><span class="bound">x</span> <span class="main">←</span> <span class="free">A</span> <span class="main">0</span><span class="main">;</span> <span class="bound">y</span> <span class="main">←</span> <span class="free">A</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">w</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">y</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">a</span> <span class="main">←</span> <span class="free">C</span><span class="main">;</span> Predicate.single <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span><span class="bound">x</span> <span class="main">←</span> <span class="free">A</span> <span class="main">0</span><span class="main">;</span> <span class="bound">y</span> <span class="main">←</span> <span class="free">A</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">w</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">y</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">a</span> <span class="main">←</span> <span class="free">C</span><span class="main">;</span> return_pmf <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span>
       <span class="keyword1">do</span> <span class="main">{</span><span class="bound">x</span> <span class="main">←</span> <span class="free">A</span> <span class="main">0</span><span class="main">;</span> <span class="bound">y</span> <span class="main">←</span> <span class="free">A</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">y</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">w</span> <span class="main">←</span> <span class="free">B</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">a</span> <span class="main">←</span> <span class="free">C</span><span class="main">;</span> return_pmf <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span><span class="bound">x</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">C</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">d</span> <span class="main">←</span> <span class="free">E</span> <span class="bound">z</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">a</span> <span class="main">←</span> <span class="free">D</span> <span class="bound">z</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">y</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> return_pmf <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span>
       <span class="keyword1">do</span> <span class="main">{</span><span class="bound">y</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">x</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span> <span class="bound">z</span> <span class="main">←</span> <span class="free">C</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">a</span> <span class="main">←</span> <span class="free">D</span> <span class="bound">z</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">d</span> <span class="main">←</span> <span class="free">E</span> <span class="bound">z</span> <span class="bound">x</span><span class="main">;</span> return_pmf <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>


<span class="keyword1"><span class="command">no_adhoc_overloading</span></span> Monad_Syntax.bind <span class="quoted">bind_pmf</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒜1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">𝒜2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sample_uniform</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">order</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">x</span> <span class="main">←</span> <span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">y</span> <span class="main">←</span> <span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">z</span> <span class="main">←</span> <span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      <span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜1</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
      <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="free">valid_plain</span> <span class="bound">msg1</span> <span class="main">∧</span> <span class="free">valid_plain</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">guess</span> <span class="main">←</span> <span class="free">𝒜2</span> <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">,</span> <span class="free">xor</span> <span class="main">(</span><span class="free">f</span> <span class="bound">z</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">)</span> <span class="bound">σ</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">guess</span> <span class="main">⟷</span> <span class="bound">b</span><span class="main">)</span>
    <span class="main">}</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">x</span> <span class="main">←</span> <span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">y</span> <span class="main">←</span> <span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜1</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
      <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="free">valid_plain</span> <span class="bound">msg1</span> <span class="main">∧</span> <span class="free">valid_plain</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      <span class="bound">x</span> <span class="main">←</span> <span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">guess</span> <span class="main">←</span> <span class="free">𝒜2</span> <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">,</span> <span class="free">xor</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">)</span> <span class="bound">σ</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">guess</span> <span class="main">⟷</span> <span class="bound">b</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">x</span> <span class="main">←</span> <span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">xa</span> <span class="main">←</span> <span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">x</span> <span class="main">←</span> <span class="free">𝒜1</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span>
      <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xb</span><span class="main">)</span> <span class="main">⇒</span>
        <span class="main">(</span><span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span>
         <span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span> <span class="main">⇒</span>
           <span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
                <span class="bound">a</span> <span class="main">←</span> assert_spmf <span class="main">(</span><span class="free">valid_plain</span> <span class="bound">msg1</span> <span class="main">∧</span> <span class="free">valid_plain</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
                <span class="bound">x</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
                <span class="bound">xaa</span> <span class="main">←</span> map_spmf <span class="free">f</span> <span class="main">(</span><span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                <span class="bound">guess</span> <span class="main">←</span> <span class="free">𝒜2</span> <span class="main">(</span><span class="free">f</span> <span class="bound">xa</span><span class="main">,</span> <span class="bound">xaa</span><span class="main">)</span> <span class="bound">σ</span><span class="main">;</span>
                return_spmf <span class="main">(</span><span class="bound">guess</span> <span class="main">⟷</span> <span class="bound">x</span><span class="main">)</span>
              <span class="main">}</span><span class="main">)</span>
         <span class="bound">xb</span>
    <span class="main">}</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">x</span> <span class="main">←</span> <span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">xa</span> <span class="main">←</span> <span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">x</span> <span class="main">←</span> <span class="free">𝒜1</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span>
      <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xb</span><span class="main">)</span> <span class="main">⇒</span>
        <span class="main">(</span><span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span>
         <span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span> <span class="main">⇒</span>
           <span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
                <span class="bound">a</span> <span class="main">←</span> assert_spmf <span class="main">(</span><span class="free">valid_plain</span> <span class="bound">msg1</span> <span class="main">∧</span> <span class="free">valid_plain</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
                <span class="bound">z</span> <span class="main">←</span> map_spmf <span class="free">f</span> <span class="main">(</span><span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                <span class="bound">guess</span> <span class="main">←</span> <span class="free">𝒜2</span> <span class="main">(</span><span class="free">f</span> <span class="bound">xa</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">σ</span><span class="main">;</span>
                map_spmf <span class="main">(</span><span class="main">(⟷)</span> <span class="bound">guess</span><span class="main">)</span> coin_spmf
              <span class="main">}</span><span class="main">)</span>
         <span class="bound">xb</span>
    <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> elgamal_step3<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">x</span> <span class="main">←</span> <span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">y</span> <span class="main">←</span> <span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      <span class="bound">p</span> <span class="main">←</span> <span class="free">𝒜1</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
      <span class="main"><span class="bound">_</span></span> <span class="main">←</span> assert_spmf <span class="main">(</span><span class="free">valid_plain</span> <span class="main">(</span>fst <span class="main">(</span>fst <span class="bound">p</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="free">valid_plain</span> <span class="main">(</span>snd <span class="main">(</span>fst <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">guess</span> <span class="main">←</span>
        <span class="free">𝒜2</span> <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">,</span> <span class="free">xor</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="bound">x</span> <span class="main">*</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> fst <span class="main">(</span>fst <span class="bound">p</span><span class="main">)</span> <span class="keyword1">else</span> snd <span class="main">(</span>fst <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
         <span class="main">(</span>snd <span class="bound">p</span><span class="main">)</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">guess</span> <span class="main">⟷</span> <span class="bound">b</span><span class="main">)</span>
    <span class="main">}</span>  <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">y</span> <span class="main">←</span> <span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      <span class="bound">p</span> <span class="main">←</span> <span class="free">𝒜1</span> <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">;</span>
      <span class="main"><span class="bound">_</span></span> <span class="main">←</span> assert_spmf <span class="main">(</span><span class="free">valid_plain</span> <span class="main">(</span>fst <span class="main">(</span>fst <span class="bound">p</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="free">valid_plain</span> <span class="main">(</span>snd <span class="main">(</span>fst <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">ya</span> <span class="main">←</span> <span class="free">sample_uniform</span> <span class="main">(</span><span class="free">order</span> <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">b'</span> <span class="main">←</span> <span class="free">𝒜2</span> <span class="main">(</span><span class="free">f</span> <span class="bound">ya</span><span class="main">,</span>
                 <span class="free">xor</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="bound">y</span> <span class="main">*</span> <span class="bound">ya</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> fst <span class="main">(</span>fst <span class="bound">p</span><span class="main">)</span> <span class="keyword1">else</span> snd <span class="main">(</span>fst <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
             <span class="main">(</span>snd <span class="bound">p</span><span class="main">)</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">⟷</span> <span class="bound">b</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Distributivity›</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">x</span> <span class="main">←</span> <span class="free">A</span> <span class="main">::</span> nat spmf<span class="main">;</span>
      <span class="bound">a</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span>
      <span class="bound">b</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        return_spmf <span class="bound">x</span>
      <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">y</span> <span class="main">←</span> <span class="free">C</span><span class="main">;</span>
        return_spmf <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="bound">y</span><span class="main">)</span>
      <span class="main">}</span>
   <span class="main">}</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">a</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span>
      <span class="bound">b</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="bound">b</span> <span class="main">=</span> <span class="bound">a</span> <span class="keyword1">then</span> <span class="free">A</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">y</span> <span class="main">←</span> <span class="free">C</span><span class="main">;</span>
        <span class="bound">x</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span>
        return_spmf <span class="main">(</span><span class="bound">y</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span>
      <span class="main">}</span>
   <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.commute <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">x</span> <span class="main">←</span> <span class="free">A</span> <span class="main">::</span> nat spmf<span class="main">;</span>
      <span class="bound">p</span> <span class="main">←</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">a</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span>
        <span class="bound">b</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span>
        return_spmf <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span>
      <span class="main">}</span><span class="main">;</span>
      <span class="bound">q</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      <span class="keyword1">if</span> <span class="bound">q</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        return_spmf <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> fst <span class="bound">p</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">y</span> <span class="main">←</span> <span class="free">C</span><span class="main">;</span>
        return_spmf <span class="main">(</span><span class="bound">y</span> <span class="main">+</span> snd <span class="bound">p</span><span class="main">)</span>
      <span class="main">}</span>
   <span class="main">}</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">q</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      <span class="keyword1">if</span> <span class="bound">q</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">x</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span>
        <span class="bound">a</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span>
        <span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span>
        return_spmf <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="bound">a</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">y</span> <span class="main">←</span> <span class="free">C</span><span class="main">;</span>
        <span class="bound">a</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span>
        <span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span>
        <span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span>
        return_spmf <span class="main">(</span><span class="bound">y</span> <span class="main">+</span> <span class="bound">a</span><span class="main">)</span>
      <span class="main">}</span>
   <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat <span class="main">+</span> nat"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">x</span> <span class="main">←</span> <span class="main">(</span><span class="free">A</span><span class="main">::</span>nat set<span class="main">)</span><span class="main">;</span>
      <span class="bound">a</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span>
      <span class="bound">b</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="keyword1">of</span>
        Inl <span class="bound">c</span> <span class="main">⇒</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span>
      <span class="main">|</span> Inr <span class="bound">c</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">y</span> <span class="main">←</span> <span class="free">C</span> <span class="bound">x</span><span class="main">;</span>
          <span class="main">{</span><span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="bound">y</span> <span class="main">+</span> <span class="bound">c</span><span class="main">)</span><span class="main">}</span>
        <span class="main">}</span>
   <span class="main">}</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">a</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span>
      <span class="bound">b</span> <span class="main">←</span> <span class="free">B</span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="free">f</span> <span class="bound">b</span> <span class="bound">a</span> <span class="keyword1">of</span>
        Inl <span class="bound">c</span> <span class="main">⇒</span> <span class="free">A</span>
      <span class="main">|</span> Inr <span class="bound">c</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">x</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span>
          <span class="bound">y</span> <span class="main">←</span> <span class="free">C</span> <span class="bound">x</span><span class="main">;</span>
          <span class="main">{</span><span class="main">(</span><span class="bound">y</span> <span class="main">+</span> <span class="bound">c</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span>
      <span class="main">}</span>
   <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.commute add.left_commute <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> sum.case_cong<span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Limits›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The following example shows that the combination of monad normalisation and regular ordered
  rewriting is not necessarily confluent.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span><span class="bound">a</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">b</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> Some <span class="main">(</span><span class="bound">a</span> <span class="main">∧</span> <span class="bound">b</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span>
       <span class="keyword1">do</span> <span class="main">{</span><span class="bound">a</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> <span class="bound">b</span> <span class="main">←</span> <span class="free">A</span><span class="main">;</span> Some <span class="main">(</span><span class="bound">a</span> <span class="main">∧</span> <span class="bound">b</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> conj_comms<span class="main">)</span><span class="main"><span class="keyword3">?</span></span>       <span class="comment1">― ‹no progress made›</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> option_bind_commute<span class="main">)</span> <span class="comment1">― ‹force a particular binder order›</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> conj_comms<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The next example shows that even monad normalisation alone is not confluent because 
  the term ordering prevents the reordering of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f A›</span></span></span></span> with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f B›</span></span></span></span>.
  But if we change <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>E›</span></span></span></span>, then the reordering works as expected.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span><span class="bound">a</span> <span class="main">←</span> <span class="free">f</span> <span class="free">A</span><span class="main">;</span> <span class="bound">b</span> <span class="main">←</span> <span class="free">f</span> <span class="free">B</span><span class="main">;</span> <span class="bound">c</span> <span class="main">←</span> <span class="free">D</span> <span class="bound">b</span><span class="main">;</span> <span class="bound">d</span> <span class="main">←</span> <span class="free">f</span> <span class="free">C</span><span class="main">;</span> <span class="free">F</span> <span class="bound">a</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">}</span> <span class="main">=</span> 
   <span class="keyword1">do</span> <span class="main">{</span><span class="bound">b</span> <span class="main">←</span> <span class="free">f</span> <span class="free">B</span><span class="main">;</span> <span class="bound">c</span> <span class="main">←</span> <span class="free">D</span> <span class="bound">b</span><span class="main">;</span> <span class="bound">a</span> <span class="main">←</span> <span class="free">f</span> <span class="free">A</span><span class="main">;</span> <span class="bound">d</span> <span class="main">←</span> <span class="free">f</span> <span class="free">C</span><span class="main">;</span> <span class="free">F</span> <span class="bound">a</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> option"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">D</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> option"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">?</span></span> <span class="comment1">― ‹no progress made›</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> option_bind_commute<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> option_bind_commute<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> refl<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span><span class="bound">a</span> <span class="main">←</span> <span class="free">f</span> <span class="free">E</span><span class="main">;</span> <span class="bound">b</span> <span class="main">←</span> <span class="free">f</span> <span class="free">B</span><span class="main">;</span> <span class="bound">c</span> <span class="main">←</span> <span class="free">D</span> <span class="bound">b</span><span class="main">;</span> <span class="bound">d</span> <span class="main">←</span> <span class="free">f</span> <span class="free">C</span><span class="main">;</span> <span class="free">F</span> <span class="bound">a</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">}</span> <span class="main">=</span> 
   <span class="keyword1">do</span> <span class="main">{</span><span class="bound">b</span> <span class="main">←</span> <span class="free">f</span> <span class="free">B</span><span class="main">;</span> <span class="bound">c</span> <span class="main">←</span> <span class="free">D</span> <span class="bound">b</span><span class="main">;</span> <span class="bound">a</span> <span class="main">←</span> <span class="free">f</span> <span class="free">E</span><span class="main">;</span> <span class="bound">d</span> <span class="main">←</span> <span class="free">f</span> <span class="free">C</span><span class="main">;</span> <span class="free">F</span> <span class="bound">a</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> option"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">D</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> option"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>