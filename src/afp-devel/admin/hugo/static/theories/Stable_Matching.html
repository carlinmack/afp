<div id="Sotomayor">
<div class="head">
<h1>Theory Sotomayor</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">theory</span></span> Sotomayor
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ \citet{Sotomayor:1996}: A non-constructive proof of the existence of stable marriages \label{sec:sotomayor} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We set the scene with a non-constructive proof of the existence of
stable matches due to \citet{Sotomayor:1996}. This approach is
pleasantly agnostic about the strictness of preferences, and moreover
avoids getting bogged down in reasoning about programs; most existing
proofs involve such but omit formal treatments of the requisite
assertions. This tradition started with \citet{GaleShapley:1962}; see
\citet{Bijlsma:1991} for a rigorous treatment.

The following contains the full details of an Isabelle/HOL
formalization of her proof, and aims to introduce the machinery we
will make heavy use of later. Further developments will elide many of
the more tedious technicalities that we include here.

The scenario consists of disjoint finite sets of men <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">M</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and
women <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">W</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, represented as types <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'m::finite"›</span></span></span></span> and
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'w::finite›</span></span></span></span> respectively. We diverge from
\citeauthor{Sotomayor:1996} by having each man and woman rank only
acceptable partners in a way that is transitive and complete. (Here
completeness requires <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Refl"<span class="antiquote"><span class="antiquote">}</span></span></span></span> in addition to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Total"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
as the latter does not imply the former, and so we end up with a total
preorder.) Such orders therefore include cycles of indifference, i.e.,
are not antisymmetric.

Also matches are treated as relations rather than functions.

We model this scenario in a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory_text</span></span> <span class="raw_text"><span class="raw_text">"<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">locale</span></span></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, a sectioning
mechanism for stating a series of lemmas relative to a set of fixed
variables (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory_text</span></span> <span class="raw_text"><span class="raw_text">"<span class="keyword2"><span class="keyword"><span class="keyword2"><span class="keyword">fixes</span></span></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) and assumptions (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory_text</span></span>
<span class="raw_text"><span class="raw_text">"<span class="keyword2"><span class="keyword"><span class="keyword2"><span class="keyword">assumes</span></span></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) that can later be instantiated and discharged.

›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span> <span class="main">×</span> <span class="tfree">'w</span><span class="main">)</span> set"</span></span>

<span class="keyword1"><span class="command">locale</span></span> StableMarriage <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Pm</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span><span class="main">::</span>finite <span class="main">⇒</span> <span class="tfree">'w</span><span class="main">::</span>finite rel"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Pw</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'w</span> <span class="main">⇒</span> <span class="tfree">'m</span> rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Pm_pref<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">m</span><span class="main">.</span> Preorder <span class="main">(</span><span class="free">Pm</span> <span class="bound">m</span><span class="main">)</span> <span class="main">∧</span> Total <span class="main">(</span><span class="free">Pm</span> <span class="bound">m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Pw_pref<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">w</span><span class="main">.</span> Preorder <span class="main">(</span><span class="free">Pw</span> <span class="bound">w</span><span class="main">)</span> <span class="main">∧</span> Total <span class="main">(</span><span class="free">Pw</span> <span class="bound">w</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

A <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹match›<span class="antiquote"><span class="antiquote">}</span></span></span></span> assigns at most one man to each woman, and
vice-versa. It is also <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹individually rational›<span class="antiquote"><span class="antiquote">}</span></span></span></span>, i.e., the
partners are acceptable to each other. The constant <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Field"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
is the union of the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Domain"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Range"<span class="antiquote"><span class="antiquote">}</span></span></span></span> of a
relation.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">match</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">match</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">⟷</span> inj_on fst <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">∧</span> inj_on snd <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">⊆</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">m</span><span class="main">.</span> <span class="main">{</span><span class="bound">m</span><span class="main">}</span> <span class="main">×</span> Field <span class="main">(</span><span class="free">Pm</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">w</span><span class="main">.</span> Field <span class="main">(</span><span class="free">Pw</span> <span class="bound">w</span><span class="main">)</span> <span class="main">×</span> <span class="main">{</span><span class="bound">w</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

A woman <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹prefers›<span class="antiquote"><span class="antiquote">}</span></span></span></span> one man to another if her preference order
ranks the former over the latter, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹strictly prefers›<span class="antiquote"><span class="antiquote">}</span></span></span></span> him if
additionally the latter is not ranked over the former, and similarly
for the men.

›</span></span>

<span class="comment1">(* AboveS doesn't work in the following: consider a cycle of
   indifference of length &gt; 1. Two things may be not-equal but agent
   is indifferent. Suggests AboveS is for antisym rels only. *)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">m_for</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound">m</span><span class="main">.</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">w_for</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound">w</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">m_prefers</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> <span class="tfree">'w</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">m_prefers</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">w'</span></span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pm</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">w</span><span class="main">∈</span>w_for <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">.</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span> <span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pm</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">w_prefers</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'w</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> <span class="tfree">'m</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">w_prefers</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">m'</span></span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pw</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">m</span><span class="main">∈</span>m_for <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">.</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">m'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pw</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">m_strictly_prefers</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> <span class="tfree">'w</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">m_strictly_prefers</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">w'</span></span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pm</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">w</span><span class="main">∈</span>w_for <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">.</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span> <span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pm</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">w'</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span> <span class="main">∉</span> <span class="free">Pm</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">w_strictly_prefers</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'w</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> <span class="tfree">'m</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">w_strictly_prefers</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">m'</span></span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pw</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">m</span><span class="main">∈</span>m_for <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">.</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">m'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pw</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">m'</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">∉</span> <span class="free">Pw</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

A couple <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹blocks›<span class="antiquote"><span class="antiquote">}</span></span></span></span> a match <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>μ›</span></span></span></span> if both strictly
prefer each other to anyone they are matched with in
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>μ›</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">blocks</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'w</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">blocks</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">∈</span> m_strictly_prefers <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">∈</span> w_strictly_prefers <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We say a match is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹stable›<span class="antiquote"><span class="antiquote">}</span></span></span></span> if there are no blocking couples.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stable</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">stable</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">⟷</span> match <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">m</span> <span class="bound">w</span><span class="main">.</span> <span class="main">¬</span> blocks <span class="bound">m</span> <span class="bound">w</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stable_match<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable <span class="free">μ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"match <span class="free">μ</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> stable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Our goal is to show that for every preference order there is a stable
match. Stable matches in this scenario form a lattice, and this proof
implicitly adopts the traditional view that men propose and women
choose.

The definitions above form the trust basis for this existence theorem;
the following are merely part of the proof apparatus, and Isabelle/HOL
enforces their soundness with respect to the argument. We will see
these concepts again in later developments.

Firstly, a match is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹simple›<span class="antiquote"><span class="antiquote">}</span></span></span></span> if every woman party to a blocking
pair is single. The most obvious such match leaves everyone single.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">simple</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">simple</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">⟷</span> match <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">m</span> <span class="bound">w</span><span class="main">.</span> blocks <span class="bound">m</span> <span class="bound">w</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">⟶</span> <span class="bound">w</span> <span class="main">∉</span> Range <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> simple_match<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"simple <span class="free">μ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"match <span class="free">μ</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> simple_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> simple_ex<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">μ</span><span class="main">.</span> simple <span class="bound">μ</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> simple_def blocks_def match_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citeauthor{Sotomayor:1996} observes the following:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> simple_no_single_women_stable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"simple <span class="free">μ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">w</span><span class="main">.</span> <span class="bound">w</span> <span class="main">∈</span> Range <span class="free">μ</span>"</span></span> <span class="comment1">― ‹No woman is single›</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable <span class="free">μ</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> simple_def stable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_simple<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable <span class="free">μ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"simple <span class="free">μ</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> simple_def stable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Secondly, a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹weakly Pareto optimal match for men (among all
simple matches)›<span class="antiquote"><span class="antiquote">}</span></span></span></span> is one for which there is no other match that all men
like as much and some man likes more.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">m_weakly_prefers</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> <span class="tfree">'w</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">m_weakly_prefers</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">w'</span></span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pm</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">w</span><span class="main">∈</span>w_for <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">.</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span> <span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pm</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">weakly_preferred_by_men</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">weakly_preferred_by_men</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="free"><span class="bound"><span class="entity">μ'</span></span></span>
     <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">m</span><span class="main">.</span> <span class="main">∀</span><span class="bound">w</span><span class="main">∈</span>w_for <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">.</span> <span class="main">∃</span><span class="bound">w'</span><span class="main">∈</span>w_for <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">μ'</span></span></span><span class="main">.</span> <span class="bound">w'</span> <span class="main">∈</span> m_weakly_prefers <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">strictly_preferred_by_a_man</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">strictly_preferred_by_a_man</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="free"><span class="bound"><span class="entity">μ'</span></span></span>
     <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">m</span><span class="main">.</span> <span class="main">∃</span><span class="bound">w</span><span class="main">∈</span>w_for <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">μ'</span></span></span><span class="main">.</span> <span class="bound">w</span> <span class="main">∈</span> m_strictly_prefers <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">weakly_Pareto_optimal_for_men</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">weakly_Pareto_optimal_for_men</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span>
     <span class="main">⟷</span> simple <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">μ'</span><span class="main">.</span> simple <span class="bound">μ'</span> <span class="main">∧</span> weakly_preferred_by_men <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="bound">μ'</span> <span class="main">∧</span> strictly_preferred_by_a_man <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="bound">μ'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We will often provide <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹introduction rules›<span class="antiquote"><span class="antiquote">}</span></span></span></span> for more complex
predicates, and sometimes derive these by elementary syntactic
manipulations expressed by the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹attributes›<span class="antiquote"><span class="antiquote">}</span></span></span></span>
enclosed in square brackets after a use-mention of a lemma. The
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> "lemmas"<span class="antiquote"><span class="antiquote">}</span></span></span></span> command binds a name to the result. To conform
with the Isar structured proof language, we use meta-logic (``Pure''
in Isabelle terminology) connectives: <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⋀›</span></span></span></span> denotes
universal quantification, and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟹›</span></span></span></span>
implication.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> weakly_preferred_by_menI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span> <span class="bound">w</span><span class="main">.</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">μ</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">w'</span><span class="main">.</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">μ'</span> <span class="main">∧</span> <span class="bound">w'</span> <span class="main">∈</span> m_weakly_prefers <span class="bound">m</span> <span class="free">μ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"weakly_preferred_by_men <span class="free">μ</span> <span class="free">μ'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> weakly_preferred_by_men_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemmas</span></span> simpleI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> simple_def<span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> weakly_Pareto_optimal_for_men_simple<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"weakly_Pareto_optimal_for_men <span class="free">μ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"simple <span class="free">μ</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> weakly_Pareto_optimal_for_men_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Later we will elide obvious technical lemmas like the following. The
more obscure proofs are typically generated automatically by
sledgehammer \citep{Blanchette:2016}.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> m_weakly_prefers_Pm<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"match <span class="free">μ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">μ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">w'</span> <span class="main">∈</span> m_weakly_prefers <span class="free">m</span> <span class="free">μ</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">w</span><span class="main">,</span> <span class="free">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pm</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> spec<span class="main">[</span><span class="operator">OF</span> Pm_pref<span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span><span class="main">]</span> assms <span class="keyword1"><span class="command">unfolding</span></span> m_weakly_prefers_def match_def preorder_on_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> FieldI2 fst_conv inj_on_contraD snd_conv<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> match_Field<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"match <span class="free">μ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">μ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pm</span> <span class="free">m</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pw</span> <span class="free">w</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> match_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> weakly_preferred_by_men_refl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"match <span class="free">μ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"weakly_preferred_by_men <span class="free">μ</span> <span class="free">μ</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> weakly_preferred_by_men_def m_weakly_prefers_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">meson</span> Pm_pref m_weakly_prefers_Pm match_Field<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> preorder_on_def refl_onD<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citeauthor[p137]{Sotomayor:1996} provides an alternative definition
of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "weakly_preferred_by_men"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. The syntax <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory_text</span></span> <span class="raw_text"><span class="raw_text">"<span class="main"><span class="main">(</span></span><span class="keyword2"><span class="keyword"><span class="keyword2"><span class="keyword">is</span></span></span></span>
<span class="var"><span class="var">?lhs</span></span> ⟷ pat<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> binds the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹schematic
variables›<span class="antiquote"><span class="antiquote">}</span></span></span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>?lhs›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>?rhs›</span></span></span></span> to the terms
separated by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟷›</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> weakly_preferred_by_men_strictly_preferred_by_a_man<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"match <span class="free">μ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"match <span class="free">μ'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"weakly_preferred_by_men <span class="free">μ</span> <span class="free">μ'</span> <span class="main">⟷</span> <span class="main">¬</span>strictly_preferred_by_a_man <span class="free">μ'</span> <span class="free">μ</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> weakly_preferred_by_men_def strictly_preferred_by_a_man_def
              m_weakly_prefers_def m_strictly_prefers_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> weakly_preferred_by_menI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m</span> <span class="skolem">w</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">μ</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">μ</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">w'</span></span> <span class="keyword2"><span class="keyword">where</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="skolem">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">μ'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w'</span><span class="main">,</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pm</span> <span class="skolem">m</span> <span class="main">⟶</span> <span class="main">(</span><span class="skolem">w</span><span class="main">,</span> <span class="skolem">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pm</span> <span class="skolem">m</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> match_def strictly_preferred_by_a_man_def m_strictly_prefers_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> spec<span class="main">[</span><span class="operator">OF</span> Pm_pref<span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">m</span></span><span class="main">]</span> assms <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">μ</span>›</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">w'</span><span class="main">.</span> <span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">μ'</span> <span class="main">∧</span> <span class="bound">w'</span> <span class="main">∈</span> m_weakly_prefers <span class="skolem">m</span> <span class="free">μ</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> preorder_on_def total_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> m_weakly_prefers_Pm match_Field<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> refl_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> weakly_Pareto_optimal_for_men_def2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"weakly_Pareto_optimal_for_men <span class="free">μ</span>
     <span class="main">⟷</span> simple <span class="free">μ</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">μ'</span><span class="main">.</span> simple <span class="bound">μ'</span> <span class="main">∧</span> strictly_preferred_by_a_man <span class="free">μ</span> <span class="bound">μ'</span> <span class="main">⟶</span> strictly_preferred_by_a_man <span class="bound">μ'</span> <span class="free">μ</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> weakly_Pareto_optimal_for_men_def simple_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> weakly_preferred_by_men_strictly_preferred_by_a_man<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citeauthor{Sotomayor:1996} claims that the existence of such a weakly
Pareto optimal match for men is ``guaranteed by the fact that
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹the set of simple matchings is nonempty›<span class="antiquote"><span class="antiquote">}</span></span></span></span> [our <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source]
"simple_ex"<span class="antiquote"><span class="antiquote">}</span></span></span></span> lemma] <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹and finite and the preferences are
transitive.›<span class="antiquote"><span class="antiquote">}</span></span></span></span>'' The following lemmas express this intuition:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> trans_finite_has_maximal_elt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"trans <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Field <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Field <span class="free">r</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>Field <span class="free">r</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>Field <span class="free">r</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">,</span>1<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> transE<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> weakly_Pareto_optimal_for_men_ex<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">μ</span><span class="main">.</span> weakly_Pareto_optimal_for_men <span class="bound">μ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">μ</span><span class="main">,</span> <span class="bound">μ'</span><span class="main">)</span><span class="main">.</span> simple <span class="bound">μ</span> <span class="main">∧</span> simple <span class="bound">μ'</span> <span class="main">∧</span> weakly_preferred_by_men <span class="bound">μ</span> <span class="bound">μ'</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> trans_finite_has_maximal_elt<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> r<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="var">?r</span>"</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Field <span class="var">?r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>Field <span class="var">?r</span><span class="main">.</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?r</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?r</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword1"><span class="command">from</span></span> Pm_pref <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"trans <span class="var">?r</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> trans_def weakly_preferred_by_men_def m_weakly_prefers_def m_strictly_prefers_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">meson</span> order_on_defs<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> transE<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> simple_ex weakly_preferred_by_men_refl<span class="main">[</span><span class="operator">OF</span> simple_match<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Field <span class="var">?r</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> Field_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> weakly_Pareto_optimal_for_men_def Field_def
    <span class="keyword1"><span class="command">using</span></span> simple_match weakly_preferred_by_men_strictly_preferred_by_a_man <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The main result proceeds by contradiction.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> weakly_Pareto_optimal_for_men_stable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"weakly_Pareto_optimal_for_men <span class="free">μ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable <span class="free">μ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>stable <span class="free">μ</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹weakly_Pareto_optimal_for_men <span class="free">μ</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"simple <span class="free">μ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> weakly_Pareto_optimal_for_men_simple<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span>stable <span class="free">μ</span>›</span></span> <span class="quoted"><span class="quoted">‹simple <span class="free">μ</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m'</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"blocks <span class="skolem">m'</span> <span class="skolem">w</span> <span class="free">μ</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∉</span> Range <span class="free">μ</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> simple_def stable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="comment1">― ‹Choose an <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>m›</span></span> that <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>w›</span></span> weakly prefers to any blocking man.›</span>
  <span class="comment1">― ‹We restrict the preference order <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>Pw w›</span></span> to the men who strictly prefer <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>w›</span></span> over their match in <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>μ›</span></span>.›</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Restr <span class="main">(</span><span class="free">Pw</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">{</span><span class="bound">m</span><span class="main">.</span> <span class="skolem">w</span> <span class="main">∈</span> m_strictly_prefers <span class="bound">m</span> <span class="free">μ</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> trans_finite_has_maximal_elt<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> r<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="var">?r</span>"</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">∈</span> Field <span class="var">?r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">m'</span><span class="main">∈</span>Field <span class="var">?r</span><span class="main">.</span> <span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="bound">m'</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?r</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">m'</span><span class="main">,</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?r</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword1"><span class="command">from</span></span> Pw_pref <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"trans <span class="var">?r</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> preorder_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> trans_Restr<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> Pw_pref <span class="quoted"><span class="quoted">‹blocks <span class="skolem">m'</span> <span class="skolem">w</span> <span class="free">μ</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m'</span><span class="main">,</span> <span class="skolem">m'</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?r</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> blocks_def w_strictly_prefers_def preorder_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Field <span class="var">?r</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> FieldI2 empty_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹blocks <span class="skolem">m'</span> <span class="skolem">w</span> <span class="free">μ</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">∉</span> Range <span class="free">μ</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"blocks <span class="skolem">m</span> <span class="skolem">w</span> <span class="free">μ</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">m'</span><span class="main">.</span> blocks <span class="bound">m'</span> <span class="skolem">w</span> <span class="free">μ</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="bound">m'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pw</span> <span class="skolem">w</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">m'</span><span class="main">,</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pw</span> <span class="skolem">w</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> blocks_def w_strictly_prefers_def Field_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="comment1">― ‹Construct a new (simple) match containing the blocking pair\ldots›</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?μ'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">μ</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="bound">w'</span><span class="main">)</span> <span class="main">|</span><span class="bound">w'</span><span class="main">.</span> True<span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="skolem">w</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="comment1">― ‹{\ldots}and show that it is a Pareto improvement for men over <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>μ›</span></span>.›</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"simple <span class="var">?μ'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> simpleI<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹simple <span class="free">μ</span>›</span></span> <span class="quoted"><span class="quoted">‹blocks <span class="skolem">m</span> <span class="skolem">w</span> <span class="free">μ</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"match <span class="var">?μ'</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> blocks_def match_def simple_def m_strictly_prefers_def w_strictly_prefers_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inj_on_diff<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m'</span> <span class="skolem">w'</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"blocks <span class="skolem">m'</span> <span class="skolem">w'</span> <span class="var">?μ'</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹blocks <span class="skolem">m'</span> <span class="skolem">w'</span> <span class="var">?μ'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">m'</span><span class="main">.</span> blocks <span class="bound">m'</span> <span class="skolem">w</span> <span class="free">μ</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="bound">m'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pw</span> <span class="skolem">w</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">m'</span><span class="main">,</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pw</span> <span class="skolem">w</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w'</span> <span class="main">≠</span> <span class="skolem">w</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> blocks_def m_strictly_prefers_def w_strictly_prefers_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w'</span> <span class="main">∉</span> Range <span class="var">?μ'</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="skolem">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">μ</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹simple <span class="free">μ</span>›</span></span> <span class="quoted"><span class="quoted">‹blocks <span class="skolem">m'</span> <span class="skolem">w'</span> <span class="var">?μ'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w'</span> <span class="main">≠</span> <span class="skolem">w</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="skolem">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">μ</span>›</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> simple_def match_def
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> fst_conv inj_on_contraD snd_conv<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">from</span></span> Pm_pref <span class="quoted"><span class="quoted">‹blocks <span class="skolem">m</span> <span class="skolem">w</span> <span class="free">μ</span>›</span></span> <span class="quoted"><span class="quoted">‹blocks <span class="skolem">m'</span> <span class="skolem">w'</span> <span class="var">?μ'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="skolem">w'</span><span class="main">)</span> <span class="main">∉</span> <span class="free">μ</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"blocks <span class="skolem">m'</span> <span class="skolem">w'</span> <span class="free">μ</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> preorder_on_def blocks_def m_strictly_prefers_def w_strictly_prefers_def
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> transE<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹simple <span class="free">μ</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w'</span> <span class="main">≠</span> <span class="skolem">w</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> simple_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weakly_preferred_by_men <span class="free">μ</span> <span class="var">?μ'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> weakly_preferred_by_menI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m'</span> <span class="skolem">w'</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m'</span><span class="main">,</span> <span class="skolem">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">μ</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">w'</span><span class="main">.</span> <span class="main">(</span><span class="skolem">m'</span><span class="main">,</span> <span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?μ'</span> <span class="main">∧</span> <span class="bound">w'</span> <span class="main">∈</span> m_weakly_prefers <span class="skolem">m'</span> <span class="free">μ</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">m'</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹blocks <span class="skolem">m</span> <span class="skolem">w</span> <span class="free">μ</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">m'</span><span class="main">,</span> <span class="skolem">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">μ</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m'</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> m_weakly_prefers_def blocks_def m_strictly_prefers_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">from</span></span> Pm_pref <span class="quoted"><span class="quoted">‹simple <span class="free">μ</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">m'</span><span class="main">,</span> <span class="skolem">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">μ</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m'</span> <span class="main">≠</span> <span class="skolem">m</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">meson</span> m_weakly_prefers_Pm match_Field preorder_on_def refl_onD simple_match<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹blocks <span class="skolem">m</span> <span class="skolem">w</span> <span class="free">μ</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"strictly_preferred_by_a_man <span class="free">μ</span> <span class="var">?μ'</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> strictly_preferred_by_a_man_def blocks_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹weakly_Pareto_optimal_for_men <span class="free">μ</span>›</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">unfolding</span></span> weakly_Pareto_optimal_for_men_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> stable_ex<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">μ</span><span class="main">.</span> stable <span class="bound">μ</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> weakly_Pareto_optimal_for_men_stable weakly_Pareto_optimal_for_men_ex <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We can exit the locale context and later re-enter it.

›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹interpret›<span class="antiquote"><span class="antiquote">}</span></span></span></span> the locale by supplying constants that instantiate
the variables we fixed earlier, and proving that these satisfy the
assumptions. In this case we provide concrete preference orders, and
by doing so we demonstrate that our theory is non-vacuous. We
arbitrarily choose \citet[Example~2.15]{RothSotomayor:1990} which
demonstrates the non-existence of man- or woman-optimal matches if
preferences are non-strict. (We define optimality shortly.) The
following bunch of types eases the description of this particular
scenario.

›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> M <span class="main">=</span> M1 <span class="main">|</span> M2 <span class="main">|</span> M3
<span class="keyword1"><span class="command">datatype</span></span> W <span class="main">=</span> W1 <span class="main">|</span> W2 <span class="main">|</span> W3

<span class="keyword1"><span class="command">lemma</span></span> M_UNIV<span class="main">:</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">=</span> set <span class="main">[</span>M1<span class="main">,</span> M2<span class="main">,</span> M3<span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> M.exhaust <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> W_UNIV<span class="main">:</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">=</span> set <span class="main">[</span>W1<span class="main">,</span> W2<span class="main">,</span> W3<span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> W.exhaust <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">instance</span></span> M <span class="main">::</span> <span class="quoted">finite</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> M_UNIV<span class="main">)</span>
<span class="keyword1"><span class="command">instance</span></span> W <span class="main">::</span> <span class="quoted">finite</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> W_UNIV<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> M_All<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">m</span><span class="main">.</span> <span class="free">P</span> <span class="bound">m</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">m</span><span class="main">∈</span>set <span class="main">[</span>M1<span class="main">,</span> M2<span class="main">,</span> M3<span class="main">]</span><span class="main">.</span> <span class="free">P</span> <span class="bound">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> M_UNIV UNIV_I<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> W_All<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">w</span><span class="main">.</span> <span class="free">P</span> <span class="bound">w</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">w</span><span class="main">∈</span>set <span class="main">[</span>W1<span class="main">,</span> W2<span class="main">,</span> W3<span class="main">]</span><span class="main">.</span> <span class="free">P</span> <span class="bound">w</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> W_UNIV UNIV_I<span class="main">)</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">Pm</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"M <span class="main">⇒</span> W rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Pm</span> M1 <span class="main">=</span> <span class="main">{</span> <span class="main">(</span>W1<span class="main">,</span> W1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>W1<span class="main">,</span> W2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>W1<span class="main">,</span> W3<span class="main">)</span><span class="main">,</span> <span class="main">(</span>W2<span class="main">,</span> W2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>W2<span class="main">,</span> W3<span class="main">)</span><span class="main">,</span> <span class="main">(</span>W3<span class="main">,</span> W3<span class="main">)</span><span class="main">,</span> <span class="main">(</span>W3<span class="main">,</span> W2<span class="main">)</span> <span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">Pm</span> M2 <span class="main">=</span> <span class="main">{</span> <span class="main">(</span>W1<span class="main">,</span> W1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>W1<span class="main">,</span> W2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>W2<span class="main">,</span> W2<span class="main">)</span> <span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">Pm</span> M3 <span class="main">=</span> <span class="main">{</span> <span class="main">(</span>W1<span class="main">,</span> W1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>W1<span class="main">,</span> W3<span class="main">)</span><span class="main">,</span> <span class="main">(</span>W3<span class="main">,</span> W3<span class="main">)</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">Pw</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"W <span class="main">⇒</span> M rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Pw</span> W1 <span class="main">=</span> <span class="main">{</span> <span class="main">(</span>M3<span class="main">,</span> M3<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M3<span class="main">,</span> M2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M3<span class="main">,</span> M1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M2<span class="main">,</span> M2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M2<span class="main">,</span> M1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M1<span class="main">,</span> M1<span class="main">)</span> <span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">Pw</span> W2 <span class="main">=</span> <span class="main">{</span> <span class="main">(</span>M2<span class="main">,</span> M2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M2<span class="main">,</span> M1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M1<span class="main">,</span> M1<span class="main">)</span> <span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">Pw</span> W3 <span class="main">=</span> <span class="main">{</span> <span class="main">(</span>M3<span class="main">,</span> M3<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M3<span class="main">,</span> M1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M1<span class="main">,</span> M1<span class="main">)</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Pm<span class="main">:</span> <span class="quoted"><span class="quoted">"Preorder <span class="main">(</span>Pm <span class="free">m</span><span class="main">)</span> <span class="main">∧</span> Total <span class="main">(</span>Pm <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> preorder_on_def refl_on_def trans_def total_on_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Pw<span class="main">:</span> <span class="quoted"><span class="quoted">"Preorder <span class="main">(</span>Pw <span class="free">w</span><span class="main">)</span> <span class="main">∧</span> Total <span class="main">(</span>Pw <span class="free">w</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> preorder_on_def refl_on_def trans_def total_on_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">w</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> Non_Strict<span class="main">:</span> StableMarriage <span class="quoted">Pm</span> <span class="quoted">Pw</span>
<span class="keyword1"><span class="command">using</span></span> Pm Pw <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We demonstrate that there are only two stable matches in this
scenario.  Isabelle/HOL does not have any special support for these
types of model checking problems, so we simply try all combinations of
men and women. Clearly this does not scale, and for larger domains we
need to be a bit cleverer (see \S\ref{sec:bossiness}).

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Non_Strict_stable1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Non_Strict.stable <span class="main">{</span><span class="main">(</span>M1<span class="main">,</span> W2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M2<span class="main">,</span> W1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M3<span class="main">,</span> W3<span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Non_Strict.stable_def Non_Strict.match_def Non_Strict.blocks_def Non_Strict.m_strictly_prefers_def
          Non_Strict.w_strictly_prefers_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> M.exhaust<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Non_Strict_stable2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Non_Strict.stable <span class="main">{</span><span class="main">(</span>M1<span class="main">,</span> W3<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M2<span class="main">,</span> W2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M3<span class="main">,</span> W1<span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Non_Strict.stable_def Non_Strict.match_def Non_Strict.blocks_def Non_Strict.m_strictly_prefers_def
          Non_Strict.w_strictly_prefers_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> M.exhaust<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Non_Strict_stable_matches<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Non_Strict.stable <span class="free">μ</span>
     <span class="main">⟷</span> <span class="free">μ</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span>M1<span class="main">,</span> W2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M2<span class="main">,</span> W1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M3<span class="main">,</span> W3<span class="main">)</span><span class="main">}</span>
     <span class="main">∨</span> <span class="free">μ</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span>M1<span class="main">,</span> W3<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M2<span class="main">,</span> W2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M3<span class="main">,</span> W1<span class="main">)</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">μ</span> <span class="main">∈</span> set <span class="main">`</span> set <span class="main">(</span>subseqs <span class="main">(</span>List.product <span class="main">[</span>M1<span class="main">,</span> M2<span class="main">,</span> M3<span class="main">]</span> <span class="main">[</span>W1<span class="main">,</span> W2<span class="main">,</span> W3<span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> subseqs_powset<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> M.exhaust W.exhaust<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Non_Strict.stable_def Non_Strict.match_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> INF_cong_simp SUP_cong_simp <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> image_cong_simp<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> INF_cong_simp SUP_cong_simp <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> image_cong_simp<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> M_All W_All Non_Strict.blocks_def Non_Strict.m_strictly_prefers_def
                         Non_Strict.w_strictly_prefers_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> INF_cong_simp SUP_cong_simp <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> image_cong_simp<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">with</span></span> Non_Strict_stable1 Non_Strict_stable2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

So far the only interesting result in this interpretation of
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>StableMarriage›</span></span></span></span> is the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source]
"Non_Strict.stable_ex"<span class="antiquote"><span class="antiquote">}</span></span></span></span> theorem, i.e., that there is a stable
match. We now add the notion of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹optimality›<span class="antiquote"><span class="antiquote">}</span></span></span></span> to our locale, and
all interpretations will automatically inherit it. Later we will also
extend locales by adding new fixed variables and assumptions.

Following \citet[Definition~2.11]{RothSotomayor:1990}, a stable match
is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹optimal for men›<span class="antiquote"><span class="antiquote">}</span></span></span></span> if every man likes it at least as much as
any other stable match (and similarly for an <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹optimal for
women›<span class="antiquote"><span class="antiquote">}</span></span></span></span> match).

›</span></span>

<span class="keyword1"><span class="command">context</span></span> StableMarriage
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">optimal_for_men</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">optimal_for_men</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span>
     <span class="main">⟷</span> stable <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">μ'</span><span class="main">.</span> stable <span class="bound">μ'</span> <span class="main">⟶</span> weakly_preferred_by_men <span class="bound">μ'</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">w_weakly_prefers</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'w</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> <span class="tfree">'m</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">w_weakly_prefers</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">m'</span></span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pw</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">m</span><span class="main">∈</span>m_for <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">.</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">m'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pw</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">weakly_preferred_by_women</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">weakly_preferred_by_women</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="free"><span class="bound"><span class="entity">μ'</span></span></span>
     <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">w</span><span class="main">.</span> <span class="main">∀</span><span class="bound">m</span><span class="main">∈</span>m_for <span class="bound">w</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">.</span> <span class="main">∃</span><span class="bound">m'</span><span class="main">∈</span>m_for <span class="bound">w</span> <span class="free"><span class="bound"><span class="entity">μ'</span></span></span><span class="main">.</span> <span class="bound">m'</span> <span class="main">∈</span> w_weakly_prefers <span class="bound">w</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">optimal_for_women</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'w</span><span class="main">)</span> match <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">optimal_for_women</span> <span class="free"><span class="bound"><span class="entity">μ</span></span></span>
     <span class="main">⟷</span> stable <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">μ'</span><span class="main">.</span> stable <span class="bound">μ'</span> <span class="main">⟶</span> weakly_preferred_by_women <span class="free"><span class="bound"><span class="entity">μ</span></span></span> <span class="bound">μ'</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We can show that there is no optimal stable match for these
preferences:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> NonStrict_not_optimal<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Non_Strict.stable <span class="free">μ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>Non_Strict.optimal_for_men <span class="free">μ</span> <span class="main">∧</span> <span class="main">¬</span>Non_Strict.optimal_for_women <span class="free">μ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> Non_Strict_stable_matches<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> disjE<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">μ</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span>M1<span class="main">,</span> W2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M2<span class="main">,</span> W1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M3<span class="main">,</span> W3<span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> Non_Strict.optimal_for_men_def Non_Strict.weakly_preferred_by_men_def
                Non_Strict.m_weakly_prefers_def Non_Strict.optimal_for_women_def
                Non_Strict.weakly_preferred_by_women_def Non_Strict.w_weakly_prefers_def
                Non_Strict_stable_matches
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">{</span></span></span><span class="main"><span class="main"><span class="main">(</span></span></span>M1<span class="main"><span class="main"><span class="main">,</span></span></span> W3<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span>M2<span class="main"><span class="main"><span class="main">,</span></span></span> W2<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span>M3<span class="main"><span class="main"><span class="main">,</span></span></span> W1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main"><span class="main">}</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">μ</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span>M1<span class="main">,</span> W3<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M2<span class="main">,</span> W2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>M3<span class="main">,</span> W1<span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> Non_Strict.optimal_for_men_def Non_Strict.weakly_preferred_by_men_def
                Non_Strict.m_weakly_prefers_def Non_Strict.optimal_for_women_def
                Non_Strict.weakly_preferred_by_women_def Non_Strict.w_weakly_prefers_def
                Non_Strict_stable_matches
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">{</span></span></span><span class="main"><span class="main"><span class="main">(</span></span></span>M1<span class="main"><span class="main"><span class="main">,</span></span></span> W2<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span>M2<span class="main"><span class="main"><span class="main">,</span></span></span> W1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span>M3<span class="main"><span class="main"><span class="main">,</span></span></span> W3<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main"><span class="main">}</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet{Sotomayor:1996} remarks that, if the preferences are strict,
there is only one weakly Pareto optimal match for men, and that it is
man-optimal. (This is the match found by the classic man-proposing
deferred acceptance algorithm due to \citet{GaleShapley:1962}.)
However she omits a proof that the man-optimal match actually exists
under strict preferences.

The easiest way to show this and further results is to exhibit the
lattice structure of the stable matches discovered by Conway (see
\citet[Theorem~2.16]{RothSotomayor:1990}), where the men- and
women-optimal matches are the extremal points. This suggests looking
for a monotonic function whose fixed points are this lattice, which is
the essence of the analysis of matching with contracts in
\S\ref{sec:contracts}.

›</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Basis">
<div class="head">
<h1>Theory Basis</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Basis
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOL/Main.html">Main</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/While_Combinator.html">HOL-Library.While_Combinator</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ Preliminaries ›</span></span>

<span class="comment1">(*&gt;*)</span><span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ HOL Detritus ›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Above_union<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Above <span class="free">r</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">Y</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> Above <span class="free">r</span> <span class="free">X</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">∈</span> Above <span class="free">r</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Above_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Above_Field<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Above <span class="free">r</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Field <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> Above_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> AboveS_Field<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> AboveS <span class="free">r</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Field <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> AboveS_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Above_Linear_singleton<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Field <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Above <span class="free">r</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> Above_def order_on_defs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> subseqs_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> set <span class="main">(</span>subseqs <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="free">y</span> <span class="main">⊆</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Pow_iff image_eqI subseqs_powset<span class="main">)</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">map_of_default</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_of_default</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">map_of_default</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">kv</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">kvs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> fst <span class="free"><span class="bound"><span class="entity">kv</span></span></span> <span class="keyword1">then</span> snd <span class="free"><span class="bound"><span class="entity">kv</span></span></span> <span class="keyword1">else</span> <span class="free">map_of_default</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">kvs</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> set_elem_equalityI <span class="main">=</span> Set.equalityI<span class="main">[</span><span class="operator">OF</span> Set.subsetI Set.subsetI<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> total_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> total_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> partial_order_on_acyclic<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"partial_order_on <span class="free">A</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"acyclic <span class="main">(</span><span class="free">r</span> <span class="main">-</span> Id<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> acyclic_irrefl assms irrefl_diff_Id partial_order_on_def preorder_on_def trancl_id trans_diff_Id<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> finite_Linear_order_induct<span class="main">[</span><span class="operator">consumes</span> 3<span class="main">,</span> <span class="operator">case_names</span> step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Field <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">x</span> <span class="main">∈</span> Field <span class="free">r</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> aboveS <span class="free">r</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">y</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_induct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">r</span></span><span class="main"><span class="main">¯</span></span> <span class="main"><span class="main">-</span></span> Id"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"wf <span class="main">(</span><span class="free">r</span><span class="main">¯</span> <span class="main">-</span> Id<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> linear_order_on_well_order_on linear_order_on_converse
    <span class="keyword1"><span class="command">unfolding</span></span> well_order_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> step<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> aboveS_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> FieldI2<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We sometimes want a notion of monotonicity over some set.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mono_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mono_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> mono_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> mono_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> mono_onD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> mono_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> mono_onE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>mono_on <span class="free">A</span> <span class="free">f</span><span class="main">;</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">;</span> <span class="free">y</span> <span class="main">∈</span> <span class="free">A</span><span class="main">;</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span><span class="main">;</span> <span class="free">f</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">thesis</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">thesis</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> mono_onD <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> mono_on_mono<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono_on UNIV <span class="main">=</span> mono"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mono_on_def mono_def fun_eq_iff<span class="main">)</span>


<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ MaxR: maximum elements of linear orders ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We generalize the existing <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "max"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Max"<span class="antiquote"><span class="antiquote">}</span></span></span></span> functions
to work on orders defined over sets. See \S\ref{sec:cf-linear} for
choice-function related lemmas.

›</span></span>

<span class="keyword1"><span class="command">locale</span></span> MaxR <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>finite rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> r_Linear_order<span class="main">:</span> <span class="quoted"><span class="quoted">"Linear_order <span class="free">r</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The basic function chooses the largest of two elements:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">maxR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">maxR</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> maxR_domain<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">⟹</span> maxR <span class="free">x</span> <span class="free">y</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> maxR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> maxR_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maxR <span class="free">x</span> <span class="free">y</span> <span class="main">∈</span> <span class="main">{</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> maxR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> maxR_rangeD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"maxR <span class="free">x</span> <span class="free">y</span> <span class="main">≠</span> <span class="free">x</span> <span class="main">⟹</span> maxR <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="quoted"><span class="quoted">"maxR <span class="free">x</span> <span class="free">y</span> <span class="main">≠</span> <span class="free">y</span> <span class="main">⟹</span> maxR <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> maxR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> maxR_idem<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maxR <span class="free">x</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> maxR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> maxR_absorb2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span> <span class="main">⟹</span> maxR <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> maxR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> maxR_absorb1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span> <span class="main">⟹</span> maxR <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> r_Linear_order <span class="keyword1"><span class="command">unfolding</span></span> maxR_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> order_on_defs antisym_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> maxR_assoc<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">,</span><span class="free">z</span><span class="main">}</span> <span class="main">⊆</span> Field <span class="free">r</span> <span class="main">⟹</span> maxR <span class="main">(</span>maxR <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="free">z</span> <span class="main">=</span> maxR <span class="free">x</span> <span class="main">(</span>maxR <span class="free">y</span> <span class="free">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> r_Linear_order <span class="keyword1"><span class="command">unfolding</span></span> maxR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> order_on_defs<span class="main"><span class="main">(</span></span>1-3<span class="main"><span class="main">)</span></span> total_on_def trans_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> maxR_commute<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">}</span> <span class="main">⊆</span> Field <span class="free">r</span> <span class="main">⟹</span> maxR <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> maxR <span class="free">y</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> r_Linear_order <span class="keyword1"><span class="command">unfolding</span></span> maxR_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> order_on_defs antisym_def total_on_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> maxR_simps <span class="main">=</span>
  maxR_idem
  maxR_absorb1
  maxR_absorb2

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We hoist this to finite sets using the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Finite_Set.fold"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
combinator. For code generation purposes it seems inevitable that we
need to fuse the fold and filter into a single total recursive
definition.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">MaxR_f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'a</span> option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">MaxR_f</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">acc</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∈</span> Field <span class="free">r</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">acc</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> maxR <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">y</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">acc</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> MaxR_f<span class="main">:</span> comp_fun_idem <span class="quoted">MaxR_f</span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible r_Linear_order
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff maxR_def MaxR_f_def order_on_defs total_on_def antisymD <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> transE <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">MaxR_opt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  MaxR_opt_eq_fold'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">MaxR_opt</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> Finite_Set.fold MaxR_f None <span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"MaxR_opt <span class="main">{}</span> <span class="main">=</span> None"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> MaxR_opt_eq_fold'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> insert<span class="main">:</span> <span class="quoted"><span class="quoted">"MaxR_opt <span class="main">(</span>insert <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">∈</span> Field <span class="free">r</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="keyword1">case</span> MaxR_opt <span class="free">A</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">x</span> <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> maxR <span class="free">x</span> <span class="bound">y</span><span class="main">)</span> <span class="keyword1">else</span> MaxR_opt <span class="free">A</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> range_Some<span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"MaxR_opt <span class="free">A</span> <span class="main">=</span> Some <span class="free">a</span> <span class="main">⟶</span> <span class="free">a</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∩</span> Field <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> MaxR_opt_eq_fold' maxR_def MaxR_f_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> range_None<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"MaxR_opt <span class="free">A</span> <span class="main">=</span> None"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∩</span> Field <span class="free">r</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Int_iff insert all_not_in_conv insert_absorb option.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> domain_empty<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∩</span> Field <span class="free">r</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"MaxR_opt <span class="free">A</span> <span class="main">=</span> None"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> empty_iff option.exhaust range_Some<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> domain<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"MaxR_opt <span class="main">(</span><span class="free">A</span> <span class="main">∩</span> Field <span class="free">r</span><span class="main">)</span> <span class="main">=</span> MaxR_opt <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> MaxR_opt_code <span class="main">=</span> MaxR_opt_eq_fold'<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"set <span class="free">A</span>"</span></span><span class="main">,</span> <span class="operator">unfolded</span> MaxR_f.fold_set_fold<span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span>

<span class="keyword1"><span class="command">lemma</span></span> range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"MaxR_opt <span class="free">A</span> <span class="main">∈</span> Some <span class="main">`</span> <span class="main">(</span><span class="free">A</span> <span class="main">∩</span> Field <span class="free">r</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span>None<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> range_Some notin_range_Some <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemma</span></span> union<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"MaxR_opt <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> MaxR_opt <span class="free">A</span> <span class="keyword1">of</span> None <span class="main">⇒</span> MaxR_opt <span class="free">B</span> <span class="main">|</span> Some <span class="bound">mA</span> <span class="main">⇒</span> Some <span class="main">(</span><span class="keyword1">case</span> MaxR_opt <span class="free">B</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="bound">mA</span> <span class="main">|</span> Some <span class="bound">mB</span> <span class="main">⇒</span> maxR <span class="bound">mA</span> <span class="bound">mB</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> maxR_assoc insert <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> range_Some <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"MaxR_opt <span class="free">A</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">.</span> MaxR_opt <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> Some <span class="bound">y</span> <span class="main">∧</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">B</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
  <span class="keyword3"><span class="command">case</span></span> empty <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> range_Some underS_incl_iff<span class="main">[</span><span class="operator">OF</span> r_Linear_order<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">note</span></span> ins <span class="main">=</span> insert
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> assms r_Linear_order <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> order_on_defs total_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ins maxR_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> transE <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> FieldI1<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> eliminate_false_implies<span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> MaxR_opt_is_greatest<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"MaxR_opt <span class="free">A</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∩</span> Field <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span><span class="main">]</span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> ins <span class="main">=</span> insert
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="skolem">A</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> r_Linear_order insert <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> order_on_defs refl_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∉</span> <span class="free">r</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> insert <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Field <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> Field <span class="free">r</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> maxR_def ins <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> range_None range_Some <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits option.splits<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∉</span> <span class="free">r</span>›</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="free">y</span> <span class="main">≠</span> <span class="skolem">x</span>›</span></span> <span class="keyword2"><span class="keyword">and</span></span> insert <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∉</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> Field <span class="free">r</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> maxR_def ins <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> range_None range_Some <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits option.splits<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> r_Linear_order <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∉</span> <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> Field <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">y</span> <span class="main">∈</span> Field <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">y</span> <span class="main">≠</span> <span class="skolem">x</span>›</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> order_on_defs total_on_def<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"trans <span class="free">r</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> r_Linear_order <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> order_on_defs<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> this <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> transD<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∉</span> <span class="free">r</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">contradiction</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> greatest_is_MaxR_opt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∩</span> Field <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∩</span> Field <span class="free">r</span><span class="main">.</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"MaxR_opt <span class="free">A</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span><span class="main">]</span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> ins <span class="main">=</span> insert
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="skolem">A</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> maxR_absorb1 maxR_absorb2
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> maxR_def ins <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> range_None range_Some <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> subset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set_option <span class="main">(</span>MaxR_opt <span class="free">B</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"MaxR_opt <span class="free">B</span> <span class="main">=</span> MaxR_opt <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> union<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">A</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">B</span><span class="main">-</span><span class="free">A</span>"</span></span><span class="main">]</span> range<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">-</span> <span class="free">A</span>"</span></span><span class="main">]</span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Un_absorb1 finite_subset maxR_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> MaxR_empty<span class="main">:</span> MaxR <span class="quoted"><span class="quoted">"<span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">interpretation</span></span> MaxR_singleton<span class="main">:</span> MaxR <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">x</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> MaxR_r_domain <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"MaxR <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"MaxR <span class="main">(</span>Restr <span class="free">r</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms Linear_order_Restr <span class="keyword1"><span class="command">unfolding</span></span> MaxR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Linear orders from lists ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Often the easiest way to specify a concrete linear order is with a
list. Here these run from greatest to least.

›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">linord_of_listP</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">linord_of_listP</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">[]</span> <span class="main">⟷</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">linord_of_listP</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∈</span> set <span class="main">(</span><span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span> <span class="free">linord_of_listP</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">linord_of_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">linord_of_list</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> linord_of_listP <span class="bound">x</span> <span class="bound">y</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">}</span>"</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_linord_of_listP<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xy</span> <span class="main">∈</span> linord_of_list <span class="free">xs</span> <span class="main">⟷</span> linord_of_listP <span class="main">(</span>fst <span class="free">xy</span><span class="main">)</span> <span class="main">(</span>snd <span class="free">xy</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> linord_of_list_def split_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_listP_linord_of_list<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"linord_of_listP <span class="free">x</span> <span class="free">y</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> linord_of_list <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> linord_of_list_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_listP_empty<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">¬</span>linord_of_listP <span class="bound">x</span> <span class="bound">y</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> linord_of_listP.simps list.exhaust list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_listP_domain<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"linord_of_listP <span class="free">x</span> <span class="free">y</span> <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">∈</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_empty<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"linord_of_list <span class="main">[]</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="quoted"><span class="quoted">"linord_of_list <span class="free">xs</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> linord_of_list_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linord_of_listP_empty<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_singleton<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> linord_of_list <span class="main">[</span><span class="free">z</span><span class="main">]</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">z</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">=</span> <span class="free">z</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> linord_of_list_linord_of_listP<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_range<span class="main">:</span>
  <span class="quoted"><span class="quoted">"linord_of_list <span class="free">xs</span> <span class="main">⊆</span> set <span class="free">xs</span> <span class="main">×</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> linord_of_list_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_Field <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Field <span class="main">(</span>linord_of_list <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> linord_of_list_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Field_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_listP_append<span class="main">:</span>
  <span class="quoted"><span class="quoted">"linord_of_listP <span class="free">x</span> <span class="free">y</span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> linord_of_listP <span class="free">x</span> <span class="free">y</span> <span class="free">xs</span> <span class="main">∨</span> linord_of_listP <span class="free">x</span> <span class="free">y</span> <span class="free">ys</span> <span class="main">∨</span> <span class="main">(</span><span class="free">y</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">∈</span> set <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_append<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> linord_of_list <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> linord_of_list <span class="free">xs</span> <span class="main">∨</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> linord_of_list <span class="free">ys</span> <span class="main">∨</span> <span class="main">(</span><span class="free">y</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">∈</span> set <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> linord_of_list_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linord_of_listP_append<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_refl_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>linord_of_list <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> linord_of_list_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> refl_onI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> refl_onD1 refl_onD2 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> linord_of_list_range<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_trans<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"trans <span class="main">(</span>linord_of_list <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> linord_of_list_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> transI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> linord_of_listP_domain <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> transE<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_antisym<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"antisym <span class="main">(</span>linord_of_list <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> linord_of_list_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> antisymI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> linord_of_listP_domain <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> antisymD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_total_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"total_on <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>linord_of_list <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> total_on_def linord_of_list_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_Restr<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> <span class="free">C</span>"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> in_set_remove1<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="comment1">(* suppress warning *)</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Restr <span class="main">(</span>linord_of_list <span class="main">(</span>remove1 <span class="free">x</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="free">C</span> <span class="main">=</span> Restr <span class="main">(</span>linord_of_list <span class="free">xs</span><span class="main">)</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> linord_of_list_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">iff</span><span class="main"><span class="main">:</span></span> in_set_remove1<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_nth<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="free">i</span><span class="main">,</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">j</span><span class="main">)</span> <span class="main">∈</span> linord_of_list <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> length <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">≤</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="skolem">xs</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> Cons <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> linord_of_list_linord_of_listP nth_equal_first_eq less_Suc_eq_0_disj linord_of_listP_domain<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> Cons <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_Linear_order<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"linear_order_on <span class="free">ys</span> <span class="main">(</span>linord_of_list <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms linord_of_list_range linord_of_list_refl_on linord_of_list_trans linord_of_list_antisym linord_of_list_total_on
<span class="keyword1"><span class="command">unfolding</span></span> order_on_defs <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Every finite linear order is generated by a list.

›</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">sorted_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> rel <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  Nil <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sorted_on</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> Cons <span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∈</span> Field <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">;</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">;</span> <span class="free">sorted_on</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">sorted_on</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">inductive_cases</span></span> sorted_on_inv<span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sorted_on <span class="free">r</span> <span class="main">[]</span>"</span></span>
  <span class="quoted"><span class="quoted">"sorted_on <span class="free">r</span> <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">insort_key_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> rel <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> list <span class="main">⇒</span> <span class="tfree">'b</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">insort_key_on</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">insort_key_on</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">then</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free">insort_key_on</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sort_key_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> rel <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span> list <span class="main">⇒</span> <span class="tfree">'b</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sort_key_on</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> foldr <span class="main">(</span>insort_key_on <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">[]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">insort_insert_key_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> rel <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> list <span class="main">⇒</span> <span class="tfree">'b</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">insort_insert_key_on</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">`</span> set <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> insort_key_on <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">sort_on</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> sort_key_on <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">insort_on</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> insort_key_on <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">insort_insert_on</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> insort_insert_key_on <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="free">r</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_on_single <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sorted_on <span class="free">r</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> Field <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> empty_iff list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.set<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> nth_Cons_0 sorted_on.simps<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_on_many<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sorted_on <span class="free">r</span> <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sorted_on <span class="free">r</span> <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">y</span> <span class="main">#</span> <span class="free">zs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="quoted"><span class="quoted">‹Linear_order <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> order_on_defs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> transE <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> FieldI1<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_on_Cons<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sorted_on <span class="free">r</span> <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span> <span class="main">∈</span> Field <span class="free">r</span> <span class="main">∧</span> sorted_on <span class="free">r</span> <span class="free">xs</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="free">xs</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹Linear_order <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> order_on_defs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> transE<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_on_distinct_set_unique<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sorted_on <span class="free">r</span> <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"sorted_on <span class="free">r</span> <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">=</span> set <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">=</span> length <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> distinct_card<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_induct2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> 1<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹Linear_order <span class="free">r</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> order_on_defs
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sorted_on_Cons<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> antisymD insertI1 insert_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_insort_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>insort_key_on <span class="free">r</span> <span class="free">f</span> <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">x</span> <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> sort_key_on_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sort_key_on <span class="free">r</span> <span class="free">f</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
        <span class="quoted"><span class="quoted">"sort_key_on <span class="free">r</span> <span class="free">f</span> <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> insort_key_on <span class="free">r</span> <span class="free">f</span> <span class="free">x</span> <span class="main">(</span>sort_key_on <span class="free">r</span> <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sort_key_on_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_sort_on <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>sort_key_on <span class="free">r</span> <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_insort_on<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_insort_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>insort_key_on <span class="free">r</span> <span class="free">f</span> <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">∉</span> set <span class="free">xs</span> <span class="main">∧</span> distinct <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_insort_on<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_sort_on <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>sort_key_on <span class="free">r</span> <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> distinct <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> distinct_insort_on<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_on_insort_key_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">`</span> set <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> Field <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sorted_on <span class="free">r</span> <span class="main">(</span>map <span class="free">f</span> <span class="main">(</span>insort_key_on <span class="free">r</span> <span class="free">f</span> <span class="free">x</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> sorted_on <span class="free">r</span> <span class="main">(</span>map <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹Linear_order <span class="free">r</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> order_on_defs
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sorted_on_Cons sorted_on_many set_insort_on refl_on_def total_on_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> transE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_on_insort_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> Field <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sorted_on <span class="free">r</span> <span class="main">(</span>insort_on <span class="free">r</span> <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> sorted_on <span class="free">r</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> sorted_on_insort_key_on<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span><span class="main">]</span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">theorem</span></span> sorted_on_sort_key_on <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">`</span> set <span class="free">xs</span> <span class="main">⊆</span> Field <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sorted_on <span class="free">r</span> <span class="main">(</span>map <span class="free">f</span> <span class="main">(</span>sort_key_on <span class="free">r</span> <span class="free">f</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sorted_on_insort_key_on<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> sorted_on_sort_on <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> Field <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sorted_on <span class="free">r</span> <span class="main">(</span>sort_on <span class="free">r</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> sorted_on_sort_key_on<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span><span class="main">]</span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> finite_sorted_on_distinct_unique<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> Field <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span><span class="bound">xs</span><span class="main">.</span> set <span class="bound">xs</span> <span class="main">=</span> <span class="free">A</span> <span class="main">∧</span> sorted_on <span class="free">r</span> <span class="bound">xs</span> <span class="main">∧</span> distinct <span class="bound">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹finite <span class="free">A</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">=</span> <span class="free">A</span> <span class="main">∧</span> distinct <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> finite_distinct_list <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">A</span> <span class="main">⊆</span> Field <span class="free">r</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ex1I<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> a<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"sort_on <span class="free">r</span> <span class="skolem">xs</span>"</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sorted_on_distinct_set_unique<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_on_linord_of_list_subseteq_r<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sorted_on <span class="free">r</span> <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"linord_of_list <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"linord_of_list <span class="main">(</span>rev <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sorted_on_Cons<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Cons.prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> linord_of_list_append linord_of_list_singleton sorted_on_Cons<span class="main">)</span>
       <span class="main">(</span><span class="operator">meson</span> contra_subsetD subsetI underS_incl_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_on_linord_of_list<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">=</span> Field <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sorted_on <span class="free">r</span> <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"linord_of_list <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"linord_of_list <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> sorted_on_linord_of_list_subseteq_r <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="keyword3"><span class="command">assume</span></span> xy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹Linear_order <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∉</span> <span class="free">r</span> <span class="main">-</span> Id"</span></span>
      <span class="keyword1"><span class="command">using</span></span> Linear_order_in_diff_Id <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> FieldI1<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> linord_of_list_Linear_order<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"rev <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"Field <span class="free">r</span>"</span></span><span class="main">]</span> assms xy
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> linord_of_list <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> Diff_subset FieldI1 FieldI2 Linear_order_in_diff_Id linord_of_list_Field set_rev sorted_on_linord_of_list_subseteq_r subset_eq<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">⊆</span> linord_of_list <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_listP_rev<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">#</span> <span class="free">zs</span> <span class="main">∈</span> set <span class="main">(</span>subseqs <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> set <span class="free">zs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"linord_of_listP <span class="free">z</span> <span class="free">y</span> <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def linord_of_listP_append <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> subseqs_set<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_sorted_on_subseqs<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">∈</span> set <span class="main">(</span>subseqs <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sorted_on <span class="main">(</span>linord_of_list <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> linord_of_list_Linear_order<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> xs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"rev <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> ys<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"Field <span class="main">(</span>linord_of_list <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Cons_in_subseqsD sorted_on_Cons linord_of_list_linord_of_listP linord_of_listP_rev <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> subseqs_set<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> linord_of_list_sorted_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sorted_on <span class="main">(</span>linord_of_list <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> linord_of_list_sorted_on_subseqs<span class="main"><span class="main">[</span></span><span class="operator">OF</span> subseqs_refl <span class="quoted"><span class="quoted">‹distinct <span class="free">xs</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> linear_order_on_list<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"linear_order_on <span class="free">ys</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> Field <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span><span class="bound">xs</span><span class="main">.</span> <span class="free">r</span> <span class="main">=</span> linord_of_list <span class="bound">xs</span> <span class="main">∧</span> distinct <span class="bound">xs</span> <span class="main">∧</span> set <span class="bound">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible finite_sorted_on_distinct_unique<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">]</span> sorted_on_linord_of_list<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">r</span></span><span class="main">]</span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> distinct_rev linord_of_list_sorted_on rev_rev_ident set_rev<span class="main">)</span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Choice_Functions">
<div class="head">
<h1>Theory Choice_Functions</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Choice_Functions
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Basis.html">Basis</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ Choice Functions \label{sec:cf} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We now develop a few somewhat general results about choice functions,
following \citet{Moulin:1985,Sen:1970,Border:2012}.
\citet{sep-preferences} provide some philosophical background on this
topic. While this material is foundational to the story we tell about
stable matching, it is perhaps best skipped over on a first reading.

The game here is to study conditions on functions that yield
acceptable choices from a given set of alternatives drawn from some
universe (a set, often a type in HOL). We adopt the Isabelle
convention of attaching the suffix <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹on›<span class="antiquote"><span class="antiquote">}</span></span></span></span> to
predicates that are defined on subsets of their types.

›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> cfun <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Most results require that the choice function yield a subset of its
argument:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">f_range_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">f_range_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">⊆</span> <span class="bound">B</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">f_range</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">f_range</span> <span class="main">≡</span> f_range_on UNIV"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> f_range_onI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">B</span><span class="main">.</span> <span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">B</span> <span class="main">⊆</span> <span class="bound">B</span><span class="main">)</span> <span class="main">⟹</span> f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> f_range_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemmas</span></span> f_range_onD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> f_range_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> f_range_onD' <span class="main">=</span> subsetD<span class="main">[</span><span class="operator">OF</span> f_range_onD<span class="main">,</span> <span class="operator">rotated</span> -1<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> f_range_on_antimono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">B</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> f_range_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Economists typically assume that the universe is finite, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹decisive›<span class="antiquote"><span class="antiquote">}</span></span></span></span>, i.e., yields non-empty sets when given
non-empty sets.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">decisive_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">decisive_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="bound">B</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">decisive</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">decisive</span> <span class="main">≡</span> decisive_on UNIV"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemmas</span></span> decisive_onD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> decisive_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> decisive_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> decisive_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> decisive_on_empty<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="main">{}</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> decisive_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> decisive_on_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">B</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms order_trans <span class="keyword1"><span class="command">unfolding</span></span> decisive_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Often we can mildly generalise existing results by not requiring that
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> be <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "decisive"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, and by dropping the finiteness
hypothesis. We make essential use of the former generalization in
\S\ref{sec:contracts}.

Some choice functions, such as those arising from linear orders
(\S\ref{sec:cf-linear}), are <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹resolute›<span class="antiquote"><span class="antiquote">}</span></span></span></span>: these always yield a
single choice.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">resolute_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">resolute_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="bound">B</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">a</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">=</span> <span class="main">{</span><span class="bound">a</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">resolute</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">resolute</span> <span class="main">≡</span> resolute_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> resolute_on_decisive_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"resolute_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> resolute_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> decisive_onI<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Often we talk about the choices that are rejected by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f›</span></span></span></span>:

\label{sec:cf-rf}

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Rf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> <span class="tfree">'a</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Rf</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Typically there are many (almost-)equivalent formulations of each
property in the literature. We try to formulate our rules in terms of
the most general of these.

›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹substitutes›<span class="antiquote"><span class="antiquote">}</span></span></span></span> condition, AKA <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹independence of irrelevant alternatives›<span class="antiquote"><span class="antiquote">}</span></span></span></span> \label{sec:cf-substitutes} AKA <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹Chernoff›<span class="antiquote"><span class="antiquote">}</span></span></span></span> ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Loosely speaking, the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹substitutes›<span class="antiquote"><span class="antiquote">}</span></span></span></span> condition asserts that an
alternative that is rejected from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> shall remain rejected
when there is ``increased competition,'' i.e., from all sets that
contain <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

\citet{HatfieldMilgrom:2005} define this property as simply the
monotonicity of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Rf"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. \citet{AygunSonmez:2012-WP2} instead
use the complicated condition shown here. Condition
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>α›</span></span></span></span>, due to \citet[p17, see below]{Sen:1970}, is
the most general and arguably the most perspicuous.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">substitutes_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">substitutes_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∃</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">-</span> <span class="bound">B</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">substitutes</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">substitutes</span> <span class="main">≡</span> substitutes_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> substitutes_on_def2<span class="main">[</span><span class="operator">simplified</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"substitutes_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">b</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">a</span> <span class="skolem">b</span>
  <span class="keyword3"><span class="command">assume</span></span> lhs<span class="main">:</span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> XXX <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_absorb<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> lhs XXX <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> substitutes_on_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute insert_absorb<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> substitutes_on_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> substitutes_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> substitutes_on_def2<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> substitutes_onD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> substitutes_on_def2<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> substitutesD <span class="main">=</span> substitutes_onD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted">UNIV</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> substitutes_on_union<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="free">B</span> <span class="main">∪</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"substitutes_on <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span> <span class="main">∪</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span><span class="main">)</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span> <span class="main">∪</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms<span class="main">(</span>3<span class="main">,</span>1-2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_commute substitutes_on_def2 le_iff_sup<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> substitutes_on_antimono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"substitutes_on <span class="free">B</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"substitutes_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> substitutes_on_def2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The equivalence with the monotonicity of alternative-rejection
requires a finiteness constraint.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> substitutes_on_Rf_mono_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"substitutes_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono_on <span class="main">(</span>Pow <span class="free">A</span><span class="main">)</span> <span class="main">(</span>Rf <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> mono_onI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> subsetI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">C</span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">∈</span> Pow <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">∈</span> Pow <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="skolem">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Rf <span class="free">f</span> <span class="skolem">B</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms substitutes_on_union<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> a<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">C</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">B</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">f</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Rf <span class="free">f</span> <span class="skolem">C</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_absorb<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> rev_finite_subset subsetCE substitutes_on_antimono sup.orderE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Rf_mono_on_substitutes<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mono_on <span class="main">(</span>Pow <span class="free">A</span><span class="main">)</span> <span class="main">(</span>Rf <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"substitutes_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> substitutes_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> mono_onE<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">b</span> <span class="skolem">B</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> y<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The above substitutes condition is equivalent to the
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹independence of irrelevant alternatives›<span class="antiquote"><span class="antiquote">}</span></span></span></span>, AKA condition
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>α›</span></span></span></span> due to \citet{Sen:1970}. Intuitively if
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a›</span></span></span></span> is chosen from a set <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A›</span></span></span></span>, then it must
be chosen from every subset of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A›</span></span></span></span> that it belongs
to. Note the lack of finiteness assumptions here.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">iia_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">iia_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound"><span class="bound">C</span></span><span class="main">⊆</span><span class="bound">B</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="bound">C</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">⟶</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">C</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">iia</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">iia</span> <span class="main">≡</span> iia_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible iia_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> iia_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible iia_onD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> iia_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> Rf_mono_on_iia_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono_on <span class="main">(</span>Pow <span class="free">A</span><span class="main">)</span> <span class="main">(</span>Rf <span class="free">f</span><span class="main">)</span> <span class="main">⟷</span> iia_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible iia_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> mono_onE <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mono_onI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Rf_mono_iia<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span>Rf <span class="free">f</span><span class="main">)</span> <span class="main">⟷</span> iia <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Rf_mono_on_iia_on<span class="main">[</span><span class="operator">of</span> <span class="quoted">UNIV</span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span> mono_on_mono <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> substitutes_iia<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"substitutes_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> iia_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Rf_mono_on_iia_on Rf_mono_on_substitutes substitutes_on_Rf_mono_on<span class="main">[</span><span class="operator">OF</span> _ assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

One key result is that the choice function must be idempotent if it
satisfies <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "iia"<span class="antiquote"><span class="antiquote">}</span></span></span></span> or any of the equivalent conditions.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> iia_f_idem<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"iia_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> iia_on_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> f_range_onD f_range_on_antimono subset_antisym subset_eq<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[p914, bottom right]{HatfieldMilgrom:2005} claim that the
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> condition coincides with the
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹substitutable preferences›<span class="antiquote"><span class="antiquote">}</span></span></span></span> condition for the college admissions
problem of \citet[Definition~6.2]{RothSotomayor:1990}, which is
similar to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "iia"<span class="antiquote"><span class="antiquote">}</span></span></span></span>:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">substitutable_preferences_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">substitutable_preferences_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="bound">B</span><span class="main">.</span> <span class="main">∀</span><span class="bound">b</span><span class="main">∈</span><span class="bound">B</span><span class="main">.</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">b</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">⟶</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main">-</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible substitutable_preferences_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> substitutable_preferences_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> substitutable_preferences_on_substitutes_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"substitutable_preferences_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> substitutes_on <span class="free">A</span> <span class="free">f</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> substitutable_preferences_on_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> substitutes_onI<span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> Diff_insert_absorb insertCI insert_absorb insert_subset<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> substitutable_preferences_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">a</span> <span class="skolem">b</span>
    <span class="keyword3"><span class="command">assume</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">b</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span> XXX <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">b</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> substitutes_on_def2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insertE insert_Diff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[p152]{Moulin:1985} defines an equivalent <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹Chernoff›<span class="antiquote"><span class="antiquote">}</span></span></span></span>
condition. Intuitively this captures the idea that ``a best choice in
some issue [set of alternatives] is still best if the issue shrinks.''

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Chernoff_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Chernoff_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound"><span class="bound">C</span></span><span class="main">⊆</span><span class="bound">B</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">∩</span> <span class="bound">C</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">C</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Chernoff</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Chernoff</span> <span class="main">≡</span> Chernoff_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> Chernoff_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> Chernoff_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> Chernoff_def <span class="main">=</span> Chernoff_on_def<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted">UNIV</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> Chernoff_on_iia_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Chernoff_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> iia_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible Chernoff_on_def iia_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Chernoff_on_union<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Chernoff_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="free">B</span> <span class="main">∪</span> <span class="free">C</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">f</span> <span class="free">B</span> <span class="main">∪</span> <span class="free">f</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> Chernoff_on_def f_range_on_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Int_iff Un_iff Un_subset_iff contra_subsetD inf_sup_ord<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">,</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[p159]{Moulin:1985} states a series of equivalent formulations
of the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Chernoff"<span class="antiquote"><span class="antiquote">}</span></span></span></span> condition. He also claims that these hold
if the two sets are disjoint.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Chernoff_a<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Chernoff_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">B</span> <span class="bound">C</span><span class="main">.</span> <span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">∧</span> <span class="bound">C</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">⟶</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="bound">C</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">f</span> <span class="bound">B</span> <span class="main">∪</span> <span class="bound">C</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD' Chernoff_on_union<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Chernoff_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">C</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">⊆</span> <span class="skolem">B</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> spec<span class="main">[</span><span class="operator">OF</span> spec<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span><span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="skolem">C</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">-</span> <span class="skolem">C</span>"</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">B</span> <span class="main">∩</span> <span class="skolem">C</span> <span class="main">⊆</span> <span class="free">f</span> <span class="skolem">C</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Un_absorb1<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Chernoff_b<span class="main">:</span> <span class="comment1">― ‹essentially the converse of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">thm</span> [source] Chernoff_on_union<span class="antiquote">}</span></span>›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Chernoff_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">B</span> <span class="bound">C</span><span class="main">.</span> <span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">∧</span> <span class="bound">C</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">⟶</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="bound">C</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">f</span> <span class="bound">B</span> <span class="main">∪</span> <span class="free">f</span> <span class="bound">C</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">using</span></span> Chernoff_on_union <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Chernoff_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">C</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">⊆</span> <span class="skolem">B</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> spec<span class="main">[</span><span class="operator">OF</span> spec<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span><span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="skolem">C</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">-</span> <span class="skolem">C</span>"</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">B</span> <span class="main">∩</span> <span class="skolem">C</span> <span class="main">⊆</span> <span class="free">f</span> <span class="skolem">C</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Un_absorb1<span class="main">)</span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD'<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Chernoff_c<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Chernoff_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">B</span> <span class="bound">C</span><span class="main">.</span> <span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">∧</span> <span class="bound">C</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">⟶</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="bound">C</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="bound">B</span> <span class="main">∪</span> <span class="bound">C</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">safe</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">C</span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> B C <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">∪</span> <span class="free">f</span> <span class="skolem">C</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Chernoff_on_union<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> C x <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> B <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span> <span class="main">⊆</span> <span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> B C x
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> iia_onD<span class="main">[</span><span class="operator">OF</span> iffD1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Chernoff_on_iia_on <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_subset_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> f_range_on_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Chernoff_a<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Un_iff Un_subset_iff rev_subsetD subset_trans<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Chernoff_d<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Chernoff_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">B</span> <span class="bound">C</span><span class="main">.</span> <span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">∧</span> <span class="bound">C</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">⟶</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="bound">C</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="bound">B</span> <span class="main">∪</span> <span class="free">f</span> <span class="bound">C</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">C</span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> BC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">∧</span> <span class="skolem">C</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Chernoff_c Un_commute<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> BC <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">B</span> <span class="main">∪</span> <span class="free">f</span> <span class="skolem">C</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> iffD1<span class="main">[</span><span class="operator">OF</span> Chernoff_c<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span><span class="main"><span class="main">]</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> f_range_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_commute inf.absorb_iff2 le_infI1<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> f_range_on_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Chernoff_a<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Un_iff Un_subset_iff rev_subsetD subset_trans<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹irrelevance of rejected contracts›<span class="antiquote"><span class="antiquote">}</span></span></span></span> condition AKA <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹consistency›<span class="antiquote"><span class="antiquote">}</span></span></span></span> AKA <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹Aizerman›<span class="antiquote"><span class="antiquote">}</span></span></span></span> \label{sec:cf-irc} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[\S4]{AygunSonmez:2012-WP2} propose to repair the results of
\citet{HatfieldMilgrom:2005} by imposing the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹irrelevance of
rejected contracts›<span class="antiquote"><span class="antiquote">}</span></span></span></span> (IRC) condition. Intuitively this requires the
choice function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to ignore unchosen alternatives.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">irc_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">irc_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="bound">a</span> <span class="main">∉</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">}</span><span class="main">)</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">irc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">irc</span> <span class="main">≡</span> irc_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible irc_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> irc_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible irc_onD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> irc_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible irc_def <span class="main">=</span> irc_on_def<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted">UNIV</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible ircI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> irc_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible ircD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> irc_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> irc_on_discard<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"irc_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">C</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">∪</span> <span class="free">C</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="free">B</span> <span class="main">∪</span> <span class="free">C</span><span class="main">)</span> <span class="main">∩</span> <span class="free">C</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="free">B</span> <span class="main">∪</span> <span class="free">C</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms<span class="main">(</span>2<span class="main">,</span>3<span class="main">,</span>4<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="skolem">C</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> irc_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> Un_subset_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

An equivalent condition is called <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹consistency›<span class="antiquote"><span class="antiquote">}</span></span></span></span> by some
(\citet[Definition~2]{ChambersYenmez:2013},
\citet[Equation~(14)]{Fleiner:2002}). Like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "iia"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, this
formulation generalizes to infinite universes.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">consistency_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">consistency_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound"><span class="bound">C</span></span><span class="main">⊆</span><span class="bound">B</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">⊆</span> <span class="bound">C</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">C</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">consistency</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">consistency</span> <span class="main">≡</span> consistency_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible consistency_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> consistency_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible consistency_onD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> consistency_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible consistency_def <span class="main">=</span> consistency_on_def<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted">UNIV</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible consistencyD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> consistency_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> irc_on_consistency_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"irc_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"consistency_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> consistency_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">C</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span><span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">B</span> <span class="main">⊆</span> <span class="skolem">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">⊆</span> <span class="skolem">B</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">∪</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="free">f</span> <span class="skolem">B</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span><span class="free">A</span>›</span></span> <span class="quoted"><span class="quoted">‹finite <span class="free">A</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">B</span> <span class="main">=</span> <span class="free">f</span> <span class="skolem">C</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> irc_on_discard<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">C</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">-</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> consistency_on_irc_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"consistency_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"irc_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> irc_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">b</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> consistency_onD<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD'<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

These conditions imply that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is idempotent:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> consistency_on_f_idem<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"consistency_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> consistency_onD f_range_onD order_refl<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[p154]{Moulin:1985} defines a similar but weaker property he
calls <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹Aizerman›<span class="antiquote"><span class="antiquote">}</span></span></span></span>:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Aizerman_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Aizerman_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound"><span class="bound">C</span></span><span class="main">⊆</span><span class="bound">B</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">⊆</span> <span class="bound">C</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">C</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Aizerman</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Aizerman</span> <span class="main">≡</span> Aizerman_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible Aizerman_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> Aizerman_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible Aizerman_onD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> Aizerman_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible Aizerman_def <span class="main">=</span> Aizerman_on_def<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted">UNIV</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> consistency_on_Aizerman_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"consistency_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Aizerman_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Aizerman_onI consistency_onD order_refl<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The converse requires <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to be idempotent
\citep[p157]{Moulin:1985}:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Aizerman_on_idem_on_consistency_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Aizerman_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free">A</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="bound">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"consistency_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> consistency_onI<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> inf.coboundedI2 le_iff_inf set_eq_subset Aizerman_onD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹law of aggregate demand›<span class="antiquote"><span class="antiquote">}</span></span></span></span> condition aka <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹size monotonicity›<span class="antiquote"><span class="antiquote">}</span></span></span></span> \label{sec:cf-lad} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[{\S}III]{HatfieldMilgrom:2005} impose the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹law of
aggregate demand›<span class="antiquote"><span class="antiquote">}</span></span></span></span> (aka <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹size monotonicity›<span class="antiquote"><span class="antiquote">}</span></span></span></span>) to obtain the rural
hospitals theorem (\S\ref{sec:contracts-rh}). It captures the
following intuition:
\begin{quote}

[...] Roughly, this law states that as the price falls, agents should
demand more of a good. Here, price falls correspond to more contracts
being available, and more demand corresponds to taking on (weakly)
more contracts.

\end{quote}

The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "card"<span class="antiquote"><span class="antiquote">}</span></span></span></span> function takes a finite set into its cardinality
(as a natural number).

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lad_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>finite cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lad_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound"><span class="bound">C</span></span><span class="main">⊆</span><span class="bound">B</span><span class="main">.</span> card <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">C</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">lad</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>finite cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lad</span> <span class="main">≡</span> lad_on UNIV"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This definition is identical amongst
\citet[{\S}III]{HatfieldMilgrom:2005}, \citet[(20)]{Fleiner:2002}, and
\citet[Definition~4]{AygunSonmez:2012-WP2}.

›</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> lad_onD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lad_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">⊆</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">f</span> <span class="free">C</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span><span class="free">f</span> <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> lad_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> ladD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lad <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">f</span> <span class="free">C</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span><span class="free">f</span> <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> lad_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subsetI<span class="main">)</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[\S5, Proposition~1]{AygunSonmez:2012-WP2} show that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "lad"<span class="antiquote"><span class="antiquote">}</span></span></span></span> imply <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "irc"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, which
therefore rescues many results in the matching-with-contracts
literature.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lad_on_substitutes_on_irc_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"substitutes_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lad_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"irc_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> irc_onI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> card_seteq<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">b</span> <span class="keyword3"><span class="command">assume</span></span> bB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">f</span> <span class="skolem">B</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> bB <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insert <span class="skolem">x</span> <span class="skolem">B</span> <span class="main">=</span> <span class="skolem">B</span> <span class="main">∨</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">b</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD'<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹substitutes_on <span class="free">A</span> <span class="free">f</span>›</span></span> bB x <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insert_subset substitutes_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lad_on <span class="free">A</span> <span class="free">f</span>›</span></span> bB <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">f</span> <span class="skolem">B</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span><span class="free">f</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lad_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_insertI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The converse does not hold.

›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹expansion›<span class="antiquote"><span class="antiquote">}</span></span></span></span> condition ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

According to \citet[p152]{Moulin:1985}, a choice function satifies
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹expansion›<span class="antiquote"><span class="antiquote">}</span></span></span></span> if an alternative chosen from two sets is also chosen
from their union.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">expansion_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">expansion_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound"><span class="bound">C</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">∩</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">C</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="bound">C</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">expansion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">expansion</span> <span class="main">≡</span> expansion_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible expansion_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> expansion_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible expansion_onD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> expansion_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">THEN</span> subsetD<span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Condition <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>γ›</span></span></span></span> due to \citet{Sen:1971} generalizes
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "expansion"<span class="antiquote"><span class="antiquote">}</span></span></span></span> to collections of sets of choices.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">expansion_gamma_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">expansion_gamma_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">As</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">⋃</span><span class="free"><span class="bound"><span class="entity">As</span></span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">As</span></span></span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">⋂</span><span class="bound">A</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">As</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">A</span><span class="main">)</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="main">⋃</span><span class="free"><span class="bound"><span class="entity">As</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">expansion_gamma</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">expansion_gamma</span> <span class="main">≡</span> expansion_gamma_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible expansion_gamma_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> expansion_gamma_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible expansion_gamma_onE <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> expansion_gamma_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">THEN</span> subsetD<span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> expansion_gamma_expansion<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">As</span><span class="main">.</span> expansion_gamma_on <span class="free">A</span> <span class="bound">As</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"expansion_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> expansion_onI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> subsetI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">C</span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">∩</span> <span class="free">f</span> <span class="skolem">C</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> expansion_gamma_onE<span class="main">[</span><span class="operator">OF</span> spec<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> As<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">B</span><span class="main">,</span><span class="skolem">C</span><span class="main">}</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> expansion_expansion_gamma<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"expansion_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">As</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"expansion_gamma_on <span class="free">A</span> <span class="free">As</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> expansion_gamma_onI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> subsetI<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="free">As</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">As</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⋂</span><span class="bound">A</span><span class="main">∈</span><span class="free">As</span><span class="main">.</span> <span class="free">f</span> <span class="bound">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹finite <span class="free">As</span>›</span></span> this <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="main">⋃</span><span class="free">As</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> expansion_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "expansion"<span class="antiquote"><span class="antiquote">}</span></span></span></span> condition plays a major role in the study of
the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹rationalizability›<span class="antiquote"><span class="antiquote">}</span></span></span></span> of choice functions, which we explore
next.

›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Axioms of revealed preference \label{sec:cf-revealed_preference} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We digress from our taxonomy of conditions on choice functions to
discuss <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹rationalizability›<span class="antiquote"><span class="antiquote">}</span></span></span></span>. A choice function is
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹rationalizable›<span class="antiquote"><span class="antiquote">}</span></span></span></span> if there exists some binary relation that generates
it, typically by taking the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹greatest›<span class="antiquote"><span class="antiquote">}</span></span></span></span> or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹maximal›<span class="antiquote"><span class="antiquote">}</span></span></span></span> elements
of the given set of alternatives:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">greatest</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> rel <span class="main">⇒</span> <span class="tfree">'a</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">greatest</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">maximal</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> rel <span class="main">⇒</span> <span class="tfree">'a</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">maximal</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">¬</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> MaxR<span class="main">)</span> greatest<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set_option <span class="main">(</span>MaxR_opt <span class="free">X</span><span class="main">)</span> <span class="main">=</span> greatest <span class="free">r</span> <span class="main">(</span><span class="free">X</span> <span class="main">∩</span> Field <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible greatest_is_MaxR_opt MaxR_opt_is_greatest <span class="keyword1"><span class="command">unfolding</span></span> greatest_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> range_Some<span class="main">)</span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> greatest_r_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Above <span class="free">r</span> <span class="free">X</span> <span class="main">⊆</span> Above <span class="free">r'</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"greatest <span class="free">r</span> <span class="free">X</span> <span class="main">⊆</span> greatest <span class="free">r'</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> greatest_def Above_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> FieldI1<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> greatest_r_mono' <span class="main">=</span> subsetD<span class="main">[</span><span class="operator">OF</span> greatest_r_mono<span class="main">,</span> <span class="operator">rotated</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> greatest_Above<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"greatest <span class="free">r</span> <span class="free">X</span> <span class="main">=</span> Above <span class="free">r</span> <span class="free">X</span> <span class="main">∩</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> greatest_def Above_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> FieldI1<span class="main">)</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Note that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "greatest"<span class="antiquote"><span class="antiquote">}</span></span></span></span> requires the relation to be reflexive
and total, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "maximal"<span class="antiquote"><span class="antiquote">}</span></span></span></span> requires it to be irreflexive, for
the choice functions to ever yield non-empty sets.

This game of uncovering the preference relations (if any) underlying a
choice function goes by the name of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹revealed preference›<span class="antiquote"><span class="antiquote">}</span></span></span></span>. (In
contrast, later we show how these conditions guarantee the existence
of stable many-to-one matches.) See \citet{Moulin:1985} and
\citet{Border:2012} for background, intuition and critique, and
\citet{Sen:1971} for further classical results and proofs.

We adopt the following notion here:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rationalizes_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> <span class="tfree">'a</span> rel <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rationalizes_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">=</span> greatest <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">B</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">rationalizes</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> <span class="tfree">'a</span> rel <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rationalizes</span> <span class="main">≡</span> rationalizes_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">%</span>invisible rationalizes_onI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">B</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="bound">B</span><span class="main">;</span> <span class="bound">y</span> <span class="main">∈</span> <span class="bound">B</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">B</span> <span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∈</span> <span class="bound">B</span><span class="main">;</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="bound">B</span><span class="main">.</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="bound">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rationalizes_on <span class="free">A</span> <span class="free">f</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> rationalizes_on_def greatest_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

In words, relation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">r</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> rationalizes the choice function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> over universe <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span> <span class="free"><span class="free">B</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> picks out the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"greatest"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> elements of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">B</span></span> <span class="main"><span class="main">⊆</span></span> <span class="free"><span class="free">A</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with respect to
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">r</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. At this point <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">r</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> can be any relation that does
the job, but soon enough we will ask that it satisfy some familiar
ordering properties.

The analysis begins by determining under what constraints <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
can be rationalized, continues by establishing some properties of all
rationalizable choice functions, and concludes by considering what it
takes to establish stronger properties.

Following \citet[\S5, Definition~2]{Border:2012} and
\citet[Definition~2]{Sen:1971}, we can generate the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹revealed
weakly preferred›<span class="antiquote"><span class="antiquote">}</span></span></span></span> relation for the choice function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rwp_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> <span class="tfree">'a</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rwp_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="bound">B</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">rwp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> <span class="tfree">'a</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rwp</span> <span class="main">≡</span> rwp_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">%</span>invisible rwp_on_Field<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span>rwp_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> f_range_on_def rwp_on_def Field_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> rwp_on_refl_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="free">A</span> <span class="main">(</span>rwp_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> refl_onI<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rwp_on <span class="free">A</span> <span class="free">f</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">×</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> rwp_on_def f_range_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> rwp_on <span class="free">A</span> <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> rwp_on_def decisive_on_def f_range_on_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

In words, if it is ever possible that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">B</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is available
and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span> <span class="free"><span class="free">B</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> chooses <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, then <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is taken to
always be at least as good as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹V-axiom›<span class="antiquote"><span class="antiquote">}</span></span></span></span> asserts that whatever is revealed to be at least as
good as anything else on offer is chosen:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">V_axiom_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">V_axiom_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="bound">B</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="bound">B</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> rwp_on <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">V_axiom</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">V_axiom</span> <span class="main">≡</span> V_axiom_on UNIV"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This axiom characterizes rationality; see
\citet[Theorem~7]{Border:2012}. \citet[\S3]{Sen:1971} calls a decisive
choice function that satisfies <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "V_axiom"<span class="antiquote"><span class="antiquote">}</span></span></span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹normal›<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rationalizes_on_f_range_on_V_axiom_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"rationalizes_on <span class="free">A</span> <span class="free">f</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"V_axiom_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> V_axiom_on_def rationalizes_on_def greatest_def f_range_on_def rwp_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> f_range_on_V_axiom_on_rationalizes_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"V_axiom_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rationalizes_on <span class="free">A</span> <span class="free">f</span> <span class="main">(</span>rwp_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms rwp_on_Field<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">unfolding</span></span> V_axiom_on_def rationalizes_on_def greatest_def f_range_on_def rwp_on_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">theorem</span></span> V_axiom_on_rationalizes_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>f_range_on <span class="free">A</span> <span class="free">f</span> <span class="main">∧</span> V_axiom_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span><span class="main">.</span> rationalizes_on <span class="free">A</span> <span class="free">f</span> <span class="bound">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible rationalizes_on_f_range_on_V_axiom_on f_range_on_V_axiom_on_rationalizes_on <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We could also ask that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> be determined directly by how it
behaves on pairs (\citet{Sen:1971}, \citet[p151]{Moulin:1985}), which
turns out to be equivalent:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rationalizable_binary_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rationalizable_binary_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="bound">B</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="bound">B</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">{</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">}</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">rationalizable_binary</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rationalizable_binary</span> <span class="main">≡</span> rationalizable_binary_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">%</span>invisible rationalizable_binary_onI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">B</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">;</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="bound">B</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∈</span> <span class="bound">B</span><span class="main">;</span> <span class="bound">y</span> <span class="main">∈</span> <span class="bound">B</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">{</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">B</span> <span class="bound">y</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">;</span> <span class="bound">y</span> <span class="main">∈</span> <span class="bound">B</span><span class="main">;</span> <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="bound">B</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">{</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">}</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="bound">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rationalizable_binary_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> rationalizable_binary_on_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD' <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> FieldI1<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> V_axiom_realizable_binary<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"V_axiom_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> rationalizable_binary_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> lhs<span class="main">:</span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> rationalizable_binary_onI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> lhs <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">{</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> V_axiom_on_def rwp_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">y</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="skolem">B</span><span class="main">.</span> <span class="skolem">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">{</span><span class="bound">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> lhs <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> V_axiom_on_def rwp_on_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> Un_subset_iff insertI1 insert_is_Un mk_disjoint_insert<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> V_axiom_on_def rwp_on_def rationalizable_binary_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

All rationalizable choice functions satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "iia"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"expansion"<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\citet{Sen:1971}, \citet[p152]{Moulin:1985}).

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rationalizable_binary_on_iia_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"rationalizable_binary_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"iia_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> iia_on_def rationalizable_binary_on_def f_range_on_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">meson</span> contra_subsetD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rationalizable_binary_on_expansion_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"rationalizable_binary_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"expansion_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span>  <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> rationalizable_binary_on_def f_range_on_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> expansion_onI<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The converse requires the set of alternatives to be finite, and
moreover fails if the choice function is not <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "decisive"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rationalizable_binary_on_converse<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>finite cfun"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"iia_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"expansion_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rationalizable_binary_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> rationalizable_binary_onI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">x</span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹iia_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">{</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> iia_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">assume</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> YYY<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="skolem">B</span><span class="main">.</span> <span class="skolem">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">{</span><span class="bound">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">y</span> <span class="skolem">C</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">⊆</span> <span class="skolem">B</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span>
  <span class="keyword1"><span class="command">using</span></span> finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">C</span></span><span class="main">]</span> that XXX YYY
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
    <span class="keyword3"><span class="command">case</span></span> empty <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹decisive_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> decisive_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">C</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹expansion_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> expansion_onD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> C<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">b</span><span class="main">,</span> <span class="skolem">y</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">y</span> <span class="skolem">C</span>"</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">note</span></span> this<span class="main">[</span><span class="operator">OF</span> subset_refl<span class="main">]</span>
  <span class="keyword1"><span class="command">with</span></span> XXX <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_absorb<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

That settles the issue of existence, but it is not clear that the
relation is really ``rational'' (for instance, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"rwp_on <span class="free"><span class="free">A</span></span> <span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
need not be transitive). Therefore the analysis continues by further
constraining the choice function so that it is rationalized by
familiar ordering relations.

For instance, the following shows that the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹axioms of revealed
preference›<span class="antiquote"><span class="antiquote">}</span></span></span></span> are rationalized by total preorders \citep[Definitions~8
and~13]{Sen:1971}\footnote{For \citet[p9]{Sen:1970}, an ordering is
complete (total), reflexive, and transitive. Alternative names are:
complete pre-ordering, complete quasi-ordering, and weak
ordering.}. These are alo equivalent to some congruence axioms due to
Samuelson \citep{Border:2012}.

We define <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to be <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹strictly revealed-preferred to›<span class="antiquote"><span class="antiquote">}</span></span></span></span>
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> if there is a situation where both are on offer and only
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is chosen:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rsp_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> <span class="tfree">'a</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="comment1">― ‹\citep[Definition~8]{Sen:1971}›</span>
  <span class="quoted"><span class="quoted">"<span class="free">rsp_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> Rf <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">rsp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> <span class="tfree">'a</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rsp</span> <span class="main">≡</span> rsp_on UNIV"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This relation is typically denoted by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">P</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, for strict
preference. The not-worse-than relation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">R</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is recovered by:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rspR_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> <span class="tfree">'a</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="comment1">― ‹\citep[Definition~9]{Sen:1971}›</span>
  <span class="quoted"><span class="quoted">"<span class="free">rspR_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">}</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∉</span> rsp_on <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">rspR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> <span class="tfree">'a</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rspR</span> <span class="main">≡</span> rspR_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">%</span>invisible rsp_on_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rsp_on <span class="free">A</span> <span class="free">f</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">×</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> rsp_on_def f_range_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[p309]{Sen:1971} defines the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹weak axiom of revealed
preference›<span class="antiquote"><span class="antiquote">}</span></span></span></span> (WARP) as follows:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">warp_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">warp_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">∈</span>rsp_on <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">.</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∉</span> rwp_on <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">warp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">warp</span> <span class="main">≡</span> warp_on UNIV"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹strong axiom of revealed preference›<span class="antiquote"><span class="antiquote">}</span></span></span></span> (SARP) is essentially
the transitive closure of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "warp"<span class="antiquote"><span class="antiquote">}</span></span></span></span> \citep[p309]{Sen:1971}:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sarp_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sarp_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>rsp_on <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">.</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∉</span> rwp_on <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sarp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sarp</span> <span class="main">≡</span> sarp_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">%</span>invisible sarp_onI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>rsp_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∉</span> rwp_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sarp_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> sarp_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> sarp_on_warp_on<span class="main">:</span> <span class="comment1">― ‹\citet[T.3 part]{Sen:1970}›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sarp_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"warp_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> sarp_on_def warp_on_def rwp_on_def rsp_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> rsp_on_irrefl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> irrefl <span class="main">(</span>rsp_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible rsp_on_def irrefl_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

For decisive choice functions, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "warp"<span class="antiquote"><span class="antiquote">}</span></span></span></span> implies <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"sarp"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. We show this following \citet{Sen:1971}, via the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹weak
congruence axiom›<span class="antiquote"><span class="antiquote">}</span></span></span></span> (WCA): if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> chooses <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> from some
set <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">B</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is revealed to be weakly preferred,
then <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must choose <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">B</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as well.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">wca_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">wca_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">∈</span>rwp_on <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> <span class="bound">B</span> <span class="main">⟶</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">wca</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">wca</span> <span class="main">≡</span> wca_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">%</span>invisible wca_onI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">B</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">;</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> rwp_on <span class="free">A</span> <span class="free">f</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="bound">B</span><span class="main">;</span> <span class="bound">y</span> <span class="main">∈</span> <span class="bound">B</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="bound">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wca_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> wca_on_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Decisive choice functions that satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "wca"<span class="antiquote"><span class="antiquote">}</span></span></span></span> are rationalized
by total preorders, in particular <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "rwp"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, and the converse
obtains if they are normal.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wca_on_V_axiom_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wca_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"V_axiom_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> V_axiom_on_def wca_on_def rwp_on_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">)</span></span> ex_in_conv f_range_onD'<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">A</span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span></span></span><span class="main"><span class="main">]</span></span> decisive_onD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">A</span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> wca_on_total_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wca_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"total_on <span class="free">A</span> <span class="main">(</span>rwp_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible<span class="main">(</span><span class="operator">rule</span> total_onI<span class="main">)</span>
 <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
 <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span>
 <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> rwp_on <span class="free">A</span> <span class="free">f</span> <span class="main">∨</span> <span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> rwp_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> wca_on_def decisive_on_def rwp_on_def total_on_def f_range_on_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rwp_on_trans<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wca_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"trans <span class="main">(</span>rwp_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> transI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> rwp_on <span class="free">A</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> rwp_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">B</span></span> <span class="skolem"><span class="skolem">C</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">C</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> rwp_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">B</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹wca_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">C</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">C</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> wca_on_def rwp_on_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">meson</span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> f_range_onD' inf_sup_ord<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> subsetCE<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> assms <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">C</span>›</span></span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">C</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> wca_on_def decisive_on_def rwp_on_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ex_in_conv<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
         <span class="main">(</span><span class="operator">metis</span> Un_iff <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> f_range_onD'<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹wca_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">C</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> wca_on_def rwp_on_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">meson</span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> f_range_onD' inf_sup_ord<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> subsetCE<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> rwp_on <span class="free">A</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> rwp_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wca_on_V_axiom_on_preorder_on<span class="main">:</span> <span class="comment1">― ‹\citet[T.1, T.3 part]{Sen:1970}›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wca_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> V_axiom_on <span class="free">A</span> <span class="free">f</span> <span class="main">∧</span> preorder_on <span class="free">A</span> <span class="main">(</span>rwp_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">∧</span> total_on <span class="free">A</span> <span class="main">(</span>rwp_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">with</span></span> rwp_on_refl_on rwp_on_trans wca_on_V_axiom_on wca_on_total_on assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> preorder_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> rhs<span class="main">:</span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> wca_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> rwp_on <span class="free">A</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span><span class="skolem">B</span><span class="main">.</span> <span class="main">(</span><span class="bound">z</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> rwp_on <span class="free">A</span> <span class="free">f</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> rwp_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> rhs <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> rwp_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span><span class="skolem">B</span><span class="main">.</span> <span class="main">(</span><span class="bound">z</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> rwp_on <span class="free">A</span> <span class="free">f</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> preorder_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> transE<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> rhs <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">B</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> V_axiom_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wca_on_rwp_on_rspR_on<span class="main">:</span> <span class="comment1">― ‹\citet[T.2]{Sen:1970}›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wca_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rwp_on <span class="free">A</span> <span class="free">f</span> <span class="main">=</span> rspR_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> set_elem_equalityI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹wca_on <span class="free">A</span> <span class="free">f</span>›</span></span> rwp_on_refl_on<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> wca_on_def rsp_on_def rspR_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD1 refl_onD2<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> wca_on_def rsp_on_def rspR_on_def rwp_on_def decisive_on_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 3 0 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> split_def
               <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{</span>fst <span class="skolem">x</span><span class="main">,</span> snd <span class="skolem">x</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span>
                <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{</span>fst <span class="skolem">x</span><span class="main">,</span> snd <span class="skolem">x</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span>
                 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD'<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rwp_on_rspR_on_wca_on<span class="main">:</span> <span class="comment1">― ‹\citet[T.2]{Sen:1970}›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"rwp_on <span class="free">A</span> <span class="free">f</span> <span class="main">=</span> rspR_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wca_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> wca_on_def rsp_on_def rspR_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> wca_on_warp_on<span class="main">:</span> <span class="comment1">― ‹\citet[T.3 part]{Sen:1970}›</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wca_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> warp_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible warp_on_def wca_on_def rsp_on_def rwp_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> warp_on_sarp_on<span class="main">:</span> <span class="comment1">― ‹\citet[T.3 part]{Sen:1970}›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"warp_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sarp_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> sarp_onI<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹warp_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"wca_on <span class="free">A</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> wca_on_warp_on <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"rwp_on <span class="free">A</span> <span class="free">f</span> <span class="main">=</span> rspR_on <span class="free">A</span> <span class="free">f</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> YYY<span class="main">:</span> <span class="quoted"><span class="quoted">"preorder_on <span class="free">A</span> <span class="main">(</span>rspR_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> ZZZ<span class="main">:</span> <span class="quoted"><span class="quoted">"total_on <span class="free">A</span> <span class="main">(</span>rspR_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible wca_on_rwp_on_rspR_on<span class="main">[</span><span class="operator">OF</span> _ assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> wca_on_V_axiom_on_preorder_on<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> wca_on_total_on<span class="main">[</span><span class="operator">OF</span> _ assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>rsp_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">b</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">∉</span> rspR_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="skolem">b</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>r_into_trancl <span class="skolem">a</span> <span class="skolem">b</span><span class="main">)</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword1"><span class="command">from</span></span> r_into_trancl rsp_on_range<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword1"><span class="command">from</span></span> r_into_trancl <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rspR_on_def<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>trancl_into_trancl <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span><span class="main">)</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword1"><span class="command">from</span></span> trancl_into_trancl rsp_on_range<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword1"><span class="command">from</span></span> trancl_into_trancl rsp_on_range<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> YYY ZZZ <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> total_on_def preorder_on_def
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> case_prodD mem_Collect_eq rspR_on_def transD<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">with</span></span> XXX <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">b</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">∉</span> rwp_on <span class="free">A</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "decisive"<span class="antiquote"><span class="antiquote">}</span></span></span></span> constraint here is necessary: consider a
Condorcet cycle over <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{</span></span><span class="free"><span class="free">x</span></span><span class="main"><span class="main">,</span></span> <span class="free"><span class="free">y</span></span><span class="main"><span class="main">,</span></span> <span class="free"><span class="free">z</span></span><span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>: forcing <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span> <span class="main"><span class="main">{</span></span><span class="free"><span class="free">x</span></span><span class="main"><span class="main">,</span></span> <span class="free"><span class="free">y</span></span><span class="main"><span class="main">,</span></span>
<span class="free"><span class="free">z</span></span><span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to be non-empty resolves this.

\citet{Sen:1971} proves that these and other conditions on choice
functions are equivalent (under the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "decisive"<span class="antiquote"><span class="antiquote">}</span></span></span></span> hypothesis).

›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹ The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹strong axiom of revealed preference›<span class="antiquote"><span class="antiquote">}</span></span></span></span> ala \citet{AygunSonmez:2012-WP2} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[\S6]{AygunSonmez:2012-WP2} adopt a different definition for a
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹strong axiom of revealed preference›<span class="antiquote"><span class="antiquote">}</span></span></span></span> and show that it holds for
all choice functions that satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "iia"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"consistency"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">nth_mod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">!%</span>"</span> 100<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main"><span class="free">!%</span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">!</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">mod</span> length <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mwc_sarp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mwc_sarp</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span>
    <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">Xs</span><span class="main">.</span> length <span class="bound">Xs</span> <span class="main">&gt;</span> <span class="main">1</span> <span class="main">∧</span> distinct <span class="main">(</span>map <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">Xs</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">Xs</span><span class="main">!%</span><span class="bound">i</span><span class="main">)</span> <span class="main">⊂</span> <span class="bound">Xs</span><span class="main">!%</span><span class="bound">i</span> <span class="main">∩</span> <span class="bound">Xs</span><span class="main">!%</span><span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">%</span>invisible mwc_sarpI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Xs</span><span class="main">.</span> <span class="main">⟦</span>length <span class="bound">Xs</span> <span class="main">&gt;</span> <span class="main">1</span><span class="main">;</span> distinct <span class="main">(</span>map <span class="free">f</span> <span class="bound">Xs</span><span class="main">)</span><span class="main">;</span> <span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">Xs</span><span class="main">!%</span><span class="bound">i</span><span class="main">)</span> <span class="main">⊂</span> <span class="bound">Xs</span><span class="main">!%</span><span class="bound">i</span> <span class="main">∩</span> <span class="bound">Xs</span><span class="main">!%</span><span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> False"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mwc_sarp <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mwc_sarp_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> iia_consistency_mwc_sarp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"iia <span class="free">f</span>"</span></span> <span class="comment1">― ‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> "substitutes"<span class="antiquote">}</span></span>›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"consistency <span class="free">f</span>"</span></span> <span class="comment1">― ‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> "irc"<span class="antiquote">}</span></span>›</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mwc_sarp <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> mwc_sarpI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Xs</span>
  <span class="keyword3"><span class="command">assume</span></span> LLL<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">Xs</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> EEE<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map <span class="free">f</span> <span class="skolem">Xs</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> AAA<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Xs</span><span class="main">!%</span><span class="bound">i</span><span class="main">)</span> <span class="main">⊂</span> <span class="skolem">Xs</span><span class="main">!%</span><span class="bound">i</span> <span class="main">∩</span> <span class="skolem">Xs</span><span class="main">!%</span><span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> 6<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="skolem">Xs</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">⋂</span><span class="bound">X</span><span class="main">∈</span>set <span class="skolem">Xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> 4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="skolem">Xs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">⋃</span><span class="main">(</span>set <span class="skolem">Xs</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">X</span><span class="main">∈</span>set <span class="skolem">Xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">X</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">using</span></span> that <span class="quoted"><span class="quoted">‹iia <span class="free">f</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> iia_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">have</span></span> 5<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="skolem">Xs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">X</span><span class="main">∈</span>set <span class="skolem">Xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">X</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">⋂</span><span class="bound">X</span><span class="main">∈</span>set <span class="skolem">Xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">X</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> that <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="skolem"><span class="skolem">k</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Xs</span> <span class="main">!</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Xs</span> <span class="main">!</span> <span class="skolem">k</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> length <span class="skolem">Xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> length <span class="skolem">Xs</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_nth<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> AAA LLL ex_least_nat_le<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> n<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">+</span> length <span class="skolem">Xs</span> <span class="main">-</span> <span class="skolem">j</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Xs</span> <span class="main">!%</span> <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">]</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Xs</span> <span class="main">!%</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">-</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Xs</span> <span class="main">!%</span> <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="operator">auto</span> <span class="main">(</span><span class="operator">metis</span> One_nat_def add_eq_if diff_diff_cancel diff_is_0_eq' lessI mod_less nat_le_linear zero_less_diff<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> AAA <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Rf <span class="free">f</span> <span class="main">(</span><span class="skolem">Xs</span><span class="main">!%</span><span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> LLL <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="skolem">Xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹iia <span class="free">f</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> iia_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">meson</span> Suc_lessD Sup_upper mod_less_divisor nth_mem<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">from</span></span> 4 5 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="skolem">Xs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="skolem">Xs</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">⋂</span><span class="bound">X</span><span class="main">∈</span>set <span class="skolem">Xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">X</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="main">(</span><span class="main">⋂</span><span class="bound">X</span><span class="main">∈</span>set <span class="skolem">Xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">X</span><span class="main">)</span> <span class="main">⊂</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Xs</span><span class="main">!%</span><span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹f_range <span class="free">f</span>›</span></span> LLL <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋂</span><span class="main">(</span><span class="free">f</span> <span class="main">`</span> set <span class="skolem">Xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">Xs</span> <span class="main">!</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> nth_mem f_range_onD <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹consistency <span class="free">f</span>›</span></span> LLL 6 <span class="keyword1"><span class="command">have</span></span> f4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="skolem">Xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Xs</span> <span class="main">!</span> <span class="main">1</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> consistencyD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range <span class="free">f</span>›</span></span> LLL 6 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">Xs</span> <span class="main">!</span> <span class="main">1</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">Xs</span> <span class="main">!</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> f_range_onD <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> INT_lower One_nat_def Suc_lessD subset_trans nth_mem top.extremum<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹consistency <span class="free">f</span>›</span></span> EEE LLL f4 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> One_nat_def Suc_lessD Sup_upper consistencyD length_map nth_eq_iff_index_eq nth_map nth_mem zero_neq_one<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Xs</span><span class="main">!%</span><span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="skolem">Xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> AAA <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Xs</span><span class="main">!%</span><span class="bound">i</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">Xs</span><span class="main">!%</span><span class="bound">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> LLL <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="skolem">Xs</span><span class="main">!%</span><span class="bound">i</span> <span class="main">⊆</span> <span class="main">⋃</span><span class="main">(</span>set <span class="skolem">Xs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> One_nat_def Suc_lessD Sup_upper mod_less_divisor nth_mem<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> 6 <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="main">(</span><span class="main">⋂</span><span class="bound">X</span><span class="main">∈</span>set <span class="skolem">Xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">X</span><span class="main">)</span> <span class="main">⊂</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Xs</span> <span class="main">!%</span> <span class="bound">i</span><span class="main">)</span>›</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Xs</span><span class="main">!%</span><span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="skolem">Xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> consistencyD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹consistency <span class="free">f</span>›</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">meson</span> dual_order.trans psubsetE<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Choice functions arising from linear orders \label{sec:cf-linear} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

An obvious way to construct a choice function is to derive one from a
linear order, i.e., a list of strict preferences. We allow such
rankings to omit some alternatives, which means the resulting function
is not decisive.

We work with a finite universe here.

›</span></span>

<span class="keyword1"><span class="command">locale</span></span> linear_cf <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>finite rel"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">linear_cf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> r_linear<span class="main">:</span> <span class="quoted"><span class="quoted">"Linear_order <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> linear_cf_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">linear_cf</span> <span class="free">X</span> <span class="main">≡</span> set_option <span class="main">(</span>MaxR.MaxR_opt <span class="free">r</span> <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> MaxR<span class="main">:</span> MaxR <span class="quoted"><span class="free">r</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">rule</span> r_linear<span class="main">)</span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemmas</span></span> maxR_code <span class="main">=</span> MaxR.maxR_def
<span class="keyword1"><span class="command">lemmas</span></span> MaxR_f_code <span class="main">=</span> MaxR.MaxR_f_def
<span class="keyword1"><span class="command">lemma</span></span> code<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">linear_cf</span> <span class="main">(</span>set <span class="free">X</span><span class="main">)</span> <span class="main">=</span> set_option <span class="main">(</span>fold MaxR.MaxR_f <span class="free">X</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> linear_cf_def <span class="keyword1"><span class="command">using</span></span> MaxR.MaxR_opt_code <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> simps <span class="main">[</span><span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">linear_cf</span> <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="free">linear_cf</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">∈</span> Field <span class="free">r</span> <span class="keyword1">then</span> <span class="keyword1">if</span> <span class="free">linear_cf</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{</span>MaxR.maxR <span class="free">x</span> <span class="bound">y</span> <span class="main">|</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">linear_cf</span> <span class="free">X</span><span class="main">}</span> <span class="keyword1">else</span> <span class="free">linear_cf</span> <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> linear_cf_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> MaxR.insert <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">linear_cf</span> <span class="free">X</span> <span class="main">⊆</span> <span class="free">X</span> <span class="main">∩</span> Field <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible linear_cf_def <span class="keyword1"><span class="command">using</span></span> MaxR.range<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">X</span></span><span class="main">]</span> finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">X</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemmas</span></span> range' <span class="main">=</span> rev_subsetD<span class="main">[</span><span class="operator">OF</span> _ range<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span>

<span class="keyword1"><span class="command">lemma</span></span> singleton<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">linear_cf</span> <span class="free">X</span> <span class="main">⟷</span> <span class="free">linear_cf</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible linear_cf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemma</span></span> subset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">linear_cf</span> <span class="free">Y</span> <span class="main">⊆</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">⊆</span> <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">linear_cf</span> <span class="free">Y</span> <span class="main">=</span> <span class="free">linear_cf</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms MaxR.subset <span class="keyword1"><span class="command">unfolding</span></span> linear_cf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> union<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">linear_cf</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">linear_cf</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> <span class="free">linear_cf</span> <span class="free">Y</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">linear_cf</span> <span class="free">Y</span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> <span class="free">linear_cf</span> <span class="free">X</span> <span class="keyword1">else</span> <span class="main">{</span>MaxR.maxR <span class="bound">x</span> <span class="bound">y</span> <span class="main">|</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">linear_cf</span> <span class="free">X</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">linear_cf</span> <span class="free">Y</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible linear_cf_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> MaxR.union<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">linear_cf</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">linear_cf</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">Y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible MaxR.mono assms <span class="keyword1"><span class="command">unfolding</span></span> linear_cf_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> elem_set<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> greatest <span class="main">=</span> MaxR.greatest<span class="main">[</span><span class="operator">folded</span> linear_cf_def<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> preferred<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">linear_cf</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms FieldI2 MaxR.MaxR_opt_is_greatest MaxR.maxR_absorb1 maxR_code <span class="keyword1"><span class="command">unfolding</span></span> linear_cf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemma</span></span> card_le<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">linear_cf</span> <span class="free">X</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible linear_cf_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"MaxR.MaxR_opt <span class="free">X</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> card<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">linear_cf</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">X</span> <span class="main">∩</span> Field <span class="free">r</span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible linear_cf_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"MaxR.MaxR_opt <span class="free">X</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> MaxR.range_None MaxR.range_Some<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> f_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">X</span> <span class="free">linear_cf</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible f_range_on_def <span class="keyword1"><span class="command">using</span></span> range <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> domain<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">linear_cf</span> <span class="main">(</span><span class="free">X</span> <span class="main">∩</span> Field <span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="free">linear_cf</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">metis</span> inf.cobounded1 range subset<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> decisive_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="main">(</span>Field <span class="free">r</span><span class="main">)</span> <span class="free">linear_cf</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible decisive_on_def linear_cf_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Int_absorb2 empty_subsetI MaxR.range_None MaxR.empty MaxR.subset<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> resolute_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"resolute_on <span class="main">(</span>Field <span class="free">r</span><span class="main">)</span> <span class="free">linear_cf</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible resolute_on_def linear_cf_def <span class="keyword1"><span class="command">using</span></span> mk_disjoint_insert <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> MaxR.insert<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Rf_mono_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono_on <span class="free">X</span> <span class="main">(</span>Rf <span class="free">linear_cf</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> mono_onI<span class="main">)</span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> contra_subsetD empty_subsetI insert_subset singleton subset<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> iia <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> Rf_mono_on_iia_on Rf_mono_on<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> Chernoff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Chernoff_on <span class="free">X</span> <span class="free">linear_cf</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Rf_mono_on range Rf_mono_on_iia_on<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">X</span></span> <span class="quoted"><span class="free">linear_cf</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span> Chernoff_on_iia_on <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> irc<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"irc_on <span class="free">X</span> <span class="free">linear_cf</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible irc_on_def linear_cf_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> MaxR.insert <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> MaxR.maxR_rangeD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> consistency<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"consistency_on <span class="free">X</span> <span class="free">linear_cf</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible irc <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> irc_on_consistency_on<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> lad<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lad_on <span class="free">X</span> <span class="free">linear_cf</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible lad_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∩</span> Field <span class="free">r</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> card<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Plott's <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹path independence›<span class="antiquote"><span class="antiquote">}</span></span></span></span> condition \label{sec:cf-path-independence}›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

As recognised by \citet[\S4]{Fleiner:2002} and
\citet{ChambersYenmez:2013} in the context of matching with contracts,
the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "irc"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> conditions together are
equivalent to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹path independence›<span class="antiquote"><span class="antiquote">}</span></span></span></span>, a condition introduced to the
social choice setting by
\citet{Plott:1973}. \citet[Lemma~6]{Moulin:1985} ascribes this
equivalence result to \citet{AizermanMalishevski:1981}.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">path_independent_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">path_independent_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">B</span> <span class="bound">C</span><span class="main">.</span> <span class="bound">B</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> <span class="bound">C</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="bound">C</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">C</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">path_independent</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">path_independent</span> <span class="main">≡</span> path_independent_on UNIV"</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemmas</span></span> path_independent_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> path_independent_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> path_independent_onD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> path_independent_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> path_independent_def <span class="main">=</span> path_independent_on_def<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted">UNIV</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Intuitively a choice function satisfying this condition ignores the
order in which choices are made in the following sense:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> path_independent_on_symmetric<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"path_independent_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">B</span> <span class="bound">C</span><span class="main">.</span> <span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">∧</span> <span class="bound">C</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">⟶</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="bound">C</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="bound">B</span> <span class="main">∪</span> <span class="free">f</span> <span class="bound">C</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> path_independent_on_def f_range_on_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> subset_trans Un_commute<span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> Un_subset_iff empty_subsetI sup.orderE Un_commute<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible path_independent_on_symmetricI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> path_independent_on_symmetric<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible path_independent_on_symmetricD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> path_independent_on_symmetric<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> path_independent_on_Chernoff_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"path_independent_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Chernoff_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> Chernoff_onI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> subsetI<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">C</span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">⊆</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">∩</span> <span class="skolem">C</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> XXX <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">C</span> <span class="main">⊆</span> <span class="skolem">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> subset_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> f_range_onD<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> XXX <span class="keyword1"><span class="command">have</span></span> YYY<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="skolem">C</span> <span class="main">∪</span> <span class="free">f</span> <span class="skolem">C</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">B</span> <span class="main">-</span> <span class="skolem">C</span> <span class="main">∪</span> <span class="free">f</span> <span class="skolem">C</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> f_range_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> XXX YYY path_independent_onD<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹path_independent_on <span class="free">A</span> <span class="free">f</span>›</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">-</span> <span class="skolem">C</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">C</span>"</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">C</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> f_range_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Un_absorb2<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> path_independent_on_consistency_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"path_independent_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"consistency_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> path_independent_on_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> consistency_onI<span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> Un_subset_iff le_iff_sup sup_commute<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Chernoff_on_consistency_on_path_independent_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Chernoff_on <span class="free">A</span> <span class="free">f</span> <span class="main">∧</span> consistency_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> path_independent_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> LHS<span class="main">:</span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> path_independent_on_symmetricI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">C</span> <span class="keyword3"><span class="command">assume</span></span> BC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> LHS assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">∪</span> <span class="skolem">C</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">B</span> <span class="main">∪</span> <span class="free">f</span> <span class="skolem">C</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> consistency_onD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">A</span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> _ _ _ Chernoff_on_union<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ assms<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span>
            <span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">with</span></span> assms path_independent_on_Chernoff_on path_independent_on_consistency_on
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> path_independent_onI2 <span class="main">=</span>
  iffD1<span class="main">[</span><span class="operator">OF</span> Chernoff_on_consistency_on_path_independent_on<span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> linear_cf<span class="main">)</span> path_independent<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"path_independent <span class="free">linear_cf</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible f_range Chernoff consistency <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> path_independent_onI2<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹ Path independence and decomposition into orderings \label{sec:cf-path-independence-orderings} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We now show that a choice function over a finite universe satisfying
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "path_independent"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is characterized by taking the maximum
elements of some finite set of orderings.

\citet[Definition~12]{Moulin:1985} says that a choice function is
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹pseudo-rationalized›<span class="antiquote"><span class="antiquote">}</span></span></span></span> by the orderings <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Rs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> chooses all of the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"greatest <span class="free"><span class="free">r</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> elements of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">B</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
for each <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">r</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">Rs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pseudo_rationalizable_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>finite set <span class="main">⇒</span> <span class="tfree">'a</span> rel set <span class="main">⇒</span> <span class="tfree">'a</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pseudo_rationalizable_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>
     <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">Rs</span></span></span><span class="main">.</span> Linear_order <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">B</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">r</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">Rs</span></span></span><span class="main">.</span> greatest <span class="bound">r</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∩</span> Field <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> pseudo_rationalizable_on_def2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"pseudo_rationalizable_on <span class="free">A</span> <span class="free">Rs</span> <span class="free">f</span>
     <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">∈</span><span class="free">Rs</span><span class="main">.</span> Linear_order <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free">A</span><span class="main">.</span> <span class="free">f</span> <span class="bound">B</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">r</span><span class="main">∈</span><span class="free">Rs</span><span class="main">.</span> set_option <span class="main">(</span>MaxR.MaxR_opt <span class="bound">r</span> <span class="bound">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible pseudo_rationalizable_on_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> MaxR.greatest MaxR.intro SUP_cong<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible pseudo_rationalizable_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> pseudo_rationalizable_on_def2<span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We deviate from \citeauthor{Moulin:1985} in using non-total linear
orders, where his are total, asymmetric, and transitive; in other
words, strict total linear orders. This allows us to treat
non-decisive choice functions, and we later show that the choice
function is decisive iff the orders are total.

\citet[Theorem~5]{Moulin:1985} assumes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Aizerman"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"Chernoff"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, which are equivalent to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "path_independent"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Aizerman_on_Chernoff_on_path_independent_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Aizerman_on <span class="free">A</span> <span class="free">f</span> <span class="main">∧</span> Chernoff_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> path_independent_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Chernoff_on_consistency_on_path_independent_on<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> consistency_on_Aizerman_on Aizerman_on_idem_on_consistency_on iia_f_idem<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> Chernoff_on_iia_on
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

It is straightforward to show that pseudo-rationalizable choice
functions satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "path_independent"<span class="antiquote"><span class="antiquote">}</span></span></span></span> using the properties of
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "MaxR.MaxR_opt"<span class="antiquote"><span class="antiquote">}</span></span></span></span>:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> pseudo_rationalizable_on_path_independent_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"pseudo_rationalizable_on <span class="free">A</span> <span class="free">Rs</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"path_independent_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> path_independent_onI2<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> f_range_on_def pseudo_rationalizable_on_def2
    <span class="keyword1"><span class="command">using</span></span> MaxR.range_Some<span class="main">[</span><span class="operator">unfolded</span> MaxR_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Chernoff_on <span class="free">A</span> <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pseudo_rationalizable_on_def2
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> Chernoff_onI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> MaxR.intro MaxR.subset empty_subsetI insert_subset option.simps<span class="main"><span class="main">(</span></span>15<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"consistency_on <span class="free">A</span> <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pseudo_rationalizable_on_def2
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> consistency_onI<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> MaxR.intro MaxR.subset SUP_cong SUP_le_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The converse requires that we construct a suitable set of orderings
that rationalize <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span> <span class="free"><span class="free">C</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for each <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">C</span></span> <span class="main"><span class="main">⊆</span></span> <span class="free"><span class="free">A</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. We
do this by finding a set <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">B</span></span> <span class="main"><span class="main">⊆</span></span> <span class="free"><span class="free">A</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span> <span class="free"><span class="free">B</span></span>
<span class="main"><span class="main">⊆</span></span> <span class="free"><span class="free">C</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> by successively removing elements in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span> <span class="free"><span class="free">A</span></span> <span class="main"><span class="main">-</span></span> <span class="free"><span class="free">f</span></span>
<span class="free"><span class="free">C</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. (As these elements are chosen by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> from supersets of
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">B</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, we rank these above all of those in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span> <span class="free"><span class="free">B</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.)  By
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "consistency"<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{sec:cf-irc}), <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span> <span class="free"><span class="free">C</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">f</span></span> <span class="free"><span class="free">B</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. We
generate one order for each element of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span> <span class="free"><span class="free">C</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. Some extra care
takes care of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "decisive"<span class="antiquote"><span class="antiquote">}</span></span></span></span> choice functions.

Termination is guaranteed by the finiteness of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and the
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "f_range_on"<span class="antiquote"><span class="antiquote">}</span></span></span></span> hypothesis.

›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>finite set"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cfun"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> conj_cong<span class="main">[</span><span class="operator">fundef_cong</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>domintros<span class="main">)</span> <span class="entity">mk_linear_orders</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> list set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mk_linear_orders</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free">f</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> <span class="main">{</span><span class="main">[]</span><span class="main">}</span>
    <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">f</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span>
         <span class="keyword1">then</span> <span class="main">{</span><span class="bound">b</span> <span class="main">#</span> <span class="bound">cs</span> <span class="main">|</span><span class="bound">b</span> <span class="bound">cs</span><span class="main">.</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free">f</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">∧</span> <span class="bound">cs</span> <span class="main">∈</span> <span class="free">mk_linear_orders</span> <span class="main">{}</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">-</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span><span class="main">)</span><span class="main">}</span>
         <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">b</span> <span class="main">=</span> <span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="keyword1">in</span> <span class="main">{</span><span class="bound">b</span> <span class="main">#</span> <span class="bound">cs</span> <span class="main">|</span><span class="bound">cs</span><span class="main">.</span> <span class="bound">cs</span> <span class="main">∈</span> <span class="free">mk_linear_orders</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">-</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="operator">pat_completeness</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> mk_linear_orders_termination<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mk_linear_orders_dom <span class="main">(</span><span class="free">C</span><span class="main">,</span> <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">t</span> <span class="main"><span class="main">≡</span></span> <span class="quoted"><span class="quoted">"card <span class="free">B</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">B</span></span> <span class="quoted"><span class="free">C</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>0 <span class="skolem">B</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> f_range_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> mk_linear_orders.domintros<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">i</span> <span class="skolem">B</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mk_linear_orders_dom <span class="main">(</span><span class="main">{}</span><span class="main">,</span> <span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">b</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">b</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> Suc.hyps<span class="main">(</span>2<span class="main">)</span> Suc.prems Suc.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">b</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">{}</span>"</span></span><span class="main">]</span> finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">B</span></span><span class="main">]</span> that
      <span class="keyword1"><span class="command">unfolding</span></span> f_range_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Diff_subset card_Diff_singleton contra_subsetD diff_Suc_1 subset_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mk_linear_orders_dom <span class="main">(</span><span class="skolem">C</span><span class="main">,</span> <span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">-</span> <span class="skolem">C</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="skolem">C</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">b</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> Suc.hyps<span class="main">(</span>2<span class="main">)</span> Suc.prems Suc.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">-</span> <span class="skolem">C</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">C</span>"</span></span><span class="main">]</span> that
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> card_Diff_singleton_if<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> contra_subsetD diff_Suc_1 f_range_onD someI subset_insertI2 subset_insert_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> mk_linear_orders.domintros<span class="main">)</span> <span class="comment1">(* the simplifier has made a mess of the rule *)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> mk_linear_orders_induct<span class="main">[</span><span class="operator">consumes</span> 2<span class="main">,</span> <span class="operator">case_names</span> base step1 step2<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> base<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">C</span> <span class="bound">B</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">;</span> <span class="free">f</span> <span class="bound">B</span> <span class="main">=</span> <span class="main">{}</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">C</span> <span class="bound">B</span> <span class="main">[]</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> step1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">C</span> <span class="bound">B</span> <span class="bound">b</span> <span class="bound">cs</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">;</span> <span class="bound">cs</span> <span class="main">∈</span> mk_linear_orders <span class="main">{}</span> <span class="main">(</span><span class="bound">B</span> <span class="main">-</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span><span class="main">)</span><span class="main">;</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free">f</span> <span class="bound">B</span><span class="main">;</span> <span class="free">f</span> <span class="bound">B</span> <span class="main">⊆</span> <span class="bound">C</span><span class="main">;</span> <span class="free">P</span> <span class="main">{}</span> <span class="main">(</span><span class="bound">B</span> <span class="main">-</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span><span class="main">)</span> <span class="bound">cs</span><span class="main">⟧</span>
                          <span class="main">⟹</span> <span class="free">P</span> <span class="bound">C</span> <span class="bound">B</span> <span class="main">(</span><span class="bound">b</span> <span class="main">#</span> <span class="bound">cs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> step2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">C</span> <span class="bound">B</span> <span class="bound">b</span> <span class="bound">cs</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">;</span> <span class="bound">cs</span> <span class="main">∈</span> mk_linear_orders <span class="bound">C</span> <span class="main">(</span><span class="bound">B</span> <span class="main">-</span> <span class="main">{</span><span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="bound">B</span> <span class="main">-</span> <span class="bound">C</span><span class="main">}</span><span class="main">)</span><span class="main">;</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free">f</span> <span class="bound">B</span><span class="main">;</span> <span class="bound">b</span> <span class="main">∉</span> <span class="bound">C</span><span class="main">;</span> <span class="free">P</span> <span class="bound">C</span> <span class="main">(</span><span class="bound">B</span> <span class="main">-</span> <span class="main">{</span><span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="bound">B</span> <span class="main">-</span> <span class="bound">C</span><span class="main">}</span><span class="main">)</span> <span class="bound">cs</span><span class="main">⟧</span>
                          <span class="main">⟹</span> <span class="free">P</span> <span class="bound">C</span> <span class="bound">B</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="bound">B</span> <span class="main">-</span> <span class="bound">C</span><span class="main">)</span> <span class="main">#</span> <span class="bound">cs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">C</span> <span class="free">B</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> mk_linear_orders_termination<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">C</span></span><span class="main">]</span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> mk_linear_orders.pinduct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">C</span> <span class="skolem">B</span> <span class="skolem">r</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mk_linear_orders.psimps Let_def base <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits
                <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> step1 step2<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span> 1<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> mk_linear_orders_non_empty<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">t</span> <span class="main"><span class="main">≡</span></span> <span class="quoted"><span class="quoted">"card <span class="free">B</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">B</span></span> <span class="quoted"><span class="free">C</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> nat_less_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">B</span> <span class="skolem">C</span><span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">B</span> <span class="main">⊆</span> <span class="skolem">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">B</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> 1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">b</span><span class="main">.</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">cs</span><span class="main">.</span> <span class="bound">cs</span> <span class="main">∈</span> local.mk_linear_orders <span class="main">{}</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">safe</span> <span class="main">(</span><span class="operator">metis</span> Diff_subset card_Diff1_less dual_order.trans finite f_range_onD'<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">⊆</span> <span class="skolem">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">B</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="quoted">"1.prems"</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">-</span> <span class="skolem">C</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">B</span> <span class="main">∧</span> <span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="keyword1">SOME</span> <span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">-</span> <span class="skolem">C</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> someI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">-</span> <span class="skolem">C</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD'<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted">"1.hyps"</span><span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">-</span> <span class="skolem">C</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> xa<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">C</span></span><span class="main">,</span> <span class="operator">OF</span> _ refl<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">cs</span><span class="main">.</span> <span class="bound">cs</span> <span class="main">∈</span> local.mk_linear_orders <span class="skolem">C</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">∉</span> <span class="skolem">C</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> card_gt_0_iff diff_Suc_less equals0D finite<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mk_linear_orders.psimps<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mk_linear_orders_termination<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span><span class="free">A</span>›</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span> Let_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mk_linear_orders_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="free">r</span> <span class="main">⊆</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> mk_linear_orders_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>base <span class="skolem">C</span> <span class="skolem">B</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f_range_on_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step1 <span class="skolem">C</span> <span class="skolem">B</span> <span class="skolem">b</span> <span class="skolem">cs</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step2 <span class="skolem">C</span> <span class="skolem">B</span> <span class="skolem">b</span> <span class="skolem">cs</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Diff_subset someI_ex subset_eq f_range_onD<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mk_linear_orders_nth<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">!</span> <span class="free">i</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="free">B</span> <span class="main">-</span> set <span class="main">(</span>take <span class="free">i</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> mk_linear_orders_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step1 <span class="skolem">C</span> <span class="skolem">B</span> <span class="skolem">b</span> <span class="skolem">cs</span> <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Diff_insert2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step2 <span class="skolem">C</span> <span class="skolem">B</span> <span class="skolem">b</span> <span class="skolem">cs</span> <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Diff_insert2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> someI2<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> mk_linear_orders_distinct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> mk_linear_orders_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step1 <span class="skolem">C</span> <span class="skolem">B</span> <span class="skolem">b</span> <span class="skolem">cs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> Diff_eq_empty_iff Diff_subset Diff_subset_conv le_iff_sup mk_linear_orders_range subset_Diff_insert<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step2 <span class="skolem">C</span> <span class="skolem">B</span> <span class="skolem">b</span> <span class="skolem">cs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">meson</span> Diff_subset order.trans mk_linear_orders_range subset_Diff_insert<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> mk_linear_orders_Linear_order<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="main">(</span>linord_of_list <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible mk_linear_orders_distinct<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> linord_of_list_Linear_order <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemma</span></span> mk_linear_orders_decisive_on_set_r<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="free">r</span> <span class="main">=</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> mk_linear_orders_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>base <span class="skolem">C</span> <span class="skolem">B</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹decisive_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> decisive_onD<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step1 <span class="skolem">C</span> <span class="skolem">B</span> <span class="skolem">b</span> <span class="skolem">cs</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step2 <span class="skolem">C</span> <span class="skolem">B</span> <span class="skolem">b</span> <span class="skolem">cs</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> f_range_on_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Un_iff insert_Diff insert_Diff_single someI subset_Un_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mk_linear_orders_decisive_on_refl_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="free">A</span> <span class="main">(</span>linord_of_list <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible linord_of_list_refl_on mk_linear_orders_decisive_on_set_r<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> mk_linear_orders_decisive_on_total_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"total_on <span class="free">A</span> <span class="main">(</span>linord_of_list <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible linord_of_list_total_on mk_linear_orders_decisive_on_set_r<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> mk_linear_orders_set_r_decisive_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> set <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"iia_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">B</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms<span class="main">(</span>1-3<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> mk_linear_orders_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>base <span class="skolem">C</span> <span class="skolem">B</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> decisive_on_empty<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step1 <span class="skolem">C</span> <span class="skolem">B</span> <span class="skolem">b</span> <span class="skolem">cs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> mk_linear_orders_range<span class="main">[</span><span class="operator">OF</span> step1.hyps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">cs</span> <span class="main">⊆</span> <span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">b</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">b</span><span class="main">}</span><span class="main">)</span> <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">with</span></span> step1 <span class="quoted"><span class="quoted">‹iia_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> decisive_onI<span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Diff_empty Diff_insert0 insert_Diff insert_not_empty subset_insert_iff decisive_onD iia_onD<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step2 <span class="skolem">C</span> <span class="skolem">B</span> <span class="skolem">b</span> <span class="skolem">cs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"decisive_on <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">-</span> <span class="skolem">C</span><span class="main">}</span><span class="main">)</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> decisive_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">D</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">D</span> <span class="main">⊆</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">D</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹iia_on <span class="free">A</span> <span class="free">f</span>›</span></span> step2 XXX <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">D</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">-</span> <span class="skolem">C</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">D</span>"</span></span><span class="main">)</span>
         <span class="main">(</span><span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> emptyE iia_onD someI_ex<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> decisive_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mk_linear_orders_total_on_decisive_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> set <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"iia_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible mk_linear_orders_set_r_decisive_on<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> _ _ assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> linord_of_list_Field<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">r</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">A</span> <span class="main">⊆</span> set <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> mk_linear_orders_MaxR_opt_f<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"MaxR.MaxR_opt <span class="main">(</span>linord_of_list <span class="free">r</span><span class="main">)</span> <span class="free">D</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"iia_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="free">D</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> linord_of_list_Linear_order<span class="main">[</span><span class="operator">OF</span> mk_linear_orders_distinct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> subset_refl<span class="main"><span class="main">]</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"MaxR <span class="main">(</span>linord_of_list <span class="free">r</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> MaxR.intro<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>2<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> greatest <span class="main">(</span>linord_of_list <span class="free">r</span><span class="main">)</span> <span class="main">(</span><span class="free">D</span> <span class="main">∩</span> Field <span class="main">(</span>linord_of_list <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> MaxR.greatest elem_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">r</span> <span class="main">!</span> <span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">r</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">j</span></span><span class="main">&lt;</span><span class="skolem">i</span><span class="main">.</span> <span class="free">r</span> <span class="main">!</span> <span class="bound">j</span> <span class="main">∉</span> <span class="free">D</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> greatest_def <span class="keyword1"><span class="command">using</span></span> mk_linear_orders_distinct<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> subset_refl<span class="main">]</span> linord_of_list_nth<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> xs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">r</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">atomize_elim</span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_conv_nth<span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> IntI less_trans not_le nth_mem set_conv_nth<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹iia_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">D</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> mk_linear_orders_nth<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> i<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">i</span></span><span class="main">]</span>
          iia_onD<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span> <span class="quoted"><span class="free">f</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">-</span> set <span class="main">(</span>take <span class="skolem">i</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">D</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> a<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">x</span></span><span class="main">]</span>
          MaxR.range_Some<span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span> <span class="operator">OF</span> <span class="quoted"><span class="quoted">‹MaxR <span class="main">(</span>linord_of_list <span class="free">r</span><span class="main">)</span>›</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_image<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mk_linear_orders_f_MaxR_opt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="free">C</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"consistency_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">⊆</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">r</span><span class="main">∈</span>mk_linear_orders <span class="free">C</span> <span class="free">B</span><span class="main">.</span> MaxR.MaxR_opt <span class="main">(</span>linord_of_list <span class="bound">r</span><span class="main">)</span> <span class="free">C</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible <span class="quoted"><span class="quoted">‹<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">C</span> <span class="main">⊆</span> <span class="free">B</span>›</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">t</span> <span class="main"><span class="main">≡</span></span> <span class="quoted"><span class="quoted">"card <span class="free">B</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">B</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> nat_less_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">B</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">B</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> consistency_onD<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">B</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">C</span></span><span class="main">]</span> <span class="quoted">"1.prems"</span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="free">C</span>›</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">B</span> <span class="main">⊆</span> <span class="free">C</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> mk_linear_orders <span class="main">{}</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> mk_linear_orders_non_empty <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Diff_subset_conv le_supI2<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> True consistency_onD<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">B</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">C</span></span><span class="main">]</span> <span class="quoted">"1.prems"</span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="free">C</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">f</span> <span class="skolem">B</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> True <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> r x <span class="keyword1"><span class="command">have</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">#</span> <span class="skolem">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="skolem">B</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> mk_linear_orders_termination<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">B</span></span> <span class="quoted"><span class="free">C</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mk_linear_orders.psimps card_eq_0_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> bexI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ XXX<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> True r x <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">C</span> <span class="main">⊆</span> <span class="skolem">B</span>›</span></span>  <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="free">C</span>›</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"MaxR.MaxR_opt <span class="main">(</span>linord_of_list <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="skolem">r</span><span class="main">)</span><span class="main">)</span> <span class="free">C</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> linord_of_list_Linear_order<span class="main">[</span><span class="operator">OF</span> mk_linear_orders_distinct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> XXX <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
          <span class="keyword1"><span class="command">unfolding</span></span> Option.elem_set<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> MaxR.greatest MaxR_def greatest_def linord_of_list_linord_of_listP <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?b</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">-</span> <span class="free">C</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?B'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="var">?b</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> False <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">-</span> <span class="free">C</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="var">?B'</span> <span class="main">&lt;</span> card <span class="skolem">B</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> f_range_on_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> card_Diff_singleton_if<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> One_nat_def card_Diff1_less card_Diff_singleton finite someI_ex subsetCE<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">C</span> <span class="main">⊆</span> <span class="skolem">B</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">-</span> <span class="free">C</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">⊆</span> <span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">-</span> <span class="free">C</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Diff_empty Diff_iff someI subset_Diff_insert<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> 1<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span> <span class="operator">OF</span> <span class="quoted"><span class="quoted">‹card <span class="var">?B'</span> <span class="main">&lt;</span> card <span class="skolem">B</span>›</span></span> refl<span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="var">?B'</span>"</span></span> <span class="quoted"><span class="quoted">"MaxR.MaxR_opt <span class="main">(</span>linord_of_list <span class="skolem">r</span><span class="main">)</span> <span class="free">C</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">f</span> <span class="skolem">B</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> False <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?b</span> <span class="main">#</span> <span class="skolem">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="skolem">B</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> mk_linear_orders_termination<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">B</span></span> <span class="quoted"><span class="free">C</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mk_linear_orders.psimps Let_def card_eq_0_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"MaxR.MaxR_opt <span class="main">(</span>linord_of_list <span class="main">(</span><span class="var">?b</span> <span class="main">#</span> <span class="skolem">r</span><span class="main">)</span><span class="main">)</span> <span class="free">C</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> MaxR.greatest_is_MaxR_opt<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> linord_of_list_Linear_order<span class="main">[</span><span class="operator">OF</span> mk_linear_orders_distinct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="var">?b</span> <span class="main">#</span> <span class="skolem">r</span> <span class="main">∈</span> mk_linear_orders <span class="free">C</span> <span class="skolem">B</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"MaxR <span class="main">(</span>linord_of_list <span class="main">(</span><span class="var">?b</span> <span class="main">#</span> <span class="skolem">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> MaxR.intro<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> r <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">∩</span> Field <span class="main">(</span>linord_of_list <span class="main">(</span><span class="var">?b</span> <span class="main">#</span> <span class="skolem">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Choice_Functions.mk_linear_orders_Linear_order Diff_subset IntD2 Int_iff MaxR.intro MaxR.range_Some f_range_on_antimono linord_of_list_Field<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> r <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">-</span> <span class="free">C</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="free">C</span> <span class="main">∩</span> Field <span class="main">(</span>linord_of_list <span class="main">(</span><span class="var">?b</span> <span class="main">#</span> <span class="skolem">r</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> linord_of_list <span class="main">(</span><span class="var">?b</span> <span class="main">#</span> <span class="skolem">r</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> someI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="skolem">B</span> <span class="main">-</span> <span class="free">C</span>"</span></span><span class="main">]</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> linord_of_list_linord_of_listP <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> MaxR.intro <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> f_range_on_antimono <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> MaxR.MaxR_opt_is_greatest<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span> Choice_Functions.mk_linear_orders_Linear_order<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> path_independent_on_pseudo_rationalizable_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>finite cfun"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"path_independent_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Rs_def<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Rs</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">C</span><span class="main">∈</span>Pow <span class="free">A</span><span class="main">.</span> linord_of_list <span class="main">`</span> mk_linear_orders <span class="free">f</span> <span class="bound">C</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pseudo_rationalizable_on <span class="free">A</span> <span class="free">Rs</span> <span class="free">f</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">∈</span><span class="free">Rs</span><span class="main">.</span> refl_on <span class="free">A</span> <span class="bound">r</span> <span class="main">∧</span> total_on <span class="free">A</span> <span class="bound">r</span> <span class="main">⟷</span> decisive_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pseudo_rationalizable_on <span class="free">A</span> <span class="free">Rs</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> pseudo_rationalizable_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> <span class="free">Rs</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="skolem">r</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> mk_linear_orders_Linear_order<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">B</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">r</span><span class="main">∈</span><span class="free">Rs</span><span class="main">.</span> set_option <span class="main">(</span>MaxR.MaxR_opt <span class="bound">r</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> set_elem_equalityI<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> path_independent_on_consistency_on<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
              mk_linear_orders_f_MaxR_opt<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> path_independent_on_Chernoff_on<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> Chernoff_on_iia_on
              mk_linear_orders_MaxR_opt_f<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">from</span></span> path_independent_on_Chernoff_on<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> Chernoff_on_iia_on
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"iia_on <span class="free">A</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">r</span><span class="main">∈</span><span class="free">Rs</span><span class="main">.</span> refl_on <span class="free">A</span> <span class="bound">r</span> <span class="main">∧</span> total_on <span class="free">A</span> <span class="bound">r</span> <span class="main">⟷</span> decisive_on <span class="free">A</span> <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> mk_linear_orders_total_on_decisive_on<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
          mk_linear_orders_decisive_on_refl_on<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
          mk_linear_orders_decisive_on_total_on<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">meson</span> linord_of_list_refl_on refl_onD refl_onD1 subsetI<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Our top-level theorem is essentially \citet[Theorem~5]{Moulin:1985}:

›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> pseudo_rationalizable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"path_independent_on <span class="free">A</span> <span class="free">f</span>
           <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">Rs</span><span class="main">.</span> pseudo_rationalizable_on <span class="free">A</span> <span class="bound">Rs</span> <span class="free">f</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">∈</span><span class="bound">Rs</span><span class="main">.</span> refl_on <span class="free">A</span> <span class="bound">r</span> <span class="main">∧</span> total_on <span class="free">A</span> <span class="bound">r</span> <span class="main">⟷</span> decisive_on <span class="free">A</span> <span class="free">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible pseudo_rationalizable_on_path_independent_on path_independent_on_pseudo_rationalizable_on<span class="main">[</span><span class="operator">OF</span> _ assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Contracts">
<div class="head">
<h1>Theory Contracts</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Contracts
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Choice_Functions.html">Choice_Functions</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Dual_Ordered_Lattice.html">HOL-Library.Dual_Ordered_Lattice</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Bourbaki_Witt_Fixpoint.html">HOL-Library.Bourbaki_Witt_Fixpoint</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/While_Combinator.html">HOL-Library.While_Combinator</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Product_Order.html">HOL-Library.Product_Order</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ \citet{HatfieldMilgrom:2005}: Matching with contracts \label{sec:contracts} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We take the original paper on matching with contracts by
\citet{HatfieldMilgrom:2005} as our roadmap, which follows a similar
path to \citet[\S2.5]{RothSotomayor:1990}. We defer further motivation
to these texts. Our first move is to capture the scenarios described
in their {\S}I(A) (p916) in a locale.

›</span></span>

<span class="keyword1"><span class="command">locale</span></span> Contracts <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Xd</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span><span class="main">::</span>finite <span class="main">⇒</span> <span class="tfree">'d</span><span class="main">::</span>finite"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Xh</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> <span class="main">⇒</span> <span class="tfree">'h</span><span class="main">::</span>finite"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Pd</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'x</span> rel"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Ch</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'h</span> <span class="main">⇒</span> <span class="tfree">'x</span> cfun"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Pd_linear<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d</span><span class="main">.</span> Linear_order <span class="main">(</span><span class="free">Pd</span> <span class="bound">d</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Pd_range<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d</span><span class="main">.</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="bound">d</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">d</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Ch_range<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> <span class="main">∀</span><span class="bound">X</span><span class="main">.</span> <span class="free">Ch</span> <span class="bound">h</span> <span class="bound">X</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span><span class="main">∈</span><span class="bound">X</span><span class="main">.</span> <span class="free">Xh</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">h</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Ch_singular<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> <span class="main">∀</span><span class="bound">X</span><span class="main">.</span> inj_on <span class="free">Xd</span> <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span> <span class="bound">X</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

The set of contracts is modelled by the type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, a free type
variable that will later be interpreted by some non-empty
set. Similarly <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'d</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'h</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> track the names of doctors
and hospitals respectively. All of these are finite by virtue of
belonging to the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>finite›</span></span></span></span> type class.

We fix four constants:
\begin{itemize}

\item <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Xd›</span></span></span></span> (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Xh›</span></span></span></span>) projects the name of the
  relevant doctor (hospital) from a contract;

\item <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Pd›</span></span></span></span> maps doctors to their linear preferences over
  some subset of contracts that name them (assumptions <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source]
  Pd_linear<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] Pd_range<span class="antiquote"><span class="antiquote">}</span></span></span></span>); and

\item <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Ch›</span></span></span></span> maps hospitals to their choice functions
  (\S\ref{sec:cf}), which are similarly constrained to contracts that
  name them (assumption <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] Ch_range<span class="antiquote"><span class="antiquote">}</span></span></span></span>). Moreover their
  choices must name each doctor at most once, i.e., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Xd›</span></span></span></span>
  must be injective on these (assumption <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source]
  "Ch_singular"<span class="antiquote"><span class="antiquote">}</span></span></span></span>).

\end{itemize}

The reader familiar with the literature will note that we do not have
a null contract (also said to represent the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹outside option›<span class="antiquote"><span class="antiquote">}</span></span></span></span> of
unemployment), and instead use partiality of the doctors'
preferences. This provides two benefits: firstly, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Xh›</span></span></span></span> is
a total function here, and secondly we achieve some economy of
description when instantiating this locale as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Pd›</span></span></span></span> only
has to rank the relevant contracts.

We note in passing that neither the doctors' nor hospitals' choice
functions are required to be decisive, unlike the standard literature
on choice functions (\S\ref{sec:cf}).

In addition to the above, the following constitute the definitions
that must be trusted for the results we prove to be meaningful.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Cd</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'x</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Cd</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">≡</span> set_option <span class="main">∘</span> MaxR.MaxR_opt <span class="main">(</span><span class="free">Pd</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">CD_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">CD_on</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">d</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">.</span> Cd <span class="bound">d</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">CD</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">CD</span> <span class="main">≡</span> CD_on UNIV"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">CH</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">CH</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">h</span><span class="main">.</span> <span class="free">Ch</span> <span class="bound">h</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Cd"<span class="antiquote"><span class="antiquote">}</span></span></span></span> constructs a choice function from the
doctor's linear preferences (see \S\ref{sec:cf-linear}). Both <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"CD"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "CH"<span class="antiquote"><span class="antiquote">}</span></span></span></span> simply aggregate opinions in the obvious
way. The functions <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "CD_on"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is parameterized with a set of
doctors to support the proofs of \S\ref{sec:contracts-vacancy-chain}.

We also define <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>RD›</span></span></span></span> (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Rh›</span></span></span></span>,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>RH›</span></span></span></span>) to be the subsets of a given set of contracts that
are rejected by the doctors (hospitals). (The abbreviation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"Rf"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is defined in \S\ref{sec:cf-rf}.)

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">RD_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">RD_on</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">≡</span> Rf <span class="main">(</span>CD_on <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">RD</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">RD</span> <span class="main">≡</span> RD_on UNIV"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">Rh</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'h</span> <span class="main">⇒</span> <span class="tfree">'x</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Rh</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">≡</span> Rf <span class="main">(</span><span class="free">Ch</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">RH</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">RH</span> <span class="main">≡</span> Rf CH"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

A <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹mechanism›<span class="antiquote"><span class="antiquote">}</span></span></span></span> maps doctor and hospital preferences into a match
(here a set of contracts).

›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="main">(</span><span class="tfree">'d</span><span class="main">,</span> <span class="tfree">'h</span><span class="main">,</span> <span class="tfree">'x</span><span class="main">)</span> mechanism <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'x</span> rel<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'h</span> <span class="main">⇒</span> <span class="tfree">'x</span> cfun<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="comment1">(* Pd *)</span>

<span class="keyword1"><span class="command">lemmas</span></span> Pd_linear' <span class="main">=</span> Pd_linear<span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> Pd_range' <span class="main">=</span> subsetD<span class="main">[</span><span class="operator">OF</span> Pd_range<span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">d</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="free">d</span>

<span class="keyword1"><span class="command">lemma</span></span> Pd_refl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms Pd_linear' <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> subset_refl underS_incl_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Pd_Xd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span> <span class="main">=</span> <span class="free">d</span> <span class="main">∧</span> <span class="free">Xd</span> <span class="free">y</span> <span class="main">=</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms Pd_range contra_subsetD <span class="keyword1"><span class="command">unfolding</span></span> Field_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Above_Pd_Xd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Above <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span> <span class="main">=</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Above_Field Pd_range'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> AboveS_Pd_Xd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> AboveS <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span> <span class="main">=</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> AboveS_Field Pd_range'<span class="main">)</span>

<span class="comment1">(* Cd *)</span>

<span class="keyword1"><span class="command">interpretation</span></span> Cd<span class="main">:</span> linear_cf <span class="quoted"><span class="quoted">"<span class="free">Pd</span> <span class="free">d</span>"</span></span> <span class="quoted"><span class="quoted">"Cd <span class="free">d</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">d</span>
<span class="keyword1"><span class="command">using</span></span> Cd_def Pd_linear <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemmas</span></span> Cd_domain <span class="main">=</span> Cd.domain
<span class="keyword1"><span class="command">lemmas</span></span> Cd_f_range <span class="main">=</span> Cd.f_range
<span class="keyword1"><span class="command">lemmas</span></span> Cd_range <span class="main">=</span> Cd.range
<span class="keyword1"><span class="command">lemmas</span></span> Cd_range' <span class="main">=</span> Cd.range'
<span class="keyword1"><span class="command">lemmas</span></span> Rf_Cd_mono <span class="main">=</span> Cd.Rf_mono_on<span class="main">[</span><span class="operator">of</span> <span class="quoted">UNIV</span><span class="main">,</span> <span class="operator">unfolded</span> mono_on_mono<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> Cd_Chernoff <span class="main">=</span> Cd.Chernoff
<span class="keyword1"><span class="command">lemmas</span></span> Cd_path_independent <span class="main">=</span> Cd.path_independent
<span class="keyword1"><span class="command">lemmas</span></span> Cd_iia <span class="main">=</span> Cd.iia
<span class="keyword1"><span class="command">lemmas</span></span> Cd_irc <span class="main">=</span> Cd.irc
<span class="keyword1"><span class="command">lemmas</span></span> Cd_lad <span class="main">=</span> Cd.lad
<span class="keyword1"><span class="command">lemmas</span></span> Cd_mono <span class="main">=</span> Cd.mono
<span class="keyword1"><span class="command">lemmas</span></span> Cd_greatest <span class="main">=</span> Cd.greatest
<span class="keyword1"><span class="command">lemmas</span></span> Cd_preferred <span class="main">=</span> Cd.preferred
<span class="keyword1"><span class="command">lemmas</span></span> Cd_singleton <span class="main">=</span> Cd.singleton
<span class="keyword1"><span class="command">lemmas</span></span> Cd_union <span class="main">=</span> Cd.union
<span class="keyword1"><span class="command">lemmas</span></span> Cd_idem <span class="main">=</span> iia_f_idem<span class="main">[</span><span class="operator">OF</span> Cd.f_range<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted">UNIV</span> <span class="quoted"><span class="free">d</span></span><span class="main"><span class="main">,</span></span> <span class="operator">folded</span> Cd_def<span class="main"><span class="main">]</span></span> Cd_iia<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted">UNIV</span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">d</span>

<span class="keyword1"><span class="command">lemma</span></span> Cd_Xd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Cd <span class="free">d</span> <span class="free">X</span> <span class="main">⟹</span> <span class="free">Xd</span> <span class="free">x</span> <span class="main">=</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Pd_range Cd_range <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemma</span></span> Cd_inj_on_Xd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="free">Xd</span> <span class="main">(</span>Cd <span class="free">d</span> <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> inj_onI<span class="main">)</span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Cd_Xd Cd_singleton<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Cd_range_disjoint<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">≠</span> <span class="free">d'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Cd <span class="free">d</span> <span class="free">A</span> <span class="main">∩</span> Cd <span class="free">d'</span> <span class="free">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms Cd_range Pd_range <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Cd_single<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="free">Xd</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Cd <span class="free">d</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms Pd_linear <span class="keyword1"><span class="command">unfolding</span></span> Cd_greatest greatest_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> Pd_Xd inj_on_eq_iff subset_refl underS_incl_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Cd_Above<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Cd <span class="free">d</span> <span class="free">X</span> <span class="main">=</span> Above <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="main">(</span><span class="free">X</span> <span class="main">∩</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Cd_greatest greatest_Above Above_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(* Code generator setup. Repeats a lot of stuff. *)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">maxR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'x</span> <span class="main">⇒</span> <span class="tfree">'x</span> <span class="main">⇒</span> <span class="tfree">'x</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">maxR</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">MaxR_f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'x</span> <span class="main">⇒</span> <span class="tfree">'x</span> option <span class="main">⇒</span> <span class="tfree">'x</span> option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">MaxR_f</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">acc</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="keyword1">case</span> <span class="bound">acc</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="bound">x</span> <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> maxR <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="keyword1">else</span> <span class="bound">acc</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> MaxR_maxR<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"MaxR.maxR <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span> maxR <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff maxR_def Cd.maxR_code<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> MaxR_MaxR_f<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"MaxR.MaxR_f <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span> MaxR_f <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff Cd.MaxR_f_code MaxR_f_def MaxR_maxR <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> Cd_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> Cd.code<span class="main">[</span><span class="operator">unfolded</span> MaxR_MaxR_f<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> Cd_simps<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Cd <span class="free">d</span> <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
        <span class="quoted"><span class="quoted">"Cd <span class="free">d</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">if</span> Cd <span class="free">d</span> <span class="free">A</span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{</span>maxR <span class="free">d</span> <span class="free">x</span> <span class="bound">y</span> <span class="main">|</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> Cd <span class="free">d</span> <span class="free">A</span><span class="main">}</span> <span class="keyword1">else</span> Cd <span class="free">d</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Cd.simps MaxR_maxR <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="comment1">(* CD *)</span>

<span class="keyword1"><span class="command">lemma</span></span> CD_on_def2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CD_on <span class="free">ds</span> <span class="free">A</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">d</span><span class="main">∈</span><span class="free">ds</span><span class="main">.</span> Cd <span class="bound">d</span> <span class="main">(</span><span class="free">A</span> <span class="main">∩</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Cd_domain <span class="keyword1"><span class="command">unfolding</span></span> CD_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> CD_on_Xd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms Cd_Xd <span class="keyword1"><span class="command">unfolding</span></span> CD_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> mem_CD_on_Cd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="free">X</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span> <span class="main">∈</span> Cd <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span> <span class="free">X</span> <span class="main">∧</span> <span class="free">Xd</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> CD_on_def <span class="keyword1"><span class="command">using</span></span> Cd_range Cd_Xd <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> CD_on_domain<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CD_on <span class="free">ds</span> <span class="free">A</span> <span class="main">∩</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span> Cd <span class="free">d</span> <span class="main">(</span><span class="free">A</span> <span class="main">∩</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> CD_on_def2 <span class="keyword1"><span class="command">using</span></span> assms Cd_range <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Pd_range'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> CD_on_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CD_on <span class="free">ds</span> <span class="free">A</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">∩</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">d</span><span class="main">∈</span><span class="free">ds</span><span class="main">.</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Cd_range <span class="keyword1"><span class="command">unfolding</span></span> CD_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemmas</span></span> CD_on_range' <span class="main">=</span> subsetD<span class="main">[</span><span class="operator">OF</span> CD_on_range<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> CD_on_f_range_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="main">(</span>CD_on <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> f_range_onI<span class="main">)</span> <span class="main">(</span><span class="operator">meson</span> CD_on_range Int_subset_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> RD_on_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span>RD_on <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> CD_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> monoI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> monoD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Rf_Cd_mono<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> CD_on_Chernoff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Chernoff <span class="main">(</span>CD_on <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> mono_on_mono RD_on_mono<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span> Rf_mono_on_iia_on<span class="main">[</span><span class="operator">of</span> <span class="quoted">UNIV</span><span class="main">]</span> Chernoff_on_iia_on <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> CD_on_irc<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"irc <span class="main">(</span>CD_on <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ircI<span class="main">)</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> CD_on_def ircD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Cd_irc<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> Cd_simps <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> SUP_cong<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> CD_on_consistency <span class="main">=</span> irc_on_consistency_on<span class="main">[</span><span class="operator">OF</span> CD_on_irc<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> CD_on_path_independent<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"path_independent <span class="main">(</span><span class="main">λ</span><span class="bound">X</span><span class="main">.</span> CD_on <span class="free">ds</span> <span class="bound">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> CD_on_f_range_on CD_on_Chernoff CD_on_consistency <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> path_independent_onI2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> CD_on_simps<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CD_on <span class="free">ds</span> <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> CD_on_range <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemmas</span></span> CD_on_iia <span class="main">=</span> RD_on_mono<span class="main">[</span><span class="operator">unfolded</span> Rf_mono_iia<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> CD_on_idem <span class="main">=</span> iia_f_idem<span class="main">[</span><span class="operator">OF</span> CD_on_f_range_on CD_on_iia<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> CD_on_inj_on_Xd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="free">Xd</span> <span class="main">(</span>CD_on <span class="free">ds</span> <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> CD_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> inj_onI<span class="main">)</span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Cd_Xd Cd_singleton<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> CD_on_card<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>CD_on <span class="free">ds</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">d</span><span class="main">∈</span><span class="free">ds</span><span class="main">.</span> card <span class="main">(</span>Cd <span class="bound">d</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> CD_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_UN_disjoint Cd_range_disjoint<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> CD_on_closed<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="free">Xd</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">d</span><span class="main">∈</span><span class="free">ds</span><span class="main">.</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CD_on <span class="free">ds</span> <span class="free">X</span> <span class="main">=</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms Cd_domain Cd_single<span class="main">[</span><span class="operator">OF</span> _ assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> CD_on_def2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Cd_range'<span class="main">)</span>

<span class="comment1">(* Ch *)</span>

<span class="keyword1"><span class="command">lemmas</span></span> Ch_singular' <span class="main">=</span> Ch_singular<span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> Ch_range' <span class="main">=</span> subsetD<span class="main">[</span><span class="operator">OF</span> Ch_range<span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">h</span></span> <span class="quoted"><span class="free">X</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="free">h</span> <span class="free">X</span>

<span class="keyword1"><span class="command">lemma</span></span> Ch_simps<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="free">h</span> <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Ch_range <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Ch_range_disjoint<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">≠</span> <span class="free">h'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="free">h</span> <span class="free">A</span> <span class="main">∩</span> <span class="free">Ch</span> <span class="free">h'</span> <span class="free">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms Ch_range <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Ch_f_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"f_range <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Ch_range <span class="keyword1"><span class="command">unfolding</span></span> f_range_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(* CH *)</span>

<span class="keyword1"><span class="command">lemma</span></span> CH_card<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>CH <span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">h</span><span class="main">∈</span>UNIV<span class="main">.</span> card <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> CH_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_UN_disjoint Ch_range_disjoint<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> CH_simps<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CH <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> CH_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Ch_simps<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> CH_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CH <span class="free">A</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> CH_def <span class="keyword1"><span class="command">using</span></span> Ch_range <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemmas</span></span> CH_range' <span class="main">=</span> subsetD<span class="main">[</span><span class="operator">OF</span> CH_range<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> CH_f_range_on <span class="main">=</span> f_range_onI<span class="main">[</span><span class="operator">OF</span> CH_range<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> mem_CH_Ch<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CH <span class="free">X</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="free">x</span><span class="main">)</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> CH_def <span class="keyword1"><span class="command">using</span></span> Ch_range <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> mem_Ch_CH<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CH <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> CH_def <span class="keyword1"><span class="command">using</span></span> assms Ch_range <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

An <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹allocation›<span class="antiquote"><span class="antiquote">}</span></span></span></span> is a set of contracts where each names a distinct
doctor. (Hospitals can contract multiple doctors.)

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">allocation</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">allocation</span> <span class="main">≡</span> inj_on <span class="free">Xd</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We often wish to extract a doctor's or a hospital's contract from an
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "allocation"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">dX</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">⇒</span> <span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'x</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">dX</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hX</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">⇒</span> <span class="tfree">'h</span> <span class="main">⇒</span> <span class="tfree">'x</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hX</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="free">Xh</span> <span class="bound">x</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">}</span>"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> dX_union<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dX <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">Y</span><span class="main">)</span> <span class="free">d</span> <span class="main">=</span> dX <span class="free">X</span> <span class="free">d</span> <span class="main">∪</span> dX <span class="free">Y</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> dX_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> dX_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d</span><span class="main">.</span> dX <span class="free">X</span> <span class="bound">d</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">d</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> dX_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>

<span class="keyword1"><span class="command">lemma</span></span> dX_range'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> dX <span class="free">X</span> <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">∧</span> <span class="free">Xd</span> <span class="free">x</span> <span class="main">=</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> dX_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> dX_empty_or_singleton<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"allocation <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d</span><span class="main">.</span> dX <span class="free">X</span> <span class="bound">d</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> dX <span class="free">X</span> <span class="bound">d</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> dX_def <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="free">X</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_onD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> dX_linear<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"allocation <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="main">(</span>dX <span class="free">X</span> <span class="free">d</span> <span class="main">×</span> dX <span class="free">X</span> <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> spec<span class="main">[</span><span class="operator">OF</span> dX_empty_or_singleton<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹allocation <span class="free">X</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">d</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemma</span></span> dX_singular<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"allocation <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">=</span> <span class="free">Xd</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dX <span class="free">X</span> <span class="free">d</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> dX_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_onD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> dX_Int_Field_Pd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"dX <span class="free">X</span> <span class="free">d</span> <span class="main">⊆</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∩</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span> dX <span class="free">X</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> dX_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Pd_range'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Cd_Above_dX<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"dX <span class="free">X</span> <span class="free">d</span> <span class="main">⊆</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Cd <span class="free">d</span> <span class="free">X</span> <span class="main">=</span> Above <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="main">(</span>dX <span class="free">X</span> <span class="free">d</span><span class="main">)</span> <span class="main">∩</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> Cd_greatest greatest_Above Above_def dX_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Pd_range'<span class="main">)</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹Stability›<span class="antiquote"><span class="antiquote">}</span></span></span></span> is the key property we look for in a match (here a
set of contracts), and consists of two parts.

Firstly, we ask that it be <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹individually rational›<span class="antiquote"><span class="antiquote">}</span></span></span></span>, i.e., the
contracts in the match are actually acceptable to all
participants. Note that this implies the match is an <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"allocation"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">individually_rational_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">individually_rational_on</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">⟷</span> CD_on <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∧</span> CH <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">individually_rational</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">individually_rational</span> <span class="main">≡</span> individually_rational_on UNIV"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The second condition requires that there be no coalition of a hospital
and one or more doctors who prefer another set of contracts involving
them; the hospital strictly, the doctors weakly. Contrast this
definition with the classical one for stable marriages given in
\S\ref{sec:sotomayor}.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">blocking_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">⇒</span> <span class="tfree">'h</span> <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">blocking_on</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">X'</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">X'</span></span></span> <span class="main">≠</span> <span class="free">Ch</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">X'</span></span></span> <span class="main">=</span> <span class="free">Ch</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∪</span> <span class="free"><span class="bound"><span class="entity">X'</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">X'</span></span></span> <span class="main">⊆</span> CD_on <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∪</span> <span class="free"><span class="bound"><span class="entity">X'</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stable_no_blocking_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">stable_no_blocking_on</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">h</span> <span class="bound">X'</span><span class="main">.</span> <span class="main">¬</span>blocking_on <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="bound">h</span> <span class="bound">X'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">stable_no_blocking</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">stable_no_blocking</span> <span class="main">≡</span> stable_no_blocking_on UNIV"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stable_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">stable_on</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">⟷</span> individually_rational_on <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∧</span> stable_no_blocking_on <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">stable</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">stable</span> <span class="main">≡</span> stable_on UNIV"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_onI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"individually_rational_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_no_blocking_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> stable_on_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> individually_rational_onI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"CD_on <span class="free">ds</span> <span class="free">X</span> <span class="main">=</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"CH <span class="free">X</span> <span class="main">=</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"individually_rational_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> individually_rational_on_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> individually_rational_on_CD_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"individually_rational_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CD_on <span class="free">ds</span> <span class="free">X</span> <span class="main">=</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> individually_rational_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> individually_rational_on_Cd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"individually_rational_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Cd <span class="free">d</span> <span class="free">X</span> <span class="main">=</span> dX <span class="free">X</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> individually_rational_on_CD_on<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dX_def mem_CD_on_Cd <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Cd_range' Cd_Xd<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> individually_rational_on_empty<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"individually_rational_on <span class="free">ds</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> CD_on_simps CH_simps individually_rational_onI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> blocking_onI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">X''</span> <span class="main">≠</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">X''</span> <span class="main">=</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">X''</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">X''</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">X''</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="free">h</span> <span class="free">X''</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> blocking_on_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> blocking_on_imp_not_stable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="free">h</span> <span class="free">X''</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> stable_on_def stable_no_blocking_on_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> blocking_on_allocation<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="free">h</span> <span class="free">X''</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"allocation <span class="free">X''</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> blocking_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Ch_singular'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> blocking_on_Field<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="free">h</span> <span class="free">X''</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dX <span class="free">X''</span> <span class="free">d</span> <span class="main">⊆</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms blocking_on_allocation<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> blocking_on_def dX_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd_range' <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> CD_on_range'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> blocking_on_CD_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="free">h</span> <span class="free">X''</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">X''</span> <span class="main">⊆</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">X''</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> blocking_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> blocking_on_CD_on'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="free">h</span> <span class="free">X''</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">X''</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">X''</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> blocking_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> blocking_on_Cd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="free">h</span> <span class="free">X''</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dX <span class="free">X''</span> <span class="free">d</span> <span class="main">⊆</span> Cd <span class="free">d</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">X''</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> blocking_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> dX_range' <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CD_on_Cd<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_no_blocking_onI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">h</span> <span class="bound">X''</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">X''</span> <span class="main">=</span> <span class="free">Ch</span> <span class="bound">h</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="bound">X''</span><span class="main">)</span><span class="main">;</span> <span class="bound">X''</span> <span class="main">≠</span> <span class="free">Ch</span> <span class="bound">h</span> <span class="free">X</span><span class="main">;</span> <span class="bound">X''</span> <span class="main">⊆</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="bound">X''</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> False"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable_no_blocking_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> stable_no_blocking_on_def blocking_on_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_no_blocking_onI2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">h</span> <span class="bound">X''</span><span class="main">.</span> blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="bound">h</span> <span class="bound">X''</span> <span class="main">⟹</span> False"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable_no_blocking_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> stable_no_blocking_on_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"stable_no_blocking_on <span class="free">ds</span> UNIV"</span></span>
<span class="keyword1"><span class="command">using</span></span> stable_no_blocking_onI <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> stable_on_CD_on<span class="main">:</span> <span class="quoted"><span class="quoted">"CD_on <span class="free">ds</span> <span class="free">X</span> <span class="main">=</span> <span class="free">X</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> stable_on_Xd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">⟹</span> <span class="free">Xd</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> stable_on_range'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> stable_on_CH<span class="main">:</span> <span class="quoted"><span class="quoted">"CH <span class="free">X</span> <span class="main">=</span> <span class="free">X</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> stable_on_no_blocking_on<span class="main">:</span> <span class="quoted"><span class="quoted">"stable_no_blocking_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms mem_CD_on_Cd Cd_range' Pd_range'
<span class="keyword1"><span class="command">unfolding</span></span> stable_on_def individually_rational_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stable_on_allocation<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"allocation <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> stable_on_def individually_rational_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> CD_on_inj_on_Xd<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_on_blocking_onD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">X''</span> <span class="main">=</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">X''</span><span class="main">)</span><span class="main">;</span> <span class="free">X''</span> <span class="main">⊆</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">X''</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">X''</span> <span class="main">=</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> stable_on_def individually_rational_on_def stable_no_blocking_on_def blocking_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> not_stable_on_cases<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> not_individually_rational not_no_blocking<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> individually_rational_on <span class="free">ds</span> <span class="free">X</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> stable_no_blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> stable_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Theorem~1: Existence of stable pairs ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We proceed to define a function whose fixed points capture all stable
matches. \citet[I(B), p917]{HatfieldMilgrom:2005} provide the
following intuition:
\begin{quote}

The first theorem states that a set of contracts is stable if any
alternative contract would be rejected by some doctor or some hospital
from its suitably defined opportunity set. In the formulas below,
think of the doctors' opportunity set as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">XD</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and the
hospitals' opportunity set as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">XH</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">X'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the
corresponding stable set, then <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">XD</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must include, in addition
to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">X'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, all contracts that would not be rejected by the
hospitals, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">XH</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must similarly include <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">X'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and
all contracts that would not be rejected by the doctors. If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"<span class="free"><span class="free">X'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is stable, then every alternative contract is rejected by
somebody, so <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">X</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">XH</span></span> <span class="main"><span class="main">∪</span></span> <span class="free"><span class="free">XD</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> [where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">X</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the
set of all contracts]. This logic is summarized in the first theorem.

\end{quote}
See also \citet[p6,\S4]{Fleiner:2003} and \citet[\S2]{Fleiner:2002},
from whom we adopt the term <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹stable pair›<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stable_pair_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">×</span> <span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">stable_pair_on</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">XD</span><span class="main">,</span> <span class="bound">XH</span><span class="main">)</span><span class="main">.</span> <span class="bound">XD</span> <span class="main">=</span> <span class="main">-</span> RH <span class="bound">XH</span> <span class="main">∧</span> <span class="bound">XH</span> <span class="main">=</span> <span class="main">-</span> RD_on <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="bound">XD</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">stable_pair</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">×</span> <span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">stable_pair</span> <span class="main">≡</span> stable_pair_on UNIV"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">match</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">×</span> <span class="tfree">'x</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">match</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> fst <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∩</span> snd <span class="free"><span class="bound"><span class="entity">X</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

\citet[Theorem~1]{HatfieldMilgrom:2005} state that every solution
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="free"><span class="free">XD</span></span><span class="main"><span class="main">,</span></span> <span class="free"><span class="free">XH</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "stable_pair"<span class="antiquote"><span class="antiquote">}</span></span></span></span> yields a stable match
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">XD</span></span> <span class="main"><span class="main">∩</span></span> <span class="free"><span class="free">XH</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and conversely, i.e., every stable match is
the intersection of some stable pair. \citet{AygunSonmez:2012-WP2}
show that neither is the case without further restrictions on the
hospitals' choice functions <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Ch</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>; we exhibit their
counterexample below.

Even so we can establish some properties in the present setting:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stable_pair_on_CD_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"match <span class="free">XD_XH</span> <span class="main">=</span> CD_on <span class="free">ds</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms CD_on_range <span class="keyword1"><span class="command">unfolding</span></span> stable_pair_on_def split_def fst_conv snd_conv
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_pair_on_CH<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"match <span class="free">XD_XH</span> <span class="main">=</span> CH <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms CH_range <span class="keyword1"><span class="command">unfolding</span></span> stable_pair_on_def split_def fst_conv snd_conv
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_pair_on_CD_on_CH<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CD_on <span class="free">ds</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">)</span> <span class="main">=</span> CH <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms stable_pair_on_CD_on stable_pair_on_CH <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_pair_on_allocation<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"allocation <span class="main">(</span>match <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible stable_pair_on_CD_on<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> CD_on_inj_on_Xd<span class="main">)</span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_pair_onI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"fst <span class="free">XD_XH</span> <span class="main">=</span> <span class="main">-</span> RH <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"snd <span class="free">XD_XH</span> <span class="main">=</span> <span class="main">-</span> RD_on <span class="free">ds</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> stable_pair_on_def split_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_pair_onE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span><span class="main">;</span> <span class="main">⟦</span><span class="main">-</span> RH <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span> <span class="main">=</span> fst <span class="free">XD_XH</span><span class="main">;</span> <span class="main">-</span> RD_on <span class="free">ds</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">)</span> <span class="main">=</span> snd <span class="free">XD_XH</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> stable_pair_on_def split_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_pair_on_Cd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Cd <span class="free">d</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">)</span> <span class="main">=</span> match <span class="free">XD_XH</span> <span class="main">∩</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> stable_pair_on_CD_on<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>›</span></span><span class="main">]</span> CD_on_domain Cd_domain <span class="quoted"><span class="quoted">‹<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_pair_on_Cd_match<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Cd <span class="free">d</span> <span class="main">(</span>match <span class="free">XD_XH</span><span class="main">)</span> <span class="main">=</span> Cd <span class="free">d</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Cd_domain Cd_idem stable_pair_on_Cd<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_pair_on_Xd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> match <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms CD_on_Xd <span class="keyword1"><span class="command">unfolding</span></span> stable_pair_on_def split_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_pair_on_match_Cd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> match <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Cd <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>match <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> CD_on_def Cd_Xd UN_iff stable_pair_on_CD_on stable_pair_on_Cd_match<span class="main">)</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We run out of steam on the following two lemmas, which are the
remaining requirements for stability.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"individually_rational_on <span class="free">ds</span> <span class="main">(</span>match <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable_no_blocking <span class="main">(</span>match <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet{HatfieldMilgrom:2005} also claim that the converse holds:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">XD_XH</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">=</span> match <span class="free">XD_XH</span>"</span></span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Again, the following counterexample shows that the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
substitutes<span class="antiquote"><span class="antiquote">}</span></span></span></span> condition on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Ch</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is too weak to guarantee
this. We show it holds under stronger assumptions in
\S\ref{sec:contracts-t1-converse}.

›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹ Theorem~1 does not hold \citep{AygunSonmez:2012-WP2} \label{sec:contracts-t1-counterexample} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The following counterexample, due to \citet[\S3:
Example~2]{AygunSonmez:2012-WP2}, comprehensively demonstrates that
\citet[Theorem~1]{HatfieldMilgrom:2005} does not hold.

We create three types: <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>D2›</span></span></span></span> consists of two elements,
representing the doctors, and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>H›</span></span></span></span> is the type of the single
hospital. There are four contracts in the type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X4›</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> D2 <span class="main">=</span> D1 <span class="main">|</span> D2
<span class="keyword1"><span class="command">datatype</span></span> H1 <span class="main">=</span> H
<span class="keyword1"><span class="command">datatype</span></span> X4 <span class="main">=</span> Xd1 <span class="main">|</span> Xd1' <span class="main">|</span> Xd2 <span class="main">|</span> Xd2'
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> D2_UNIV<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"UNIV <span class="main">=</span> set <span class="main">[</span>D1<span class="main">,</span> D2<span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> D2.exhaust <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">instantiation</span></span> D2 <span class="main">::</span> <span class="quoted">enum</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"enum_class.enum <span class="main">=</span> <span class="main">[</span>D1<span class="main">,</span> D2<span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"enum_class.enum_all <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> D1 <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> D2<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"enum_class.enum_ex <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> D1 <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> D2<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enum_D2_def enum_all_D2_def enum_ex_D2_def D2_UNIV<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> D2_ALL<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">d</span><span class="main">.</span> <span class="free">P</span> <span class="bound">d</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">d</span><span class="main">∈</span><span class="main">{</span>D1<span class="main">,</span> D2<span class="main">}</span><span class="main">.</span> <span class="free">P</span> <span class="bound">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> D2_UNIV <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> D2_UNION<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">d</span><span class="main">.</span> <span class="free">P</span> <span class="bound">d</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">d</span><span class="main">∈</span><span class="main">{</span>D1<span class="main">,</span> D2<span class="main">}</span><span class="main">.</span> <span class="free">P</span> <span class="bound">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> D2_UNIV <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">instance</span></span> H1 <span class="main">::</span> <span class="quoted">finite</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> H1.exhaust ex_new_if_finite finite.intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> finite_insert insert_subset subset_insertI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> X4_UNIV<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"UNIV <span class="main">=</span> set <span class="main">[</span>Xd1<span class="main">,</span> Xd1'<span class="main">,</span> Xd2<span class="main">,</span> Xd2'<span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> X4.exhaust <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemmas</span></span> X4_pow <span class="main">=</span> subset_subseqs<span class="main">[</span><span class="operator">OF</span> subset_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> subset_UNIV Set.equalityD1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> X4_UNIV<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">instance</span></span> X4 <span class="main">::</span> <span class="quoted">finite</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> X4_UNIV<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> X4_ALL<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">X''</span><span class="main">.</span> <span class="free">P</span> <span class="bound">X''</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">X''</span><span class="main">∈</span>set <span class="main">`</span> set <span class="main">(</span>subseqs <span class="main">[</span>Xd1<span class="main">,</span> Xd1'<span class="main">,</span> Xd2<span class="main">,</span> Xd2'<span class="main">]</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">X''</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> X4_pow <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">X4d</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"X4 <span class="main">⇒</span> D2"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">X4d</span> Xd1 <span class="main">=</span> D1"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">X4d</span> Xd1' <span class="main">=</span> D1"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">X4d</span> Xd2 <span class="main">=</span> D2"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">X4d</span> Xd2' <span class="main">=</span> D2"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">X4h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"X4 <span class="main">⇒</span> H1"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">X4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">≡</span> H"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">PX4d</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"D2 <span class="main">⇒</span> X4 rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">PX4d</span> D1 <span class="main">=</span> linord_of_list <span class="main">[</span>Xd1'<span class="main">,</span> Xd1<span class="main">]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">PX4d</span> D2 <span class="main">=</span> linord_of_list <span class="main">[</span>Xd2<span class="main">,</span> Xd2'<span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">CX4h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"H1 <span class="main">⇒</span> X4 cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd1<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1'<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd1'<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd2<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd2<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd2'<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd2'<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1<span class="main">,</span> Xd1'<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd1<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1<span class="main">,</span> Xd2<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd1<span class="main">,</span> Xd2<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1<span class="main">,</span> Xd2'<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd2'<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1'<span class="main">,</span> Xd2<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd1'<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1'<span class="main">,</span> Xd2'<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd1'<span class="main">,</span> Xd2'<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd2<span class="main">,</span> Xd2'<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd2<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1<span class="main">,</span> Xd1'<span class="main">,</span> Xd2<span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1<span class="main">,</span> Xd1'<span class="main">,</span> Xd2'<span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1<span class="main">,</span> Xd2<span class="main">,</span> Xd2'<span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1'<span class="main">,</span> Xd2<span class="main">,</span> Xd2'<span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1<span class="main">,</span> Xd1'<span class="main">,</span> Xd2<span class="main">,</span> Xd2'<span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX4h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
                      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
                      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cut_tac</span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">b</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> X4_pow<span class="main">)</span>
                      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
                      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
                      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="operator">lexicographic_order</span>

<span class="keyword1"><span class="command">lemma</span></span> PX4d_linear<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="main">(</span>PX4d <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">d</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linord_of_list_Linear_order<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> PX4d_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span>PX4d <span class="free">d</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> X4d <span class="bound">x</span> <span class="main">=</span> <span class="free">d</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">d</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> CX4h_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CX4h <span class="free">h</span> <span class="free">X</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> H <span class="main">=</span> <span class="free">h</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span> <span class="free">X</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> CX4h.cases<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="operator">OF</span> H1.nchotomy<span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="quoted"><span class="free">h</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> CX4h_singular<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inj_on X4d <span class="main">(</span>CX4h <span class="free">h</span> <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span> <span class="free">X</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> CX4h.cases<span class="main">)</span> <span class="operator">auto</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> StableNoDecomp<span class="main">:</span> Contracts <span class="quoted">X4d</span> <span class="quoted">X4h</span> <span class="quoted">PX4d</span> <span class="quoted">CX4h</span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible PX4d_linear PX4d_range CX4h_range CX4h_singular <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

There are two stable matches in this model.

›</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> Xd1_Xd2_stable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"StableNoDecomp.stable <span class="main">{</span>Xd1<span class="main">,</span> Xd2<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> StableNoDecomp.stable_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"StableNoDecomp.individually_rational <span class="main">{</span>Xd1<span class="main">,</span> Xd2<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> StableNoDecomp.individually_rational_on_def StableNoDecomp.CD_on_def
      StableNoDecomp.CH_def insert_commute D2_UNION <span class="quasi_keyword">cong</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_cong_simp<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"StableNoDecomp.stable_no_blocking <span class="main">{</span>Xd1<span class="main">,</span> Xd2<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> StableNoDecomp.stable_no_blocking_onI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span>H<span class="main">,</span> <span class="improper">X''</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> CX4h.cases<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_commute<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Xd1'_Xd2'_stable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"StableNoDecomp.stable <span class="main">{</span>Xd1'<span class="main">,</span> Xd2'<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> StableNoDecomp.stable_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"StableNoDecomp.individually_rational <span class="main">{</span>Xd1'<span class="main">,</span> Xd2'<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> StableNoDecomp.individually_rational_on_def StableNoDecomp.CD_on_def
      StableNoDecomp.CH_def insert_commute D2_UNION <span class="quasi_keyword">cong</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_cong_simp<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"StableNoDecomp.stable_no_blocking <span class="main">{</span>Xd1'<span class="main">,</span> Xd2'<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> StableNoDecomp.stable_no_blocking_onI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span>H<span class="main">,</span> <span class="improper">X''</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> CX4h.cases<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_commute<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"StableNoDecomp.stable <span class="free">X</span> <span class="main">⟷</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{</span>Xd1<span class="main">,</span> Xd2<span class="main">}</span> <span class="main">∨</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{</span>Xd1'<span class="main">,</span> Xd2'<span class="main">}</span>"</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> X4_pow<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">X</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> StableNoDecomp.stable_on_def StableNoDecomp.individually_rational_on_def
              StableNoDecomp.stable_no_blocking_on_def StableNoDecomp.blocking_on_def
              StableNoDecomp.CD_on_def StableNoDecomp.CH_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> D2_UNION X4_ALL insert_commute StableNoDecomp.maxR_def <span class="quasi_keyword">cong</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_cong_simp<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> Xd1_Xd2_stable Xd1'_Xd2'_stable <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

However neither arises from a pair <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>XD, XH›</span></span></span></span> that satisfy
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "StableNoDecomp.stable_pair"<span class="antiquote"><span class="antiquote">}</span></span></span></span>:

›</span></span>




<span class="keyword1"><span class="command">lemma</span></span> StableNoDecomp_XD_XH<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"StableNoDecomp.stable_pair <span class="main">(</span><span class="free">XD</span><span class="main">,</span> <span class="free">XH</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">XD</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∧</span> <span class="free">XH</span> <span class="main">=</span> <span class="main">{</span>Xd1<span class="main">,</span> Xd1'<span class="main">,</span> Xd2<span class="main">,</span> Xd2'<span class="main">}</span><span class="main">)</span>"</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> image_cong_simp <span class="main">[</span><span class="operator">cong</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="keyword1"><span class="command">note</span></span> INF_cong_simp <span class="main">[</span><span class="operator">cong</span><span class="main">]</span> <span class="keyword1"><span class="command">note</span></span> SUP_cong_simp <span class="main">[</span><span class="operator">cong</span><span class="main">]</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="comment1">(* Expand the Cartesian product and check. *)</span>
  <span class="keyword1"><span class="command">using</span></span> X4_pow <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">XD</span></span><span class="main">]</span> X4_pow <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">XH</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> StableNoDecomp.stable_pair_onE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> StableNoDecomp.CD_on_def StableNoDecomp.CH_def<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> X4_UNIV <span class="main">[</span><span class="operator">simplified</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> D2_ALL D2_UNION X4_ALL insert_commute StableNoDecomp.maxR_def linord_of_list_linord_of_listP<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> StableNoDecomp.stable_pair_on_def <span class="keyword1"><span class="command">using</span></span> X4.exhaust <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> StableNoDecomp.CH_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">proposition</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"StableNoDecomp.stable_pair <span class="main">(</span><span class="free">XD</span><span class="main">,</span> <span class="free">XH</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>StableNoDecomp.stable <span class="main">(</span><span class="free">XD</span> <span class="main">∩</span> <span class="free">XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> StableNoDecomp_XD_XH<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> StableNoDecomp.stable_on_def StableNoDecomp.stable_no_blocking_on_def StableNoDecomp.blocking_on_def StableNoDecomp.individually_rational_on_empty<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> StableNoDecomp.mem_CD_on_Cd MaxR_def exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">D1</span><span class="main"><span class="main">]</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">H</span><span class="main"><span class="main">]</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{</span>Xd1<span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Moreover the converse of Theorem~1 does not hold either: the single
decomposition that satisfies <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "StableNoDecomp.stable_pair"<span class="antiquote"><span class="antiquote">}</span></span></span></span> (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span>
[source] "StableNoDecomp_XD_XH"<span class="antiquote"><span class="antiquote">}</span></span></span></span>) does not yield a stable match:

›</span></span>

<span class="keyword1"><span class="command">proposition</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"StableNoDecomp.stable <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">XD</span> <span class="bound">XH</span><span class="main">.</span> StableNoDecomp.stable_pair <span class="main">(</span><span class="bound">XD</span><span class="main">,</span> <span class="bound">XH</span><span class="main">)</span> <span class="main">∧</span> <span class="free">X</span> <span class="main">=</span> <span class="bound">XD</span> <span class="main">∩</span> <span class="bound">XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms StableNoDecomp_XD_XH stable <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

So there is not hope for \citet[Theorem~1]{HatfieldMilgrom:2005} as it
stands. Note that the counterexample satisfies the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
condition (see \S\ref{sec:cf-substitutes}):

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"substitutes <span class="main">(</span>CX4h H<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> substitutes_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">A</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> CX4h H <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> CX4h H <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="skolem">a</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">b</span></span></span></span></span></span></span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span> <span class="main">(</span><span class="operator">rule</span> CX4h.cases<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span>H<span class="main"><span class="main">,</span></span> <span class="skolem"><span class="skolem">A</span></span><span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span> <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Therefore while <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> supports the monotonicity argument
that underpins their deferred-acceptance algorithm (see
\S\ref{sec:contracts-algorithmics}), it is not enough to rescue
Theorem~1. One way forward is to constrain the hospitals'
choice functions, which we discuss in the next section.

›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹ Theorem 1 holds with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹independence of rejected contracts›<span class="antiquote"><span class="antiquote">}</span></span></span></span> \label{sec:contracts-irc} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet{AygunSonmez:2012-WP2} propose to rectify this issue by
requiring hospitals' choices to satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "irc"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
(\S\ref{sec:cf-irc}). Reassuringly their counterexample fails to
satisfy it:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>irc <span class="main">(</span>CX4h H<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> irc_onD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> a<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Xd2"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{</span>Xd1<span class="main">,</span> Xd1'<span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We adopt this hypothesis by extending the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Contracts"<span class="antiquote"><span class="antiquote">}</span></span></span></span> locale:

›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ContractsWithIRC <span class="main">=</span> Contracts <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Ch_irc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> irc <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This property requires that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Ch›</span></span></span></span> behave, for example, as
follows:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Ch_domain<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">A</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">Xh</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">h</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible irc_on_discard<span class="main">[</span><span class="operator">OF</span> spec<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Ch_irc<span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="quoted"><span class="free">h</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">Xh</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">h</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">-</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">Xh</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">h</span><span class="main">}</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Un_Diff_Int <span class="dynamic"><span class="dynamic">ac_simps</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">%</span>invisible CH_domain<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CH <span class="free">A</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">Xh</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">h</span><span class="main">}</span> <span class="main">=</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">A</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">Xh</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">h</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> CH_def <span class="keyword1"><span class="command">using</span></span> Ch_range <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Ch_domain<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">%</span>invisible stable_pair_on_Ch<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span> <span class="main">=</span> match <span class="free">XD_XH</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">Xh</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">h</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> stable_pair_on_CH<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> CH_domain Ch_domain <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible Ch_consistency <span class="main">=</span> irc_on_consistency_on<span class="main">[</span><span class="operator">OF</span> spec<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Ch_irc<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">h</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">h</span>

<span class="keyword1"><span class="command">lemmas</span></span> Ch_irc_idem <span class="main">=</span> consistency_on_f_idem<span class="main">[</span><span class="operator">OF</span> Ch_f_range Ch_consistency<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> CH_irc_idem<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CH <span class="main">(</span>CH <span class="free">A</span><span class="main">)</span> <span class="main">=</span> CH <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible CH_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> CH_def CH_domain Ch_domain Ch_irc_idem<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Ch_CH_irc_idem<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>CH <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible CH_domain CH_irc_idem Ch_domain <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This suffices to show the left-to-right direction of Theorem~1.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stable_pair_on_individually_rational<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"individually_rational_on <span class="free">ds</span> <span class="main">(</span>match <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">metis</span> CD_on_idem CH_irc_idem stable_pair_on_CD_on stable_pair_on_CD_on_CH assms individually_rational_onI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_pair_on_stable_no_blocking_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable_no_blocking_on <span class="free">ds</span> <span class="main">(</span>match <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> stable_no_blocking_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="skolem">X''</span>
  <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">=</span> <span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span>match <span class="free">XD_XH</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">≠</span> <span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span>match <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> CD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">⊆</span> CD_on <span class="free">ds</span> <span class="main">(</span>match <span class="free">XD_XH</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">⊆</span> snd <span class="free">XD_XH</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> CD <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">⊆</span> CD_on <span class="free">ds</span> <span class="main">(</span>CD_on <span class="free">ds</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">)</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> stable_pair_on_CD_on<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">⊆</span> CD_on <span class="free">ds</span> <span class="main">(</span>fst <span class="free">XD_XH</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> CD_on_path_independent <span class="keyword1"><span class="command">unfolding</span></span> path_independent_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Un_commute<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fst <span class="free">XD_XH</span> <span class="main">∩</span> CD_on <span class="free">ds</span> <span class="main">(</span>fst <span class="free">XD_XH</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span> <span class="main">⊆</span> CD_on <span class="free">ds</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> CD_on_Chernoff <span class="keyword1"><span class="command">unfolding</span></span> Chernoff_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_commute<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> stable_pair_on_def split_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span> <span class="main">=</span> <span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span><span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> consistencyD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Ch_consistency<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range'<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> NE <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">≠</span> <span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stable_pair_on_CH<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> CH_domain<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="skolem">h</span></span><span class="main">]</span> Ch_domain<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">h</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Ch_irc_idem<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">≠</span> <span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span>match <span class="free">XD_XH</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stable_pair_on_CH<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> CH_domain<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="skolem">h</span></span><span class="main">]</span> Ch_domain<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">h</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> inf.right_idem inf_sup_distrib2<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> C <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> stable_pair_on_stable_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="main">(</span>match <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms stable_pair_on_allocation stable_pair_on_individually_rational stable_pair_on_stable_no_blocking_on
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> stable_onI<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹ The converse of Theorem~1 \label{sec:contracts-t1-converse} ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Contracts<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

The forward direction of Theorem~1 gives us a way of finding stable
matches by computing fixed points of a function closely related to
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "stable_pair"<span class="antiquote"><span class="antiquote">}</span></span></span></span> (see \S\ref{sec:contracts-algorithmics}). The
converse says that every stable match can be decomposed in this way,
which implies that the stable matches form a lattice (see also
\S\ref{sec:contracts-algorithmics}).

The following proofs assume that the hospitals' choice functions
satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "irc"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithIRC
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Following \citet[Proof of Theorem~1]{HatfieldMilgrom:2005}, we
partition the set of all contracts into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">[</span></span><span class="free"><span class="free">X</span></span><span class="main"><span class="main">,</span></span> <span class="free"><span class="free">XD_smallest</span></span> <span class="main"><span class="main">-</span></span> <span class="free"><span class="free">X</span></span><span class="main"><span class="main">,</span></span>
<span class="free"><span class="free">XH_largest</span></span> <span class="main"><span class="main">-</span></span> <span class="free"><span class="free">X</span></span><span class="main"><span class="main">]</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with careful definitions of the two sets <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"<span class="free"><span class="free">XD_smallest</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">XH_largest</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. Specifically <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"<span class="free"><span class="free">XH_largest</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> contains all contracts ranked at least as good as those
in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">X</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> by the doctors, considering unemployment and
unacceptable contracts. Similarly <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">XD_smallest</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> contains those
ranked at least as poorly.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">XH_largest</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">XH_largest</span> <span class="main">=</span>
     <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">ds</span>
       <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>
       <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> dX <span class="free">X</span> <span class="main">(</span><span class="free">Xd</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">XD_smallest</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">XD_smallest</span> <span class="main">=</span> <span class="main">-</span> <span class="main">(</span>XH_largest <span class="main">-</span> <span class="free">X</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Ch_XH_largest_Field<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> XH_largest"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> XH_largest_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Ch_XH_largest_Xd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> XH_largest"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> XH_largest_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> X_subseteq_XH_largest<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">⊆</span> XH_largest"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">d</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Cd <span class="skolem">d</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> stable_on_CD_on<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> CD_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> XH_largest"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Pd_linear' Pd_range' Cd_range subset_Image1_Image1_iff<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">Pd</span> <span class="skolem">d</span>"</span></span><span class="main">]</span> stable_on_allocation<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span> <span class="quoted"><span class="free">X</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> XH_largest_def linear_order_on_def partial_order_on_def stable_on_def inj_on_def dX_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> X_subseteq_XD_smallest<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">⊆</span> XD_smallest"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> XD_smallest_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> X_XD_smallest_XH_largest<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">=</span> XD_smallest <span class="main">∩</span> XH_largest"</span></span>
<span class="keyword1"><span class="command">using</span></span> X_subseteq_XH_largest <span class="keyword1"><span class="command">unfolding</span></span> XD_smallest_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The goal of the next few lemmas is to show the constituents of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"stable_pair_on <span class="free"><span class="free">ds</span></span> <span class="main"><span class="main">(</span></span>XD_smallest<span class="main"><span class="main">,</span></span> XH_largest<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

Intuitively, if a doctor has a contract <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">X</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
then all of their contracts in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "XH_largest"<span class="antiquote"><span class="antiquote">}</span></span></span></span> are at least as
desirable as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and so the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"stable_no_blocking"<span class="antiquote"><span class="antiquote">}</span></span></span></span> hypothesis guarantees the hospitals choose
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "XH_largest"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, and similarly the doctors
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "XD_smallest"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> XH_largestCdXXH_largest<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> XH_largest"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Cd <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">Ch</span> <span class="free">h</span> XH_largest<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">y</span> <span class="main">=</span> <span class="free">Xd</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> XH_largest_def dX_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range'<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Ch_XH_largest_Field<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> Pd_linear Pd_range <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> assms Ch_XH_largest_Field<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Cd_greatest greatest_def<span class="main">)</span>
       <span class="main">(</span><span class="operator">metis</span> Ch_singular Pd_range' inj_onD subset_refl underS_incl_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> CH_XH_largest<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CH XH_largest <span class="main">=</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="skolem">h</span> XH_largest <span class="main">⊆</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">Ch</span> <span class="skolem">h</span> XH_largest<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">h</span>
    <span class="keyword1"><span class="command">using</span></span> XH_largestCdXXH_largest Ch_XH_largest_Xd Ch_XH_largest_Field <span class="keyword1"><span class="command">unfolding</span></span> CD_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="skolem">h</span> XH_largest <span class="main">=</span> <span class="free">Ch</span> <span class="skolem">h</span> <span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">h</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Ch</span> <span class="skolem">h</span> XH_largest <span class="main">⊆</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">Ch</span> <span class="skolem">h</span> XH_largest<span class="main">)</span>›</span></span> X_subseteq_XH_largest
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> stable_on_blocking_onD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">h</span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> X''<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free"><span class="free">Ch</span></span></span> <span class="skolem"><span class="skolem"><span class="skolem">h</span></span></span> XH_largest"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span>
          <span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> consistencyD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Ch_consistency<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range'<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> stable_on_CH<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> CH_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Cd_XD_smallest<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Cd <span class="free">d</span> <span class="main">(</span>XD_smallest <span class="main">∩</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Cd <span class="free">d</span> <span class="main">(</span><span class="free">X</span> <span class="main">∩</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∩</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">with</span></span> Pd_range' Cd_range'<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">X</span></span><span class="main">]</span> stable_on_CD_on<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span><span class="main">]</span> mem_CD_on_Cd assms
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> XH_largest <span class="main">∩</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> XH_largest_def dX_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> XD_smallest_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Int_Un_distrib2<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">with</span></span> Pd_linear'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">d</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> stable_on_CD_on stable_on_allocation assms
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> XD_smallest_def order_on_defs total_on_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 0 0 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Int_Un_distrib2 Cd_greatest greatest_def XH_largest_def dX_def<span class="main">)</span>
       <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> IntI Pd_range' UnCI inj_onD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> CD_on_XD_smallest<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CD_on <span class="free">ds</span> XD_smallest <span class="main">=</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> stable_on_CD_on<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> CD_on_def2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Cd_XD_smallest<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> stable_on_stable_pair_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="main">(</span>XD_smallest<span class="main">,</span> XH_largest<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> stable_pair_onI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> prod.sel<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> CH_XH_largest <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> RH XH_largest <span class="main">=</span> <span class="main">-</span> <span class="main">(</span>XH_largest <span class="main">-</span> <span class="free">X</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> X_XD_smallest_XH_largest <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> XD_smallest"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> XD_smallest_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"XD_smallest <span class="main">=</span> <span class="main">-</span>RH XH_largest"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">from</span></span> CD_on_XD_smallest <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span>RD_on <span class="free">ds</span> XD_smallest <span class="main">=</span> <span class="main">-</span><span class="main">(</span>XD_smallest <span class="main">-</span> <span class="free">X</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> XH_largest"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> XD_smallest_def <span class="keyword1"><span class="command">using</span></span> X_subseteq_XH_largest <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"XH_largest <span class="main">=</span> <span class="main">-</span>RD_on <span class="free">ds</span> XD_smallest"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Our ultimate statement of Theorem~1 of \cite{HatfieldMilgrom:2005} ala
\citet{AygunSonmez:2012-WP2} goes as follows, bearing in mind that we
are working in the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "ContractsWithIRC"<span class="antiquote"><span class="antiquote">}</span></span></span></span> locale:

›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> T1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">XD_XH</span><span class="main">.</span> stable_pair_on <span class="free">ds</span> <span class="bound">XD_XH</span> <span class="main">∧</span> <span class="free">X</span> <span class="main">=</span> match <span class="bound">XD_XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> stable_pair_on_stable_on stable_on_stable_pair_on X_XD_smallest_XH_largest <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Theorem~3: Algorithmics \label{sec:contracts-algorithmics} ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Contracts<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

Having revived Theorem~1, we reformulate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "stable_pair"<span class="antiquote"><span class="antiquote">}</span></span></span></span> as a
monotone (aka <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹isotone›<span class="antiquote"><span class="antiquote">}</span></span></span></span>) function and exploit the lattice
structure of its fixed points, following \citet[{\S}II,
Theorem~3]{HatfieldMilgrom:2005}. This underpins all of their results
that we formulate here. \citet[\S2]{Fleiner:2002} provides an
intuitive gloss of these definitions.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">F1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">F1</span> <span class="free"><span class="bound"><span class="entity">X'</span></span></span> <span class="main">=</span> <span class="main">-</span> RH <span class="free"><span class="bound"><span class="entity">X'</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">F2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">F2</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">X'</span></span></span> <span class="main">=</span> <span class="main">-</span> RD_on <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">X'</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">F</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">×</span> <span class="tfree">'x</span> set dual <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">×</span> <span class="tfree">'x</span> set dual"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">XD</span><span class="main">,</span> <span class="bound">XH</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>F1 <span class="main">(</span>undual <span class="bound">XH</span><span class="main">)</span><span class="main">,</span> dual <span class="main">(</span>F2 <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">(</span>F1 <span class="main">(</span>undual <span class="bound">XH</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We exploit Isabelle/HOL's ordering type classes (over the type
constructors <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">×</span></span> <span class="tfree"><span class="tfree">'b</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) to define
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "F"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. As <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "F"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "antimono"<span class="antiquote"><span class="antiquote">}</span></span></span></span> (where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span>
"antimono_def"<span class="antiquote"><span class="antiquote">}</span></span></span></span> for a lattice order <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>≤›</span></span></span></span>) on its
second argument <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>XH›</span></span></span></span>, we adopt the dual lattice order
using the type constructor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> dual"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "dual"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "undual"<span class="antiquote"><span class="antiquote">}</span></span></span></span> mediate the isomorphism on values, to satisfy
Isabelle/HOL's <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "mono"<span class="antiquote"><span class="antiquote">}</span></span></span></span> predicate. Note we work under the
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> hypothesis here.

Relating this function to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "stable_pair"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is syntactically
awkward but straightforward:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fix_F_stable_pair_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">=</span> F <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="main">(</span>map_prod id undual <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">X</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_def F1_def F2_def stable_pair_on_def dual_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stable_pair_on_fix_F<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_prod id dual <span class="free">X</span> <span class="main">=</span> F <span class="free">ds</span> <span class="main">(</span>map_prod id dual <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms
<span class="keyword1"><span class="command">unfolding</span></span> F_def F1_def F2_def stable_pair_on_def split_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_map_prod id_apply prod.collapse snd_map_prod undual_dual<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Contracts<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

The function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> F<span class="antiquote"><span class="antiquote">}</span></span></span></span> is monotonic under <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> substitutes<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ContractsWithSubstitutes <span class="main">=</span> Contracts <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Ch_substitutes<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> substitutes <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> Rh_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span>Rh <span class="free">h</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible substitutes_on_Rf_mono_on<span class="main">[</span><span class="operator">OF</span> spec<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Ch_substitutes<span class="main"><span class="main">]</span></span><span class="main">]</span> mono_on_mono <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemmas</span></span> Ch_iia <span class="main">=</span> Rh_mono<span class="main">[</span><span class="operator">unfolded</span> Rf_mono_iia<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> Ch_Chernoff <span class="main">=</span> Ch_iia<span class="main">[</span><span class="operator">unfolded</span> Chernoff_on_iia_on<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> Ch_subsitutes_idem <span class="main">=</span> iia_f_idem<span class="main">[</span><span class="operator">OF</span> Ch_f_range Ch_iia<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> RH_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono RH"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible CH_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> monoI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> monoD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Rh_mono<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> CH_iia <span class="main">=</span> RH_mono<span class="main">[</span><span class="operator">unfolded</span> Rf_mono_iia<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> CH_Chernoff <span class="main">=</span> CH_iia<span class="main">[</span><span class="operator">unfolded</span> Chernoff_on_iia_on<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> CH_substitutes_idem <span class="main">=</span> iia_f_idem<span class="main">[</span><span class="operator">OF</span> CH_f_range_on CH_iia<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> F1_antimono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"antimono F1"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> antimonoI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> F1_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Diff_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ monoD<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> RH_mono<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> F2_antimono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"antimono <span class="main">(</span>F2 <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> antimonoI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> F2_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Diff_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ monoD<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> RD_on_mono<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> F_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span>F <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible F_def <span class="keyword1"><span class="command">using</span></span> antimonoD<span class="main">[</span><span class="operator">OF</span> F1_antimono<span class="main">]</span> antimonoD<span class="main">[</span><span class="operator">OF</span> F2_antimono<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> monoI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> less_eq_dual_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We define the extremal fixed points using Isabelle/HOL's least and
greatest fixed point operators:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">gfp_F</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">×</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gfp_F</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">=</span> map_prod id undual <span class="main">(</span>gfp <span class="main">(</span>F <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lfp_F</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">×</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lfp_F</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">=</span> map_prod id undual <span class="main">(</span>lfp <span class="main">(</span>F <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> gfp_F_stable_pair_on <span class="main">=</span> fix_F_stable_pair_on<span class="main">[</span><span class="operator">OF</span> gfp_unfold<span class="main"><span class="main">[</span></span><span class="operator">OF</span> F_mono<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">folded</span> gfp_F_def<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> lfp_F_stable_pair_on <span class="main">=</span> fix_F_stable_pair_on<span class="main">[</span><span class="operator">OF</span> lfp_unfold<span class="main"><span class="main">[</span></span><span class="operator">OF</span> F_mono<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">folded</span> lfp_F_def<span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

These last two lemmas show that the least and greatest fixed points do
satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "stable_pair"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

Using standard fixed-point properties, we can establish:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> F2_o_F1_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span>F2 <span class="free">ds</span> <span class="main">∘</span> F1<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">metis</span> F2_antimono F1_antimono antimono_def comp_apply monoI<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> F2_F1_mono <span class="main">=</span> F2_o_F1_mono<span class="main">[</span><span class="operator">unfolded</span> o_def<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> gfp_F_lfp_F<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gfp_F <span class="free">ds</span> <span class="main">=</span> <span class="main">(</span>F1 <span class="main">(</span>lfp <span class="main">(</span>F2 <span class="free">ds</span> <span class="main">∘</span> F1<span class="main">)</span><span class="main">)</span><span class="main">,</span> lfp <span class="main">(</span>F2 <span class="free">ds</span> <span class="main">∘</span> F1<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?F'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"dual <span class="main">∘</span> F2 <span class="free">ds</span> <span class="main">∘</span> F1 <span class="main">∘</span> undual"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"gfp <span class="main">(</span>F <span class="free">ds</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>F1 <span class="main">(</span>undual <span class="main">(</span>gfp <span class="var">?F'</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> gfp <span class="var">?F'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> gfp_prod<span class="main"><span class="main">[</span></span><span class="operator">OF</span> F_mono<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_def o_def gfp_const<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"gfp <span class="var">?F'</span> <span class="main">=</span> dual <span class="main">(</span>lfp <span class="main">(</span>F2 <span class="free">ds</span> <span class="main">∘</span> F1<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfp_dual_gfp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> F2_o_F1_mono<span class="main"><span class="main">,</span></span> <span class="operator">simplified</span> o_assoc<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> gfp_F_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We need hospital CFs to satisfy both <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> substitutes<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> irc<span class="antiquote"><span class="antiquote">}</span></span></span></span>
to relate these fixed points to stable matches.

›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ContractsWithSubstitutesAndIRC <span class="main">=</span>
  ContractsWithSubstitutes <span class="main">+</span> ContractsWithIRC
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> gfp_F_stable_on <span class="main">=</span> stable_pair_on_stable_on<span class="main">[</span><span class="operator">OF</span> gfp_F_stable_pair_on<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> lfp_F_stable_on <span class="main">=</span> stable_pair_on_stable_on<span class="main">[</span><span class="operator">OF</span> lfp_F_stable_pair_on<span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\label{sec:contracts-codegen-gfp_F}

We demonstrate the effectiveness of our definitions by executing an
example due to \citet[p920]{HatfieldMilgrom:2005} using Isabelle/HOL's
code generator \citep{Haftmann-Nipkow:2010:code}. Note that, while
adequate for this toy instance, the representations used here are
hopelessly n{\"a}ive: sets are represented by lists and operations
typically traverse the entire contract space. It is feasible, with
more effort, to derive efficient algorithms; see, for instance,
\citet{Bijlsma:1991,Bulwahn-et-al:2008:imp_HOL}.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithSubstitutes
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> gfp_F_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gfp_F <span class="free">ds</span> <span class="main">=</span> map_prod id undual <span class="main">(</span>while <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> F <span class="free">ds</span> <span class="bound">A</span> <span class="main">≠</span> <span class="bound">A</span><span class="main">)</span> <span class="main">(</span>F <span class="free">ds</span><span class="main">)</span> top<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible gfp_F_def gfp_while_lattice<span class="main">[</span><span class="operator">OF</span> F_mono<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> lfp_F_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lfp_F <span class="free">ds</span> <span class="main">=</span> map_prod id undual <span class="main">(</span>while <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> F <span class="free">ds</span> <span class="bound">A</span> <span class="main">≠</span> <span class="bound">A</span><span class="main">)</span> <span class="main">(</span>F <span class="free">ds</span><span class="main">)</span> bot<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible lfp_F_def lfp_while_lattice<span class="main">[</span><span class="operator">OF</span> F_mono<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

There are two hospitals and two doctors.

›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> H2 <span class="main">=</span> H1 <span class="main">|</span> H2

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The contract space is simply the Cartesian product <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"D2 <span class="main"><span class="main">×</span></span>
H2"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> X_D2_H2 <span class="main">=</span> <span class="quoted"><span class="quoted">"D2 <span class="main">×</span> H2"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Doctor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "D1"<span class="antiquote"><span class="antiquote">}</span></span></span></span> prefers <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>H1 ≻ H2›</span></span></span></span>, doctor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"D2"<span class="antiquote"><span class="antiquote">}</span></span></span></span> the same <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>H1 ≻ H2›</span></span></span></span> (but over different
contracts).

›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">P_D2_H2_d</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"D2 <span class="main">⇒</span> X_D2_H2 rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P_D2_H2_d</span> D1 <span class="main">=</span> linord_of_list <span class="main">[</span><span class="main">(</span>D1<span class="main">,</span> H1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>D1<span class="main">,</span> H2<span class="main">)</span><span class="main">]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">P_D2_H2_d</span> D2 <span class="main">=</span> linord_of_list <span class="main">[</span><span class="main">(</span>D2<span class="main">,</span> H1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>D2<span class="main">,</span> H2<span class="main">)</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Hospital <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "H1"<span class="antiquote"><span class="antiquote">}</span></span></span></span> prefers <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>{D1} ≻ {D2} ≻
∅›</span></span></span></span>, and hospital <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "H2"<span class="antiquote"><span class="antiquote">}</span></span></span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>{D1, D2}
≻ {D1} ≻ {D2} ≻ ∅›</span></span></span></span>. We interpret
these constraints as follows:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">P_D2_H2_H1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"X_D2_H2 cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P_D2_H2_H1</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span>D1<span class="main">,</span> H1<span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> <span class="main">{</span><span class="main">(</span>D1<span class="main">,</span> H1<span class="main">)</span><span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">(</span>D2<span class="main">,</span> H1<span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> <span class="main">{</span><span class="main">(</span>D2<span class="main">,</span> H1<span class="main">)</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">P_D2_H2_H2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"X_D2_H2 cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P_D2_H2_H2</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span>
     <span class="main">(</span><span class="keyword1">if</span> <span class="main">{</span><span class="main">(</span>D1<span class="main">,</span> H2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>D2<span class="main">,</span> H2<span class="main">)</span><span class="main">}</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> <span class="main">{</span><span class="main">(</span>D1<span class="main">,</span> H2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>D2<span class="main">,</span> H2<span class="main">)</span><span class="main">}</span> <span class="keyword1">else</span>
      <span class="keyword1">if</span> <span class="main">(</span>D1<span class="main">,</span> H2<span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> <span class="main">{</span><span class="main">(</span>D1<span class="main">,</span> H2<span class="main">)</span><span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">(</span>D2<span class="main">,</span> H2<span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> <span class="main">{</span><span class="main">(</span>D2<span class="main">,</span> H2<span class="main">)</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">P_D2_H2_h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"H2 <span class="main">⇒</span> X_D2_H2 cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P_D2_H2_h</span> H1 <span class="main">=</span> P_D2_H2_H1"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">P_D2_H2_h</span> H2 <span class="main">=</span> P_D2_H2_H2"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> H2_UNIV<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"UNIV <span class="main">=</span> set <span class="main">[</span>H1<span class="main">,</span> H2<span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> H2.exhaust <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">instantiation</span></span> H2 <span class="main">::</span> <span class="quoted">enum</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"enum_class.enum <span class="main">=</span> <span class="main">[</span>H1<span class="main">,</span> H2<span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"enum_class.enum_all <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> H1 <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> H2<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"enum_class.enum_ex <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> H1 <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> H2<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enum_H2_def enum_all_H2_def enum_ex_H2_def H2_UNIV<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> H2_ALL <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">h</span><span class="main">.</span> <span class="free">P</span> <span class="bound">h</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">h</span><span class="main">∈</span><span class="main">{</span>H1<span class="main">,</span> H2<span class="main">}</span><span class="main">.</span> <span class="free">P</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> H2_UNIV <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> H2_UNION<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">h</span><span class="main">.</span> <span class="free">P</span> <span class="bound">h</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">h</span><span class="main">∈</span><span class="main">{</span>H1<span class="main">,</span> H2<span class="main">}</span><span class="main">.</span> <span class="free">P</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> H2_UNIV <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> P_D2_H2_d_linear<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="main">(</span>P_D2_H2_d <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">d</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linord_of_list_Linear_order<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> P_D2_H2_d_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span>P_D2_H2_d <span class="free">d</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> fst <span class="bound">x</span> <span class="main">=</span> <span class="free">d</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">d</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> P_D2_H2_h_substitutes<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"substitutes <span class="main">(</span>P_D2_H2_h <span class="free">h</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> substitutes_onI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> P_D2_H2_H1_def P_D2_H2_H2_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Isabelle's code generator requires us to hoist the relevant
definitions from the locale to the top-level (see the \verb!codegen!
documentation, \S7.3).

›</span></span>

<span class="keyword1"><span class="command">global_interpretation</span></span> P920_example<span class="main">:</span>
  ContractsWithSubstitutes <span class="quoted">fst</span> <span class="quoted">snd</span> <span class="quoted">P_D2_H2_d</span> <span class="quoted">P_D2_H2_h</span>
<span class="keyword2"><span class="keyword">defines</span></span> P920_example_gfp_F <span class="main">=</span> <span class="quoted">P920_example.gfp_F</span>
    <span class="keyword2"><span class="keyword">and</span></span> P920_example_lfp_F <span class="main">=</span> <span class="quoted">P920_example.lfp_F</span>
    <span class="keyword2"><span class="keyword">and</span></span> P920_example_F <span class="main">=</span> <span class="quoted">P920_example.F</span>
    <span class="keyword2"><span class="keyword">and</span></span> P920_example_F1 <span class="main">=</span> <span class="quoted">P920_example.F1</span>
    <span class="keyword2"><span class="keyword">and</span></span> P920_example_F2 <span class="main">=</span> <span class="quoted">P920_example.F2</span>
    <span class="keyword2"><span class="keyword">and</span></span> P920_example_maxR <span class="main">=</span> <span class="quoted">P920_example.maxR</span>
    <span class="keyword2"><span class="keyword">and</span></span> P920_example_MaxR_f <span class="main">=</span> <span class="quoted">P920_example.MaxR_f</span>
    <span class="keyword2"><span class="keyword">and</span></span> P920_example_Cd <span class="main">=</span> <span class="quoted">P920_example.Cd</span>
    <span class="keyword2"><span class="keyword">and</span></span> P920_example_CD_on <span class="main">=</span> <span class="quoted">P920_example.CD_on</span>
    <span class="keyword2"><span class="keyword">and</span></span> P920_example_CH <span class="main">=</span> <span class="quoted">P920_example.CH</span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible P_D2_H2_d_linear P_D2_H2_h_substitutes
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> D2_ALL P_D2_H2_H1_def P_D2_H2_H2_def<span class="main">)</span>

<span class="comment1">(*&lt;*)</span>

<span class="comment1">(*

Codegen hackery: avoid the CoSet constructor as some operations do not
handle it.

*)</span>

<span class="keyword1"><span class="command">declare</span></span> UNIV_coset<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> UNIV_enum<span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> compl_set<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">]</span> compl_coset<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> Compl_eq_Diff_UNIV<span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="comment1">(*
code_thms P920_example_gfp_F
export_code P920_example_gfp_F in SML module_name F file "F.sml"
value "P920_example_gfp_F UNIV"
*)</span>

<span class="keyword1"><span class="command">lemma</span></span> P920_example_gfp_F_value<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"P920_example_gfp_F UNIV <span class="main">=</span> <span class="main">(</span><span class="main">{</span><span class="main">(</span>D1<span class="main">,</span> H1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>D1<span class="main">,</span> H2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>D2<span class="main">,</span> H2<span class="main">)</span><span class="main">}</span><span class="main">,</span> <span class="main">{</span><span class="main">(</span>D1<span class="main">,</span> H1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>D2<span class="main">,</span> H1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>D2<span class="main">,</span> H2<span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">lemma</span></span> P920_example_gfp_F_match_value<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"P920_example.match <span class="main">(</span>P920_example_gfp_F UNIV<span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span>D1<span class="main">,</span> H1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>D2<span class="main">,</span> H2<span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> P920_example_gfp_F_value <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> P920_example_lfp_F_value<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"P920_example_lfp_F UNIV <span class="main">=</span> <span class="main">(</span><span class="main">{</span><span class="main">(</span>D1<span class="main">,</span> H1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>D1<span class="main">,</span> H2<span class="main">)</span><span class="main">,</span> <span class="main">(</span>D2<span class="main">,</span> H2<span class="main">)</span><span class="main">}</span><span class="main">,</span> <span class="main">{</span><span class="main">(</span>D1<span class="main">,</span> H1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>D2<span class="main">,</span> H1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>D2<span class="main">,</span> H2<span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We can now evaluate the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "gfp"<span class="antiquote"><span class="antiquote">}</span></span></span></span> of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "P920_example.F"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
(i.e., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>F›</span></span></span></span> specialized to the above constants) using
Isabelle's \verb!value! antiquotation or \verb!eval! method. This
yields the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(XD, XH)›</span></span></span></span> pair:

\begin{center}
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> <span class="main"><span class="main">(</span></span><span class="operator"><span class="operator">rhs</span></span><span class="main"><span class="main">)</span></span> "P920_example_gfp_F_value"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
\end{center}

The stable match is therefore <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> <span class="main"><span class="main">(</span></span><span class="operator"><span class="operator">rhs</span></span><span class="main"><span class="main">)</span></span> "P920_example_gfp_F_match_value"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "lfp"<span class="antiquote"><span class="antiquote">}</span></span></span></span> of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "P920_example.F"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is identical to the
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "gfp"<span class="antiquote"><span class="antiquote">}</span></span></span></span>:

\begin{center}
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> <span class="main"><span class="main">(</span></span><span class="operator"><span class="operator">rhs</span></span><span class="main"><span class="main">)</span></span> "P920_example_lfp_F_value"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
\end{center}

This implies that there is only one stable match in this scenario.

›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Theorem~4: Optimality \label{sec:contracts-optimality} ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ContractsWithSubstitutes<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

\citet[Theorem~4]{HatfieldMilgrom:2005} assert that the greatest fixed
point <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "gfp_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span> of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "F"<span class="antiquote"><span class="antiquote">}</span></span></span></span> yields the stable match most
preferred by the doctors in the following sense:

›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">doctor_optimal_match</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">doctor_optimal_match</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span>
    <span class="main">⟷</span> <span class="main">(</span>stable_on <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="bound">X</span><span class="main">.</span> stable_on <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="bound">X</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemmas</span></span> doctor_optimal_matchI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> doctor_optimal_match_def<span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> doctor_optimal_match_stable_on <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> doctor_optimal_match_def<span class="main">,</span> <span class="operator">THEN</span> conjunct1<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> doctor_optimal_match_optimal <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> doctor_optimal_match_def<span class="main">,</span> <span class="operator">THEN</span> conjunct2<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> doctor_optimal_match_unique<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"doctor_optimal_match <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"doctor_optimal_match <span class="free">ds</span> <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">=</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffD2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> set_eq_iff<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword1"><span class="command">from</span></span> Pd_linear'<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> d<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span>"</span></span><span class="main">]</span> Pd_Xd<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> d<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span>"</span></span><span class="main">]</span>
       stable_on_allocation<span class="main">[</span><span class="operator">OF</span> doctor_optimal_match_stable_on<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
       stable_on_allocation<span class="main">[</span><span class="operator">OF</span> doctor_optimal_match_stable_on<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
       assms
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">⟷</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="free">Y</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> doctor_optimal_match_def order_on_defs
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> antisymD inj_on_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ContractsWithSubstitutes<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

In a similar sense, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "lfp_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is the doctor-pessimal match.

We state a basic doctor-optimality result in terms of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"stable_pair"<span class="antiquote"><span class="antiquote">}</span></span></span></span> in the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "ContractsWithSubstitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> locale for
generality; we can establish <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "doctor_optimal_match"<span class="antiquote"><span class="antiquote">}</span></span></span></span> only
under additional constraints on hospital choice functions (see
\S\ref{sec:contracts-irc}).

›</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithSubstitutes
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">XD_XH</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">×</span> <span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> gfp_F_upperbound<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">,</span> dual <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> gfp <span class="main">(</span>F <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">,</span> dual <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> F <span class="free">ds</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">,</span> dual <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stable_pair_on_fix_F<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> id_apply map_prod_simp prod.collapse<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> gfp_upperbound<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> XD_XH_gfp_F<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fst <span class="free">XD_XH</span> <span class="main">⊆</span> fst <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span> <span class="main">⊆</span> snd <span class="free">XD_XH</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible gfp_F_upperbound
<span class="keyword1"><span class="command">unfolding</span></span> gfp_F_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_eq_dual_def less_eq_prod_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lfp_F_upperbound<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lfp <span class="main">(</span>F <span class="free">ds</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">,</span> dual <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">,</span> dual <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> F <span class="free">ds</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">,</span> dual <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stable_pair_on_fix_F<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> id_apply map_prod_simp prod.collapse<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lfp_lowerbound<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> XD_XH_lfp_F<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>lfp_F <span class="free">ds</span><span class="main">)</span> <span class="main">⊆</span> fst <span class="free">XD_XH</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"snd <span class="free">XD_XH</span> <span class="main">⊆</span> snd <span class="main">(</span>lfp_F <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible lfp_F_upperbound
<span class="keyword1"><span class="command">unfolding</span></span> lfp_F_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_eq_dual_def less_eq_prod_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We appeal to the doctors' linear preferences to show the optimality
(pessimality) of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "gfp_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span> (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "lfp_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span>) for doctors.

›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> gfp_f_doctor_optimal<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> match <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> match <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms gfp_F_stable_pair_on<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ds<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ds</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>›</span></span>
      stable_pair_on_CD_on stable_pair_on_Xd Cd_Xd mem_CD_on_Cd
      XD_XH_gfp_F<span class="main">(</span>1<span class="main">)</span> Cd_mono<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> d<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"fst <span class="free">XD_XH</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> Y<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"fst <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> sup.absorb_iff2<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> lfp_f_doctor_pessimal<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> match <span class="main">(</span>lfp_F <span class="free">ds</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> match <span class="free">XD_XH</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms lfp_F_stable_pair_on<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ds<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ds</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>›</span></span>
      stable_pair_on_CD_on stable_pair_on_Xd Cd_Xd mem_CD_on_Cd
      XD_XH_lfp_F<span class="main">(</span>1<span class="main">)</span> Cd_mono<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> d<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"fst <span class="main">(</span>lfp_F <span class="free">ds</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> Y<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"fst <span class="free">XD_XH</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> sup.absorb_iff2<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ContractsWithSubstitutesAndIRC<span class="main">)</span> gfp_F_doctor_optimal_match<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"doctor_optimal_match <span class="free">ds</span> <span class="main">(</span>match <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> doctor_optimal_matchI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gfp_F_stable_on<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> T1 <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> gfp_f_doctor_optimal<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ContractsWithSubstitutesAndIRC<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

Conversely <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "lfp_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is most preferred by the hospitals in a
revealed-preference sense, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "gfp_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span> least preferred. These
results depend on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] Ch_domain<span class="antiquote"><span class="antiquote">}</span></span></span></span> and hence the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"irc"<span class="antiquote"><span class="antiquote">}</span></span></span></span> hypothesis on hospital choice functions.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithSubstitutesAndIRC
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">theorem</span></span> lfp_f_hospital_optimal<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>match <span class="main">(</span>lfp_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>match <span class="main">(</span>lfp_F <span class="free">ds</span><span class="main">)</span> <span class="main">∪</span> match <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"match <span class="main">(</span>lfp_F <span class="free">ds</span><span class="main">)</span> <span class="main">∪</span> match <span class="free">XD_XH</span> <span class="main">⊆</span> snd <span class="main">(</span>lfp_F <span class="free">ds</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> XD_XH_lfp_F<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> le_infI2<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>match <span class="main">(</span>lfp_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span>›</span></span> lfp_F_stable_pair_on stable_pair_on_Ch Ch_range <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> iia_onD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Ch_iia<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">h</span></span></span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"snd <span class="main"><span class="main"><span class="main">(</span></span></span>lfp_F <span class="free"><span class="free"><span class="free">ds</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> gfp_f_hospital_pessimal<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>match <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>match <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span> <span class="main">∪</span> match <span class="free">XD_XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"match <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span> <span class="main">∪</span> match <span class="free">XD_XH</span> <span class="main">⊆</span> snd <span class="free">XD_XH</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> XD_XH_gfp_F<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> le_infI2<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> assms lfp_F_stable_pair_on stable_pair_on_Ch Ch_range <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> iia_onD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Ch_iia<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">h</span></span></span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"snd <span class="free"><span class="free"><span class="free">XD_XH</span></span></span>"</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The general lattice-theoretic results of e.g. \citet{Fleiner:2002}
depend on the full Tarski-Knaster fixed point theorem, which is
difficult to state in the present type class-based setting. (The
theorem itself is available in the Isabelle/HOL distribution but
requires working with less convenient machinery.)

›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Theorem~5 does not hold \citep{HatfieldKojima:2008} ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Contracts<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

\citet[Theorem~5]{HatfieldMilgrom:2005} claim that:
\begin{quote}

Suppose <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>H›</span></span></span></span> contains at least two hospitals, which we
denote by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>h›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>h'›</span></span></span></span>. Further suppose that
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Rh <span class="free"><span class="free">h</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is not isotone, that is, contracts are not <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>h›</span></span></span></span>. Then there exist preference
orderings for the doctors in set <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>D›</span></span></span></span>, a preference
ordering for a hospital <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>h'›</span></span></span></span> with a single job opening
such that, regardless of the preferences of the other hospitals, no
stable set of contracts exists.

\end{quote}

\citet[Observation~1]{HatfieldKojima:2008} show this is not true:
there can be stable matches even if hospital choice functions violate
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. This motivates looking for conditions weaker
than <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> that still guarantee stable matches, a
project taken up by \citet{HatfieldKojima:2010}; see
\S\ref{sec:cop}. We omit their counterexample to this incorrect claim.

›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Theorem~6: ``Vacancy chain'' dynamics \label{sec:contracts-vacancy-chain} ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ContractsWithSubstitutesAndIRC<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

\citet[II(C), p923]{HatfieldMilgrom:2005} propose a model for updating
a stable match <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">X</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> when a doctor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">d'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
retires. Intuitively the contracts mentioning <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">d'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are
discarded and a modified algorithm run from the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "XH_largest"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "XD_smallest"<span class="antiquote"><span class="antiquote">}</span></span></span></span> sets determined from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">X</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. The
result is another stable match where the remaining doctors <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">ds</span></span>
<span class="main"><span class="main">-</span></span> <span class="main"><span class="main">{</span></span><span class="free"><span class="free">d'</span></span><span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are (weakly) better off and the hospitals (weakly) worse off
than they were in the initial state. The proofs are essentially the
same as for optimality (\S\ref{sec:contracts-optimality}).

›</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithSubstitutesAndIRC
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">d'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citeauthor{HatfieldMilgrom:2005} do not motivate why the process uses
this functional and not <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "F"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">F'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">×</span> <span class="tfree">'a</span> set dual <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">×</span> <span class="tfree">'a</span> set dual"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">F'</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">XD</span><span class="main">,</span> <span class="bound">XH</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">-</span> RH <span class="main">(</span>undual <span class="bound">XH</span><span class="main">)</span><span class="main">,</span> dual <span class="main">(</span><span class="main">-</span> RD_on <span class="main">(</span><span class="free">ds</span><span class="main">-</span><span class="main">{</span><span class="free">d'</span><span class="main">}</span><span class="main">)</span> <span class="bound">XD</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> F'_apply<span class="main">:</span>
  <span class="quoted"><span class="quoted">"F' <span class="main">(</span><span class="free">XD</span><span class="main">,</span> <span class="free">XH</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">-</span> RH <span class="main">(</span>undual <span class="free">XH</span><span class="main">)</span><span class="main">,</span> dual <span class="main">(</span><span class="main">-</span> RD_on <span class="main">(</span><span class="free">ds</span> <span class="main">-</span> <span class="main">{</span><span class="free">d'</span><span class="main">}</span><span class="main">)</span> <span class="free">XD</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F'_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">%</span>invisible F1'_antimono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"antimono <span class="main">(</span><span class="main">λ</span><span class="bound">XH</span><span class="main">.</span> <span class="main">-</span> RH <span class="bound">XH</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> antimonoI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> F1_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Diff_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ monoD<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> RH_mono<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">%</span>invisible F2'_antimono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"antimono <span class="main">(</span><span class="main">λ</span><span class="bound">XD</span><span class="main">.</span> <span class="main">-</span> RD_on <span class="main">(</span><span class="free">ds</span><span class="main">-</span><span class="main">{</span><span class="free">d'</span><span class="main">}</span><span class="main">)</span> <span class="bound">XD</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> antimonoI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> F2_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Diff_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ monoD<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> RD_on_mono<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> F'_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono F'"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible F'_def <span class="keyword1"><span class="command">using</span></span> antimonoD<span class="main">[</span><span class="operator">OF</span> F1'_antimono<span class="main">]</span> antimonoD<span class="main">[</span><span class="operator">OF</span> F2'_antimono<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> monoI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> less_eq_dual_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fix_F'_stable_pair_on<span class="main">:</span>
  <span class="quoted"><span class="quoted">"stable_pair_on <span class="main">(</span><span class="free">ds</span> <span class="main">-</span> <span class="main">{</span><span class="free">d'</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>map_prod id undual <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> F' <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">A</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> that <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"F' <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> Rf CH <span class="main">(</span>undual <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="quoted"><span class="quoted">"dual <span class="main">(</span><span class="main">-</span> Rf <span class="main">(</span>CD_on <span class="main">(</span><span class="free">ds</span> <span class="main">-</span> <span class="main">{</span><span class="free">d'</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> F'_apply prod_eq_iff fst_conv snd_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">A</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stable_pair_on_def dual_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We model their update process using the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "while"<span class="antiquote"><span class="antiquote">}</span></span></span></span> combinator,
as we cannot connect it to the extremal fixed points as we did in
\S\ref{sec:contracts-algorithmics} because we begin computing from the
stable match <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">X</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">F'_iter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">×</span> <span class="tfree">'a</span> set dual"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">F'_iter</span> <span class="main">=</span> <span class="main">(</span>while <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> F' <span class="bound">A</span> <span class="main">≠</span> <span class="bound">A</span><span class="main">)</span> F' <span class="main">(</span>XD_smallest <span class="free">ds</span> <span class="free">X</span><span class="main">,</span> dual <span class="main">(</span>XH_largest <span class="free">ds</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">F'_iter_match</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">F'_iter_match</span> <span class="main">≡</span> match <span class="main">(</span>map_prod id undual F'_iter<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> F_start<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"F <span class="free">ds</span> <span class="main">(</span>XD_smallest <span class="free">ds</span> <span class="free">X</span><span class="main">,</span> dual <span class="main">(</span>XH_largest <span class="free">ds</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>XD_smallest <span class="free">ds</span> <span class="free">X</span><span class="main">,</span> dual <span class="main">(</span>XH_largest <span class="free">ds</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible CH_XH_largest<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span><span class="main">]</span> CD_on_XD_smallest<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span><span class="main">]</span> X_subseteq_XH_largest<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">unfolding</span></span> F_def F1_def F2_def XD_smallest_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> F'_start<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>XD_smallest <span class="free">ds</span> <span class="free">X</span><span class="main">,</span> dual <span class="main">(</span>XH_largest <span class="free">ds</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> F' <span class="main">(</span>XD_smallest <span class="free">ds</span> <span class="free">X</span><span class="main">,</span> dual <span class="main">(</span>XH_largest <span class="free">ds</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible F_start <span class="keyword1"><span class="command">unfolding</span></span> F_def F1_def F2_def F'_def
<span class="keyword1"><span class="command">unfolding</span></span> CD_on_def XD_smallest_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_eq_iff dual_less_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> F'_iter_stable_pair_on<span class="main">:</span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="main">(</span><span class="free">ds</span><span class="main">-</span><span class="main">{</span><span class="free">d'</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>map_prod id undual F'_iter<span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?thesis1</span>"</span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> F'_start_le_F'_iter<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>XD_smallest <span class="free">ds</span> <span class="free">X</span><span class="main">,</span> dual <span class="main">(</span>XH_largest <span class="free">ds</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> F'_iter"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?thesis2</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">P</span></span> <span class="keyword2"><span class="keyword">where</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"while_option <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> F' <span class="bound">A</span> <span class="main">≠</span> <span class="bound">A</span><span class="main">)</span> F' <span class="main">(</span><span class="main">(</span>XD_smallest <span class="free">ds</span> <span class="free">X</span><span class="main">)</span><span class="main">,</span> dual <span class="main">(</span>XH_largest <span class="free">ds</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Some <span class="skolem">P</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> while_option_finite_increasing_Some<span class="main">[</span><span class="operator">OF</span> F'_mono _ F'_start<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> while_option_stop2<span class="main">[</span><span class="operator">OF</span> XXX<span class="main">]</span> fix_F'_stable_pair_on<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">P</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis1</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?thesis2</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> funpow_mono2<span class="main">[</span><span class="operator">OF</span> F'_mono _ order.refl F'_start<span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> i<span class="main"><span class="main">=</span></span><span class="quoted"><span class="main">0</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> F'_iter_def while_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> F'_iter_match_stable_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="main">(</span><span class="free">ds</span><span class="main">-</span><span class="main">{</span><span class="free">d'</span><span class="main">}</span><span class="main">)</span> F'_iter_match"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> stable_pair_on_stable_on<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> F'_iter_stable_pair_on<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> F'_iter_match_doctors_weakly_better_off<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Cd <span class="free">d</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">≠</span> <span class="free">d'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> Cd <span class="free">d</span> F'_iter_match<span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> assms
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Cd_Xd Cd_range' stable_on_Xd<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> stable_on_stable_pair_on<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">∈</span>Cd <span class="free">d</span> <span class="main">(</span>XD_smallest <span class="free">ds</span> <span class="free">X</span> <span class="main">∪</span> fst F'_iter<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="free">d</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> Cd_mono<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> X_XD_smallest_XH_largest stable_pair_on_Cd_match<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> F'_iter_stable_pair_on F'_start_le_F'_iter
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">∈</span>Cd <span class="free">d</span> <span class="main">(</span>fst F'_iter<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="free">d</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Pair_le Un_absorb1 prod.collapse<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">d</span> <span class="main">≠</span> <span class="free">d'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span>›</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> stable_pair_on_Cd<span class="main">[</span><span class="operator">OF</span> F'_iter_stable_pair_on<span class="main">,</span> <span class="operator">symmetric</span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">d</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> Cd_domain<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Cd_idem<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> F'_iter_match_hospitals_weakly_worse_off<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>F'_iter_match <span class="main">∪</span> <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> F'_iter_stable_pair_on F'_start_le_F'_iter stable_on_stable_pair_on<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span><span class="main">]</span> X_subseteq_XH_largest<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"F'_iter_match <span class="main">∪</span> <span class="free">X</span> <span class="main">⊆</span> XH_largest <span class="free">ds</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_eq_prod_def le_infI2 less_eq_dual_def<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> assms Ch_range <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> iia_onD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Ch_iia<span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"XH_largest <span class="free"><span class="free"><span class="free">ds</span></span></span> <span class="free"><span class="free"><span class="free">X</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> Ch_CH_irc_idem CH_XH_largest<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citeauthor{HatfieldMilgrom:2005} observe but do not prove that
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "F'_iter_match"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is not necessarily doctor-optimal wrt the new
set of doctors, even if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">X</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> was.

These results seem incomplete. One might expect that the process of
reacting to a doctor's retirement would involve considering new
entrants to the workforce and allowing the set of possible contracts
to be refined. There are also the questions of hospitals opening and
closing.

›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Theorems~8~and~9: A ``rural hospitals'' theorem \label{sec:contracts-rh} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Given that some hospitals are less desirable than others, the question
arises of whether there is a mechanism that can redistribute doctors
to under-resourced hospitals while retaining the stability of the
match. Roth's <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹rural hospitals theorem›<span class="antiquote"><span class="antiquote">}</span></span></span></span>
\citep[Theorem~5.12]{RothSotomayor:1990} resolves this in the negative
by showing that each doctor and hospital signs the same number of
contracts in every stable match. In the context of contracts the
theorem relies on the further hypothesis that hospital choices satisfy
the law of aggregate demand (\S\ref{sec:cf-lad}).

›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ContractsWithLAD <span class="main">=</span> Contracts <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Ch_lad<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> lad <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> ContractsWithSubstitutesAndLAD <span class="main">=</span>
  ContractsWithSubstitutes <span class="main">+</span> ContractsWithLAD

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We can use results that hold under <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "irc"<span class="antiquote"><span class="antiquote">}</span></span></span></span> by discharging that
hypothesis against <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "lad"<span class="antiquote"><span class="antiquote">}</span></span></span></span> using the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source]
"lad_on_substitutes_on_irc_on"<span class="antiquote"><span class="antiquote">}</span></span></span></span> lemma. This is the effect of the
following <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sublocale›</span></span></span></span> command:

›</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> ContractsWithSubstitutesAndLAD <span class="main">&lt;</span> ContractsWithSubstitutesAndIRC
<span class="keyword1"><span class="command">using</span></span> Ch_range Ch_substitutes Ch_lad <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lad_on_substitutes_on_irc_on f_range_onI<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithSubstitutesAndLAD
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The following results lead to \citet[Theorem~8]{HatfieldMilgrom:2005},
and the proofs go as they say. Again we state these with respect to an
arbitrary solution to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "stable_pair"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">XD_XH</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">×</span> <span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Cd_XD_gfp_F_card<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>Cd <span class="free">d</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span>Cd <span class="free">d</span> <span class="main">(</span>fst <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms Cd_lad XD_XH_gfp_F<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>›</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">unfolding</span></span> lad_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Ch_gfp_F_XH_card<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>snd <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Ch_lad XD_XH_gfp_F<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>›</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">unfolding</span></span> lad_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_8<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span> <span class="main">⟹</span> card <span class="main">(</span>Cd <span class="free">d</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span>Cd <span class="free">d</span> <span class="main">(</span>fst <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>snd <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Sum_Cd_gfp</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">∑</span><span class="bound">d</span><span class="main">∈</span><span class="free">ds</span><span class="main">.</span> card <span class="main">(</span>Cd <span class="bound">d</span> <span class="main">(</span>fst <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Sum_Ch_gfp</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">∑</span><span class="bound">h</span><span class="main">∈</span>UNIV<span class="main">.</span> card <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span> <span class="main">(</span>snd <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Sum_Cd_XD</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">∑</span><span class="bound">d</span><span class="main">∈</span><span class="free">ds</span><span class="main">.</span> card <span class="main">(</span>Cd <span class="bound">d</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Sum_Ch_XH</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">∑</span><span class="bound">h</span><span class="main">∈</span>UNIV<span class="main">.</span> card <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span> <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Sum_Cd_gfp</span> <span class="main">=</span> <span class="var">?Sum_Ch_gfp</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stable_pair_on_CD_on_CH<span class="main">[</span><span class="operator">OF</span> gfp_F_stable_pair_on<span class="main">]</span> CD_on_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> CH_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="var">?Sum_Ch_XH</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Ch_gfp_F_XH_card <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?Sum_Cd_XD</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stable_pair_on_CD_on_CH<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>›</span></span><span class="main">]</span> CD_on_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> CH_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Sum_Cd_XD</span> <span class="main">=</span> <span class="var">?Sum_Cd_gfp</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Cd_XD_gfp_F_card <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_iff sum_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Cd_XD_gfp_F_card <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span> <span class="main">⟹</span> card <span class="main">(</span>Cd <span class="free">d</span> <span class="main">(</span>fst <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span>Cd <span class="free">d</span> <span class="main">(</span>fst <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> sum_mono_inv<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Sum_Ch_XH</span> <span class="main">=</span> <span class="var">?Sum_Cd_XD</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stable_pair_on_CD_on_CH<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_pair_on <span class="free">ds</span> <span class="free">XD_XH</span>›</span></span><span class="main">]</span> CD_on_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> CH_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="var">?Sum_Cd_gfp</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Cd_XD_gfp_F_card <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?Sum_Ch_gfp</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stable_pair_on_CD_on_CH<span class="main">[</span><span class="operator">OF</span> gfp_F_stable_pair_on<span class="main">]</span> CD_on_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> CH_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Sum_Ch_gfp</span> <span class="main">=</span> <span class="var">?Sum_Ch_XH</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Ch_gfp_F_XH_card <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_iff sum_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Ch_gfp_F_XH_card <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>snd <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> sym<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sum_mono_inv<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Their result may be more easily understood when phrased in terms of
arbitrary stable matches:

›</span></span>

<span class="keyword1"><span class="command">corollary</span></span> rural_hospitals_theorem<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span> <span class="main">⟹</span> card <span class="main">(</span>Cd <span class="free">d</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span>Cd <span class="free">d</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms T1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span> <span class="quoted"><span class="free">X</span></span><span class="main">]</span> T1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span> <span class="quoted"><span class="free">Y</span></span><span class="main">]</span> Theorem_8 stable_pair_on_Cd_match Ch_CH_irc_idem stable_pair_on_CH
<span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[Theorem~9]{HatfieldMilgrom:2005} show that without <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"lad"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, the rural hospitals theorem does not hold. Their proof does
not seem to justify the theorem as stated (for instance, the contracts
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x'›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>y'›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>z'›</span></span></span></span> need not
exist), and so we instead simply provide a counterexample (discovered
by \verb!nitpick!) to the same effect.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ContractsWithSubstitutesAndIRC<span class="main">)</span> Theorem_9_counterexample<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">Z</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="free">Z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">datatype</span></span> X3 <span class="main">=</span> Xd1 <span class="main">|</span> Xd1' <span class="main">|</span> Xd2
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> X3_UNIV<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"UNIV <span class="main">=</span> set <span class="main">[</span>Xd1<span class="main">,</span> Xd1'<span class="main">,</span> Xd2<span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> X3.exhaust <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemmas</span></span> X3_pow <span class="main">=</span> subset_subseqs<span class="main">[</span><span class="operator">OF</span> subset_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> subset_UNIV Set.equalityD1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> X3_UNIV<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">instance</span></span> X3 <span class="main">::</span> <span class="quoted">finite</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> X3_UNIV<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> X3_all_pow<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">X''</span><span class="main">.</span> <span class="free">P</span> <span class="bound">X''</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">X''</span><span class="main">∈</span>set <span class="main">`</span> set <span class="main">(</span>subseqs <span class="main">[</span>Xd1<span class="main">,</span> Xd1'<span class="main">,</span> Xd2<span class="main">]</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">X''</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> X3_pow <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">X3d</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"X3 <span class="main">⇒</span> D2"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">X3d</span> Xd1 <span class="main">=</span> D1"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">X3d</span> Xd1' <span class="main">=</span> D1"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">X3d</span> Xd2 <span class="main">=</span> D2"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">X3h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"X3 <span class="main">⇒</span> H1"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">X3h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">≡</span> H"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">PX3d</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"D2 <span class="main">⇒</span> X3 rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">PX3d</span> D1 <span class="main">=</span> linord_of_list <span class="main">[</span>Xd1<span class="main">,</span> Xd1'<span class="main">]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">PX3d</span> D2 <span class="main">=</span> linord_of_list <span class="main">[</span>Xd2<span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">CX3h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"H1 <span class="main">⇒</span> X3 set <span class="main">⇒</span> X3 set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">CX3h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd1<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX3h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1'<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd1'<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX3h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd2<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd2<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX3h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1<span class="main">,</span> Xd1'<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd1'<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX3h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1<span class="main">,</span> Xd2<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd1<span class="main">,</span> Xd2<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX3h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1'<span class="main">,</span> Xd2<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd1'<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX3h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{</span>Xd1<span class="main">,</span> Xd1'<span class="main">,</span> Xd2<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Xd1'<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX3h</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cut_tac</span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">b</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> X3_pow<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword1"><span class="command">lemma</span></span> PX3d_linear<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="main">(</span>PX3d <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">d</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linord_of_list_Linear_order<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> PX3d_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span>PX3d <span class="free">d</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> X3d <span class="bound">x</span> <span class="main">=</span> <span class="free">d</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">d</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> CX3h_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CX3h <span class="free">h</span> <span class="free">X</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span><span class="main">∈</span><span class="free">X</span><span class="main">.</span> X3h <span class="bound">x</span> <span class="main">=</span> <span class="free">h</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span> <span class="free">X</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> CX3h.cases<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">)</span></span> H1.exhaust<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> CX3h_singular<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inj_on X3d <span class="main">(</span>CX3h <span class="free">h</span> <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span> <span class="free">X</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> CX3h.cases<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> CX3h_substitutes<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"substitutes <span class="main">(</span>CX3h <span class="free">h</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> substitutes_onI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cut_tac</span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">B</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> X3_pow<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">b</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">a</span></span></span></span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> CX3h_irc<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"irc <span class="main">(</span>CX3h <span class="free">h</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ircI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cut_tac</span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">B</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> X3_pow<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">a</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">interpretation</span></span> Theorem_9<span class="main">:</span> ContractsWithSubstitutesAndIRC <span class="quoted">X3d</span> <span class="quoted">X3h</span> <span class="quoted">PX3d</span> <span class="quoted">CX3h</span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible PX3d_linear PX3d_range CX3h_range CX3h_singular CX3h_substitutes CX3h_irc
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Theorem_9_stable_Xd1'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Theorem_9.stable_on UNIV <span class="main">{</span>Xd1'<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> Theorem_9.stable_onI<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> image_cong_simp <span class="main">[</span><span class="operator">cong</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="keyword1"><span class="command">note</span></span> INF_cong_simp <span class="main">[</span><span class="operator">cong</span><span class="main">]</span> <span class="keyword1"><span class="command">note</span></span> SUP_cong_simp <span class="main">[</span><span class="operator">cong</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Theorem_9.individually_rational_on UNIV <span class="main">{</span>Xd1'<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Theorem_9.individually_rational_onI<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> D2_UNION Theorem_9.CD_on_def Theorem_9.CH_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Theorem_9.stable_no_blocking_on UNIV <span class="main">{</span>Xd1'<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Theorem_9.stable_no_blocking_onI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">h</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cut_tac</span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">X''</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> X3_pow<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_commute<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Theorem_9_stable_Xd1_Xd2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Theorem_9.stable_on UNIV <span class="main">{</span>Xd1<span class="main">,</span> Xd2<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> Theorem_9.stable_onI<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> image_cong_simp <span class="main">[</span><span class="operator">cong</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="keyword1"><span class="command">note</span></span> INF_cong_simp <span class="main">[</span><span class="operator">cong</span><span class="main">]</span> <span class="keyword1"><span class="command">note</span></span> SUP_cong_simp <span class="main">[</span><span class="operator">cong</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Theorem_9.individually_rational_on UNIV <span class="main">{</span>Xd1<span class="main">,</span> Xd2<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Theorem_9.individually_rational_onI<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> D2_UNION Theorem_9.CD_on_def Theorem_9.CH_def insert_commute<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Theorem_9.stable_no_blocking_on UNIV <span class="main">{</span>Xd1<span class="main">,</span> Xd2<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Theorem_9.stable_no_blocking_onI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">h</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cut_tac</span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">X''</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> X3_pow<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> D2_UNION Theorem_9.CD_on_def Theorem_9.maxR_def linord_of_list_linord_of_listP insert_commute<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

This violates the rural hospitals theorem:

›</span></span>

<span class="keyword1"><span class="command">theorem</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>Theorem_9.CH <span class="main">{</span>Xd1'<span class="main">}</span><span class="main">)</span> <span class="main">≠</span> card <span class="main">(</span>Theorem_9.CH <span class="main">{</span>Xd1<span class="main">,</span> Xd2<span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Theorem_9_stable_Xd1' Theorem_9_stable_Xd1_Xd2 Theorem_9.stable_on_CH <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

{\ldots}which is attributed to the failure of the hospitals' choice
functions to satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "lad"<span class="antiquote"><span class="antiquote">}</span></span></span></span>:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> CX3h_not_lad<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>lad <span class="main">(</span>CX3h <span class="free">h</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible lad_on_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">{</span></span>Xd1<span class="main"><span class="main">,</span></span> Xd1'<span class="main"><span class="main">,</span></span> Xd2<span class="main"><span class="main">}</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">{</span></span>Xd1<span class="main"><span class="main">,</span></span> Xd2<span class="main"><span class="main">}</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet{CiupanHatfieldKominers:2016} discuss an alternative approach to
this result in a marriage market.

›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Theorems~15 and 16: Cumulative Offer Processes \label{sec:contracts-cop} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The goal of \citet[{\S}V]{HatfieldMilgrom:2005} is to connect this
theory of contracts with matching to earlier work on auctions by the
first of the authors, in particular by eliminating the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> hypothesis. They do so by defining a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹cumulative
offer process›<span class="antiquote"><span class="antiquote">}</span></span></span></span> (COP):

›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cop_F_HM</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">×</span> <span class="tfree">'x</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">×</span> <span class="tfree">'x</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cop_F_HM</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">XD</span><span class="main">,</span> <span class="bound">XH</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">-</span> RH <span class="bound">XH</span><span class="main">,</span> <span class="bound">XH</span> <span class="main">∪</span> CD_on <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">(</span><span class="main">-</span> RH <span class="bound">XH</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Intuitively all of the doctors simultaneously offer their most
preferred contracts that have yet to be rejected by the hospitals, and
the hospitals choose amongst these and all that have been offered
previously. Asking hospital choice functions to satisfy the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> condition effectively forces hospitals to consider only
the contracts they have previously not rejected.

This definition is neither monotonic nor increasing (i.e., it is not
the case that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">∀</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">≤</span></span> cop_F_HM <span class="free"><span class="free">ds</span></span> <span class="bound"><span class="bound">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>). We rectify
this by focusing on the second part of the definition.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cop_F</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cop_F</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">XH</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">XH</span></span></span> <span class="main">∪</span> CD_on <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">(</span><span class="main">-</span> RH <span class="free"><span class="bound"><span class="entity">XH</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cop_F_HM_cop_F<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cop_F_HM <span class="free">ds</span> <span class="free">XD_XH</span> <span class="main">=</span> <span class="main">(</span><span class="main">-</span> RH <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span><span class="main">,</span> cop_F <span class="free">ds</span> <span class="main">(</span>snd <span class="free">XD_XH</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> cop_F_HM_def cop_F_def split_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> cop_F_increasing<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> cop_F <span class="free">ds</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible cop_F_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We have the following straightforward case distinction principles:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cop_F_cases<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> cop_F <span class="free">ds</span> <span class="free">fp</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>fp<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">fp</span>"</span></span> <span class="main">|</span> <span class="main">(</span>CD_on<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span>RH <span class="free">fp</span><span class="main">)</span> <span class="main">-</span> <span class="free">fp</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> cop_F_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> CH_cop_F_cases<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="free">fp</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>CH<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CH <span class="free">fp</span>"</span></span> <span class="main">|</span> <span class="main">(</span>RH_fp<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> RH <span class="free">fp</span>"</span></span> <span class="main">|</span> <span class="main">(</span>CD_on<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span>RH <span class="free">fp</span><span class="main">)</span> <span class="main">-</span> <span class="free">fp</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms CH_range cop_F_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The existence of fixed points for our earlier definitions
(\S\ref{sec:contracts-algorithmics}) was guaranteed by the
Tarski-Knaster theorem, which relies on the monotonicity of the
defining functional. As <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "cop_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span> lacks this property, we
appeal instead to the Bourbaki-Witt theorem for increasing
functions.

›</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> COP<span class="main">:</span> bourbaki_witt_fixpoint <span class="quoted">Sup</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"cop_F <span class="free">ds</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">ds</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> bourbaki_witt_fixpoint_complete_latticeI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> cop_F_increasing<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fp_cop_F</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fp_cop_F</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">=</span> COP.fixp_above <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">cop</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">≡</span> CH <span class="main">(</span>fp_cop_F <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span>"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemmas</span></span> fp_cop_F_unfold <span class="main">=</span> COP.fixp_above_unfold<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> a<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">{}</span>"</span></span><span class="main">,</span> <span class="operator">folded</span> fp_cop_F_def<span class="main">,</span> <span class="operator">simplified</span> Field_def<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> fp_cop_F_code <span class="main">=</span> COP.fixp_above_conv_while<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> a<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">{}</span>"</span></span><span class="main">,</span> <span class="operator">folded</span> fp_cop_F_def<span class="main">,</span> <span class="operator">simplified</span> Field_def<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Given that the set of contracts is finite, we avoid continuity and
admissibility issues; we have the following straightforward induction
principle:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fp_cop_F_induct<span class="main">[</span><span class="operator">case_names</span> base step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">fp</span><span class="main">.</span> <span class="free">P</span> <span class="bound">fp</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>cop_F <span class="free">ds</span> <span class="bound">fp</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> COP.fixp_above_induct<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> a<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">{}</span></span></span>"</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">folded</span> fp_cop_F_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
   <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> admissible_chfin<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

An alternative is to use the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "while"<span class="antiquote"><span class="antiquote">}</span></span></span></span> combinator, which is
equivalent to the above by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] COP.fixp_above_conv_while<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

In any case, invariant reasoning is essential to verifying the
properties of the COP, no matter how we phrase it. We develop a small
program logic to ease the reuse of the invariants we
prove.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">valid</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">valid</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">{}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fp</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="bound">fp</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="bound">fp</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">(</span>cop_F <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="bound">fp</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">invariant</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">invariant</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> valid <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Intuitively <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"valid <span class="free"><span class="free">ds</span></span> <span class="free"><span class="free">P</span></span> <span class="free"><span class="free">Q</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> asserts that the COP satisfies
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Q</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> assuming that it satisfies <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">P</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. This allows us to
decompose our invariant proofs. By setting the precondition to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"True"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"invariant <span class="free"><span class="free">ds</span></span> <span class="free"><span class="free">P</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> captures the proof obligations of
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">fp_cop_F_induct</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> exactly.

The following lemmas ease the syntactic manipulation of these facts.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> validI<span class="main">[</span><span class="operator">case_names</span> base step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">ds</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">fp</span><span class="main">.</span> <span class="main">⟦</span><span class="free">P</span> <span class="free">ds</span> <span class="bound">fp</span><span class="main">;</span> <span class="free">Q</span> <span class="free">ds</span> <span class="bound">fp</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="free">ds</span> <span class="main">(</span>cop_F <span class="free">ds</span> <span class="bound">fp</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid <span class="free">ds</span> <span class="free">P</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> valid_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> invariant_cop_FD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"invariant <span class="free">ds</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">ds</span> <span class="free">fp</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">ds</span> <span class="main">(</span>cop_F <span class="free">ds</span> <span class="free">fp</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> valid_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> invariantD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"invariant <span class="free">ds</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">ds</span> <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms fp_cop_F_induct <span class="keyword1"><span class="command">unfolding</span></span> valid_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> valid_pre<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid <span class="free">ds</span> <span class="free">P'</span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">fp</span><span class="main">.</span> <span class="free">P</span> <span class="free">ds</span> <span class="bound">fp</span> <span class="main">⟹</span> <span class="free">P'</span> <span class="free">ds</span> <span class="bound">fp</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid <span class="free">ds</span> <span class="free">P</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> valid_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> valid_invariant<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid <span class="free">ds</span> <span class="free">P</span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"invariant <span class="free">ds</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"invariant <span class="free">ds</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">ds</span> <span class="bound">fp</span><span class="main">.</span> <span class="free">P</span> <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">ds</span> <span class="bound">fp</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> valid_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> valid_conj<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid <span class="free">ds</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ds</span> <span class="bound">fp</span><span class="main">.</span> <span class="free">R</span> <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">ds</span> <span class="bound">fp</span><span class="main">)</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid <span class="free">ds</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ds</span> <span class="bound">fp</span><span class="main">.</span> <span class="free">R</span> <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">ds</span> <span class="bound">fp</span><span class="main">)</span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid <span class="free">ds</span> <span class="free">R</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">ds</span> <span class="bound">fp</span><span class="main">.</span> <span class="free">P</span> <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">ds</span> <span class="bound">fp</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">unfolding</span></span> valid_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ContractsWithSubstitutes<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

\citet[Theorem~15]{HatfieldMilgrom:2005} assert that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"fp_cop_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is equivalent to the doctor-offering algorithm <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"gfp_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, assuming <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. (Note that the fixed points
generated by increasing functions do not necessarily form a lattice,
so there is not necessarily a hospital-optimal match, and indeed in
general these do not exist.)  Our proof is eased by the decomposition
lemma <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] gfp_F_lfp_F<span class="antiquote"><span class="antiquote">}</span></span></span></span> and the standard properties of fixed
points in a lattice.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithSubstitutes
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lfp_F2_o_F1_fp_cop_F<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lfp <span class="main">(</span>F2 <span class="free">ds</span> <span class="main">∘</span> F1<span class="main">)</span> <span class="main">=</span> fp_cop_F <span class="free">ds</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>F2 <span class="free">ds</span> <span class="main">∘</span> F1<span class="main">)</span> <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span> <span class="main">⊆</span> cop_F <span class="free">ds</span> <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> F2_def F1_def cop_F_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lfp <span class="main">(</span>F2 <span class="free">ds</span> <span class="main">∘</span> F1<span class="main">)</span> <span class="main">⊆</span> fp_cop_F <span class="free">ds</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfp_lowerbound fp_cop_F_unfold<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fp_cop_F <span class="free">ds</span> <span class="main">⊆</span> lfp <span class="main">(</span>F2 <span class="free">ds</span> <span class="main">∘</span> F1<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> fp_cop_F_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> base <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">fp</span><span class="main">)</span> <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="skolem">fp</span> <span class="main">⊆</span> lfp <span class="main">(</span>F2 <span class="free">ds</span> <span class="main">∘</span> F1<span class="main">)</span>›</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span> RH <span class="skolem">fp</span><span class="main">)</span> <span class="main">⊆</span> lfp <span class="main">(</span>F2 <span class="free">ds</span> <span class="main">∘</span> F1<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> lfp_unfold<span class="main"><span class="main">[</span></span><span class="operator">OF</span> F2_o_F1_mono<span class="main"><span class="main">]</span></span><span class="main">)</span>
         <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Compl_Diff_eq F1_antimono F2_antimono F1_def F2_def Un_subset_iff antimonoD comp_apply<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> IH <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> cop_F_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_15<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gfp_F <span class="free">ds</span> <span class="main">=</span> <span class="main">(</span><span class="main">-</span> RH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span><span class="main">,</span> fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> lfp_F2_o_F1_fp_cop_F <span class="keyword1"><span class="command">unfolding</span></span> gfp_F_lfp_F F1_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_15_match<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"match <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span> <span class="main">=</span> CH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Theorem_15 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> CH_range<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\label{sec:contracts-codegen-fp_cop_F}

With some auxiliary definitions, we can evaluate the COP on the
example from \S\ref{sec:contracts-codegen-gfp_F}.

›</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">P920_example_cop_F</span> <span class="main">=</span> P920_example.cop_F"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">P920_example_fp_cop_F</span> <span class="main">=</span> P920_example.fp_cop_F"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> P920_example_cop_F_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> P920_example.cop_F_def<span class="main">[</span><span class="operator">folded</span> P920_example_cop_F_def<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> P920_example_fp_cop_F_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> P920_example.fp_cop_F_code<span class="main">[</span><span class="operator">folded</span> P920_example_fp_cop_F_def P920_example_cop_F_def<span class="main">]</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> P920_example_fp_cop_F_value<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"P920_example_CH <span class="main">(</span>P920_example_fp_cop_F UNIV<span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span>D1<span class="main">,</span> H1<span class="main">)</span><span class="main">,</span> <span class="main">(</span>D2<span class="main">,</span> H2<span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[Theorem~16]{HatfieldMilgrom:2005} assert that this process
yields a stable match when we have a single hospital (now called an
auctioneer) with unrestricted preferences. As before, this holds
provided the auctioneer's preferences satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "irc"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

We begin by establishing two obvious invariants of the COP that
hold in general.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">%</span>invisible CH_Ch_singular<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>UNIV<span class="main">::</span><span class="tfree">'h</span> set<span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">h</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CH <span class="free">A</span> <span class="main">=</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> CH_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cop_F_range_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cop_F_range_inv</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">fp</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">fp</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cop_F_closed_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cop_F_closed_inv</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">fp</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">fp</span></span></span><span class="main">.</span> above <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="bound">x</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">fp</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The first, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "cop_F_range_inv"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, simply states that the result
of the COP respects the structural conditions for doctors. The second
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "cop_F_closed_inv"<span class="antiquote"><span class="antiquote">}</span></span></span></span> states that the COP is upwards-closed with
respect to the doctors' preferences.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cop_F_range_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"invariant <span class="free">ds</span> cop_F_range_inv"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_def cop_F_range_inv_def cop_F_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CD_on_Cd <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Cd_range'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> cop_F_closed_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"invariant <span class="free">ds</span> cop_F_closed_inv"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_def cop_F_closed_inv_def cop_F_def above_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> subset_iff<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> Cd_preferred ComplI Un_upper1 mem_CD_on_Cd subsetCE<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> fp_cop_F_range_inv <span class="main">=</span> invariantD<span class="main">[</span><span class="operator">OF</span> cop_F_range_inv<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> fp_cop_F_range_inv' <span class="main">=</span> fp_cop_F_range_inv<span class="main">[</span><span class="operator">unfolded</span> cop_F_range_inv_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> fp_cop_F_closed_inv <span class="main">=</span> invariantD<span class="main">[</span><span class="operator">OF</span> cop_F_closed_inv<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> fp_cop_F_closed_inv' <span class="main">=</span> subsetD<span class="main">[</span><span class="operator">OF</span> bspec<span class="main"><span class="main">[</span></span><span class="operator">OF</span> invariantD<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> cop_F_closed_inv<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">unfolded</span> cop_F_closed_inv_def<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">simplified</span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The only challenge in showing that the COP yields a stable match is in
establishing <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "stable_no_blocking_on"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. Our key lemma states
that that if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "CH"<span class="antiquote"><span class="antiquote">}</span></span></span></span> rejects all contracts for doctor
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>d›</span></span></span></span> in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "fp_cop_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, then all contracts for
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>d›</span></span></span></span> are in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "fp_cop_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cop_F_RH<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"aboveS <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="free">x</span> <span class="main">⊆</span> RH <span class="free">fp</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> cop_F <span class="free">ds</span> <span class="free">fp</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms Pd_linear <span class="keyword1"><span class="command">unfolding</span></span> cop_F_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CD_on_Cd Cd_greatest greatest_def aboveS_def order_on_defs total_on_def subset_iff<span class="main">)</span>
   <span class="main">(</span><span class="operator">metis</span> Compl_Diff_eq Compl_iff Diff_iff IntE Pd_Xd refl_onD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fp_cop_F_all<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> CH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="main">⊆</span> fp_cop_F <span class="free">ds</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> spec<span class="main">[</span><span class="operator">OF</span> Pd_linear<span class="main">]</span> this finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">Pd</span> <span class="free">d</span>"</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> fp_cop_F <span class="free">ds</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_Linear_order_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> assms Pd_range Pd_Xd cop_F_RH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">d</span></span> <span class="quoted"><span class="free">ds</span></span> <span class="main">_</span> <span class="quoted"><span class="quoted">"fp_cop_F <span class="free">ds</span>"</span></span><span class="main">,</span> <span class="operator">unfolded</span> fp_cop_F_unfold<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> aboveS_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">iff</span><span class="main"><span class="main">:</span></span> image_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet{AygunSonmez:2012-WP2} observe that any blocking contract must
be weakly preferred by its doctor to anything in the outcome of the
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "fp_cop_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span>:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fp_cop_F_preferred<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span>CH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span> <span class="main">∪</span> <span class="free">X''</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span> <span class="main">=</span> <span class="free">Xd</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms fp_cop_F_range_inv'<span class="main">[</span><span class="operator">OF</span> CH_range'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span> Pd_Xd Pd_linear
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> CD_on_def Cd_greatest greatest_def<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> Int_iff Un_iff subset_refl underS_incl_iff<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The headline lemma cobbles these results together.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> X''_closed<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">X''</span> <span class="main">⊆</span> CD_on <span class="free">ds</span> <span class="main">(</span>CH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span> <span class="main">∪</span> <span class="free">X''</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">X''</span> <span class="main">⊆</span> fp_cop_F <span class="free">ds</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">X''</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> fp_cop_F <span class="free">ds</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="free">Xd</span> <span class="main">`</span> CH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">y</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> CH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command">with</span></span> assms <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="free">X''</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> CH_range fp_cop_F_closed_inv' fp_cop_F_preferred <span class="keyword1"><span class="command">unfolding</span></span> above_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> assms <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="free">X''</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Cd_range' IntD2 fp_cop_F_all mem_CD_on_Cd rev_subsetD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Contracts<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "irc"<span class="antiquote"><span class="antiquote">}</span></span></span></span> constraint on the auctioneer's preferences is
needed for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "stable_no_blocking"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and their part of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"individually_rational"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithIRC
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cop_stable_no_blocking_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable_no_blocking_on <span class="free">ds</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> stable_no_blocking_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="skolem">X''</span>
  <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">=</span> <span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span>CH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">≠</span> <span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span>CH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> CD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">⊆</span> CD_on <span class="free">ds</span> <span class="main">(</span>CH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> CD <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">⊆</span> fp_cop_F <span class="free">ds</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> X''_closed<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"CH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span> <span class="main">∪</span> <span class="skolem">X''</span> <span class="main">⊆</span> fp_cop_F <span class="free">ds</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> CH_range <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> C NE Ch_CH_irc_idem<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">h</span></span><span class="main">]</span>  <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">using</span></span> consistency_onD<span class="main">[</span><span class="operator">OF</span> Ch_consistency _ X<span class="main">]</span> CH_domain Ch_domain <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_16<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>UNIV<span class="main">::</span><span class="tfree">'c</span> set<span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">h</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="var">?fp</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> stable_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"individually_rational_on <span class="free">ds</span> <span class="var">?fp</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> individually_rational_onI<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> h <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"allocation <span class="var">?fp</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Ch_singular CH_Ch_singular<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"CD_on <span class="free">ds</span> <span class="var">?fp</span> <span class="main">=</span> <span class="var">?fp</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> CD_on_closed<span class="main">)</span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> CH_range' fp_cop_F_range_inv'<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"CH <span class="main">(</span>CH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> CH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> CH_irc_idem<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"stable_no_blocking_on <span class="free">ds</span> <span class="var">?fp</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cop_stable_no_blocking_on<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Concluding remarks ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

From \citet{HatfieldMilgrom:2005}, we have not shown Theorems~2, 7, 13
and~14, all of which are intended to position their results against
prior work in this space. We delay establishing their strategic
results (Theorems~10, 11 and~12) to \S\ref{sec:strategic}, after we
have developed more useful invariants for the COP.

By assuming \isa{irc}, \citet{AygunSonmez:2012-WP2} are essentially
trading on Plott's path independence condition
(\S\ref{sec:cf-path-independence}), as observed by
\citet{ChambersYenmez:2013}. The latter show that these results
generalize naturally to many-to-many matches, where doctors also use
path-independent choice functions; see also \citet{Fleiner:2003}.

For many applications, however, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> proves to be
too strong a condition. The COP of \S\ref{sec:contracts-cop} provides
a way forward, as we discuss in the next section.

›</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="COP">
<div class="head">
<h1>Theory COP</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> COP
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Contracts.html">Contracts</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ \citet{HatfieldKojima:2010}: Substitutes and stability for matching with contracts \label{sec:cop} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet{HatfieldKojima:2010} set about weakening <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
and therefore making the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹cumulative offer processes›<span class="antiquote"><span class="antiquote">}</span></span></span></span> (COPs,
\S\ref{sec:contracts-cop}) applicable to more matching problems. In
doing so they lose the lattice structure of the stable matches, which
necessitates redeveloping the results of \S\ref{sec:contracts}.

In contrast to the COP of \S\ref{sec:contracts-cop},
\citet{HatfieldKojima:2010} develop and analyze a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span>
‹single-offer›<span class="antiquote"><span class="antiquote">}</span></span></span></span> variant, where only one doctor (who has
no held contract) proposes per round. The order of doctors making
offers is not specified. We persist with the simultaneous-offer COP as
it is deterministic. See \citet{HirataKasuya:2014} for equivalence
arguments.

We begin with some observations due to
\citeauthor{AygunSonmez:2012-WP}. Firstly, as for the
matching-with-contracts setting of \S\ref{sec:contracts},
\citet{AygunSonmez:2012-WP} demonstrate that these results depend on
hospital preferences satisfying <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "irc"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. We do not formalize
their examples. Secondly, an alternative to hospitals having choice
functions (as we have up to now) is for the hospitals to have
preference orders over sets, which is suggested by both
\citet{HatfieldMilgrom:2005} (weakly) and \citet{HatfieldKojima:2010}.
\citet[\S2]{AygunSonmez:2012-WP} argue that this approach is
under-specified and propose to define <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Ch›</span></span></span></span> as choosing
amongst maximal elements of some non-strict preference order (i.e.,
including indifference). They then claim that this is equivalent to
taking <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Ch›</span></span></span></span> as primitive, and so we continue down that
path.

›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Theorem~1: the COP yields a stable match under <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹bilateral substitutes›<span class="antiquote"><span class="antiquote">}</span></span></span></span> ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The weakest replacement condition suggested by
\citet[\S1]{HatfieldKojima:2010} for the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
condition on hospital choice functions is termed <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹bilateral
substitutes›<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
\begin{quote}

Contracts are <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹bilateral substitutes›<span class="antiquote"><span class="antiquote">}</span></span></span></span> for a hospital if there are
no two contracts <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>z›</span></span></span></span> and a set of
contracts <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Y›</span></span></span></span> with other doctors than those associated
with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>z›</span></span></span></span> such that the hospital that
regards <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Y›</span></span></span></span> as available wants to sign <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>z›</span></span></span></span>
if and only if <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> becomes available. In other words,
contracts are bilateral substitutes when any hospital, presented with
an offer from a doctor he does not currently employ, never wishes to
also hire another doctor he does not currently employ at a contract he
previously rejected.

\end{quote}

Note that this constraint is specific to this matching-with-contracts
setting, unlike those of \S\ref{sec:cf}.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bilateral_substitutes_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">⇒</span> <span class="tfree">'x</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bilateral_substitutes_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>
     <span class="main">⟷</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∃</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> <span class="free">Xd</span> <span class="bound">a</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="bound">B</span> <span class="main">∧</span> <span class="free">Xd</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="bound">B</span>
                     <span class="main">∧</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">bilateral_substitutes</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bilateral_substitutes</span> <span class="main">≡</span> bilateral_substitutes_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bilateral_substitutes_on_def2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bilateral_substitutes_on <span class="free">A</span> <span class="free">f</span>
     <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">b</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">a</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="bound">B</span> <span class="main">∧</span> <span class="free">Xd</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="bound">B</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> iffI<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">a</span> <span class="skolem">b</span>
  <span class="keyword3"><span class="command">assume</span></span> lhs<span class="main">:</span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">a</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">b</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> XXX <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_absorb<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> lhs XXX <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> bilateral_substitutes_on_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute insert_absorb<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bilateral_substitutes_on_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> bilateral_substitutes_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> bilateral_substitutes_on_def2<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> bilateral_substitutes_onD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> bilateral_substitutes_on_def2<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> bilateral_substitutes_def <span class="main">=</span> bilateral_substitutes_on_def2<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted">UNIV</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> bilateral_substitutesI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> bilateral_substitutes_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> bilateral_substitutesD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> bilateral_substitutes_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> substitutes_on_bilateral_substitutes_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"substitutes_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bilateral_substitutes_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bilateral_substitutes_onI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> substitutes_onD<span class="main"><span class="main">[</span></span><span class="operator">rotated</span> -1<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[\S4, Definition~5]{AygunSonmez:2012-WP} give the following
equivalent definition:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bilateral_substitutes_on_def3<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bilateral_substitutes_on <span class="free">A</span> <span class="free">f</span>
     <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">b</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">Xd</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free">Xd</span> <span class="main">`</span> <span class="bound">B</span> <span class="main">∨</span> <span class="free">Xd</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free">Xd</span> <span class="main">`</span> <span class="bound">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible bilateral_substitutes_on_def2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

As before, we define a series of locales that capture the relevant
hypotheses about hospital choice functions.

›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ContractsWithBilateralSubstitutes <span class="main">=</span> Contracts <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Ch_bilateral_substitutes<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> bilateral_substitutes <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> ContractsWithSubstitutes <span class="main">&lt;</span> ContractsWithBilateralSubstitutes
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Ch_substitutes <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> substitutes_on_bilateral_substitutes_on<span class="main">)</span>

<span class="keyword1"><span class="command">locale</span></span> ContractsWithBilateralSubstitutesAndIRC <span class="main">=</span>
  ContractsWithBilateralSubstitutes <span class="main">+</span> ContractsWithIRC

<span class="keyword1"><span class="command">sublocale</span></span> ContractsWithSubstitutesAndIRC <span class="main">&lt;</span> ContractsWithBilateralSubstitutesAndIRC
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithBilateralSubstitutesAndIRC
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The key difficulty in showing the stability of the result of the COP
under this condition \citep[Theorem~1]{HatfieldKojima:2010} is in
proving that it ensures we get an <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "allocation"<span class="antiquote"><span class="antiquote">}</span></span></span></span>; the remainder
of the proof of \S\ref{sec:contracts-cop} (for a single hospital,
where this property is trivial) goes through unchanged. We avail
ourselves of \citet[Lemma]{HirataKasuya:2014}, which they say is a
restatement of the proof of
\citet[Theorem~1]{HatfieldKojima:2010}. See also
\citet[Appendix~A]{AygunSonmez:2012-WP}.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bilateral_substitutes_lemma<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">≠</span> <span class="free">Xd</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> notI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x'</span></span> <span class="keyword2"><span class="keyword">where</span></span> x'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">X</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x'</span> <span class="main">=</span> <span class="free">d</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> Ch_irc <span class="quoted"><span class="quoted">‹<span class="free">d</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">X</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> irc_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">y</span> <span class="main">∉</span> <span class="main">{</span><span class="free">Xd</span> <span class="free">x</span><span class="main">,</span> <span class="free">d</span><span class="main">}</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> Ch_range <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">d</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">d</span> <span class="main">≠</span> <span class="free">Xd</span> <span class="free">x</span>›</span></span> x'
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="skolem">x'</span> <span class="var">?X'</span><span class="main">)</span> <span class="main">=</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> consistencyD<span class="main">[</span><span class="operator">OF</span> Ch_consistency<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">h</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">x'</span> <span class="var">?X'</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">iff</span><span class="main"><span class="main">:</span></span> image_iff<span class="main">)</span> <span class="comment1">(* slow *)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> Ch_range Ch_singular <span class="quoted"><span class="quoted">‹<span class="free">d</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>›</span></span> x' <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">X</span><span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="free">x</span> <span class="main">(</span>insert <span class="skolem">x'</span> <span class="var">?X'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">X</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> consistencyD<span class="main">[</span><span class="operator">OF</span> Ch_consistency<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">h</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"insert <span class="free">x</span> <span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"insert <span class="free">x</span> <span class="main">(</span>insert <span class="skolem">x'</span> <span class="var">?X'</span><span class="main">)</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute<span class="main">)</span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="free">d</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>›</span></span> x'
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">using</span></span> bilateral_substitutesD<span class="main">[</span><span class="operator">OF</span> spec<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Ch_bilateral_substitutes<span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="quoted"><span class="free">h</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> a<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> b<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">x'</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="var">?X'</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

Our proof essentially adds the inductive details these earlier efforts
skipped over. It is somewhat complicated by our use of the
simultaneous-offer COP.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bilateral_substitutes_lemma_union<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span> <span class="main">∩</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Y</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"allocation <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">Y</span></span><span class="main">]</span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">d</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bilateral_substitutes_lemma<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> cop_F_CH_CD_on_disjoint<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cop_F_closed_inv <span class="free">ds</span> <span class="free">fp</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cop_F_range_inv <span class="free">ds</span> <span class="free">fp</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="main">`</span> CH <span class="free">fp</span> <span class="main">∩</span> <span class="free">Xd</span> <span class="main">`</span> <span class="main">(</span>CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span> RH <span class="free">fp</span><span class="main">)</span> <span class="main">-</span> <span class="free">fp</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms CH_range <span class="keyword1"><span class="command">unfolding</span></span> cop_F_range_inv_def cop_F_closed_inv_def above_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_eq_iff mem_CD_on_Cd Cd_greatest greatest_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Our key lemma shows that we effectively have <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
for rejected contracts, provided the relevant doctor does not have a
contract held with the relevant hospital. Note the similarity to
Theorem~4 (\S\ref{sec:cop-theorem-4}).

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cop_F_RH_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cop_F_closed_inv <span class="free">ds</span> <span class="free">fp</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cop_F_range_inv <span class="free">ds</span> <span class="free">fp</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="free">x</span><span class="main">)</span> <span class="free">fp</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> RH <span class="free">fp</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> RH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="free">fp</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> RH <span class="free">fp</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> cop_F <span class="free">ds</span> <span class="free">fp</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> cop_F_increasing <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="free">fp</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> Ch_singular <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="free">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> RH <span class="free">fp</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>cop_F <span class="free">ds</span> <span class="free">fp</span><span class="main">)</span> <span class="main">=</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">fp</span> <span class="main">∪</span> <span class="main">(</span>CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span>RH <span class="free">fp</span><span class="main">)</span> <span class="main">-</span> <span class="free">fp</span> <span class="main">-</span> <span class="main">{</span><span class="bound">z</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">z</span> <span class="main">=</span> <span class="free">Xd</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> cop_F_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> consistencyD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Ch_consistency<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CH_Ch <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range' inj_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> cop_F_CH_CD_on_disjoint<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹cop_F_closed_inv <span class="free">ds</span> <span class="free">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹cop_F_range_inv <span class="free">ds</span> <span class="free">fp</span>›</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>cop_F <span class="free">ds</span> <span class="free">fp</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">rule</span> bilateral_substitutes_lemma_union<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="free">x</span><span class="main">)</span> <span class="free">fp</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span>
             <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> CH_def CD_on_inj_on_Xd inj_on_diff<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="free">fp</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mem_CH_Ch<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cop_F_allocation_inv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid <span class="free">ds</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ds</span> <span class="bound">fp</span><span class="main">.</span> cop_F_range_inv <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> cop_F_closed_inv <span class="bound">ds</span> <span class="bound">fp</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ds</span> <span class="bound">fp</span><span class="main">.</span> allocation <span class="main">(</span>CH <span class="bound">fp</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> validI<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> base <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> CH_simps<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">fp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"allocation <span class="main">(</span>CH <span class="skolem">fp</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cop_F_closed_inv <span class="free">ds</span> <span class="skolem">fp</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cop_F_range_inv <span class="free">ds</span> <span class="skolem">fp</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">note</span></span> cop_F_CH_CD_on_disjoint <span class="main">=</span> cop_F_CH_CD_on_disjoint<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹cop_F_closed_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹cop_F_range_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> cop_F_RH_mono <span class="main">=</span> cop_F_RH_mono<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹cop_F_closed_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹cop_F_range_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> inj_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xh</span> <span class="skolem">y</span> <span class="main">=</span> <span class="free">Xh</span> <span class="skolem">x</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> Ch_singular <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">y</span>›</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CH_Ch <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_onD<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xh</span> <span class="skolem">y</span> <span class="main">≠</span> <span class="free">Xh</span> <span class="skolem">x</span>›</span></span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> CH_cop_F_cases<span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> CH <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CH <span class="skolem">fp</span>›</span></span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> CH_cop_F_cases<span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> CH <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CH <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="main">(</span>CH <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CH <span class="skolem">fp</span>›</span></span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_onD<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> RH_fp <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> RH <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="main">(</span>CH <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xh</span> <span class="skolem">y</span> <span class="main">≠</span> <span class="free">Xh</span> <span class="skolem">x</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CH <span class="skolem">fp</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">y</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">y</span><span class="main">)</span> <span class="skolem">fp</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> Ch_CH_irc_idem Ch_range' inj_on_contraD<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> RH <span class="skolem">fp</span>›</span></span> cop_F_RH_mono <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> CD_on <span class="keyword1"><span class="command">note</span></span> y' <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span> RH <span class="skolem">fp</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">with</span></span> cop_F_CH_CD_on_disjoint <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CH <span class="skolem">fp</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> RH_fp <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> RH <span class="skolem">fp</span>›</span></span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> CH_cop_F_cases<span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> CH <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CH <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="main">(</span>CH <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xh</span> <span class="skolem">y</span> <span class="main">≠</span> <span class="free">Xh</span> <span class="skolem">x</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CH <span class="skolem">fp</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">fp</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> Ch_CH_irc_idem Ch_range' inj_on_contraD<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> RH <span class="skolem">fp</span>›</span></span> cop_F_RH_mono <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> RH_fp <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> RH <span class="skolem">fp</span>›</span></span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">fp</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> True
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="main">(</span>CH <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xh</span> <span class="skolem">y</span> <span class="main">≠</span> <span class="free">Xh</span> <span class="skolem">x</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">y</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">y</span><span class="main">)</span> <span class="skolem">fp</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> Ch_range' inj_onD mem_CH_Ch<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> RH <span class="skolem">fp</span>›</span></span> cop_F_RH_mono <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">fp</span>›</span></span>
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> RH <span class="skolem">fp</span>›</span></span> cop_F_RH_mono <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> CD_on <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span> RH <span class="skolem">fp</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">from</span></span> cop_F_CH_CD_on_disjoint <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span> RH <span class="skolem">fp</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">fp</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> CH_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range'<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> RH <span class="skolem">fp</span>›</span></span> cop_F_RH_mono <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> CD_on <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span> RH <span class="skolem">fp</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">fp</span>›</span></span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> CH_cop_F_cases<span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> CH <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CH <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">with</span></span> cop_F_CH_CD_on_disjoint <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span> RH <span class="skolem">fp</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">fp</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> RH_fp <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> RH <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">from</span></span> cop_F_CH_CD_on_disjoint <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span> RH <span class="skolem">fp</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">y</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">y</span><span class="main">)</span> <span class="skolem">fp</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> CH_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range'<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> RH <span class="skolem">fp</span>›</span></span> cop_F_RH_mono <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> CD_on <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span> RH <span class="skolem">fp</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span> RH <span class="skolem">fp</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">fp</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> CD_on_inj_on_Xd DiffD1 inj_on_eq_iff<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fp_cop_F_allocation<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"allocation <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"invariant <span class="free">ds</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ds</span> <span class="bound">fp</span><span class="main">.</span> cop_F_range_inv <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> cop_F_closed_inv <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> allocation <span class="main">(</span>CH <span class="bound">fp</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cop_F_range_inv cop_F_closed_inv cop_F_allocation_inv
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> valid_conj <span class="main"><span class="keyword3">|</span></span> <span class="operator">blast</span> <span class="main"><span class="keyword3">|</span></span> <span class="operator">rule</span> valid_pre<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> invariantD<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> stable_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"individually_rational_on <span class="free">ds</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> individually_rational_onI<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> fp_cop_F_allocation <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"CD_on <span class="free">ds</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span> <span class="main">=</span> cop <span class="free">ds</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> CD_on_closed<span class="main">)</span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fp_cop_F_range_inv' CH_range'<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"CH <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span> <span class="main">=</span> cop <span class="free">ds</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> CH_irc_idem<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"stable_no_blocking_on <span class="free">ds</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cop_stable_no_blocking_on<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ContractsWithBilateralSubstitutesAndIRC<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

\citet[\S3.1]{HatfieldKojima:2010} provide an example that shows that
the traditional optimality and strategic results do not hold under
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "bilateral_substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, which motivates looking for a
stronger condition that remains weaker than <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

Their example involves two doctors, two hospitals, and five contracts.

›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> X5 <span class="main">=</span> Xd1 <span class="main">|</span> Xd1' <span class="main">|</span> Xd2 <span class="main">|</span> Xd2' <span class="main">|</span> Xd2''

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">X5d</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"X5 <span class="main">⇒</span> D2"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">X5d</span> Xd1 <span class="main">=</span> D1"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">X5d</span> Xd1' <span class="main">=</span> D1"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">X5d</span> Xd2 <span class="main">=</span> D2"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">X5d</span> Xd2' <span class="main">=</span> D2"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">X5d</span> Xd2'' <span class="main">=</span> D2"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">X5h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"X5 <span class="main">⇒</span> H2"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">X5h</span> Xd1 <span class="main">=</span> H1"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">X5h</span> Xd1' <span class="main">=</span> H1"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">X5h</span> Xd2 <span class="main">=</span> H1"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">X5h</span> Xd2' <span class="main">=</span> H2"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">X5h</span> Xd2'' <span class="main">=</span> H1"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">PX5d</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"D2 <span class="main">⇒</span> X5 rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">PX5d</span> D1 <span class="main">=</span> linord_of_list <span class="main">[</span>Xd1<span class="main">,</span> Xd1'<span class="main">]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">PX5d</span> D2 <span class="main">=</span> linord_of_list <span class="main">[</span>Xd2<span class="main">,</span> Xd2'<span class="main">,</span> Xd2''<span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">CX5h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"H2 <span class="main">⇒</span> X5 cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">CX5h</span> H1 <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span>
     <span class="main">(</span><span class="keyword1">if</span> <span class="main">{</span>Xd1'<span class="main">,</span> Xd2<span class="main">}</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> <span class="main">{</span>Xd1'<span class="main">,</span> Xd2<span class="main">}</span> <span class="keyword1">else</span>
      <span class="keyword1">if</span> <span class="main">{</span>Xd2''<span class="main">}</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> <span class="main">{</span>Xd2''<span class="main">}</span> <span class="keyword1">else</span>
      <span class="keyword1">if</span> <span class="main">{</span>Xd1<span class="main">}</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> <span class="main">{</span>Xd1<span class="main">}</span> <span class="keyword1">else</span>
      <span class="keyword1">if</span> <span class="main">{</span>Xd1'<span class="main">}</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> <span class="main">{</span>Xd1'<span class="main">}</span> <span class="keyword1">else</span>
      <span class="keyword1">if</span> <span class="main">{</span>Xd2<span class="main">}</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> <span class="main">{</span>Xd2<span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CX5h</span> H2 <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="main">{</span> <span class="bound">x</span> <span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">=</span> Xd2' <span class="main">}</span>"</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> X5_UNIV<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"UNIV <span class="main">=</span> set <span class="main">[</span>Xd1<span class="main">,</span> Xd1'<span class="main">,</span> Xd2<span class="main">,</span> Xd2'<span class="main">,</span> Xd2''<span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> X5.exhaust <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemmas</span></span> X5_pow <span class="main">=</span> subset_subseqs<span class="main">[</span><span class="operator">OF</span> subset_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> subset_UNIV Set.equalityD1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> X5_UNIV<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">instance</span></span> X5 <span class="main">::</span> <span class="quoted">finite</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> X5_UNIV<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> X5_ALL<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">X''</span><span class="main">.</span> <span class="free">P</span> <span class="bound">X''</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">X''</span><span class="main">∈</span>set <span class="main">`</span> set <span class="main">(</span>subseqs <span class="main">[</span>Xd1<span class="main">,</span> Xd1'<span class="main">,</span> Xd2<span class="main">,</span> Xd2'<span class="main">,</span> Xd2''<span class="main">]</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">X''</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> X5_pow <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> PX5d_linear<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="main">(</span>PX5d <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">d</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linord_of_list_Linear_order<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> PX5d_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span>PX5d <span class="free">d</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> X5d <span class="bound">x</span> <span class="main">=</span> <span class="free">d</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">d</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> CX5h_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CX5h <span class="free">h</span> <span class="free">X</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> X5h <span class="bound">x</span> <span class="main">=</span> <span class="free">h</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> CX5h_singular<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inj_on X5d <span class="main">(</span>CX5h <span class="free">h</span> <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> inj_onI<span class="main">)</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> BSI<span class="main">:</span> Contracts <span class="quoted">X5d</span> <span class="quoted">X5h</span> <span class="quoted">PX5d</span> <span class="quoted">CX5h</span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible PX5d_linear PX5d_range CX5h_range CX5h_singular <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> CX5h_bilateral_substitutes<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"BSI.bilateral_substitutes <span class="main">(</span>CX5h <span class="free">h</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> BSI.bilateral_substitutes_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> X5_ALL<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> CX5h_irc<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"irc <span class="main">(</span>CX5h <span class="free">h</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> irc_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> X5_ALL<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> BSI<span class="main">:</span> ContractsWithBilateralSubstitutesAndIRC <span class="quoted">X5d</span> <span class="quoted">X5h</span> <span class="quoted">PX5d</span> <span class="quoted">CX5h</span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible CX5h_bilateral_substitutes CX5h_irc <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

There are two stable matches in this model.

›</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> Xd1_Xd2'_stable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"BSI.stable <span class="main">{</span>Xd1<span class="main">,</span> Xd2'<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> BSI.stable_onI<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> image_cong_simp <span class="main">[</span><span class="operator">cong</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="keyword1"><span class="command">note</span></span> INF_cong_simp <span class="main">[</span><span class="operator">cong</span><span class="main">]</span> <span class="keyword1"><span class="command">note</span></span> SUP_cong_simp <span class="main">[</span><span class="operator">cong</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"BSI.individually_rational <span class="main">{</span>Xd1<span class="main">,</span> Xd2'<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> BSI.individually_rational_on_def BSI.CD_on_def BSI.CH_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute D2_UNION H2_UNION<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"BSI.stable_no_blocking <span class="main">{</span>Xd1<span class="main">,</span> Xd2'<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> BSI.stable_no_blocking_on_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> X5_ALL BSI.blocking_on_def BSI.mem_CD_on_Cd BSI.maxR_def linord_of_list_linord_of_listP<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Xd1'_Xd2_stable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"BSI.stable <span class="main">{</span>Xd1'<span class="main">,</span> Xd2<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> BSI.stable_onI<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> image_cong_simp <span class="main">[</span><span class="operator">cong</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="keyword1"><span class="command">note</span></span> INF_cong_simp <span class="main">[</span><span class="operator">cong</span><span class="main">]</span> <span class="keyword1"><span class="command">note</span></span> SUP_cong_simp <span class="main">[</span><span class="operator">cong</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"BSI.individually_rational <span class="main">{</span>Xd1'<span class="main">,</span> Xd2<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> BSI.individually_rational_on_def BSI.CD_on_def BSI.CH_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute D2_UNION H2_UNION<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"BSI.stable_no_blocking <span class="main">{</span>Xd1'<span class="main">,</span> Xd2<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> BSI.stable_no_blocking_on_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> X5_ALL BSI.blocking_on_def BSI.mem_CD_on_Cd BSI.maxR_def linord_of_list_linord_of_listP<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BSI_stable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"BSI.stable <span class="free">X</span> <span class="main">⟷</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{</span>Xd1<span class="main">,</span> Xd2'<span class="main">}</span> <span class="main">∨</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{</span>Xd1'<span class="main">,</span> Xd2<span class="main">}</span>"</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> X5_pow<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">X</span></span><span class="main">]</span> BSI.stable_on_allocation<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_eq_iff<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> BSI.stable_on_def BSI.individually_rational_on_def BSI.stable_no_blocking_on_def BSI.blocking_on_def BSI.CH_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 0 1 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> D2_UNION H2_UNION X5_ALL BSI.mem_CD_on_Cd BSI.maxR_def linord_of_list_linord_of_listP<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> Xd1'_Xd2_stable Xd1_Xd2'_stable <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Contracts<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

Therefore there is no doctor-optimal match under these preferences:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∃</span> <span class="main">(</span><span class="bound">Y</span><span class="main">::</span>X5 set<span class="main">)</span><span class="main">.</span> BSI.doctor_optimal_match UNIV <span class="bound">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> BSI.doctor_optimal_match_def BSI_stable
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cut_tac</span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">Y</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> X5_pow<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_eq_iff<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> X5_ALL linord_of_list_linord_of_listP<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Theorem~3: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹pareto separability›<span class="antiquote"><span class="antiquote">}</span></span></span></span> relates <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹unilateral substitutes›<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹substitutes›<span class="antiquote"><span class="antiquote">}</span></span></span></span> ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[\S4]{HatfieldKojima:2010} proceed to define <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹unilateral
substitutes›<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
\begin{quote}

[P]references satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹unilateral substitutes›<span class="antiquote"><span class="antiquote">}</span></span></span></span> if whenever a
hospital rejects the contract <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">z</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> when that is the only
contract with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Xd</span></span> <span class="free"><span class="free">z</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> available, it still rejects the contract
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">z</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> when the choice set expands.

\end{quote}

›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">unilateral_substitutes_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">⇒</span> <span class="tfree">'x</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unilateral_substitutes_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>
     <span class="main">⟷</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∃</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> <span class="free">Xd</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="bound">B</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">unilateral_substitutes</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unilateral_substitutes</span> <span class="main">≡</span> unilateral_substitutes_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unilateral_substitutes_on_def2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"unilateral_substitutes_on <span class="free">A</span> <span class="free">f</span>
     <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">b</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="bound">B</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> iffI<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">a</span> <span class="skolem">b</span>
  <span class="keyword3"><span class="command">assume</span></span> lhs<span class="main">:</span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">b</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> XXX <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_absorb<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> lhs XXX <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> unilateral_substitutes_on_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute insert_absorb<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> unilateral_substitutes_on_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible unilateral_substitutes_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> unilateral_substitutes_on_def2<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible unilateral_substitutes_onD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> unilateral_substitutes_on_def2<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible unilateral_substitutes_def <span class="main">=</span> unilateral_substitutes_on_def2<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted">UNIV</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible unilateral_substitutesI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> unilateral_substitutes_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible unilateral_substitutesD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> unilateral_substitutes_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[\S4, Definition~6]{AygunSonmez:2012-WP} give the following equivalent definition:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unilateral_substitutes_on_def3<span class="main">:</span>
  <span class="quoted"><span class="quoted">"unilateral_substitutes_on <span class="free">A</span> <span class="free">f</span>
     <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">b</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">Xd</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free">Xd</span> <span class="main">`</span> <span class="bound">B</span><span class="main">)</span>"</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="main">%</span>invisible unilateral_substitutes_on_def2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible unilateral_substitutes_def3 <span class="main">=</span> unilateral_substitutes_on_def3<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted">UNIV</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible unilateral_substitutesD3 <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> unilateral_substitutes_def3<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> substitutes_on_unilateral_substitutes_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"substitutes_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"unilateral_substitutes_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> unilateral_substitutes_onI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> substitutes_onD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> unilateral_substitutes_on_bilateral_substitutes_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"unilateral_substitutes_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bilateral_substitutes_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bilateral_substitutes_onI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> unilateral_substitutes_onD<span class="main"><span class="main">[</span></span><span class="operator">rotated</span> -1<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The following defines locales for the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"unilateral_substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> hypothesis, and inserts these between those
for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "bilateral_substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> ContractsWithUnilateralSubstitutes <span class="main">=</span> Contracts <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Ch_unilateral_substitutes<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> unilateral_substitutes <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> ContractsWithUnilateralSubstitutes <span class="main">&lt;</span> ContractsWithBilateralSubstitutes
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Ch_unilateral_substitutes <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> unilateral_substitutes_on_bilateral_substitutes_on<span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> ContractsWithSubstitutes <span class="main">&lt;</span> ContractsWithUnilateralSubstitutes
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Ch_substitutes <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> substitutes_on_unilateral_substitutes_on<span class="main">)</span>

<span class="keyword1"><span class="command">locale</span></span> ContractsWithUnilateralSubstitutesAndIRC <span class="main">=</span>
  ContractsWithUnilateralSubstitutes <span class="main">+</span> ContractsWithIRC

<span class="keyword1"><span class="command">sublocale</span></span> ContractsWithUnilateralSubstitutesAndIRC <span class="main">&lt;</span> ContractsWithBilateralSubstitutesAndIRC
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">sublocale</span></span> ContractsWithSubstitutesAndIRC <span class="main">&lt;</span> ContractsWithUnilateralSubstitutesAndIRC
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Contracts<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

\citet[Theorem~3]{HatfieldKojima:2010} relate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"unilateral_substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span>
‹Pareto separability›<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
\begin{quote}

Preferences are <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹Pareto separable›<span class="antiquote"><span class="antiquote">}</span></span></span></span> for a hospital if the
hospital's choice between <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x'›</span></span></span></span>, two
[distinct] contracts with the same doctor, does not depend on what
other contracts the hospital has access to.

\end{quote}
This result also depends on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "irc"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pareto_separable_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pareto_separable_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span>
     <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound"><span class="bound">C</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">b</span> <span class="main">∧</span> <span class="free">Xd</span> <span class="bound">a</span> <span class="main">=</span> <span class="free">Xd</span> <span class="bound">b</span> <span class="main">∧</span> <span class="free">Xh</span> <span class="bound">a</span> <span class="main">=</span> <span class="free">Xh</span> <span class="bound">b</span>
                     <span class="main">∧</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="bound">b</span><span class="main">)</span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="bound">b</span><span class="main">)</span> <span class="main">(</span><span class="bound">C</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">pareto_separable</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pareto_separable</span> <span class="main">≡</span> pareto_separable_on UNIV"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible pareto_separable_def <span class="main">=</span> pareto_separable_on_def<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted">UNIV</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible pareto_separable_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> pareto_separable_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible pareto_separable_onD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> pareto_separable_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> substitutes_on_pareto_separable_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> substitutes_on <span class="free">A</span> <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pareto_separable_on <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> pareto_separable_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">C</span> <span class="skolem">a</span> <span class="skolem">b</span>
  <span class="keyword3"><span class="command">assume</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">a</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xh</span> <span class="skolem">a</span> <span class="main">=</span> <span class="free">Xh</span> <span class="skolem">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">note</span></span> Ch_iiaD <span class="main">=</span> iia_onD<span class="main">[</span><span class="operator">OF</span> iffD1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> substitutes_iia spec<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> substitutes_on <span class="free">A</span> <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">rotated</span> -1<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
  <span class="keyword1"><span class="command">from</span></span> XXX <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">{</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> Ch_iiaD<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> XXX <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">{</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Ch_singular inj_on_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> XXX <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">(</span><span class="skolem">C</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_iiaD<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> XXX <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">C</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unilateral_substitutes_on_pareto_separable_on_substitutes_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> unilateral_substitutes_on <span class="free">A</span> <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> irc_on <span class="free">A</span> <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"pareto_separable_on <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"substitutes_on <span class="free">A</span> <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> substitutes_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">a</span> <span class="skolem">b</span>
  <span class="keyword3"><span class="command">assume</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">b</span> <span class="main">∈</span> <span class="free">Xd</span> <span class="main">`</span> <span class="skolem">B</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">b</span> <span class="main">∈</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> XXX <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Ch_range <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹pareto_separable_on <span class="free">A</span>›</span></span> XXX
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> pareto_separable_onD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">A</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> a<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> b<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">a</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span>"</span></span><span class="main">]</span> Ch_range
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xh</span> <span class="skolem">b</span> <span class="main">=</span> <span class="free">h</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute insert_absorb<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?B'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> <span class="skolem">B</span> <span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">≠</span> <span class="free">Xd</span> <span class="skolem">b</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> irc_on <span class="free">A</span> <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span>›</span></span> XXX False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="var">?B'</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> consistency_onD<span class="main">[</span><span class="operator">OF</span> irc_on_consistency_on<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="free">h</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">b</span> <span class="skolem">B</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">b</span> <span class="var">?B'</span>"</span></span><span class="main">]</span> Ch_range
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">iff</span><span class="main"><span class="main">:</span></span> image_iff<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> unilateral_substitutes_on <span class="free">A</span> <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span>›</span></span> XXX False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="var">?B'</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> unilateral_substitutes_onD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="free">h</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="var">?B'</span>"</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">iff</span><span class="main"><span class="main">:</span></span> image_iff<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> irc_on <span class="free">A</span> <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span>›</span></span> XXX False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> consistency_onD<span class="main">[</span><span class="operator">OF</span> irc_on_consistency_on<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="free">h</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span>
                              <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">A</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="var">?B'</span><span class="main">)</span>"</span></span><span class="main">]</span>
              Ch_range'<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="free">h</span></span> <span class="quoted"><span class="quoted">"insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span><span class="main">]</span> Ch_singular
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_on_contraD<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> unilateral_substitutes_on <span class="free">A</span> <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span>›</span></span> XXX <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> unilateral_substitutes_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_3<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> irc_on <span class="free">A</span> <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">h</span><span class="main">.</span> substitutes_on <span class="free">A</span> <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">h</span><span class="main">.</span> unilateral_substitutes_on <span class="free">A</span> <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span><span class="main">)</span> <span class="main">∧</span> pareto_separable_on <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms
      unilateral_substitutes_on_pareto_separable_on_substitutes_on substitutes_on_pareto_separable_on
      substitutes_on_unilateral_substitutes_on
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹ \citet{AfacanTurhan:2015}: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹doctor separability›<span class="antiquote"><span class="antiquote">}</span></span></span></span> relates bi- and unilateral substitutes ›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

\citet[Theorem~1]{AfacanTurhan:2015} relate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"bilateral_substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "unilateral_substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> using
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹doctor separability›<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
\begin{quote}

<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹[Doctor separability (DS)]›<span class="antiquote"><span class="antiquote">}</span></span></span></span> says that if a doctor is not chosen
from a set of contracts in the sense that no contract of him is
selected, then that doctor should still not be chosen unless a
contract of a new doctor (that is, doctor having no contract in the
given set of contracts) becomes available. For practical purposes, we
can consider DS as capturing contracts where certain groups of doctors
are substitutes. [footnote: If <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Xd x ∉ Xd ` Ch h (Y
∪ {x, z})›</span></span></span></span>, then doctor <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Xd x›</span></span></span></span> is not
chosen. And under DS, he continues not to be chosen unless a new
doctor comes. Hence, we can interpret it as the doctors in the given
set of contracts are substitutes.]

\end{quote}

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">doctor_separable_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">⇒</span> <span class="tfree">'x</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">doctor_separable_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>
     <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">.</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">,</span> <span class="bound">c</span><span class="main">}</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> <span class="free">Xd</span> <span class="bound">a</span> <span class="main">≠</span> <span class="free">Xd</span> <span class="bound">b</span> <span class="main">∧</span> <span class="free">Xd</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">Xd</span> <span class="bound">c</span> <span class="main">∧</span> <span class="free">Xd</span> <span class="bound">a</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">}</span><span class="main">)</span>
         <span class="main">⟶</span> <span class="free">Xd</span> <span class="bound">a</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">,</span> <span class="bound">c</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">doctor_separable</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> cfun <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">doctor_separable</span> <span class="main">≡</span> doctor_separable_on UNIV"</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemmas</span></span> doctor_separable_def <span class="main">=</span> doctor_separable_on_def<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted">UNIV</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> doctor_separable_onI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> doctor_separable_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> doctor_separable_onD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> doctor_separable_on_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">,</span> <span class="operator">rotated</span> -1<span class="main">]</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> unilateral_substitutes_on_doctor_separable_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"unilateral_substitutes_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"irc_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free">A</span><span class="main">.</span> allocation <span class="main">(</span><span class="free">f</span> <span class="bound">B</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"doctor_separable_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> doctor_separable_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span>
  <span class="keyword3"><span class="command">assume</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">a</span> <span class="main">≠</span> <span class="free">Xd</span> <span class="skolem">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">b</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">a</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> notI<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?C</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> <span class="skolem">B</span> <span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">≠</span> <span class="free">Xd</span> <span class="skolem">a</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">=</span> <span class="skolem">a</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹irc_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> XXX<span class="main">(</span>1-3<span class="main">,</span>7<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="var">?C</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> consistency_onD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> irc_on_consistency_on<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">A</span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span></span> f<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span>
            <span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">A</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">f</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹unilateral_substitutes_on <span class="free">A</span> <span class="free">f</span>›</span></span> XXX
    <span class="keyword1"><span class="command">have</span></span> abcC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="var">?C</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> unilateral_substitutes_onD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">A</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">f</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> a<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">c</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> b<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">b</span> <span class="var">?C</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">a</span><span class="main">}</span>"</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹irc_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free">A</span><span class="main">.</span> allocation <span class="main">(</span><span class="free">f</span> <span class="bound">B</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> XXX<span class="main">(</span>1-4<span class="main">)</span> a
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="var">?C</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> consistency_onD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> irc_on_consistency_on<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">A</span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span></span> f<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>4<span class="main"><span class="keyword3">]</span></span><span class="main"><span class="keyword3">,</span></span>
            <span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> f_range_onD'<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">A</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> inj_on_contraD insert_subset<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> a abcC <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a'</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> a'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a'</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">a'</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">a</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a'</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> notI<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> a'X<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a'</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?B</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"insert <span class="skolem">a</span> <span class="skolem">B</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">a'</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> XXX a'
    <span class="keyword1"><span class="command">have</span></span> XXX_7'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">a</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a'</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="var">?B</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> imageI insert_Diff_single insert_absorb insert_commute<span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?C</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> <span class="var">?B</span> <span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">≠</span> <span class="free">Xd</span> <span class="skolem">a</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">=</span> <span class="skolem">a'</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹irc_on <span class="free">A</span> <span class="free">f</span>›</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> XXX<span class="main">(</span>1-3<span class="main">)</span> a' XXX_7'
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a'</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="var">?B</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a'</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="var">?C</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> consistency_onD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> irc_on_consistency_on<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">A</span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span></span> f<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span>
            <span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">A</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">f</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">a'</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="var">?B</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹unilateral_substitutes_on <span class="free">A</span> <span class="free">f</span>›</span></span> XXX<span class="main">(</span>1-6<span class="main">)</span> XXX_7' a'
    <span class="keyword1"><span class="command">have</span></span> abcC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a'</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a'</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="var">?C</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> unilateral_substitutes_onD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">A</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">f</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> a<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">c</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> b<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">a'</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">b</span> <span class="var">?C</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">a'</span><span class="main">}</span>"</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute rev_image_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a'</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="var">?B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a'</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="var">?C</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> consistency_onD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> irc_on_consistency_on<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">A</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span></span> f<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> a' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insert <span class="skolem">a'</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="var">?B</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free">A</span><span class="main">.</span> allocation <span class="main">(</span><span class="free">f</span> <span class="bound">B</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> XXX<span class="main">(</span>1-4<span class="main">)</span> a' a'X
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a'</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="var">?B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> insert <span class="skolem">a'</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> <span class="var">?B</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">≠</span> <span class="free">Xd</span> <span class="skolem">a</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">=</span> <span class="skolem">a'</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> f_range_onD'<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">A</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> inj_on_contraD insert_subset<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> <span class="quoted"><span class="quoted">‹irc_on <span class="free">A</span> <span class="free">f</span>›</span></span> XXX<span class="main"><span class="main">(</span></span>1-4<span class="main"><span class="main">)</span></span> a' <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> a' a'X abcC <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> insert_Diff insert_Diff_single insert_commute<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> XXX
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">a</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_range_onD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bilateral_substitutes_on_doctor_separable_on_unilateral_substitutes_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"bilateral_substitutes_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"doctor_separable_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"unilateral_substitutes_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> unilateral_substitutes_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="skolem">a</span> <span class="skolem">b</span>
  <span class="keyword3"><span class="command">assume</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">b</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">a</span> <span class="main">∈</span> <span class="free">Xd</span> <span class="main">`</span> <span class="skolem">B</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">C</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="keyword2"><span class="keyword">where</span></span> Cc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">=</span> insert <span class="skolem">c</span> <span class="skolem">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∉</span> <span class="skolem">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">c</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Set.set_insert image_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>›</span></span> Cc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="skolem">C</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹f_range_on <span class="free">A</span> <span class="free">f</span>›</span></span> XXX Cc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">b</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">f</span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="main">(</span>insert <span class="skolem">c</span> <span class="skolem">C</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> f_range_onD' image_eqI insertE insert_subset<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹doctor_separable_on <span class="free">A</span> <span class="free">f</span>›</span></span> XXX Cc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> doctor_separable_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> <span class="quoted"><span class="quoted">‹bilateral_substitutes_on <span class="free">A</span> <span class="free">f</span>›</span></span> XXX <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main">:</span> bilateral_substitutes_onD›</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> unilateral_substitutes_on_doctor_separable_on_bilateral_substitutes_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"irc_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">B</span></span><span class="main">⊆</span><span class="free">A</span><span class="main">.</span> allocation <span class="main">(</span><span class="free">f</span> <span class="bound">B</span><span class="main">)</span>"</span></span> <span class="comment1">― ‹A rephrasing of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">thm</span> [source] "Ch_singular"<span class="antiquote">}</span></span>.›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"f_range_on <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"unilateral_substitutes_on <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> bilateral_substitutes_on <span class="free">A</span> <span class="free">f</span> <span class="main">∧</span> doctor_separable_on <span class="free">A</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible assms
      unilateral_substitutes_on_bilateral_substitutes_on
      unilateral_substitutes_on_doctor_separable_on
      bilateral_substitutes_on_doctor_separable_on_unilateral_substitutes_on
<span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[Remark~2]{AfacanTurhan:2015} observe the independence of the
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "doctor_separable"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "pareto_separable"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"bilateral_substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> conditions.

›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Theorems~4 and 5: Doctor optimality ›</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithUnilateralSubstitutesAndIRC
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

We return to analyzing the COP following
\citet{HatfieldKojima:2010}. The next goal is to establish a
doctor-optimality result for it in the spirit of
\S\ref{sec:contracts-optimality}.

We first show that, with hospital choice functions satisfying <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"unilateral_substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, we effectively have the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> condition for all contracts that have been rejected. In
other words, hospitals never renegotiate with doctors.

The proof is by induction over the finite set <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> no_renegotiation_union<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="free">x</span> <span class="main">(</span><span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">Y</span><span class="main">)</span> <span class="main">-</span> <span class="main">{</span><span class="bound">z</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">z</span> <span class="main">=</span> <span class="free">Xd</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">Y</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
  <span class="keyword3"><span class="command">case</span></span> empty
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">drule</span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> equalityD2<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> consistencyD<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator">OF</span> Ch_consistency<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">h</span></span></span></span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main"><span class="main"><span class="main"><span class="main">,</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">X</span></span></span></span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">rotated</span> -1<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> image_iff <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range'<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">y</span> <span class="skolem">Y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="skolem">y</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="skolem">y</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span>›</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">y</span> <span class="main">=</span> <span class="free">Xd</span> <span class="free">x</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">Y</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="skolem">y</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> Ch_singular Un_iff inj_onD insert_absorb<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> xy <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">y</span> <span class="main">≠</span> <span class="free">Xd</span> <span class="free">x</span>›</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> notI<span class="main">)</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> insert <span class="skolem">y</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="skolem">y</span> <span class="main">(</span>insert <span class="free">x</span> <span class="main">(</span><span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">Y</span><span class="main">)</span> <span class="main">-</span> <span class="main">{</span><span class="bound">z</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">z</span> <span class="main">=</span> <span class="free">Xd</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> equalityD1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> consistencyD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Ch_consistency<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">h</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">,</span></span> <span class="operator">rotated</span> -1<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span>
                  <span class="operator">assumption</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> Ch_range' Ch_singular Un_iff inj_onD insertE<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>insert <span class="free">x</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">Y</span> <span class="main">-</span> <span class="main">{</span><span class="bound">z</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">z</span> <span class="main">=</span> <span class="free">Xd</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> unilateral_substitutesD3<span class="main"><span class="main">[</span></span><span class="operator">OF</span> spec<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> Ch_unilateral_substitutes<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">of</span> <span class="quoted"><span class="free">h</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">Y</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> Ch_irc <span class="keyword1"><span class="command">unfolding</span></span> irc_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword1"><span class="command">from</span></span> insert<span class="main">(</span>4<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_commute insert_Diff_if <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits
               <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> unilateral_substitutesD3<span class="main"><span class="main">[</span></span><span class="operator">OF</span> spec<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> Ch_unilateral_substitutes<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">of</span> <span class="quoted"><span class="free">h</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> a<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

To discharge the first antecedent of this lemma, we need an invariant
for the COP that asserts that, for each doctor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">d</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, there is a
subset of the contracts currently offered by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">d</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> that was
previously uniformly rejected by the COP, for each contract that is
rejected at the current step. To support a later theorem (see
\S\ref{sec:cop-worst}) we require these subsets to be upwards-closed
with respect to the doctor's preferences.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">cop_F_rejected_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cop_F_rejected_inv</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">fp</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>RH <span class="free"><span class="bound"><span class="entity">fp</span></span></span><span class="main">.</span> <span class="main">∃</span><span class="bound"><span class="bound">fp'</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">fp</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="bound">fp'</span> <span class="main">∧</span> above <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="bound">x</span> <span class="main">⊆</span> <span class="bound">fp'</span> <span class="main">∧</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> CH <span class="bound">fp'</span><span class="main">)</span>"</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemmas</span></span> cop_F_rejected_invI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> cop_F_rejected_inv_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> conj_imp_eq_imp_imp<span class="main">]</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> cop_F_rejected_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid <span class="free">ds</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ds</span> <span class="bound">fp</span><span class="main">.</span> cop_F_range_inv <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> cop_F_closed_inv <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> allocation <span class="main">(</span>CH <span class="bound">fp</span><span class="main">)</span><span class="main">)</span> cop_F_rejected_inv"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> validI<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> base <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> cop_F_rejected_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">fp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cop_F_closed_inv <span class="free">ds</span> <span class="skolem">fp</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cop_F_range_inv <span class="free">ds</span> <span class="skolem">fp</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"allocation <span class="main">(</span>CH <span class="skolem">fp</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cop_F_rejected_inv <span class="free">ds</span> <span class="skolem">fp</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cop_F_rejected_invI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> cop_F <span class="free">ds</span> <span class="skolem">fp</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound"><span class="bound">fp'</span></span><span class="main">⊆</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="bound">fp'</span> <span class="main">∧</span> above <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">⊆</span> <span class="bound">fp'</span> <span class="main">∧</span> <span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> CH <span class="bound">fp'</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="free">Xd</span> <span class="main">`</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∉</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span>
        <span class="keyword2"><span class="keyword">where</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">y</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> imageE<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> cop_F <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> cop_F_cases<span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> fp <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">fp</span>›</span></span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> CH_cop_F_cases<span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> CH <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CH <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="main">(</span>CH <span class="skolem">fp</span><span class="main">)</span>›</span></span> y<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> CH <span class="skolem">fp</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> inj_on_eq_iff<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹cop_F_rejected_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">fp</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> cop_F_rejected_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Diff_iff Un_upper1 cop_F_def subset_refl subset_trans<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> RH_fp <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> RH <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹cop_F_rejected_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span>
          <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">fp'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">fp'</span> <span class="main">⊆</span> <span class="skolem">fp</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">fp'</span> <span class="main">∧</span> above <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">y</span><span class="main">)</span><span class="main">)</span> <span class="skolem">y</span> <span class="main">⊆</span> <span class="skolem">fp'</span> <span class="main">∧</span> <span class="free">Xd</span> <span class="skolem">y</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> CH <span class="skolem">fp'</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> cop_F_rejected_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CH_Ch<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">using</span></span> no_renegotiation_union<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">fp'</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> Y<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"cop_F <span class="free">ds</span> <span class="skolem">fp</span>"</span></span><span class="main">]</span> cop_F_increasing
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_Ch_CH image_iff<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> Un_absorb1 mem_CH_Ch subset_trans<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> CD_on <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span> RH <span class="skolem">fp</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">with</span></span> cop_F_increasing <span class="quoted"><span class="quoted">‹cop_F_closed_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> cop_F_CH_CD_on_disjoint<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹cop_F_closed_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹cop_F_range_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">fp</span>›</span></span> y<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> cop_F_closed_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">fp</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> CD_on
        <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span> <span class="keyword3"><span class="command">assume</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">z</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">x</span>"</span></span>
          <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="main">(</span>CH <span class="skolem">fp</span><span class="main">)</span>›</span></span> x<span class="main">(</span>2<span class="main">)</span> z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≠</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">from</span></span> z<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span>
          <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> CH_cop_F_cases<span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> CH
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹cop_F_range_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹cop_F_closed_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span> RH <span class="skolem">fp</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">fp</span>›</span></span> z<span class="main">(</span>2<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">≠</span> <span class="skolem">x</span>›</span></span>
            <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
              <span class="keyword1"><span class="command">using</span></span> cop_F_CH_CD_on_disjoint <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> RH_fp <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> RH <span class="skolem">fp</span>›</span></span>
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹cop_F_rejected_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span>
            <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">fp'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">fp'</span> <span class="main">⊆</span> <span class="skolem">fp</span> <span class="main">∧</span> <span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">fp'</span> <span class="main">∧</span> above <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">z</span><span class="main">)</span><span class="main">)</span> <span class="skolem">z</span> <span class="main">⊆</span> <span class="skolem">fp'</span> <span class="main">∧</span> <span class="free">Xd</span> <span class="skolem">z</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> CH <span class="skolem">fp'</span>"</span></span>
              <span class="keyword1"><span class="command">unfolding</span></span> cop_F_rejected_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CH_Ch<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
              <span class="keyword1"><span class="command">using</span></span> no_renegotiation_union<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">fp'</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> Y<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"cop_F <span class="free">ds</span> <span class="skolem">fp</span>"</span></span><span class="main">]</span> cop_F_increasing
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_Ch_CH image_iff<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> Un_absorb1 mem_CH_Ch subset_trans<span class="main">)</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> CD_on <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span> RH <span class="skolem">fp</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">fp</span>›</span></span>
            <span class="keyword1"><span class="command">with</span></span> z<span class="main">(</span>2<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="main">-</span> RH <span class="skolem">fp</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">≠</span> <span class="skolem">x</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> CD_on_inj_on_Xd DiffD1 inj_onD<span class="main">)</span>
          <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">with</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> CH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">with</span></span> cop_F_closed_inv <span class="quoted"><span class="quoted">‹cop_F_closed_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> cop_F <span class="free">ds</span> <span class="skolem">fp</span>›</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> cop_F_closed_inv_def subsetI valid_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fp_cop_F_rejected_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cop_F_rejected_inv <span class="free">ds</span> <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"invariant <span class="free">ds</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ds</span> <span class="bound">fp</span><span class="main">.</span> cop_F_range_inv <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> cop_F_closed_inv <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> allocation <span class="main">(</span>CH <span class="bound">fp</span><span class="main">)</span> <span class="main">∧</span> cop_F_rejected_inv <span class="bound">ds</span> <span class="bound">fp</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cop_F_range_inv cop_F_closed_inv cop_F_allocation_inv cop_F_rejected_inv
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> valid_conj <span class="main"><span class="keyword3">|</span></span> <span class="operator">blast</span> <span class="main"><span class="keyword3">|</span></span> <span class="operator">rule</span> valid_pre<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> invariantD<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\label{sec:cop-theorem-4}

\citet[Theorem~4]{HatfieldKojima:2010} assert that we effectively
recover <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> for the contracts relevant to the
COP. We cannot adopt their phrasing as it talks about the execution
traces of the COP, and not just its final state. Instead we present
the result we use, which relates two consecutive states in an
execution trace of the COP:

›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_4<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cop_F_rejected_inv <span class="free">ds</span> <span class="free">fp</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> RH <span class="free">fp</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> RH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="free">fp</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible bspec<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> cop_F_rejected_inv_def<span class="main"><span class="main">]</span></span><span class="main">]</span> cop_F_increasing<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">fp</span></span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span>
      no_renegotiation_union<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Xh</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> Y<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"cop_F <span class="free">ds</span> <span class="free">fp</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CH_Ch image_iff Ch_CH_irc_idem<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> le_iff_sup mem_Ch_CH sup.coboundedI1<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\label{sec:cop-worst}

Another way to interpret <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "cop_F_rejected_inv"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is to observe
that the doctor-optimal match contains the least preferred of the
contracts that the doctors have offered.

›</span></span>

<span class="keyword1"><span class="command">corollary</span></span> fp_cop_F_worst<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> cop <span class="free">ds</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> fp_cop_F <span class="free">ds</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">y</span> <span class="main">=</span> <span class="free">Xd</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∉</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> CH_range' Pd_linear eq_iff fp_cop_F_range_inv' order_on_defs<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> total_on_def underS_incl_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∉</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> fp_cop_F_allocation <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> fp_cop_F_rejected_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">y</span> <span class="main">∈</span> fp_cop_F <span class="free">ds</span>›</span></span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">fp'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">fp'</span> <span class="main">⊆</span> fp_cop_F <span class="free">ds</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">∈</span> <span class="skolem">fp'</span> <span class="main">∧</span> above <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span> <span class="free">y</span> <span class="main">⊆</span> <span class="skolem">fp'</span> <span class="main">∧</span> <span class="free">Xd</span> <span class="free">y</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> CH <span class="skolem">fp'</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> cop_F_rejected_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">y</span>›</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">using</span></span> no_renegotiation_union<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Xh</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">fp'</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> Y<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"fp_cop_F <span class="free">ds</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> above_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CH_Ch image_iff<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> contra_subsetD le_iff_sup mem_Ch_CH mem_Collect_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The doctor optimality result, Theorem~5, hinges on showing that no
contract in any stable match is ever rejected.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">theorem_5_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">theorem_5_inv</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">fp</span></span></span> <span class="main">⟷</span> RH <span class="free"><span class="bound"><span class="entity">fp</span></span></span> <span class="main">∩</span> <span class="main">⋃</span><span class="main">{</span><span class="bound">X</span><span class="main">.</span> stable_on <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="bound">X</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> theorem_5_invI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">z</span> <span class="bound">X</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">z</span> <span class="main">∈</span> RH <span class="free">fp</span><span class="main">;</span> <span class="bound">z</span> <span class="main">∈</span> <span class="bound">X</span><span class="main">;</span> stable_on <span class="free">ds</span> <span class="bound">X</span><span class="main">⟧</span> <span class="main">⟹</span> False"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"theorem_5_inv <span class="free">ds</span> <span class="free">fp</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> theorem_5_inv_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> theorem_5_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid <span class="free">ds</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ds</span> <span class="bound">fp</span><span class="main">.</span> cop_F_range_inv <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> cop_F_closed_inv <span class="bound">ds</span> <span class="bound">fp</span>
                     <span class="main">∧</span> allocation <span class="main">(</span>CH <span class="bound">fp</span><span class="main">)</span> <span class="main">∧</span> cop_F_rejected_inv <span class="bound">ds</span> <span class="bound">fp</span><span class="main">)</span> theorem_5_inv"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> validI<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> base <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> theorem_5_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">fp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cop_F_range_inv <span class="free">ds</span> <span class="skolem">fp</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cop_F_closed_inv <span class="free">ds</span> <span class="skolem">fp</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"allocation <span class="main">(</span>CH <span class="skolem">fp</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cop_F_rejected_inv <span class="free">ds</span> <span class="skolem">fp</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"theorem_5_inv <span class="free">ds</span> <span class="skolem">fp</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> theorem_5_invI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span> <span class="skolem">X</span> <span class="keyword3"><span class="command">assume</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> RH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">X</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="skolem">X</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹theorem_5_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">X</span>›</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="skolem">X</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> z'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∉</span> RH <span class="skolem">fp</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> theorem_5_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">Y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">≡</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> z <span class="keyword1"><span class="command">have</span></span> YYY<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">(</span>insert <span class="skolem">z</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> consistencyD<span class="main">[</span><span class="operator">OF</span> Ch_consistency<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mem_CH_Ch Y_def<span class="main">)</span>
         <span class="main">(</span><span class="operator">metis</span> Ch_f_range f_range_on_def insert_subset subset_insertI top_greatest<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> yRx<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">Y</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">y</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∉</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> Pd_linear <span class="quoted"><span class="quoted">‹cop_F_range_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="skolem">X</span>›</span></span> that
      <span class="keyword1"><span class="command">have</span></span> BBB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> Y_def cop_F_def cop_F_range_inv_def order_on_defs total_on_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CD_on_Cd <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Ch_range'<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> Cd_range' Int_iff refl_onD stable_on_range'<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="skolem">X</span>›</span></span> <span class="quoted"><span class="quoted">‹cop_F_closed_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹theorem_5_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> BBB that <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">fp</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">fp</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> cop_F_def cop_F_closed_inv_def theorem_5_inv_def above_def Y_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CD_on_Cd <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range' Cd_preferred<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="skolem">X</span>›</span></span> <span class="quoted"><span class="quoted">‹theorem_5_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">fp</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> theorem_5_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CH_Ch<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="main">(</span>CH <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">y</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">x</span>›</span></span> BBB <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="skolem">fp</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Ch_range' inj_onD mem_CH_Ch<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">Y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">fp</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">fp</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
        <span class="keyword1"><span class="command">unfolding</span></span> Y_def <span class="keyword1"><span class="command">using</span></span> Theorem_4<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹cop_F_rejected_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">y</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Ch_range' Diff_iff mem_CH_Ch<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">z</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="skolem">Y</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">safe</span><span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">w</span> <span class="keyword3"><span class="command">assume</span></span> w<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">z</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">w</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">Y</span>"</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">fp</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">fp</span>›</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">fp</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">z</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">w</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">Y</span>›</span></span> z' <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">fp</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∉</span> CH <span class="skolem">fp</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Ch_irc_idem DiffI YYY Y_def <span class="quoted"><span class="quoted">‹allocation <span class="main">(</span>CH <span class="skolem">fp</span><span class="main">)</span>›</span></span> inj_on_eq_iff insert_absorb<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> Theorem_4<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹cop_F_rejected_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">w</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">Y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">fp</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
            <span class="keyword1"><span class="command">unfolding</span></span> Y_def CH_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">∉</span> <span class="skolem">fp</span>›</span></span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">Y</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="skolem">fp</span> <span class="main">∧</span> <span class="skolem">w</span> <span class="main">∈</span> cop_F <span class="free">ds</span> <span class="skolem">fp</span> <span class="main">∧</span> <span class="free">Xh</span> <span class="skolem">w</span> <span class="main">=</span> <span class="free">Xh</span> <span class="skolem">z</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> Y_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range'<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹cop_F_closed_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹cop_F_range_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∉</span> RH <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">∉</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">z</span> <span class="main">=</span> <span class="free">Xd</span> <span class="skolem">w</span>›</span></span>
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
            <span class="keyword1"><span class="command">unfolding</span></span> cop_F_closed_inv_def cop_F_range_inv_def above_def
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cop_F_def mem_CD_on_Cd Cd_greatest greatest_def<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∉</span> <span class="skolem">fp</span>›</span></span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹cop_F_range_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> <span class="quoted"><span class="quoted">‹cop_F_closed_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span> z <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∉</span> <span class="skolem">fp</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">z</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="skolem">fp</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> cop_F_range_inv_def cop_F_closed_inv_def above_def
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CD_on_Cd Cd_greatest greatest_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mem_Ch_CH <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cop_F_cases<span class="main">)</span>
             <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> CH_range'<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> w <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> RH <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∉</span> <span class="skolem">fp</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Y_def cop_F_def mem_CH_Ch<span class="main">)</span>
             <span class="main">(</span><span class="operator">metis</span> CD_on_inj_on_Xd Ch_range' Un_iff inj_onD no_renegotiation_union<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">(</span><span class="skolem">X</span> <span class="main">∪</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">(</span><span class="skolem">X</span> <span class="main">∪</span> <span class="skolem">Y</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">X</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">z</span> <span class="main">∈</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">(</span>insert <span class="skolem">z</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> no_renegotiation_union<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"insert <span class="skolem">z</span> <span class="skolem">Y</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> Y<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">X</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">z</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Xh</span> <span class="skolem">z</span>"</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> Un_insert_right insert_Diff Un_commute<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">z</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="skolem">Y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">(</span>insert <span class="skolem">z</span> <span class="skolem">Y</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range'<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">(</span><span class="skolem">X</span> <span class="main">∪</span> <span class="skolem">Y</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>stable_on <span class="free">ds</span> <span class="skolem">X</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> blocking_on_imp_not_stable<span class="main"><span class="main">[</span></span><span class="operator">OF</span> blocking_onI<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> False <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">X</span>›</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="skolem">X</span>›</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">(</span><span class="skolem">X</span> <span class="main">∪</span> <span class="skolem">Y</span><span class="main">)</span> <span class="main">≠</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="skolem">X</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> mem_CH_Ch stable_on_CH <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">(</span><span class="skolem">X</span> <span class="main">∪</span> <span class="skolem">Y</span><span class="main">)</span> <span class="main">=</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">(</span><span class="skolem">X</span> <span class="main">∪</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">(</span><span class="skolem">X</span> <span class="main">∪</span> <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> Ch_range' <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> consistencyD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Ch_consistency<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">(</span><span class="skolem">X</span> <span class="main">∪</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> Ch_singular'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">Xh</span> <span class="skolem">z</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X</span> <span class="main">∪</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">(</span>cop_F <span class="free">ds</span> <span class="skolem">fp</span><span class="main">)</span>"</span></span><span class="main">]</span>
             invariant_cop_FD<span class="main">[</span><span class="operator">OF</span> cop_F_range_inv <span class="quoted"><span class="quoted">‹cop_F_range_inv <span class="free">ds</span> <span class="skolem">fp</span>›</span></span><span class="main">]</span>
             stable_on_allocation<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="skolem">X</span>›</span></span><span class="main">]</span> stable_on_Xd<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="skolem">X</span>›</span></span><span class="main">]</span>
             stable_on_range'<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="skolem">X</span>›</span></span><span class="main">]</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="skolem">X</span> <span class="main">∪</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">(</span><span class="skolem">X</span> <span class="main">∪</span> <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> cop_F_range_inv_def
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CD_on_Cd Cd_greatest greatest_def<span class="main">)</span>
             <span class="main">(</span><span class="operator">metis</span> Ch_range' IntE Pd_range' Pd_refl Un_iff Y_def inj_onD yRx<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="skolem">X</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fp_cop_F_theorem_5_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"theorem_5_inv <span class="free">ds</span> <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"invariant <span class="free">ds</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ds</span> <span class="bound">fp</span><span class="main">.</span> cop_F_range_inv <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> cop_F_closed_inv <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> allocation <span class="main">(</span>CH <span class="bound">fp</span><span class="main">)</span> <span class="main">∧</span> cop_F_rejected_inv <span class="bound">ds</span> <span class="bound">fp</span> <span class="main">∧</span> theorem_5_inv <span class="bound">ds</span> <span class="bound">fp</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cop_F_range_inv cop_F_closed_inv cop_F_allocation_inv cop_F_rejected_inv theorem_5_inv
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> valid_conj <span class="main"><span class="keyword3">|</span></span> <span class="operator">blast</span> <span class="main"><span class="keyword3">|</span></span> <span class="operator">rule</span> valid_pre<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> invariantD<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_5<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> cop <span class="free">ds</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> fp_cop_F_theorem_5_inv assms
  <span class="keyword1"><span class="command">have</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> RH <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> theorem_5_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">Xd</span> <span class="main">`</span> cop <span class="free">ds</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> cop <span class="free">ds</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">z</span> <span class="main">=</span> <span class="free">Xd</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> z <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">with</span></span> Pd_linear'<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> d<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span>"</span></span><span class="main">]</span> fp_cop_F_range_inv'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">z</span></span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span> assms z
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> order_on_defs total_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> CH_range' refl_onD stable_on_range'<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> fp_cop_F_closed_inv'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">z</span></span> <span class="quoted"><span class="free">ds</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> x z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> fp_cop_F <span class="free">ds</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> above_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CH_Ch <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range'<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> fp_cop_F_allocation x z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_onD<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> Pd_linear assms z <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> equalityD2 stable_on_range' underS_incl_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> cop <span class="free">ds</span>›</span></span>
    <span class="keyword1"><span class="command">with</span></span> assms x <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DiffI Diff_eq_empty_iff fp_cop_F_all emptyE imageI stable_on_Xd stable_on_range'<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> fp_cop_F_doctor_optimal_match<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"doctor_optimal_match <span class="free">ds</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> doctor_optimal_matchI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Theorem_1 Theorem_5<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\label{sec:cop-opposition-of-interests}

The next lemma demonstrates the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹opposition of interests›<span class="antiquote"><span class="antiquote">}</span></span></span></span> of
doctors and hospitals: if all doctors weakly prefer one stable match
to another, then the hospitals weakly prefer the converse.

As we do not have linear preferences for hospitals, we use revealed
preference and hence assume <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "irc"<span class="antiquote"><span class="antiquote">}</span></span></span></span> holds of hospital choice
functions. Our definition of the doctor-preferred ordering <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"<span class="free"><span class="free">dpref</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> follows the Isabelle/HOL convention of putting the larger
(more preferred) element on the right, and takes care with
unemployment.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">dpref</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">dpref</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">%</span>invisible dprefI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> dpref_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithIRC
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Lemma_1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">Z</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"dpref <span class="free">Z</span> <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">Z</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">Y</span> <span class="main">∪</span> <span class="free">Z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">Y</span> <span class="main">∪</span> <span class="free">Z</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">Z</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∉</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">Y</span> <span class="main">∪</span> <span class="free">Z</span><span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">Y</span> <span class="main">∪</span> <span class="free">Z</span><span class="main">)</span> <span class="main">≠</span> <span class="free">Ch</span> <span class="free">h</span> <span class="free">Z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">Y</span> <span class="main">∪</span> <span class="free">Z</span><span class="main">)</span> <span class="main">=</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">Z</span> <span class="main">∪</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">Y</span> <span class="main">∪</span> <span class="free">Z</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> consistency_onD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Ch_consistency<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range'<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="free">Z</span> <span class="main">∪</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">Y</span> <span class="main">∪</span> <span class="free">Z</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="free">Y</span> <span class="main">∪</span> <span class="free">Z</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">Y</span>›</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">Z</span>›</span></span> that
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">y</span> <span class="main">∈</span> <span class="free">ds</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> stable_on_Xd stable_on_range' Ch_range' <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Un_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> Pd_linear'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">y</span>"</span></span><span class="main">]</span> Ch_singular <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">Y</span>›</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">Z</span>›</span></span> <span class="quoted"><span class="quoted">‹dpref <span class="free">Z</span> <span class="free">Y</span>›</span></span> that <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> dpref_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CD_on_Cd Cd_greatest greatest_def<span class="main">)</span>
         <span class="main">(</span><span class="operator">metis</span> Ch_range' Pd_Xd Un_iff eq_iff inj_on_contraD stable_on_allocation underS_incl_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> stable_on_blocking_onD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">Z</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Contracts<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

\citet[Corollary~1 (of Theorem~5 and Lemma~1)]{HatfieldKojima:2010}:
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "unilateral_substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> implies there is a hospital-pessimal
match, which is indeed the doctor-optimal one.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithUnilateralSubstitutesAndIRC
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Corollary_1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">Z</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dpref <span class="free">Z</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">Z</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>cop <span class="free">ds</span> <span class="main">∪</span> <span class="free">Z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"dpref <span class="free">Z</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> dprefI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Theorem_5<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">Z</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">Z</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="main">(</span><span class="free">Xh</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>cop <span class="free">ds</span> <span class="main">∪</span> <span class="free">Z</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Lemma_1<span class="main">[</span><span class="operator">OF</span> Theorem_1 assms <span class="quoted"><span class="quoted">‹dpref <span class="free">Z</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span>›</span></span><span class="main">]</span> stable_on_CH
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CH_Ch<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[p1717]{HatfieldKojima:2010} show that there is not always a
hospital-optimal/doctor-pessimal match when hospital preferences
satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "unilateral_substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, in contrast to the
situation under <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> (see
\S\ref{sec:contracts-optimality}). This reflects the loss of the
lattice structure.

›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Theorem~6: A ``rural hospitals'' theorem \label{sec:cop-rh} ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Contracts<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

\citet[Theorem~6]{HatfieldKojima:2010} demonstrates a ``rural
hospitals'' theorem for the COP assuming hospital choice functions
satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "unilateral_substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "lad"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, as for
\S\ref{sec:contracts-rh}. However \citet[\S4,
Example~1]{AygunSonmez:2012-WP} observe that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source]
"lad_on_substitutes_on_irc_on"<span class="antiquote"><span class="antiquote">}</span></span></span></span> does not hold with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"bilateral_substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span> instead of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, and their
Example~3 similarly for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "unilateral_substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. Moreover
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "fp_cop_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span> can yield an unstable allocation with just these
two hypotheses. Ergo we need to assume <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "irc"<span class="antiquote"><span class="antiquote">}</span></span></span></span> even when we
have <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "lad"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, unlike before (see \S\ref{sec:contracts-rh}).

This theorem is the foundation for all later strategic results.

›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ContractsWithUnilateralSubstitutesAndIRCAndLAD <span class="main">=</span> ContractsWithUnilateralSubstitutesAndIRC <span class="main">+</span> ContractsWithLAD

<span class="keyword1"><span class="command">sublocale</span></span> ContractsWithSubstitutesAndLAD <span class="main">&lt;</span> ContractsWithUnilateralSubstitutesAndIRCAndLAD
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Ch_lad <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithUnilateralSubstitutesAndIRCAndLAD
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The proofs of these first two lemmas are provided by
\citet[Theorem~6]{HatfieldKojima:2010}. We treat unemployment in the
definition of the function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as we did in
\S\ref{sec:contracts-t1-converse}.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> RHT_Cd_card<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>Cd <span class="free">d</span> <span class="free">X</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span>Cd <span class="free">d</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">Xd</span> <span class="main">`</span> <span class="free">X</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">X</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">d</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Cd <span class="free">d</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Cd_singleton mem_CD_on_Cd stable_on_CD_on <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">from</span></span> Theorem_5<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="free">X</span>›</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"Cd <span class="free">d</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Cd_single Cd_singleton FieldI2 <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">d</span>›</span></span> fp_cop_F_allocation <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Cd <span class="free">d</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Cd_Xd Cd_range' <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> RHT_Ch_card<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">X</span><span class="main">.</span> <span class="main">{</span><span class="bound">y</span> <span class="main">|</span><span class="bound">y</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">ds</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="bound">X</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">Xd</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span> <span class="main">=</span> fp_cop_F <span class="free">ds</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> set_elem_equalityI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="free">Xd</span> <span class="main">`</span> cop <span class="free">ds</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> A_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> CH_range' above_def fp_cop_F_closed_inv' mem_Collect_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>›</span></span> fp_cop_F_all <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> A_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> fp_cop_F_worst <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> A_def <span class="keyword1"><span class="command">using</span></span> fp_cop_F_range_inv'<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"CH <span class="main">(</span><span class="skolem">A</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"CH <span class="main">(</span><span class="skolem">A</span> <span class="free">X</span><span class="main">)</span> <span class="main">≠</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"CH <span class="main">(</span><span class="skolem">A</span> <span class="free">X</span><span class="main">)</span> <span class="main">≠</span> CH <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> stable_on_CH <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">h</span></span> <span class="keyword2"><span class="keyword">where</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span><span class="skolem">A</span> <span class="free">X</span><span class="main">)</span> <span class="main">≠</span> <span class="free">Ch</span> <span class="skolem">h</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> mem_CH_Ch <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> blocking_on_imp_not_stable<span class="main"><span class="main">[</span></span><span class="operator">OF</span> blocking_onI<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span><span class="skolem">A</span> <span class="free">X</span><span class="main">)</span> <span class="main">≠</span> <span class="free">Ch</span> <span class="skolem">h</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
      <span class="keyword1"><span class="command">from</span></span> Pd_linear <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span><span class="skolem">A</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span><span class="skolem">A</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> A_def
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> consistencyD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Ch_consistency<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span>
              <span class="operator">auto</span> 10 0 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range' stable_on_Xd stable_on_range' stable_on_allocation inj_onD underS_incl_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span><span class="skolem">A</span> <span class="free">X</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> Ch_singular Pd_linear <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="free">Ch</span> <span class="skolem">h</span> <span class="main">(</span><span class="skolem">A</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> A_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 9 3 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_CD_on_Cd Cd_greatest greatest_def
                     <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Ch_range' Pd_range' Cd_Xd Cd_single inj_onD underS_incl_iff
                    <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> FieldI1<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">from</span></span> Pd_linear Theorem_5<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">A</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> A_def order_on_defs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Pd_Xd <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> transE<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="skolem">A</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span><span class="skolem">A</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ladD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> spec<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> Ch_lad<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Ch_CH_irc_idem<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The top-level proof is the same as in \S\ref{sec:contracts-rh}.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Theorem_6_fp_cop_F<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span> <span class="main">⟹</span> card <span class="main">(</span>Cd <span class="free">d</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span>Cd <span class="free">d</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Sum_Cd_COP</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">∑</span><span class="bound">d</span><span class="main">∈</span><span class="free">ds</span><span class="main">.</span> card <span class="main">(</span>Cd <span class="bound">d</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Sum_Ch_COP</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">∑</span><span class="bound">h</span><span class="main">∈</span>UNIV<span class="main">.</span> card <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span> <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Sum_Cd_X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">∑</span><span class="bound">d</span><span class="main">∈</span><span class="free">ds</span><span class="main">.</span> card <span class="main">(</span>Cd <span class="bound">d</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Sum_Ch_X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">∑</span><span class="bound">h</span><span class="main">∈</span>UNIV<span class="main">.</span> card <span class="main">(</span><span class="free">Ch</span> <span class="bound">h</span> <span class="free">X</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Sum_Cd_COP</span> <span class="main">=</span> <span class="var">?Sum_Ch_COP</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Theorem_1 stable_on_CD_on CD_on_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> CH_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="var">?Sum_Ch_X</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> RHT_Ch_card <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?Sum_Cd_X</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> CD_on_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> CH_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> stable_on_CD_on stable_on_CH <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Sum_Cd_X</span> <span class="main">=</span> <span class="var">?Sum_Cd_COP</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> RHT_Cd_card <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_iff sum_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> RHT_Cd_card <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span> <span class="main">⟹</span> card <span class="main">(</span>Cd <span class="free">d</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span>Cd <span class="free">d</span> <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> sum_mono_inv<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Sum_Ch_X</span> <span class="main">=</span> <span class="var">?Sum_Cd_X</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> stable_on_CD_on stable_on_CH CD_on_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> CH_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="var">?Sum_Cd_COP</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> RHT_Cd_card <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?Sum_Ch_COP</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> CD_on_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> CH_card<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> Theorem_1 stable_on_CD_on stable_on_CH <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Sum_Ch_COP</span> <span class="main">=</span> <span class="var">?Sum_Ch_X</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> RHT_Ch_card <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_iff sum_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> RHT_Ch_card <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="main">(</span>fp_cop_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> sym<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sum_mono_inv<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_6<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span> <span class="main">⟹</span> card <span class="main">(</span>Cd <span class="free">d</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span>Cd <span class="free">d</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span><span class="free">Ch</span> <span class="free">h</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Theorem_6_fp_cop_F assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Concluding remarks ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We next discuss a kind of interference between doctors termed
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹bossiness›<span class="antiquote"><span class="antiquote">}</span></span></span></span> in \S\ref{sec:bossiness}. This has some implications
for the strategic issues we discuss in \S\ref{sec:strategic}.

›</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Bossiness">
<div class="head">
<h1>Theory Bossiness</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Bossiness
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="COP.html">COP</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ \citet{Kojima:2010}: The non-existence of a stable and non-bossy mechanism \label{sec:bossiness} ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Contracts<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

\citet{Kojima:2010} says that ``a mechanism is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹nonbossy›<span class="antiquote"><span class="antiquote">}</span></span></span></span> if an
agent cannot change [the] allocation of other agents unless doing so
also changes her own allocation.'' He shows that no mechanism can be
both <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "stable_on"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹nonbossy›<span class="antiquote"><span class="antiquote">}</span></span></span></span> in a one-to-one marriage
market. We establish this result in our matching-with-contracts
setting here.

There are two complications. Firstly, as not all agent preferences
yield stable matches (unlike the marriage market), we constrain
hospital choice functions to satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"ContractsWithBilateralSubstitutesAndIRC"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, which is the weakest
condition formalized here that ensures that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "fp_cop_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span> yields
stable matches. (We note that it is not the weakest condition
guaranteeing the existence of stable matches.)

Secondly, non-bossiness needs to separately treat the preferences of
the doctors and the choice functions of the hospitals.

We work in the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Contracts"<span class="antiquote"><span class="antiquote">}</span></span></span></span> locale for its types and the
constants <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Xd</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Xh</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. To account for the
quantification over preferences, we directly use some raw constants
from the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Contracts"<span class="antiquote"><span class="antiquote">}</span></span></span></span> locale.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">mechanism_domain</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'x</span> rel<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'h</span> <span class="main">⇒</span> <span class="tfree">'x</span> cfun<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mechanism_domain</span> <span class="main">≡</span> ContractsWithBilateralSubstitutesAndIRC <span class="free">Xd</span> <span class="free">Xh</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">nonbossy</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'d</span><span class="main">,</span> <span class="tfree">'h</span><span class="main">,</span> <span class="tfree">'x</span><span class="main">)</span> mechanism <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nonbossy</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="main">⟷</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">Pd</span> <span class="bound">Pd'</span> <span class="bound">Ch</span><span class="main">.</span> <span class="main">∀</span><span class="bound">d</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">.</span> mechanism_domain <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="main">∧</span> mechanism_domain <span class="main">(</span><span class="bound">Pd</span><span class="main">(</span><span class="bound">d</span><span class="main">:=</span><span class="bound">Pd'</span><span class="main">)</span><span class="main">)</span> <span class="bound">Ch</span> <span class="main">⟶</span>
      dX <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span> <span class="bound">d</span> <span class="main">=</span> dX <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="main">(</span><span class="bound">Pd</span><span class="main">(</span><span class="bound">d</span><span class="main">:=</span><span class="bound">Pd'</span><span class="main">)</span><span class="main">)</span> <span class="bound">Ch</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span> <span class="bound">d</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="main">(</span><span class="bound">Pd</span><span class="main">(</span><span class="bound">d</span><span class="main">:=</span><span class="bound">Pd'</span><span class="main">)</span><span class="main">)</span> <span class="bound">Ch</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span>
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Pd</span> <span class="bound">Ch</span> <span class="bound">Ch'</span> <span class="bound">h</span><span class="main">.</span> mechanism_domain <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="main">∧</span> mechanism_domain <span class="bound">Pd</span> <span class="main">(</span><span class="bound">Ch</span><span class="main">(</span><span class="bound">h</span><span class="main">:=</span><span class="bound">Ch'</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span>
      hX <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span> <span class="bound">h</span> <span class="main">=</span> hX <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="bound">Pd</span> <span class="main">(</span><span class="bound">Ch</span><span class="main">(</span><span class="bound">h</span><span class="main">:=</span><span class="bound">Ch'</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span> <span class="bound">h</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="bound">Pd</span> <span class="main">(</span><span class="bound">Ch</span><span class="main">(</span><span class="bound">h</span><span class="main">:=</span><span class="bound">Ch'</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mechanism_stable</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'d</span><span class="main">,</span> <span class="tfree">'h</span><span class="main">,</span> <span class="tfree">'x</span><span class="main">)</span> mechanism <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mechanism_stable</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span>
     <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Pd</span> <span class="bound">Ch</span><span class="main">.</span> mechanism_domain <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="main">⟶</span> Contracts.stable_on <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> nonbossy_Pd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"nonbossy <span class="free">ds</span> <span class="free">φ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mechanism_domain <span class="free">Pd'</span> <span class="free">Ch'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mechanism_domain <span class="main">(</span><span class="free">Pd'</span><span class="main">(</span><span class="free">d</span><span class="main">:=</span><span class="free">Pd''</span><span class="main">)</span><span class="main">)</span> <span class="free">Ch'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"dX <span class="main">(</span><span class="free">φ</span> <span class="free">Pd'</span> <span class="free">Ch'</span> <span class="free">ds</span><span class="main">)</span> <span class="free">d</span> <span class="main">=</span> dX <span class="main">(</span><span class="free">φ</span> <span class="main">(</span><span class="free">Pd'</span><span class="main">(</span><span class="free">d</span><span class="main">:=</span><span class="free">Pd''</span><span class="main">)</span><span class="main">)</span> <span class="free">Ch'</span> <span class="free">ds</span><span class="main">)</span> <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">φ</span> <span class="free">Pd'</span> <span class="free">Ch'</span> <span class="free">ds</span> <span class="main">=</span> <span class="free">φ</span> <span class="main">(</span><span class="free">Pd'</span><span class="main">(</span><span class="free">d</span><span class="main">:=</span><span class="free">Pd''</span><span class="main">)</span><span class="main">)</span> <span class="free">Ch'</span> <span class="free">ds</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> nonbossy_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> nonbossy_Ch<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"nonbossy <span class="free">ds</span> <span class="free">φ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mechanism_domain <span class="free">Pd'</span> <span class="free">Ch'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mechanism_domain <span class="free">Pd'</span> <span class="main">(</span><span class="free">Ch'</span><span class="main">(</span><span class="free">h</span><span class="main">:=</span><span class="free">Ch''</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"hX <span class="main">(</span><span class="free">φ</span> <span class="free">Pd'</span> <span class="free">Ch'</span> <span class="free">ds</span><span class="main">)</span> <span class="free">h</span> <span class="main">=</span> hX <span class="main">(</span><span class="free">φ</span> <span class="free">Pd'</span> <span class="main">(</span><span class="free">Ch'</span><span class="main">(</span><span class="free">h</span><span class="main">:=</span><span class="free">Ch''</span><span class="main">)</span><span class="main">)</span> <span class="free">ds</span><span class="main">)</span> <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">φ</span> <span class="free">Pd'</span> <span class="free">Ch'</span> <span class="free">ds</span> <span class="main">=</span> <span class="free">φ</span> <span class="free">Pd'</span> <span class="main">(</span><span class="free">Ch'</span><span class="main">(</span><span class="free">h</span><span class="main">:=</span><span class="free">Ch''</span><span class="main">)</span><span class="main">)</span> <span class="free">ds</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> nonbossy_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Contracts<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

The proof is somewhat similar to those for Roth's impossibility
results (see, for instance, \citet[Theorem~4.4]{RothSotomayor:1990}).
It relies on the existence of at least three doctors, three hospitals,
and a complete set of contracts between these. The following locale
captures a suitable set of constraints.

›</span></span>

<span class="keyword1"><span class="command">locale</span></span> BossyConstants <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Xd</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> <span class="main">⇒</span> <span class="tfree">'d</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Xh</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> <span class="main">⇒</span> <span class="tfree">'h</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">d1h1</span> <span class="free">d1h2</span> <span class="free">d1h3</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'x</span></span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">d2h1</span> <span class="free">d2h2</span> <span class="free">d2h3</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'x</span></span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">d3h1</span> <span class="free">d3h2</span> <span class="free">d3h3</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'x</span></span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ds<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">[</span><span class="free">Xd</span> <span class="free">d1h1</span><span class="main">,</span> <span class="free">Xd</span> <span class="free">d2h1</span><span class="main">,</span> <span class="free">Xd</span> <span class="free">d3h1</span><span class="main">]</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hs<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">[</span><span class="free">Xh</span> <span class="free">d1h1</span><span class="main">,</span> <span class="free">Xh</span> <span class="free">d1h2</span><span class="main">,</span> <span class="free">Xh</span> <span class="free">d1h3</span><span class="main">]</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Xd_xs<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="main">`</span> <span class="main">{</span><span class="free">d1h2</span><span class="main">,</span> <span class="free">d1h3</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">Xd</span> <span class="free">d1h1</span><span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="main">`</span> <span class="main">{</span><span class="free">d2h2</span><span class="main">,</span> <span class="free">d2h3</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">Xd</span> <span class="free">d2h1</span><span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="main">`</span> <span class="main">{</span><span class="free">d3h2</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">Xd</span> <span class="free">d3h1</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Xh_xs<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">Xh</span> <span class="main">`</span> <span class="main">{</span><span class="free">d2h1</span><span class="main">,</span> <span class="free">d3h1</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">Xh</span> <span class="free">d1h1</span><span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">Xh</span> <span class="main">`</span> <span class="main">{</span><span class="free">d2h2</span><span class="main">,</span> <span class="free">d3h2</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">Xh</span> <span class="free">d1h2</span><span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">Xh</span> <span class="main">`</span> <span class="main">{</span><span class="free">d2h3</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">Xh</span> <span class="free">d1h3</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> dset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">Xd</span> <span class="free">d1h1</span><span class="main">,</span> <span class="free">Xd</span> <span class="free">d2h1</span><span class="main">,</span> <span class="free">Xd</span> <span class="free">d3h1</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">ds</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> ContractsWithBossyConstants <span class="main">=</span>
  Contracts <span class="main">+</span> BossyConstants
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">d1</span> <span class="main">≡</span> <span class="free">Xd</span> <span class="free">d1h1</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">d2</span> <span class="main">≡</span> <span class="free">Xd</span> <span class="free">d2h1</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">d3</span> <span class="main">≡</span> <span class="free">Xd</span> <span class="free">d3h1</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">h1</span> <span class="main">≡</span> <span class="free">Xh</span> <span class="free">d1h1</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">h2</span> <span class="main">≡</span> <span class="free">Xh</span> <span class="free">d1h2</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">h3</span> <span class="main">≡</span> <span class="free">Xh</span> <span class="free">d1h3</span>"</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> xs<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">[</span><span class="free">d1h1</span><span class="main">,</span> <span class="free">d1h2</span><span class="main">,</span> <span class="free">d1h3</span><span class="main">,</span> <span class="free">d2h1</span><span class="main">,</span> <span class="free">d2h2</span><span class="main">,</span> <span class="free">d2h3</span><span class="main">,</span> <span class="free">d3h1</span><span class="main">,</span> <span class="free">d3h2</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Xd_xs Xh_xs ds hs <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We proceed to show that variations on the following preferences for
doctors and hospitals force a stable mechanism to be bossy. Recall
that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "linord_of_list"<span class="antiquote"><span class="antiquote">}</span></span></span></span> constructs a linear order from a list of
elements greatest to least. The hospital choice functions take at most
one contract from those on offer, and are again ordered from most
preferable to least.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">BPd</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">BPd</span> <span class="main">≡</span> map_of_default <span class="main">{}</span> <span class="main">[</span> <span class="main">(</span>d1<span class="main">,</span> linord_of_list <span class="main">[</span><span class="free">d1h3</span><span class="main">,</span> <span class="free">d1h2</span><span class="main">,</span> <span class="free">d1h1</span><span class="main">]</span><span class="main">)</span>
                           <span class="main">,</span> <span class="main">(</span>d2<span class="main">,</span> linord_of_list <span class="main">[</span><span class="free">d2h3</span><span class="main">,</span> <span class="free">d2h2</span><span class="main">,</span> <span class="free">d2h1</span><span class="main">]</span><span class="main">)</span>
                           <span class="main">,</span> <span class="main">(</span>d3<span class="main">,</span> linord_of_list <span class="main">[</span><span class="free">d3h1</span><span class="main">,</span> <span class="free">d3h2</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">]</span><span class="main">)</span> <span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mkhord</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> list <span class="main">⇒</span> <span class="tfree">'d</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mkhord</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> set_option <span class="main">(</span>List.find <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">BCh</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'a</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">BCh</span> <span class="main">≡</span> map_of_default <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">{}</span><span class="main">)</span> <span class="main">[</span> <span class="main">(</span>h1<span class="main">,</span> mkhord <span class="main">[</span><span class="free">d1h1</span><span class="main">,</span> <span class="free">d2h1</span><span class="main">,</span> <span class="free">d3h1</span><span class="main">]</span><span class="main">)</span>
                                 <span class="main">,</span> <span class="main">(</span>h2<span class="main">,</span> mkhord <span class="main">[]</span><span class="main">)</span>
                                 <span class="main">,</span> <span class="main">(</span>h3<span class="main">,</span> mkhord <span class="main">[</span><span class="free">d3h3</span><span class="main">,</span> <span class="free">d2h3</span><span class="main">,</span> <span class="free">d1h3</span><span class="main">]</span><span class="main">)</span> <span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Interpreting the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Contracts"<span class="antiquote"><span class="antiquote">}</span></span></span></span> locale gives us access to some
useful constants.

›</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> Bossy<span class="main">:</span> Contracts <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted">BPd</span> <span class="quoted">BCh</span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Xd_xs Xh_xs xs <span class="keyword1"><span class="command">unfolding</span></span> BPd_def BCh_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> linord_of_list_Linear_order<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> BPd_BCh_mechanism_domain<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mechanism_domain BPd BCh"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> BCh_def bilateral_substitutes_on_def irc_on_def<span class="main">)</span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> BPd_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"BPd d1 <span class="main">=</span> linord_of_list <span class="main">[</span><span class="free">d1h3</span><span class="main">,</span> <span class="free">d1h2</span><span class="main">,</span> <span class="free">d1h1</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"BPd d2 <span class="main">=</span> linord_of_list <span class="main">[</span><span class="free">d2h3</span><span class="main">,</span> <span class="free">d2h2</span><span class="main">,</span> <span class="free">d2h1</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"BPd d3 <span class="main">=</span> linord_of_list <span class="main">[</span><span class="free">d3h1</span><span class="main">,</span> <span class="free">d3h2</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∉</span> <span class="main">{</span>d1<span class="main">,</span> d2<span class="main">,</span> d3<span class="main">}</span> <span class="main">⟷</span> BPd <span class="free">d</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> BPd_def <span class="keyword1"><span class="command">using</span></span> Xd_xs ds <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> BCh_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"BCh h1 <span class="main">=</span> mkhord <span class="main">[</span><span class="free">d1h1</span><span class="main">,</span> <span class="free">d2h1</span><span class="main">,</span> <span class="free">d3h1</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"BCh h3 <span class="main">=</span> mkhord <span class="main">[</span><span class="free">d3h3</span><span class="main">,</span> <span class="free">d2h3</span><span class="main">,</span> <span class="free">d1h3</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∉</span> <span class="main">{</span>h1<span class="main">,</span> h3<span class="main">}</span> <span class="main">⟹</span> BCh <span class="free">h</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> BCh_def <span class="keyword1"><span class="command">using</span></span> Xh_xs hs <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> Bossy_CD_on_Cd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Bossy.CD_on <span class="free">ds</span> <span class="free">X</span> <span class="main">=</span> Bossy.Cd d1 <span class="free">X</span> <span class="main">∪</span> Bossy.Cd d2 <span class="free">X</span> <span class="main">∪</span> Bossy.Cd d3 <span class="free">X</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⊆</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Bossy.CD_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> BPd_simps<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> Bossy.Cd_range' Field_empty Int_iff empty_iff insertE<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> dset <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">⊆</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Bossy.CD_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Bossy_CH_BCh<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Bossy.CH <span class="free">X</span> <span class="main">=</span> BCh h1 <span class="free">X</span> <span class="main">∪</span> BCh h3 <span class="free">X</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⊆</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Bossy.CH_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> BCh_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">⊆</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Bossy.CH_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Bossy_CH_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">⊆</span> Bossy.CH <span class="free">X'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">⊆</span> set <span class="main">[</span><span class="free">d1h1</span><span class="main">,</span> <span class="free">d1h3</span><span class="main">,</span> <span class="free">d2h1</span><span class="main">,</span> <span class="free">d2h3</span><span class="main">,</span> <span class="free">d3h1</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Bossy_CH_BCh BCh_simps <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> Bossy_stable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Bossy.stable_on <span class="free">ds</span> <span class="free">X</span> <span class="main">⟷</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{</span><span class="free">d1h1</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">}</span>"</span></span>
<span class="comment1">(*&lt;*)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">with</span></span> Xd_xs ds xs <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> Bossy.stable_on_allocation<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> Bossy.stable_on_CH<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> Bossy.stable_on_CD_on<span class="main">)</span>

    <span class="comment1">(* Enumerate all possible contracts *)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> Bossy_CH_range<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Set.equalityD2<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> subset_subseqs<span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Bossy_CH_BCh BCh_simps insert_eq_iff insert_commute<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> Bossy.stable_on_blocking_onD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"h3"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X''<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">d3h3</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> ds<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ds</span></span><span class="main">]</span>
          Bossy.stable_on_blocking_onD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"h1"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X''<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">d2h1</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> ds<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ds</span></span><span class="main">]</span>
          Bossy.stable_on_blocking_onD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"h1"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X''<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">d1h1</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> ds<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ds</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Bossy_CH_BCh BCh_simps Bossy_CD_on_Cd BPd_simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Bossy.stable_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Bossy.individually_rational_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Bossy.individually_rational_onI<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> xs <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Bossy.CD_on <span class="free">ds</span> <span class="free">X</span> <span class="main">=</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Bossy_CD_on_Cd BPd_simps<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Bossy.CH <span class="free">X</span> <span class="main">=</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Bossy_CH_BCh BCh_simps insert_commute<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Bossy.stable_no_blocking_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Bossy.stable_no_blocking_onI<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="skolem">X''</span> <span class="keyword3"><span class="command">assume</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">=</span> BCh <span class="skolem">h</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">≠</span> BCh <span class="skolem">h</span> <span class="free">X</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">⊆</span> Bossy.CD_on <span class="free">ds</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span> XXX<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">h</span> <span class="main">∈</span> <span class="main">{</span>h1<span class="main">,</span> h3<span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> BCh_simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> XXX<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> X''<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">⊆</span> set <span class="main">[</span><span class="free">d1h1</span><span class="main">,</span> <span class="free">d1h3</span><span class="main">,</span> <span class="free">d2h1</span><span class="main">,</span> <span class="free">d2h3</span><span class="main">,</span> <span class="free">d3h1</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">]</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> Bossy_CH_range<span class="main">[</span><span class="operator">unfolded</span> Bossy.CH_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span> XXX h X'' Xh_xs hs xs <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> subset_subseqs<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> BCh_simps<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The second preference order has doctor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "d2"<span class="antiquote"><span class="antiquote">}</span></span></span></span> reject all
contracts and is otherwise the same as the first.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">BPd'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">BPd'</span> <span class="main">=</span> BPd<span class="main">(</span>d2 <span class="main">:=</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> Bossy'<span class="main">:</span> Contracts <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted">BPd'</span> <span class="quoted">BCh</span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Xd_xs Xh_xs xs <span class="keyword1"><span class="command">unfolding</span></span> BPd_def BPd'_def BCh_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> linord_of_list_Linear_order<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> BPd'_BCh_mechanism_domain<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mechanism_domain BPd' BCh"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> BCh_def bilateral_substitutes_on_def irc_on_def<span class="main">)</span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> BPd'_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"BPd' d1 <span class="main">=</span> linord_of_list <span class="main">[</span><span class="free">d1h3</span><span class="main">,</span> <span class="free">d1h2</span><span class="main">,</span> <span class="free">d1h1</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"BPd' d3 <span class="main">=</span> linord_of_list <span class="main">[</span><span class="free">d3h1</span><span class="main">,</span> <span class="free">d3h2</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∉</span> <span class="main">{</span>d1<span class="main">,</span> d3<span class="main">}</span> <span class="main">⟷</span> BPd' <span class="free">d</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> BPd_def BPd'_def <span class="keyword1"><span class="command">using</span></span> Xd_xs ds <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> Bossy'_CD_on_Cd<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Bossy'.CD_on <span class="free">ds</span> <span class="free">X</span> <span class="main">=</span> Bossy'.Cd d1 <span class="free">X</span> <span class="main">∪</span> Bossy'.Cd d3 <span class="free">X</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⊆</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Bossy'.CD_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> BPd'_simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> Bossy'.Cd_range' Field_empty Int_iff empty_iff insertE<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> dset <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">⊆</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Bossy'.CD_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> Bossy'_stable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Bossy'.stable_on <span class="free">ds</span> <span class="free">X</span> <span class="main">⟷</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{</span><span class="free">d1h3</span><span class="main">,</span> <span class="free">d3h1</span><span class="main">}</span> <span class="main">∨</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{</span><span class="free">d1h1</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">}</span>"</span></span>
<span class="comment1">(*&lt;*)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">with</span></span> dset <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> Xd_xs ds xs <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> Bossy'.stable_on_allocation<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> Bossy'.stable_on_CH<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> Bossy'.stable_on_CD_on<span class="main">)</span>

    <span class="comment1">(* Enumerate all possible contracts *)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> Bossy_CH_range<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Set.equalityD2<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> subset_subseqs<span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Bossy_CH_BCh BCh_simps insert_eq_iff insert_commute<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> Bossy'.stable_on_blocking_onD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"h3"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X''<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">d3h3</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> ds<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ds</span></span><span class="main">]</span>
          Bossy'.stable_on_blocking_onD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"h1"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X''<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">d1h1</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> ds<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ds</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Bossy_CH_BCh BCh_simps Bossy'_CD_on_Cd BPd'_simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Bossy'.stable_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Bossy'.individually_rational_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Bossy'.individually_rational_onI<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> ds xs <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Bossy'.CD_on <span class="free">ds</span> <span class="free">X</span> <span class="main">=</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Bossy'_CD_on_Cd BPd'_simps<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> xs <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Bossy.CH <span class="free">X</span> <span class="main">=</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Bossy_CH_BCh BCh_simps<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Bossy'.stable_no_blocking_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Bossy'.stable_no_blocking_onI<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="skolem">X''</span> <span class="keyword3"><span class="command">assume</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">=</span> BCh <span class="skolem">h</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">≠</span> BCh <span class="skolem">h</span> <span class="free">X</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">⊆</span> Bossy'.CD_on <span class="free">ds</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span> XXX<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">h</span> <span class="main">∈</span> <span class="main">{</span>h1<span class="main">,</span> h2<span class="main">,</span> h3<span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> BCh_simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> XXX<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> X''<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">⊆</span> set <span class="main">[</span><span class="free">d1h1</span><span class="main">,</span> <span class="free">d1h3</span><span class="main">,</span> <span class="free">d2h1</span><span class="main">,</span> <span class="free">d2h3</span><span class="main">,</span> <span class="free">d3h1</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">]</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> Bossy_CH_range<span class="main">[</span><span class="operator">unfolded</span> Bossy.CH_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span> XXX h X'' Xh_xs ds hs xs <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> subset_subseqs<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> BCh_simps<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Bossy'_CD_on_Cd Bossy'.maxR_def linord_of_list_linord_of_listP BPd'_simps<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The third preference order adjusts the choice function of hospital
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "h2"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and is otherwise the same as the second.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">BCh'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'a</span> cfun"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">BCh'</span> <span class="main">≡</span> BCh<span class="main">(</span>h2 <span class="main">:=</span> mkhord <span class="main">[</span><span class="free">d1h2</span><span class="main">,</span> <span class="free">d2h2</span><span class="main">,</span> <span class="free">d3h2</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> Bossy''<span class="main">:</span> Contracts <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted">BPd'</span> <span class="quoted">BCh'</span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Xd_xs Xh_xs xs <span class="keyword1"><span class="command">unfolding</span></span> BPd_def BPd'_def BCh_def BCh'_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> linord_of_list_Linear_order<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> BPd'_BCh'_mechanism_domain<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mechanism_domain BPd' BCh'"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> BCh_def BCh'_def bilateral_substitutes_on_def irc_on_def<span class="main">)</span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> BCh'_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"BCh' h1 <span class="main">=</span> mkhord <span class="main">[</span><span class="free">d1h1</span><span class="main">,</span> <span class="free">d2h1</span><span class="main">,</span> <span class="free">d3h1</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"BCh' h2 <span class="main">=</span> mkhord <span class="main">[</span><span class="free">d1h2</span><span class="main">,</span> <span class="free">d2h2</span><span class="main">,</span> <span class="free">d3h2</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"BCh' h3 <span class="main">=</span> mkhord <span class="main">[</span><span class="free">d3h3</span><span class="main">,</span> <span class="free">d2h3</span><span class="main">,</span> <span class="free">d1h3</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∉</span> <span class="main">{</span>h1<span class="main">,</span> h2<span class="main">,</span> h3<span class="main">}</span> <span class="main">⟹</span> BCh' <span class="free">h</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> BCh_def BCh'_def <span class="keyword1"><span class="command">using</span></span> Xh_xs hs <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> Bossy''_CH_BCh'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Bossy''.CH <span class="free">X</span> <span class="main">=</span> BCh' h1 <span class="free">X</span> <span class="main">∪</span> BCh' h2 <span class="free">X</span> <span class="main">∪</span> BCh' h3 <span class="free">X</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⊆</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Bossy''.CH_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> BCh_def BCh'_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">⊆</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Bossy''.CH_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Bossy''_CD_on_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">⊆</span> Bossy''.CD_on <span class="free">ds</span> <span class="free">X'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">⊆</span> set <span class="main">[</span><span class="free">d1h1</span><span class="main">,</span> <span class="free">d1h2</span><span class="main">,</span> <span class="free">d1h3</span><span class="main">,</span> <span class="free">d3h1</span><span class="main">,</span> <span class="free">d3h2</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Bossy'_CD_on_Cd BPd'_simps <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Bossy''.Cd_range'<span class="main">)</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> Bossy''_stable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Bossy''.stable_on <span class="free">ds</span> <span class="free">X</span> <span class="main">⟷</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{</span><span class="free">d3h1</span><span class="main">,</span> <span class="free">d1h3</span><span class="main">}</span>"</span></span>
<span class="comment1">(*&lt;*)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">with</span></span> Xd_xs ds xs <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> Bossy''.stable_on_allocation<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> Bossy''.stable_on_CH<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> Bossy''.stable_on_CD_on<span class="main">)</span>

    <span class="comment1">(* Enumerate all possible contracts *)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> Bossy''_CD_on_range<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Set.equalityD2<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> subset_subseqs<span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Bossy''_CH_BCh' BCh'_simps insert_eq_iff insert_commute<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> Bossy''.stable_on_blocking_onD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"h1"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X''<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">d3h1</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> ds<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ds</span></span><span class="main">]</span>
          Bossy''.stable_on_blocking_onD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"h2"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X''<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">d1h2</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> ds<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ds</span></span><span class="main">]</span>
          Bossy''.stable_on_blocking_onD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"h3"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X''<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">d1h3</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> ds<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ds</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> BCh'_simps Bossy'_CD_on_Cd BPd'_simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Bossy''.maxR_def linord_of_list_linord_of_listP BPd'_simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Bossy''.stable_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Bossy''.individually_rational_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Bossy''.individually_rational_onI<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> ds xs <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Bossy''.CD_on <span class="free">ds</span> <span class="free">X</span> <span class="main">=</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Bossy'_CD_on_Cd BPd'_simps<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> xs <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Bossy''.CH <span class="free">X</span> <span class="main">=</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Bossy''_CH_BCh' BCh'_simps<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Bossy''.stable_no_blocking_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Bossy''.stable_no_blocking_onI<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="skolem">X''</span> <span class="keyword3"><span class="command">assume</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">=</span> BCh' <span class="skolem">h</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">≠</span> BCh' <span class="skolem">h</span> <span class="free">X</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">⊆</span> Bossy''.CD_on <span class="free">ds</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span> XXX<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">h</span> <span class="main">∈</span> <span class="main">{</span>h1<span class="main">,</span> h2<span class="main">,</span> h3<span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> BCh'_simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> XXX<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> X''<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">X''</span> <span class="main">⊆</span> set <span class="main">[</span><span class="free">d1h1</span><span class="main">,</span> <span class="free">d1h2</span><span class="main">,</span> <span class="free">d1h3</span><span class="main">,</span> <span class="free">d3h1</span><span class="main">,</span> <span class="free">d3h2</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">]</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> Bossy''_CD_on_range <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span> XXX h X'' Xh_xs ds hs xs <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> subset_subseqs<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> BCh'_simps<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Bossy'_CD_on_Cd BPd'_simps Bossy'.maxR_def linord_of_list_linord_of_listP<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span>mechanism_stable <span class="free">ds</span> <span class="free">φ</span> <span class="main">∧</span> nonbossy <span class="free">ds</span> <span class="free">φ</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> notI<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> conjE<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> S<span class="main">:</span> <span class="quoted"><span class="quoted">"Bossy.mechanism_stable <span class="free">ds</span> <span class="free">φ</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> NB<span class="main">:</span> <span class="quoted"><span class="quoted">"Bossy.nonbossy <span class="free">ds</span> <span class="free">φ</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> S Bossy'_stable BPd'_BCh_mechanism_domain
  <span class="keyword1"><span class="command">consider</span></span> <span class="main">(</span>A<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">φ</span> BPd' BCh <span class="free">ds</span> <span class="main">=</span> <span class="main">{</span><span class="free">d1h3</span><span class="main">,</span> <span class="free">d3h1</span><span class="main">}</span>"</span></span> <span class="main">|</span> <span class="main">(</span>B<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">φ</span> BPd' BCh <span class="free">ds</span> <span class="main">=</span> <span class="main">{</span><span class="free">d1h1</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> mechanism_stable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">case</span></span> A
    <span class="keyword1"><span class="command">from</span></span> S BPd_BCh_mechanism_domain Bossy_stable <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">φ</span> BPd BCh <span class="free">ds</span> <span class="main">=</span> <span class="main">{</span><span class="free">d1h1</span><span class="main">,</span> <span class="free">d3h3</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> mechanism_stable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> Xd_xs ds xs dset A <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command">using</span></span> nonbossy_Pd<span class="main">[</span><span class="operator">OF</span> NB BPd_BCh_mechanism_domain BPd'_BCh_mechanism_domain<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> BPd'_def<span class="main"><span class="main">]</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> BPd'_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> dX_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> B
    <span class="keyword1"><span class="command">from</span></span> S BPd'_BCh'_mechanism_domain Bossy''_stable <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">φ</span> BPd' BCh' <span class="free">ds</span> <span class="main">=</span> <span class="main">{</span><span class="free">d3h1</span><span class="main">,</span> <span class="free">d1h3</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> mechanism_stable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> Xh_xs hs xs dset B <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command">using</span></span> nonbossy_Ch<span class="main">[</span><span class="operator">OF</span> NB BPd'_BCh_mechanism_domain BPd'_BCh'_mechanism_domain<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> BCh'_def<span class="main"><span class="main">]</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> BCh'_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> hX_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

In particular, the COP (see \S\ref{sec:cop}) is bossy as it always
yields stable matches under <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "mechanism_stable"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_1_COP<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span>nonbossy <span class="free">ds</span> Contracts.cop"</span></span>
<span class="keyword1"><span class="command">using</span></span> ContractsWithBilateralSubstitutesAndIRC.Theorem_1 Theorem_1 mechanism_stable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Therefore doctors can interfere with other doctors' allocations under
the COP without necessarily disadvantaging themselves, which has
implications for the notion of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹group strategy-proof›<span class="antiquote"><span class="antiquote">}</span></span></span></span>
\citep{HatfieldKojima:2009}; see \S\ref{sec:strategic-gsp}.

›</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Strategic">
<div class="head">
<h1>Theory Strategic</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Strategic
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="COP.html">COP</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ Strategic results \label{sec:strategic} ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ContractsWithSubstitutes<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

We proceed to establish a series of strategic results for the COP (see
\S\ref{sec:contracts-cop} and \S\ref{sec:cop}), making use of the
invariants we developed for it. These results also apply to the
matching-with-contracts setting of \S\ref{sec:contracts}, and where
possible we specialize our lemmas to it.

›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ \citet{HatfieldMilgrom:2005}: Theorems~10 and~11: Truthful revelation as a Dominant Strategy \label{sec:strategic-contracts} ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ContractsWithSubstitutes<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

Theorems~10 and 11 demonstrate that doctors cannot obtain better
results for themselves in the doctor-optimal match (i.e., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"cop <span class="free"><span class="free">ds</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, equal to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"match <span class="main"><span class="main">(</span></span>gfp_F <span class="free"><span class="free">ds</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source]
"Theorem_15_match"<span class="antiquote"><span class="antiquote">}</span></span></span></span> assuming hospital preferences satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>) by misreporting their preferences. (See
\citet[\S4.2]{RothSotomayor:1990} for a discussion about the
impossibility of a mechanism being strategy-proof for all agents.)

\citet[{\S}III(B)]{HatfieldMilgrom:2005} provide the
following intuition:
\begin{quote}

We will show the positive incentive result for the doctor-offering
algorithm in two steps which highlight the different roles of the two
preference assumptions. First, we show that the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
condition, by itself, guarantees that doctors cannot benefit by
exaggerating the ranking of an unattainable contract. More precisely,
if there exists a preferences list for a doctor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">d</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> such that
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">d</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> obtains contract <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> by submitting this list, then
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">d</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> can also obtain <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> by submitting a preference
list that includes only contract <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> [Theorem~10]. Second, we
will show that adding the law of aggregate demand guarantees that a
doctor does at least as well as reporting truthfully as by reporting
any singleton [Theorem~11]. Together, these are the dominant strategy
result.

\end{quote}

We prove Theorem~10 via a lemma that states that the contracts above
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">X</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for some stable match <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">X</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with respect to
manipulated preferences <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Pd</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">Xd</span></span> <span class="free"><span class="free">x</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> do not improve the outcome
for doctor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Xd</span></span> <span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with respect to their true preferences
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Pd'</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">Xd</span></span> <span class="free"><span class="free">x</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in the doctor-optimal match for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Pd'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

This is weaker than \citet[Lemma~1]{HatfieldKojima:2009} (see
\S\ref{sec:strategic-hk2010-lemma1}) as we do not guarantee that the
allocation does not change. By the bossiness result of
\S\ref{sec:bossiness}, such manipulations can change the outcomes of
the other doctors; this lemma establishes that only weak improvements
are possible.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithUnilateralSubstitutesAndIRC
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">d'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Pd'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Pd'_d'_linear<span class="main">:</span> <span class="quoted"><span class="quoted">"Linear_order <span class="main">(</span><span class="free">Pd'</span> <span class="free">d'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Pd'_d'_range<span class="main">:</span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span><span class="free">Pd'</span> <span class="free">d'</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">d'</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Pd'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d</span><span class="main">.</span> <span class="bound">d</span><span class="main">≠</span><span class="free">d'</span> <span class="main">⟶</span> <span class="free">Pd'</span> <span class="bound">d</span> <span class="main">=</span> <span class="free">Pd</span> <span class="bound">d</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> PdXXX_linear<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="main">(</span><span class="free">Pd'</span> <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Pd_linear Pd'_d'_linear Pd' <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">=</span> <span class="free">d'</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> PdXXX_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span><span class="free">Pd'</span> <span class="free">d</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">d</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Pd_range Pd'_d'_range Pd' <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">=</span> <span class="free">d'</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemmas</span></span> PdXXX_range' <span class="main">=</span> subsetD<span class="main">[</span><span class="operator">OF</span> PdXXX_range<span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">interpretation</span></span> PdXXX<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRC <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted"><span class="free">Pd'</span></span> <span class="quoted"><span class="free">Ch</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible PdXXX_linear PdXXX_range Ch_range Ch_singular Ch_unilateral_substitutes Ch_irc
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Pd_above_irrelevant<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> d'_Field<span class="main">:</span> <span class="quoted"><span class="quoted">"dX <span class="free">X</span> <span class="free">d'</span> <span class="main">⊆</span> Field <span class="main">(</span><span class="free">Pd'</span> <span class="free">d'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> d'_Above<span class="main">:</span> <span class="quoted"><span class="quoted">"Above <span class="main">(</span><span class="free">Pd'</span> <span class="free">d'</span><span class="main">)</span> <span class="main">(</span>dX <span class="free">X</span> <span class="free">d'</span><span class="main">)</span> <span class="main">⊆</span> Above <span class="main">(</span><span class="free">Pd</span> <span class="free">d'</span><span class="main">)</span> <span class="main">(</span>dX <span class="free">X</span> <span class="free">d'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> PdXXX.cop <span class="free">ds</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd'</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> PdXXX.Theorem_5<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ccontr <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>PdXXX.stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> PdXXX.not_stable_on_cases<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> not_individually_rational
    <span class="keyword1"><span class="command">from</span></span> Pd' <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> d'_Field <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> PdXXX.Cd <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span> <span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> dX_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> stable_on_range' stable_on_allocation PdXXX.Cd_single<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> not_individually_rational <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command">unfolding</span></span> PdXXX.individually_rational_on_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> PdXXX.mem_CD_on_Cd stable_on_Xd <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> stable_on_CH PdXXX.CD_on_range'<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> not_no_blocking
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">h</span></span> <span class="skolem"><span class="skolem">X''</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"PdXXX.blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="skolem">h</span> <span class="skolem">X''</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> PdXXX.stable_no_blocking_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="skolem">h</span> <span class="skolem">X''</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> blocking_onI<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X''</span>"</span></span>
      <span class="keyword1"><span class="command">note</span></span> Pbos <span class="main">=</span> PdXXX.blocking_on_Field<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹PdXXX.blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span><span class="main">]</span>
                  PdXXX.blocking_on_allocation<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹PdXXX.blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span><span class="main">]</span>
                  PdXXX.blocking_on_CD_on'<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹PdXXX.blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X''</span>›</span></span><span class="main">]</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> CD_on <span class="free">ds</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">d'</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">from</span></span> Pd_linear' d'_Field d'_Above <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X''</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">d'</span>›</span></span> Pbos
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dX <span class="skolem">X''</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⊆</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> PdXXX.mem_CD_on_Cd PdXXX.Cd_Above PdXXX.dX_Int_Field_Pd Above_union
                          Int_Un_distrib2 dX_singular <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Above_Field<span class="main">)</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dX <span class="free">X</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⊆</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> dX_range' stable_on_range'<span class="main">)</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> Pd_linear' Pd_range PdXXX_range d'_Field d'_Above <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X''</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">d'</span>›</span></span> Pbos
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> PdXXX.mem_CD_on_Cd PdXXX.Cd_Above_dX mem_CD_on_Cd Cd_Above_dX
                             Above_union dX_union Int_Un_distrib2<span class="main">)</span>
             <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dX_singular <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Above_Linear_singleton<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> PdXXX.CD_on <span class="free">ds</span> <span class="main">(</span><span class="free">X</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd' PdXXX.mem_CD_on_Cd mem_CD_on_Cd PdXXX.Cd_greatest Cd_greatest<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> <span class="quoted"><span class="quoted">‹PdXXX.blocking_on <span class="free">ds</span> <span class="free">X</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main">:</span> PdXXX.blocking_on_def›</span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> blocking_on_imp_not_stable<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We now specialize this lemma to Theorem~10 by defining a preference
order for the doctors where distinguished doctors <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">ds</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> submit
single preferences for the contracts they receive in the
doctor-optimal match.

The function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> "override_on_def"<span class="antiquote"><span class="antiquote">}</span></span></span></span> denotes function update at
several points.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Pd_singletons_for_ds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">⇒</span> <span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'x</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Pd_singletons_for_ds</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">≡</span> override_on <span class="free">Pd</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> dX <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="bound">d</span> <span class="main">×</span> dX <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="bound">d</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span>"</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> Pd_singletons_for_ds_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span>Pd_singletons_for_ds <span class="free">X</span> <span class="free">ds</span> <span class="free">d</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">d</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Pd_range dX_range <span class="keyword1"><span class="command">unfolding</span></span> Pd_singletons_for_ds_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Field_def override_on_def<span class="main">)</span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Pd_singletons_for_ds_linear<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"allocation <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="main">(</span>Pd_singletons_for_ds <span class="free">X</span> <span class="free">ds</span> <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Pd_singletons_for_ds_def <span class="keyword1"><span class="command">using</span></span> Pd_linear dX_linear<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> override_on_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Pd_singletons_for_ds_simps<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds</span> <span class="main">⟹</span> Pd_singletons_for_ds <span class="free">X</span> <span class="free">ds</span> <span class="free">d</span> <span class="main">=</span> dX <span class="free">X</span> <span class="free">d</span> <span class="main">×</span> dX <span class="free">X</span> <span class="free">d</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∉</span> <span class="free">ds</span> <span class="main">⟹</span> Pd_singletons_for_ds <span class="free">X</span> <span class="free">ds</span> <span class="free">d</span> <span class="main">=</span> <span class="free">Pd</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Pd_singletons_for_ds_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We interpret our <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "ContractsWithUnilateralSubstitutesAndIRC"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
locale with respect to this updated preference order, which gives us
the stable match and properties of it.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithUnilateralSubstitutesAndIRC
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span>
  Singleton_for_d<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRC <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted"><span class="quoted">"Pd_singletons_for_ds <span class="free">X</span> <span class="main">{</span><span class="free">d</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="free">Ch</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">d</span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Pd_singletons_for_ds_linear Pd_singletons_for_ds_range Ch_range Ch_singular Ch_unilateral_substitutes Ch_irc
                 stable_on_allocation<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Our version of \citet[Theorem~10]{HatfieldMilgrom:2005} (for the COP)
states that if a doctor submits a preference order containing just
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is their contract in some stable match
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">X</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, then that doctor receives exactly <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in the
doctor-optimal match and all other doctors do at least as well.

›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_10_fp_cop_F<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> Singleton_for_d.cop <span class="free">d</span> <span class="free">ds</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> Pd_singletons_for_ds <span class="free">X</span> <span class="main">{</span><span class="free">d</span><span class="main">}</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Pd_above_irrelevant<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ds<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">ds</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> d'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">d</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> X<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">X</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> stable_on_allocation <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Above <span class="main">(</span>Pd_singletons_for_ds <span class="free">X</span> <span class="main">{</span><span class="free">d</span><span class="main">}</span> <span class="free">d</span><span class="main">)</span> <span class="main">(</span>Singleton_for_d.dX <span class="free">X</span> <span class="free">d</span><span class="main">)</span> <span class="main">⊆</span> Above <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="main">(</span>Singleton_for_d.dX <span class="free">X</span> <span class="free">d</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Above_def Pd_singletons_for_ds_simps dX_def<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> inj_on_eq_iff stable_on_range' Pd_refl<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> stable_on_allocation <span class="quoted"><span class="quoted">‹stable_on <span class="free">ds</span> <span class="free">X</span>›</span></span> Pd_singletons_for_ds_linear Pd_singletons_for_ds_range assms
     <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">simp_all</span><span class="keyword3">,</span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main">:</span> Pd_singletons_for_ds_simps dX_def›</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ContractsWithSubstitutesAndIRC<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

We can recover the original Theorem~10 by specializing this result to
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "gfp_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithSubstitutesAndIRC
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span>
  Singleton_for_d<span class="main">:</span> ContractsWithSubstitutesAndIRC <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted"><span class="quoted">"Pd_singletons_for_ds <span class="main">(</span>match <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="free">d</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="free">Ch</span></span>
<span class="keyword2"><span class="keyword">for</span></span> <span class="free">ds</span> <span class="free">d</span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Pd_singletons_for_ds_linear Pd_singletons_for_ds_range Ch_range Ch_singular Ch_substitutes Ch_irc gfp_F_stable_on
                 stable_on_allocation<span class="main">[</span><span class="operator">OF</span> gfp_F_stable_on<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_10<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> match <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> match <span class="main">(</span>Singleton_for_d.gfp_F <span class="free">ds</span> <span class="free">d</span> <span class="free">ds</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> Pd_singletons_for_ds <span class="main">(</span>match <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="free">d</span><span class="main">}</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Theorem_10_fp_cop_F Singleton_for_d.Theorem_15_match Theorem_15_match gfp_F_stable_on assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">corollary</span></span> Theorem_10_d<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> match <span class="main">(</span>gfp_F <span class="free">ds</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> match <span class="main">(</span>Singleton_for_d.gfp_F <span class="free">ds</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span> <span class="free">ds</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> gfp_F_stable_on<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span> Theorem_10<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span>"</span></span><span class="main">]</span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd_singletons_for_ds_simps dX_def inj_on_eq_iff <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> stable_on_allocation<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ContractsWithSubstitutes<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

The second theorem \citep[Theorem~11]{HatfieldMilgrom:2005} depends on
both Theorem~10 and the rural hospitals theorem
(\S\ref{sec:contracts-rh}, \S\ref{sec:cop-rh}). It shows that,
assuming everything else is fixed, if doctor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">d'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> obtains
contract <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with (manipulated) preferences <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Pd</span></span> <span class="free"><span class="free">d'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in
the doctor-optimal match, then they will obtain a contract at least as
good by submitting their true preferences <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Pd'</span></span> <span class="free"><span class="free">d'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (with
respect to these true preferences).

›</span></span>

<span class="keyword1"><span class="command">locale</span></span> TruePrefs <span class="main">=</span> Contracts <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Pd'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"stable_on <span class="free">ds</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Pd'_d'_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd'</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Pd'_d'_linear<span class="main">:</span> <span class="quoted"><span class="quoted">"Linear_order <span class="main">(</span><span class="free">Pd'</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Pd'_d'_range<span class="main">:</span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span><span class="free">Pd'</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">Xd</span> <span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Pd'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d</span><span class="main">.</span> <span class="bound">d</span><span class="main">≠</span><span class="free">Xd</span> <span class="free">x</span> <span class="main">⟶</span> <span class="free">Pd'</span> <span class="bound">d</span> <span class="main">=</span> <span class="free">Pd</span> <span class="bound">d</span>"</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Pd'_linear<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="main">(</span><span class="free">Pd'</span> <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Pd_linear Pd'_d'_linear Pd' <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">=</span> <span class="free">Xd</span> <span class="free">x</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> Pd'_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span><span class="free">Pd'</span> <span class="free">d</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">d</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Pd_range Pd'_d'_range Pd' <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">=</span> <span class="free">Xd</span> <span class="free">x</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Pd'_tax</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Pd'_tax</span> <span class="main">=</span> <span class="main">(</span><span class="free">Pd'</span><span class="main">(</span><span class="free">Xd</span> <span class="free">x</span> <span class="main">:=</span> Restr <span class="main">(</span><span class="free">Pd'</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>above <span class="main">(</span><span class="free">Pd'</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Pd'_tax_linear<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="main">(</span>Pd'_tax <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Pd'_linear Pd'_d'_linear Linear_order_Restr <span class="keyword1"><span class="command">unfolding</span></span> Pd'_tax_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> Pd'_tax_Pd'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Pd'_tax <span class="free">d</span> <span class="main">⊆</span> <span class="free">Pd'</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Pd'_tax_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> Pd'_tax_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span>Pd'_tax <span class="free">d</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">d</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Pd'_range Pd'_tax_Pd' <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> mono_Field subset_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Pd'_tax_x<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Field <span class="main">(</span>Pd'_tax <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Pd'_d'_x Pd'_d'_linear <span class="keyword1"><span class="command">unfolding</span></span> Pd'_tax_def above_def order_on_defs
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> FieldI2 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Pd'_Above<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">⊆</span> above <span class="main">(</span><span class="free">Pd'</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Above <span class="main">(</span><span class="free">Pd'</span> <span class="free">d</span><span class="main">)</span> <span class="free">Y</span> <span class="main">⊆</span> Above <span class="main">(</span>Pd'_tax <span class="free">d</span><span class="main">)</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Pd'_d'_linear assms <span class="keyword1"><span class="command">unfolding</span></span> Above_def Pd'_tax_def above_def order_on_defs
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Refl_Field_Restr subset_eq <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> transE<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">locale</span></span> ContractsWithUnilateralSubstitutesAndIRCAndLADAndTruePrefs <span class="main">=</span>
  ContractsWithUnilateralSubstitutesAndIRCAndLAD <span class="main">+</span> TruePrefs
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> TruePref<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRCAndLAD <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted"><span class="free">Pd'</span></span> <span class="quoted"><span class="free">Ch</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Pd'_linear Pd'_range Ch_range Ch_singular Ch_unilateral_substitutes Ch_irc Ch_lad
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> TruePref_tax<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRCAndLAD <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted">Pd'_tax</span> <span class="quoted"><span class="free">Ch</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Pd'_tax_linear Pd'_tax_range Ch_range Ch_singular Ch_unilateral_substitutes Ch_irc Ch_lad
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">interpretation</span></span>
  Singleton_for_d<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRCAndLAD <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted"><span class="quoted">"Pd_singletons_for_ds <span class="free">X</span> <span class="main">{</span><span class="free">Xd</span> <span class="free">x</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="free">Ch</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Pd_singletons_for_ds_linear Pd_singletons_for_ds_range Ch_range Ch_singular Ch_unilateral_substitutes Ch_irc Ch_lad X stable_on_allocation<span class="main">[</span><span class="operator">OF</span> X<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> Xd_x_ds<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible X stable_on_Xd x <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> TruePref_tax_Cd_not_x<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">≠</span> <span class="free">Xd</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"TruePref_tax.Cd <span class="free">d</span> <span class="main">=</span> Singleton_for_d.Cd <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms spec<span class="main">[</span><span class="operator">OF</span> Pd'<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">d</span></span><span class="main">]</span> stable_on_allocation<span class="main">[</span><span class="operator">OF</span> X<span class="main">]</span>
<span class="keyword1"><span class="command">unfolding</span></span> TruePref_tax.Cd_def Singleton_for_d.Cd_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Pd'_tax_def Pd_singletons_for_ds_simps<span class="main">)</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> Theorem_11_Pd'_tax<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">∈</span>TruePref_tax.cop <span class="free">ds</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> Pd'_tax <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Z</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"TruePref_tax.cop <span class="free">ds</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="var">?thesis</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="var">?Z</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Pd'_range Pd'_linear<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span>"</span></span><span class="main">]</span> Pd'_d'_x <span class="keyword1"><span class="command">unfolding</span></span> order_on_defs
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> bspec<span class="main"><span class="keyword3">,</span></span>
          <span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd'_tax_def above_def Refl_Field_Restr <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD
                   <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> CH_range' TruePref_tax.fp_cop_F_range_inv'<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"Singleton_for_d.stable_on <span class="free">ds</span> <span class="var">?Z</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> Theorem_10_fp_cop_F<span class="main">[</span><span class="operator">OF</span> X x<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span>"</span></span><span class="main">]</span> X
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CH <span class="main">(</span>Singleton_for_d.fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd_singletons_for_ds_simps dX_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_onD stable_on_allocation<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> Singleton_for_d.fp_cop_F_allocation
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Singleton_for_d.Cd <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>Singleton_for_d.cop <span class="free">ds</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Singleton_for_d.Cd_single Singleton_for_d.Cd_singleton Singleton_for_d.fp_cop_F_range_inv'
                TruePref_tax.CH_range'<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> Singleton_for_d.Theorem_1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="skolem">Y</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"Singleton_for_d.stable_on <span class="free">ds</span> <span class="skolem">Y</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">Y</span>
      <span class="keyword1"><span class="command">using</span></span> Singleton_for_d.Theorem_6_fp_cop_F<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ds<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">ds</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">Y</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> d<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="free">x</span>"</span></span><span class="main">]</span> that Xd_x_ds x
            card_Suc_eq<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"Singleton_for_d.Cd <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span> <span class="skolem">Y</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> k<span class="main"><span class="main">=</span></span><span class="quoted"><span class="main">0</span></span><span class="main">]</span> stable_on_allocation<span class="main">[</span><span class="operator">OF</span> X<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Singleton_for_d.Cd_singleton<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> Pd_singletons_for_ds_simps dX_def
                    <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Singleton_for_d.Cd_range' inj_onD<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="var">?Z</span>›</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span>Singleton_for_d.stable_on <span class="free">ds</span> <span class="var">?Z</span>›</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> Singleton_for_d.not_stable_on_cases<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> not_individually_rational
      <span class="keyword1"><span class="command">with</span></span> TruePref_tax.Theorem_1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="var">?Z</span>›</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
        <span class="keyword1"><span class="command">unfolding</span></span> TruePref_tax.stable_on_def Singleton_for_d.individually_rational_on_def
                  TruePref_tax.individually_rational_on_def Singleton_for_d.CD_on_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Singleton_for_d.Cd_range'<span class="main">)</span>
           <span class="main">(</span><span class="operator">metis</span> TruePref_tax.mem_CD_on_Cd TruePref_tax_Cd_not_x image_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> not_no_blocking
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">h</span></span> <span class="skolem"><span class="skolem">X''</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"Singleton_for_d.blocking_on <span class="free">ds</span> <span class="var">?Z</span> <span class="skolem">h</span> <span class="skolem">X''</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> Singleton_for_d.stable_no_blocking_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"TruePref_tax.blocking_on <span class="free">ds</span> <span class="var">?Z</span> <span class="skolem">h</span> <span class="skolem">X''</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> TruePref_tax.blocking_onI<span class="main">)</span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">X''</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹Singleton_for_d.blocking_on <span class="free">ds</span> <span class="var">?Z</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> YYY<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> Singleton_for_d.CD_on <span class="free">ds</span> <span class="main">(</span><span class="var">?Z</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> Singleton_for_d.blocking_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> TruePref_tax.CD_on <span class="free">ds</span> <span class="main">(</span><span class="var">?Z</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">y</span> <span class="main">=</span> <span class="free">Xd</span> <span class="free">x</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">with</span></span> inj_on_eq_iff<span class="main">[</span><span class="operator">OF</span> stable_on_allocation x<span class="main">]</span> X YYY <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Singleton_for_d.mem_CD_on_Cd Pd_singletons_for_ds_simps dX_def
                          <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Singleton_for_d.Cd_range'<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> X Xd_x_ds TruePref_tax.Theorem_1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">Xd</span> <span class="main">`</span> <span class="var">?Z</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">X''</span>›</span></span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">using</span></span> Singleton_for_d.blocking_on_allocation<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Singleton_for_d.blocking_on <span class="free">ds</span> <span class="var">?Z</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span><span class="main">]</span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> TruePref_tax.mem_CD_on_Cd TruePref_tax.Cd_greatest greatest_def Pd'_tax_x<span class="main">)</span>
               <span class="main">(</span><span class="operator">metis</span> TruePref_tax.Pd_range' image_eqI inj_on_contraD TruePref_tax.Pd_refl<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> YYY <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Singleton_for_d.mem_CD_on_Cd TruePref_tax.mem_CD_on_Cd TruePref_tax_Cd_not_x<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> <span class="quoted"><span class="quoted">‹Singleton_for_d.blocking_on <span class="free">ds</span> <span class="var">?Z</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main">:</span> Singleton_for_d.blocking_on_def›</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> TruePref_tax.Theorem_1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> TruePref_tax.blocking_on_imp_not_stable<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_11_fp_cop_F<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">∈</span>TruePref.cop <span class="free">ds</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd'</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> Theorem_11_Pd'_tax
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> CH <span class="main">(</span>TruePref_tax.fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span> xy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> Pd'_tax <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">from</span></span> TruePref_tax.stable_on_range'<span class="main">[</span><span class="operator">OF</span> TruePref_tax.Theorem_1<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dX <span class="main">(</span>CH <span class="main">(</span>TruePref_tax.fp_cop_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> Field <span class="main">(</span><span class="free">Pd'</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dX_def<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> Pd'_tax_Pd' contra_subsetD mono_Field<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">from</span></span> TruePref_tax.fp_cop_F_allocation<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span> Pd'_tax_Pd' y xy
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Above <span class="main">(</span><span class="free">Pd'</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>dX <span class="main">(</span>CH <span class="main">(</span>TruePref_tax.fp_cop_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>
     <span class="main">⊆</span> Above <span class="main">(</span>Pd'_tax <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>dX <span class="main">(</span>CH <span class="main">(</span>TruePref_tax.fp_cop_F <span class="free">ds</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> Pd'_Above<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dX_singular above_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> TruePref_tax.Pd_Xd<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> Pd'_linear Pd'_range TruePref_tax.Theorem_1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span> y
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">z</span><span class="main">∈</span>CH <span class="main">(</span>TruePref.fp_cop_F <span class="free">ds</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd'</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> TruePref_tax.Pd_above_irrelevant<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> d'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free"><span class="free">Xd</span></span></span> <span class="free"><span class="free"><span class="free">x</span></span></span>"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> X<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"CH <span class="main"><span class="main"><span class="main">(</span></span></span>TruePref_tax.fp_cop_F <span class="free"><span class="free"><span class="free">ds</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span>
          <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Pd'_tax_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Pd'_linear xy z <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Pd'_tax_def order_on_defs <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> TruePref.Pd_Xd transE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> ContractsWithSubstitutesAndLADAndTruePrefs <span class="main">=</span>
  ContractsWithSubstitutesAndLAD <span class="main">+</span> TruePrefs

<span class="keyword1"><span class="command">sublocale</span></span> ContractsWithSubstitutesAndLADAndTruePrefs
        <span class="main">&lt;</span> ContractsWithUnilateralSubstitutesAndIRCAndLADAndTruePrefs
<span class="keyword1"><span class="command">by</span></span> <span class="main">%</span>invisible <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithSubstitutesAndLADAndTruePrefs
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> TruePref<span class="main">:</span> ContractsWithSubstitutesAndLAD <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted"><span class="free">Pd'</span></span> <span class="quoted"><span class="free">Ch</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Pd'_linear Pd'_range Ch_range Ch_singular Ch_substitutes Ch_irc Ch_lad
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Theorem_11<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">∈</span>match <span class="main">(</span>TruePref.gfp_F <span class="free">ds</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Pd'</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Theorem_11_fp_cop_F TruePref.Theorem_15_match <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Note that this theorem depends on the hypotheses introduced by the
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "TruePrefs"<span class="antiquote"><span class="antiquote">}</span></span></span></span> locale, and only applies to doctor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Xd</span></span>
<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. The following sections show more general and syntactically
self-contained results.

We omit \citet[Theorem~12]{HatfieldMilgrom:2005}, which demonstrates
the almost-necessity of LAD for truth revelation to be the dominant
strategy for doctors.

›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ \citet{HatfieldKojima:2009,HatfieldKojima:2010}: The doctor-optimal match is group strategy-proof \label{sec:strategic-gsp} ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

\citet[Theorem~7]{HatfieldKojima:2010} assert that the COP is group
strategy-proof, which we define below. We begin by focusing on a
single agent \citep{HatfieldKojima:2009}: \begin{quote}

A mechanism <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">φ</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹strategy-proof›<span class="antiquote"><span class="antiquote">}</span></span></span></span> if, for any
preference profile <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Pd</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, there is no doctor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">d</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and
preferences <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Pd'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> such that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">d</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> strictly prefers
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y<span class="hidden">⇩</span><sub>d</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x<span class="hidden">⇩</span><sub>d</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> according to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Pd</span></span>
<span class="free"><span class="free">d</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x<span class="hidden">⇩</span><sub>d</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y<span class="hidden">⇩</span><sub>d</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are the
(possibly null) contracts for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">d</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">φ</span></span> <span class="free"><span class="free">Pd</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>φ Pd(d := Pd')›</span></span></span></span>, respectively.

\end{quote}

The syntax <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> "fun_upd_def"<span class="antiquote"><span class="antiquote">}</span></span></span></span> denotes function update at a point.

We make this definition in the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Contracts›</span></span></span></span> locale to
avail ourselves of some types and the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Xd›</span></span></span></span> and
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Xh›</span></span></span></span> constants. We also restrict hospital preferences to
those that guarantee our earlier strategic results.  As <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"<span class="free"><span class="free">gfp_F</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> requires these to satisfy the stronger <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "substitutes"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
constraint for stable matches to exist, we now deal purely with the
COP.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">mechanism_domain</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'x</span> rel<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'h</span> <span class="main">⇒</span> <span class="tfree">'x</span> cfun<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mechanism_domain</span> <span class="main">≡</span> ContractsWithUnilateralSubstitutesAndIRCAndLAD <span class="free">Xd</span> <span class="free">Xh</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">strategy_proof</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'d</span><span class="main">,</span> <span class="tfree">'h</span><span class="main">,</span> <span class="tfree">'x</span><span class="main">)</span> mechanism <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">strategy_proof</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="main">⟷</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">Pd</span> <span class="bound">Ch</span><span class="main">.</span> mechanism_domain <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="main">⟶</span>
     <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">d</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">.</span> <span class="main">∃</span><span class="bound">Pd'</span><span class="main">.</span> mechanism_domain <span class="main">(</span><span class="bound">Pd</span><span class="main">(</span><span class="bound">d</span><span class="main">:=</span><span class="bound">Pd'</span><span class="main">)</span><span class="main">)</span> <span class="bound">Ch</span>
       <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="main">(</span><span class="bound">Pd</span><span class="main">(</span><span class="bound">d</span><span class="main">:=</span><span class="bound">Pd'</span><span class="main">)</span><span class="main">)</span> <span class="bound">Ch</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> AboveS <span class="main">(</span><span class="bound">Pd</span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span>dX <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> strategy_proofI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Pd</span> <span class="bound">Pd'</span> <span class="bound">Ch</span> <span class="bound">d</span> <span class="bound">y</span><span class="main">.</span> <span class="main">⟦</span> mechanism_domain <span class="bound">Pd</span> <span class="bound">Ch</span><span class="main">;</span> mechanism_domain <span class="main">(</span><span class="bound">Pd</span><span class="main">(</span><span class="bound">d</span><span class="main">:=</span><span class="bound">Pd'</span><span class="main">)</span><span class="main">)</span> <span class="bound">Ch</span><span class="main">;</span> <span class="bound">d</span> <span class="main">∈</span> <span class="free">ds</span><span class="main">;</span>
                             <span class="bound">y</span> <span class="main">∈</span> <span class="free">φ</span> <span class="main">(</span><span class="bound">Pd</span><span class="main">(</span><span class="bound">d</span> <span class="main">:=</span> <span class="bound">Pd'</span><span class="main">)</span><span class="main">)</span> <span class="bound">Ch</span> <span class="free">ds</span><span class="main">;</span> <span class="bound">y</span> <span class="main">∈</span> Field <span class="main">(</span><span class="bound">Pd</span> <span class="bound">d</span><span class="main">)</span><span class="main">;</span>
                             <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>dX <span class="main">(</span><span class="free">φ</span> <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="free">ds</span><span class="main">)</span> <span class="bound">d</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">y</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">Pd</span> <span class="bound">d</span> <span class="main">⟧</span> <span class="main">⟹</span> False"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"strategy_proof <span class="free">ds</span> <span class="free">φ</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> strategy_proof_def AboveS_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> fp_cop_F_strategy_proof<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"strategy_proof <span class="free">ds</span> Contracts.cop"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"strategy_proof <span class="main">_</span> <span class="var">?φ</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> strategy_proofI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Pd</span> <span class="skolem">Pd'</span> <span class="skolem">Ch</span> <span class="skolem">d</span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"mechanism_domain <span class="skolem">Pd</span> <span class="skolem">Ch</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"mechanism_domain <span class="main">(</span><span class="skolem">Pd</span><span class="main">(</span><span class="skolem">d</span><span class="main">:=</span><span class="skolem">Pd'</span><span class="main">)</span><span class="main">)</span> <span class="skolem">Ch</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="var">?φ</span> <span class="main">(</span><span class="skolem">Pd</span><span class="main">(</span><span class="skolem">d</span> <span class="main">:=</span> <span class="skolem">Pd'</span><span class="main">)</span><span class="main">)</span> <span class="skolem">Ch</span> <span class="free">ds</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> Field <span class="main">(</span><span class="skolem">Pd</span> <span class="skolem">d</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>dX <span class="main">(</span><span class="var">?φ</span> <span class="skolem">Pd</span> <span class="skolem">Ch</span> <span class="free">ds</span><span class="main">)</span> <span class="skolem">d</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="skolem">y</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Pd</span> <span class="skolem">d</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">interpret</span></span> TruePref<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRCAndLAD <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted"><span class="skolem">Pd</span></span> <span class="quoted"><span class="skolem">Ch</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">from</span></span> B <span class="keyword1"><span class="command">interpret</span></span> ManiPref<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRCAndLAD <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Pd</span><span class="main">(</span><span class="skolem">d</span> <span class="main">:=</span> <span class="skolem">Pd'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="skolem">Ch</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">from</span></span> B y <span class="keyword1"><span class="command">interpret</span></span> ManiPref<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRCAndLADAndTruePrefs <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Pd</span><span class="main">(</span><span class="skolem">d</span> <span class="main">:=</span> <span class="skolem">Pd'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="skolem">Ch</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="quoted">"<span class="var">?φ</span> <span class="main">(</span><span class="skolem">Pd</span><span class="main">(</span><span class="skolem">d</span> <span class="main">:=</span> <span class="skolem">Pd'</span><span class="main">)</span><span class="main">)</span> <span class="skolem">Ch</span> <span class="free">ds</span>"</span></span> <span class="quoted"><span class="free">ds</span></span> <span class="quoted"><span class="skolem">Pd</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> FieldI2 TruePref.Pd_Xd TruePref.Pd_linear TruePref.Pd_range' subsetI ManiPref.Theorem_1<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> ManiPref.Theorem_11_fp_cop_F <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> TruePref.cop <span class="free">ds</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">with</span></span> TruePref.Pd_linear TruePref.stable_on_allocation<span class="main">[</span><span class="operator">OF</span> TruePref.Theorem_1<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span> TruePref.Pd_Xd TruePref.Pd_range' y
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">unfolding</span></span> order_on_defs antisym_def dX_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> mem_Collect_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The adaptation to groups is straightforward
\citep{HatfieldKojima:2009,HatfieldKojima:2010}:
\begin{quote}

A mechanism <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">φ</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹group strategy-proof›<span class="antiquote"><span class="antiquote">}</span></span></span></span> if, for
any preference profile <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Pd</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, there is no group of doctors
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">ds'</span></span> <span class="main"><span class="main">⊆</span></span> <span class="free"><span class="free">ds</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and a preference profile <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Pd'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
such that every <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">d</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">ds'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> strictly prefers <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"<span class="free"><span class="free">y<span class="hidden">⇩</span><sub>d</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x<span class="hidden">⇩</span><sub>d</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> according to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Pd</span></span> <span class="free"><span class="free">d</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, where
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x<span class="hidden">⇩</span><sub>d</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y<span class="hidden">⇩</span><sub>d</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are the (possibly null)
contracts for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">d</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">φ</span></span> <span class="free"><span class="free">Pd</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>φ
Pd(d<span class="hidden">⇩</span><sub>1</sub> := Pd' d<span class="hidden">⇩</span><sub>1</sub>, …, d<span class="hidden">⇩</span><sub>n</sub> := Pd' d<span class="hidden">⇩</span><sub>n</sub>)›</span></span></span></span>,
respectively.

\end{quote}

This definition requires all doctors in the coalition to strictly
prefer the outcome with manipulated preferences, as
\citeauthor{Kojima:2010}'s bossiness results (see
\S\ref{sec:bossiness}) show that a doctor may influence other doctors'
allocations without affecting their own. See
\citet[\S3]{HatfieldKojima:2009} for discussion, and also
\citet[Chapter~4]{RothSotomayor:1990}; in particular their \S4.3.1
discusses the robustness of these results and exogenous transfers.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">group_strategy_proof</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'d</span><span class="main">,</span> <span class="tfree">'h</span><span class="main">,</span> <span class="tfree">'x</span><span class="main">)</span> mechanism <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">group_strategy_proof</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="main">⟷</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">Pd</span> <span class="bound">Ch</span><span class="main">.</span> mechanism_domain <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="main">⟶</span>
     <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">ds'</span></span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">.</span> <span class="bound">ds'</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">Pd'</span><span class="main">.</span> mechanism_domain <span class="main">(</span>override_on <span class="bound">Pd</span> <span class="bound">Pd'</span> <span class="bound">ds'</span><span class="main">)</span> <span class="bound">Ch</span>
       <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">d</span><span class="main">∈</span><span class="bound">ds'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="main">(</span>override_on <span class="bound">Pd</span> <span class="bound">Pd'</span> <span class="bound">ds'</span><span class="main">)</span> <span class="bound">Ch</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> AboveS <span class="main">(</span><span class="bound">Pd</span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span>dX <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> group_strategy_proofI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Pd</span> <span class="bound">Pd'</span> <span class="bound">Ch</span> <span class="bound">ds'</span><span class="main">.</span> <span class="main">⟦</span> mechanism_domain <span class="bound">Pd</span> <span class="bound">Ch</span><span class="main">;</span> mechanism_domain <span class="main">(</span>override_on <span class="bound">Pd</span> <span class="bound">Pd'</span> <span class="bound">ds'</span><span class="main">)</span> <span class="bound">Ch</span><span class="main">;</span> <span class="bound">ds'</span> <span class="main">⊆</span> <span class="free">ds</span><span class="main">;</span> <span class="bound">ds'</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">;</span>
                             <span class="main">∀</span><span class="bound">d</span><span class="main">∈</span><span class="bound">ds'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="free">φ</span> <span class="main">(</span>override_on <span class="bound">Pd</span> <span class="bound">Pd'</span> <span class="bound">ds'</span><span class="main">)</span> <span class="bound">Ch</span> <span class="free">ds</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> AboveS <span class="main">(</span><span class="bound">Pd</span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span>dX <span class="main">(</span><span class="free">φ</span> <span class="bound">Pd</span> <span class="bound">Ch</span> <span class="free">ds</span><span class="main">)</span> <span class="bound">d</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> False"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"group_strategy_proof <span class="free">ds</span> <span class="free">φ</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> group_strategy_proof_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemmas</span></span> group_strategy_proofD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> group_strategy_proof_def<span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> disj_imp<span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> group_strategy_proof_strategy_proof<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"group_strategy_proof <span class="free">ds</span> <span class="free">φ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"strategy_proof <span class="free">ds</span> <span class="free">φ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="operator">rule</span> strategy_proofI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Pd</span> <span class="skolem">Pd'</span> <span class="skolem">Ch</span> <span class="skolem">d</span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"mechanism_domain <span class="skolem">Pd</span> <span class="skolem">Ch</span>"</span></span> <span class="quoted"><span class="quoted">"mechanism_domain <span class="main">(</span><span class="skolem">Pd</span><span class="main">(</span><span class="skolem">d</span> <span class="main">:=</span> <span class="skolem">Pd'</span><span class="main">)</span><span class="main">)</span> <span class="skolem">Ch</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span> <span class="free">ds</span>"</span></span>
         <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">φ</span> <span class="main">(</span><span class="skolem">Pd</span><span class="main">(</span><span class="skolem">d</span> <span class="main">:=</span> <span class="skolem">Pd'</span><span class="main">)</span><span class="main">)</span> <span class="skolem">Ch</span> <span class="free">ds</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> Field <span class="main">(</span><span class="skolem">Pd</span> <span class="skolem">d</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>dX <span class="main">(</span><span class="free">φ</span> <span class="skolem">Pd</span> <span class="skolem">Ch</span> <span class="free">ds</span><span class="main">)</span> <span class="skolem">d</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="skolem">y</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Pd</span> <span class="skolem">d</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">unfolding</span></span> group_strategy_proof_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">Pd</span></span><span class="main"><span class="main">]</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">Ch</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> override_on_insert AboveS_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">d</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\label{sec:strategic-hk2010-lemma1}

Perhaps surprisingly, \citet[Lemma~1, for a single
doctor]{HatfieldKojima:2010} assert that shuffling any contract above
the doctor-optimal one to the top of a doctor's preference order
preserves exactly the doctor-optimal match, which on the face of it
seems to contradict the bossiness result of \S\ref{sec:bossiness}: by
the earlier strategy-proofness results, this cannot affect the outcome
for that particular doctor, but by bossiness it may affect others.
The key observation is that this manipulation preserves blocking
coalitions in the presence of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "lad"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

This result is central to showing the group-strategy-proofness of the
COP.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> Contracts
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">shuffle_to_top</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> set <span class="main">⇒</span> <span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'x</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">shuffle_to_top</span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> <span class="free">Pd</span> <span class="bound">d</span> <span class="main">-</span> dX <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="bound">d</span> <span class="main">×</span> UNIV <span class="main">∪</span> <span class="main">(</span>Domain <span class="main">(</span><span class="free">Pd</span> <span class="bound">d</span><span class="main">)</span> <span class="main">∪</span> dX <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="bound">d</span><span class="main">)</span> <span class="main">×</span> dX <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="bound">d</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Pd_shuffle_to_top</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set <span class="main">⇒</span> <span class="tfree">'x</span> set <span class="main">⇒</span> <span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'x</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Pd_shuffle_to_top</span> <span class="free"><span class="bound"><span class="entity">ds'</span></span></span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">=</span> override_on <span class="free">Pd</span> <span class="main">(</span>shuffle_to_top <span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ds'</span></span></span>"</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> shuffle_to_top_Field<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"allocation <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span>shuffle_to_top <span class="free">Y</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="main">∪</span> dX <span class="free">Y</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> shuffle_to_top_def Field_def <span class="keyword1"><span class="command">using</span></span> dX_empty_or_singleton<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Domain.simps<span class="main"><span class="keyword3">;</span></span> <span class="operator">meson</span> FieldI2 equalityE Pd_refl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> shuffle_to_top_Total<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"allocation <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Total <span class="main">(</span>shuffle_to_top <span class="free">Y</span> <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Pd_linear'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">d</span></span><span class="main">]</span> dX_empty_or_singleton<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
<span class="keyword1"><span class="command">unfolding</span></span> order_on_defs total_on_def shuffle_to_top_Field<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> shuffle_to_top_def Domain.simps <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> shuffle_to_top_linear<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"allocation <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="main">(</span>shuffle_to_top <span class="free">Y</span> <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Pd_linear'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">d</span></span><span class="main">]</span> dX_empty_or_singleton<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> shuffle_to_top_Total<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
<span class="keyword1"><span class="command">unfolding</span></span> shuffle_to_top_def order_on_defs
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Field_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> antisymI refl_onI transI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD antisymD <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> transE<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> shuffle_to_top_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span>shuffle_to_top <span class="free">Y</span> <span class="free">d</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">d</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> shuffle_to_top_def <span class="keyword1"><span class="command">using</span></span> Pd_range dX_range <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Field_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> shuffle_to_top_range'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> shuffle_to_top <span class="free">Y</span> <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="main">∪</span> dX <span class="free">Y</span> <span class="free">d</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">∈</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="main">∪</span> dX <span class="free">Y</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> shuffle_to_top_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> FieldI1 FieldI2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Pd_shuffle_to_top_linear<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"allocation <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Linear_order <span class="main">(</span>Pd_shuffle_to_top <span class="free">ds'</span> <span class="free">Y</span> <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Pd_shuffle_to_top_def <span class="keyword1"><span class="command">using</span></span> Pd_linear shuffle_to_top_linear<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds'</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> Pd_shuffle_to_top_range<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span>Pd_shuffle_to_top <span class="free">ds'</span> <span class="free">Y</span> <span class="free">d</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">d</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Pd_shuffle_to_top_def <span class="keyword1"><span class="command">using</span></span> Pd_range shuffle_to_top_range <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds'</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> Pd_shuffle_to_top_simps<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Pd_shuffle_to_top <span class="main">(</span>insert <span class="free">d</span> <span class="free">ds'</span><span class="main">)</span> <span class="free">Y</span> <span class="main">=</span> <span class="main">(</span>Pd_shuffle_to_top <span class="free">ds'</span> <span class="free">Y</span><span class="main">)</span><span class="main">(</span><span class="free">d</span> <span class="main">:=</span> shuffle_to_top <span class="free">Y</span> <span class="free">d</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> <span class="free">ds'</span> <span class="main">⟹</span> Pd_shuffle_to_top <span class="free">ds'</span> <span class="free">Y</span> <span class="free">d</span> <span class="main">=</span> shuffle_to_top <span class="free">Y</span> <span class="free">d</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∉</span> <span class="free">ds'</span> <span class="main">⟹</span> Pd_shuffle_to_top <span class="free">ds'</span> <span class="free">Y</span> <span class="free">d</span> <span class="main">=</span> <span class="free">Pd</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Pd_shuffle_to_top_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> override_on_insert<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Pd_shuffle_to_top_Field<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"allocation <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span>Pd_shuffle_to_top <span class="free">ds'</span> <span class="free">Y</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="free">d</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">d</span> <span class="main">∈</span> <span class="free">ds'</span> <span class="keyword1">then</span> dX <span class="free">Y</span> <span class="free">d</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Pd_shuffle_to_top_simps shuffle_to_top_Field<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Above_shuffle_to_top<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Above <span class="main">(</span>shuffle_to_top <span class="free">Y</span> <span class="main">(</span><span class="free">Xd</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"allocation <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> Above_def shuffle_to_top_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dX_singular <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Pd_Xd dX_range' Pd_range' inj_onD<span class="main">)</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithUnilateralSubstitutesAndIRCAndLAD
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Lemma_1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"allocation <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> III<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d</span><span class="main">∈</span><span class="free">ds''</span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="free">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> AboveS <span class="main">(</span><span class="free">Pd</span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span>dX <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span> <span class="bound">d</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cop <span class="free">ds</span> <span class="main">=</span> Contracts.cop <span class="main">(</span>Pd_shuffle_to_top <span class="free">ds''</span> <span class="free">Y</span><span class="main">)</span> <span class="free">Ch</span> <span class="free">ds</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds''</span></span><span class="main">]</span> subset_refl
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ds''</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_subset_induct'<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> empty <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Pd_shuffle_to_top_simps<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">d</span> <span class="skolem">ds'</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> insert
  <span class="keyword1"><span class="command">interpret</span></span> Pds'<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRCAndLAD <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted"><span class="quoted">"Pd_shuffle_to_top <span class="skolem">ds'</span> <span class="free">Y</span>"</span></span> <span class="quoted"><span class="free">Ch</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Pd_shuffle_to_top_linear<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹allocation <span class="free">Y</span>›</span></span><span class="main">]</span> Pd_shuffle_to_top_range Ch_range Ch_singular Ch_unilateral_substitutes Ch_irc Ch_lad
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Z</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"CH <span class="main">(</span>Pds'.fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> <span class="quoted"><span class="quoted">‹cop <span class="free">ds</span> <span class="main">=</span> <span class="var">?Z</span>›</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Pd_shuffle_to_top</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Pd_shuffle_to_top <span class="main">(</span>insert <span class="skolem">d</span> <span class="skolem">ds'</span><span class="main">)</span> <span class="free">Y</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> insert <span class="keyword1"><span class="command">interpret</span></span> Pdds'<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRCAndLAD <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="var"><span class="quoted"><span class="var">?Pd_shuffle_to_top</span></span></span> <span class="quoted"><span class="free">Ch</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Pd_shuffle_to_top_linear<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹allocation <span class="free">Y</span>›</span></span><span class="main">]</span> Pd_shuffle_to_top_range Ch_range Ch_singular Ch_unilateral_substitutes Ch_irc Ch_lad
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Pd_shuffle_to_top_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="comment1">― ‹\citet[Lemma~1, for a single doctor]{HatfieldKojima:2010}›</span>
  <span class="keyword1"><span class="command">have</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?Z</span> <span class="main">=</span> CH <span class="main">(</span>Pdds'.fp_cop_F <span class="free">ds</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Pdds'.doctor_optimal_match_unique<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Pdds'.doctor_optimal_matchI Pdds'.fp_cop_F_doctor_optimal_match<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Pdds'.stable_on <span class="free">ds</span> <span class="var">?Z</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Pdds'.stable_onI<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Pdds'.individually_rational_on <span class="free">ds</span> <span class="var">?Z</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Pdds'.individually_rational_onI<span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Pdds'.CD_on <span class="free">ds</span> <span class="var">?Z</span> <span class="main">=</span> <span class="var">?Z</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> set_elem_equalityI<span class="main">)</span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="free">Y</span>›</span></span> IH Pds'.Theorem_1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">d</span> <span class="main">∉</span> <span class="skolem">ds'</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pds'.stable_on_Xd Pdds'.mem_CD_on_Cd Pdds'.Cd_greatest greatest_def
                               Pd_shuffle_to_top_Field<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹allocation <span class="free">Y</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span>
                <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Pd_shuffle_to_top_simps shuffle_to_top_def dX_def Set.Ball_def<span class="main"><span class="keyword3">,</span></span>
                <span class="operator">metis</span> stable_on_range'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Theorem_1<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">ds</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span> inj_on_contraD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Pds'.fp_cop_F_allocation<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">ds</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span>
                      fp_cop_F_worst<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">ds</span></span></span></span></span></span><span class="main"><span class="main">]</span></span> Pd_range' Pds'.CH_range'<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">meson</span> IntE Pdds'.CD_on_range'<span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"CH <span class="var">?Z</span> <span class="main">=</span> <span class="var">?Z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> CH_irc_idem<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Pdds'.stable_no_blocking_on <span class="free">ds</span> <span class="var">?Z</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Pdds'.stable_no_blocking_onI2<span class="main">)</span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="skolem">X''</span> <span class="keyword3"><span class="command">assume</span></span> Pbo<span class="main">:</span> <span class="quoted"><span class="quoted">"Pdds'.blocking_on <span class="free">ds</span> <span class="var">?Z</span> <span class="skolem">h</span> <span class="skolem">X''</span>"</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Pds'.blocking_on <span class="free">ds</span> <span class="var">?Z</span> <span class="skolem">h</span> <span class="skolem">X''</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Pds'.blocking_onI<span class="main">)</span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X''</span>"</span></span>
          <span class="keyword1"><span class="command">note</span></span> Pbos <span class="main">=</span> Pdds'.blocking_on_allocation<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Pdds'.blocking_on <span class="free">ds</span> <span class="var">?Z</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span><span class="main">]</span>
                      Pdds'.blocking_on_CD_on'<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Pdds'.blocking_on <span class="free">ds</span> <span class="var">?Z</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X''</span>›</span></span><span class="main">]</span>
                      Pdds'.blocking_on_Cd<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Pdds'.blocking_on <span class="free">ds</span> <span class="var">?Z</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> d<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span>"</span></span><span class="main">]</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Pds'.CD_on <span class="free">ds</span> <span class="main">(</span><span class="var">?Z</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">d</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> True
            <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="free">Y</span>›</span></span> III <span class="quoted"><span class="quoted">‹<span class="skolem">d</span> <span class="main">∈</span> <span class="free">ds''</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">d</span>›</span></span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dX <span class="free">Y</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⊆</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> AboveS_Pd_Xd AboveS_Field dX_range' inj_on_eq_iff<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> <span class="quoted"><span class="quoted">‹allocation <span class="free">Y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">d</span> <span class="main">∉</span> <span class="skolem">ds'</span>›</span></span>
                          Pdds'.blocking_on_Field<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Pdds'.blocking_on <span class="free">ds</span> <span class="var">?Z</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> d<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">d</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">d</span>›</span></span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dX <span class="skolem">X''</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⊆</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd_shuffle_to_top_simps shuffle_to_top_Field<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="free">Y</span>›</span></span> bspec<span class="main">[</span><span class="operator">OF</span> III<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> IH<span class="main"><span class="main">]</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">d</span> <span class="main">∈</span> <span class="free">ds''</span>›</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">d</span> <span class="main">∉</span> <span class="skolem">ds'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X''</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">d</span>›</span></span>
                          Pds'.stable_on_allocation<span class="main">[</span><span class="operator">OF</span> Pds'.Theorem_1<span class="main">]</span> Pbos
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pdds'.mem_CD_on_Cd Pds'.mem_CD_on_Cd Pds'.Cd_Above Pdds'.Cd_Above
                                 Int_Un_distrib2 Pd_shuffle_to_top_Field<span class="main">)</span>
                 <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd_shuffle_to_top_simps dX_singular dX_Int_Field_Pd<span class="main"><span class="keyword3">;</span></span>
                  <span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Above_def AboveS_def Pd_refl shuffle_to_top_def dX_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> FieldI1 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Pd_range' <span class="quasi_keyword">iff</span><span class="main"><span class="main">:</span></span> inj_on_eq_iff<span class="main">)</span>
         <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> False
            <span class="keyword1"><span class="command">from</span></span> Pbos <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">d</span>›</span></span>
            <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Pdds'.mem_CD_on_Cd Pds'.mem_CD_on_Cd Pds'.Cd_greatest Pdds'.Cd_greatest<span class="main">)</span>
                 <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Pd_shuffle_to_top_simps<span class="main">)</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> <span class="quoted"><span class="quoted">‹Pdds'.blocking_on <span class="free">ds</span> <span class="var">?Z</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main">:</span> Pdds'.blocking_on_def›</span><span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> Pds'.Theorem_1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Pds'.blocking_on_imp_not_stable<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">W</span> <span class="skolem">w</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Pdds'.stable_on <span class="free">ds</span> <span class="skolem">W</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">W</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> III <span class="quoted"><span class="quoted">‹<span class="skolem">d</span> <span class="main">∈</span> <span class="free">ds''</span>›</span></span> IH
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> Y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">Y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> AboveS <span class="main">(</span><span class="free">Pd</span> <span class="skolem">d</span><span class="main">)</span> <span class="main">(</span>dX <span class="main">(</span>Pds'.cop <span class="free">ds</span><span class="main">)</span> <span class="skolem">d</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">d</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> AboveS_Pd_Xd<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">z</span><span class="main">∈</span>Pds'.cop <span class="free">ds</span><span class="main">.</span> <span class="main">(</span><span class="skolem">w</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="main">∈</span> Pd_shuffle_to_top <span class="main">(</span>insert <span class="skolem">d</span> <span class="skolem">ds'</span><span class="main">)</span> <span class="free">Y</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">w</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">W</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">W</span>›</span></span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">d</span> <span class="main">∉</span> <span class="skolem">ds'</span>›</span></span> <span class="quoted"><span class="quoted">‹Pdds'.stable_on <span class="free">ds</span> <span class="skolem">W</span>›</span></span> Y <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">W</span>›</span></span>
        <span class="keyword1"><span class="command">interpret</span></span> Pdds'<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRCAndLADAndTruePrefs
                           <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted"><span class="quoted">"Pd_shuffle_to_top <span class="main">(</span>insert <span class="skolem">d</span> <span class="skolem">ds'</span><span class="main">)</span> <span class="free">Y</span>"</span></span> <span class="quoted"><span class="free">Ch</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="skolem">W</span></span> <span class="quoted"><span class="free">ds</span></span> <span class="quoted"><span class="quoted">"Pd_shuffle_to_top <span class="skolem">ds'</span> <span class="free">Y</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> <span class="main">%</span>invisible Pds'.Pd_linear Pds'.Pd_range Pd_shuffle_to_top_simps Pd_range' <span class="keyword1"><span class="command">unfolding</span></span> AboveS_def
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">d</span> <span class="main">∉</span> <span class="skolem">ds'</span>›</span></span> Y Pdds'.Theorem_11_fp_cop_F <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span>
          <span class="keyword1"><span class="command">using</span></span> Pds'.stable_on_allocation<span class="main">[</span><span class="operator">OF</span> Pds'.Theorem_1<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span> Pd_linear Pd_range'
          <span class="keyword1"><span class="command">unfolding</span></span> order_on_defs antisym_def AboveS_def dX_def
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd_shuffle_to_top_simps<span class="main">)</span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Pd_Xd<span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">W</span>›</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"Pds'.stable_on <span class="free">ds</span> <span class="skolem">W</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹Pds'.stable_on <span class="free">ds</span> <span class="skolem">W</span>›</span></span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="free">Y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">d</span> <span class="main">∉</span> <span class="skolem">ds'</span>›</span></span> Y <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">W</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">W</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">using</span></span> Pds'.Theorem_5<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Pds'.stable_on <span class="free">ds</span> <span class="skolem">W</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">W</span>›</span></span><span class="main">]</span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 0 2 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd_shuffle_to_top_simps shuffle_to_top_def dX_def AboveS_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Pd_range' inj_onD<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span>Pds'.stable_on <span class="free">ds</span> <span class="skolem">W</span>›</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> Pds'.not_stable_on_cases<span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> not_individually_rational
            <span class="keyword1"><span class="command">note</span></span> Psos <span class="main">=</span> Pdds'.stable_on_allocation<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Pdds'.stable_on <span class="free">ds</span> <span class="skolem">W</span>›</span></span><span class="main">]</span>
                        Pdds'.stable_on_CH<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Pdds'.stable_on <span class="free">ds</span> <span class="skolem">W</span>›</span></span><span class="main">]</span>
                        Pdds'.stable_on_Xd<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Pdds'.stable_on <span class="free">ds</span> <span class="skolem">W</span>›</span></span><span class="main">]</span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Pds'.Cd <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">W</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">W</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
            <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">d</span>"</span></span><span class="main">)</span>
              <span class="keyword3"><span class="command">case</span></span> True
              <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="free">Y</span>›</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="skolem">W</span>›</span></span> Y<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">W</span>›</span></span>
                   Pdds'.stable_on_range'<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Pdds'.stable_on <span class="free">ds</span> <span class="skolem">W</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">W</span>›</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">W</span>›</span></span>
              <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd_shuffle_to_top_Field <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> dX_range' inj_onD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Pds'.Cd_single<span class="main">)</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">case</span></span> False
              <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="free">Y</span>›</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="skolem">W</span>›</span></span> Pdds'.stable_on_range'<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Pdds'.stable_on <span class="free">ds</span> <span class="skolem">W</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">W</span>›</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">W</span>›</span></span>
              <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd_shuffle_to_top_Field <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Pds'.Cd_single<span class="main">)</span>
            <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">with</span></span> not_individually_rational <span class="quoted"><span class="quoted">‹Pdds'.CH <span class="skolem">W</span> <span class="main">=</span> <span class="skolem">W</span>›</span></span> Psos<span class="main">(</span>3<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
              <span class="keyword1"><span class="command">unfolding</span></span> Pds'.individually_rational_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pds'.mem_CD_on_Cd <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Pds'.Cd_range'<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> not_no_blocking
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">h</span></span> <span class="skolem"><span class="skolem">X''</span></span> <span class="keyword2"><span class="keyword">where</span></span> Pbo<span class="main">:</span> <span class="quoted"><span class="quoted">"Pds'.blocking_on <span class="free">ds</span> <span class="skolem">W</span> <span class="skolem">h</span> <span class="skolem">X''</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> Pds'.stable_no_blocking_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Pdds'.blocking_on <span class="free">ds</span> <span class="skolem">W</span> <span class="skolem">h</span> <span class="skolem">X''</span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Pdds'.blocking_onI<span class="main">)</span>
            <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X''</span>"</span></span>
            <span class="keyword1"><span class="command">note</span></span> Pbos <span class="main">=</span> Pds'.blocking_on_allocation<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Pds'.blocking_on <span class="free">ds</span> <span class="skolem">W</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span><span class="main">]</span>
                        Pds'.blocking_on_CD_on'<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Pds'.blocking_on <span class="free">ds</span> <span class="skolem">W</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X''</span>›</span></span><span class="main">]</span>
                        Pds'.blocking_on_Field<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Pds'.blocking_on <span class="free">ds</span> <span class="skolem">W</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> d<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">d</span></span><span class="main">]</span>
            <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Pdds'.CD_on <span class="free">ds</span> <span class="main">(</span><span class="skolem">W</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">d</span>"</span></span><span class="main">)</span>
              <span class="keyword3"><span class="command">case</span></span> True
              <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="free">Y</span>›</span></span> III <span class="quoted"><span class="quoted">‹<span class="skolem">d</span> <span class="main">∈</span> <span class="free">ds''</span>›</span></span>  <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">d</span>›</span></span>
              <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dX <span class="free">Y</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⊆</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> AboveS_Pd_Xd AboveS_Field dX_range' inj_on_eq_iff<span class="main">)</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">d</span> <span class="main">∉</span> <span class="skolem">ds'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">d</span>›</span></span> Pbos
              <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dX <span class="skolem">X''</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⊆</span> Field <span class="main">(</span><span class="free">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd_shuffle_to_top_simps<span class="main">)</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹allocation <span class="free">Y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">d</span> <span class="main">∉</span> <span class="skolem">ds'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">W</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">d</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X''</span>›</span></span> Pbos
              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pdds'.mem_CD_on_Cd Pds'.mem_CD_on_Cd Pds'.Cd_Above Pdds'.Cd_Above
                                   Int_Un_distrib2<span class="main">)</span>
                   <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd_shuffle_to_top_simps shuffle_to_top_Field dX_singular dX_Int_Field_Pd Un_absorb2<span class="main"><span class="keyword3">,</span></span>
                    <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> <span class="free">Y</span>›</span></span> shuffle_to_top_def dX_def Above_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_onD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> FieldI1<span class="main">)</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">case</span></span> False
              <span class="keyword1"><span class="command">from</span></span> Pbos <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">d</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Pdds'.mem_CD_on_Cd Pds'.mem_CD_on_Cd Pds'.Cd_greatest Pdds'.Cd_greatest<span class="main">)</span>
                   <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Pd_shuffle_to_top_simps<span class="main">)</span>
            <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> <span class="quoted"><span class="quoted">‹Pds'.blocking_on <span class="free">ds</span> <span class="skolem">W</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main">:</span> Pds'.blocking_on_def›</span><span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹Pdds'.stable_on <span class="free">ds</span> <span class="skolem">W</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Pdds'.blocking_on_imp_not_stable<span class="main">)</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?Z</span> <span class="main">=</span> CH <span class="main">(</span>Pdds'.fp_cop_F <span class="free">ds</span><span class="main">)</span>›</span></span> IH <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"cop <span class="free">ds</span> <span class="main">=</span> Pdds'.cop <span class="free">ds</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The top-level theorem states that the COP is group strategy proof. To
account for the quantification over preferences, we directly use the
raw constants from the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Contracts"<span class="antiquote"><span class="antiquote">}</span></span></span></span> locale.

›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> fp_cop_F_group_strategy_proof<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"group_strategy_proof <span class="free">ds</span> Contracts.cop"</span></span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"group_strategy_proof <span class="main">_</span> <span class="var">?φ</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> group_strategy_proofI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Pd</span> <span class="skolem">Pds'</span> <span class="skolem">Ch</span> <span class="skolem">ds'</span>
  <span class="keyword3"><span class="command">assume</span></span> XXX<span class="main">:</span> <span class="quoted"><span class="quoted">"mechanism_domain <span class="skolem">Pd</span> <span class="skolem">Ch</span>"</span></span> <span class="quoted"><span class="quoted">"mechanism_domain <span class="main">(</span>override_on <span class="skolem">Pd</span> <span class="skolem">Pds'</span> <span class="skolem">ds'</span><span class="main">)</span> <span class="skolem">Ch</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> YYY<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ds'</span> <span class="main">⊆</span> <span class="free">ds</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ds'</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> ZZZ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d</span><span class="main">∈</span><span class="skolem">ds'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="var">?φ</span> <span class="main">(</span>override_on <span class="skolem">Pd</span> <span class="skolem">Pds'</span> <span class="skolem">ds'</span><span class="main">)</span> <span class="skolem">Ch</span> <span class="free">ds</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> AboveS <span class="main">(</span><span class="skolem">Pd</span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span>dX <span class="main">(</span><span class="var">?φ</span> <span class="skolem">Pd</span> <span class="skolem">Ch</span> <span class="free">ds</span><span class="main">)</span> <span class="bound">d</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> XXX<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">interpret</span></span> TruePref<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRCAndLAD <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted"><span class="skolem">Pd</span></span> <span class="quoted"><span class="skolem">Ch</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">from</span></span> XXX<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">interpret</span></span>
    ManiPref<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRCAndLAD <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted"><span class="quoted">"override_on <span class="skolem">Pd</span> <span class="skolem">Pds'</span> <span class="skolem">ds'</span>"</span></span> <span class="quoted"><span class="skolem">Ch</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Y</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"ManiPref.cop <span class="free">ds</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Z</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"TruePref.cop <span class="free">ds</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Pd_shuffle_to_top</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"TruePref.Pd_shuffle_to_top <span class="skolem">ds'</span> <span class="var">?Y</span>"</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> ManiPref'<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRCAndLAD <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="var"><span class="quoted"><span class="var">?Pd_shuffle_to_top</span></span></span> <span class="quoted"><span class="skolem">Ch</span></span>
    <span class="keyword1"><span class="command">using</span></span> TruePref.Ch_unilateral_substitutes TruePref.Ch_irc TruePref.Ch_lad TruePref.Ch_range TruePref.Ch_singular
          TruePref.Pd_shuffle_to_top_linear ManiPref.stable_on_allocation<span class="main">[</span><span class="operator">OF</span> ManiPref.Theorem_1<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
          TruePref.Pd_shuffle_to_top_range ManiPref.dX_range
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Y'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"ManiPref'.cop <span class="free">ds</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ManiPref'.stable_on <span class="free">ds</span> <span class="var">?Y</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ManiPref'.stable_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ManiPref'.individually_rational_on <span class="free">ds</span> <span class="var">?Y</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ManiPref'.individually_rational_onI<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ManiPref'.CD_on <span class="free">ds</span> <span class="var">?Y</span> <span class="main">=</span> <span class="var">?Y</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> set_elem_equalityI<span class="main">)</span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="free">ds</span> <span class="main">∧</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∉</span> <span class="skolem">ds'</span> <span class="main">⟶</span> <span class="skolem">x</span> <span class="main">∈</span> Field <span class="main">(</span><span class="skolem">Pd</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ManiPref.fp_cop_F_range_inv' TruePref.CH_range' override_on_apply_notin<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> ManiPref.Theorem_1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ManiPref.stable_on_allocation
                    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ManiPref'.Cd_single ManiPref'.mem_CD_on_Cd TruePref.Pd_shuffle_to_top_Field dX_def<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">meson</span> IntE ManiPref'.CD_on_range'<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ManiPref'.CH <span class="var">?Y</span> <span class="main">=</span> <span class="var">?Y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ManiPref'.CH_irc_idem<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ManiPref'.stable_no_blocking_on <span class="free">ds</span> <span class="var">?Y</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ManiPref'.stable_no_blocking_onI2<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="skolem">X''</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"ManiPref'.blocking_on <span class="free">ds</span> <span class="var">?Y</span> <span class="skolem">h</span> <span class="skolem">X''</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ManiPref.blocking_on <span class="free">ds</span> <span class="var">?Y</span> <span class="skolem">h</span> <span class="skolem">X''</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ManiPref.blocking_onI<span class="main">)</span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X''</span>"</span></span>
        <span class="keyword1"><span class="command">note</span></span> Pbos <span class="main">=</span> ManiPref'.blocking_on_Field<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹ManiPref'.blocking_on <span class="free">ds</span> <span class="var">?Y</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> d<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span>"</span></span><span class="main">]</span>
                    ManiPref'.blocking_on_allocation<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹ManiPref'.blocking_on <span class="free">ds</span> <span class="var">?Y</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span><span class="main">]</span>
                    ManiPref'.blocking_on_CD_on'<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹ManiPref'.blocking_on <span class="free">ds</span> <span class="var">?Y</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X''</span>›</span></span><span class="main">]</span>
                    ManiPref'.blocking_on_Cd<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹ManiPref'.blocking_on <span class="free">ds</span> <span class="var">?Y</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> d<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span>"</span></span><span class="main">]</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> ManiPref.CD_on <span class="free">ds</span> <span class="main">(</span><span class="var">?Y</span> <span class="main">∪</span> <span class="skolem">X''</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">ds'</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">from</span></span> ManiPref.fp_cop_F_allocation<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X''</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">ds'</span>›</span></span> Pbos bspec<span class="main">[</span><span class="operator">OF</span> ZZZ <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">ds'</span>›</span></span><span class="main">]</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dX <span class="skolem">X''</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⊆</span> Field <span class="main">(</span><span class="skolem">Pds'</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dX_singular ManiPref'.mem_CD_on_Cd ManiPref'.Cd_Above TruePref.Pd_shuffle_to_top_Field<span class="main">)</span>
               <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> TruePref.Pd_shuffle_to_top_simps dX_singular <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> TruePref.AboveS_Pd_Xd
                          <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ManiPref.fp_cop_F_range_inv' ManiPref.CH_range' TruePref.Above_shuffle_to_top<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> ManiPref.stable_on_range'<span class="main">[</span><span class="operator">OF</span> ManiPref.Theorem_1<span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">ds'</span>›</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dX <span class="var">?Y</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⊆</span> Field <span class="main">(</span><span class="skolem">Pds'</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dX_range' override_on_apply_in subsetI<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> bspec<span class="main">[</span><span class="operator">OF</span> ZZZ <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">ds'</span>›</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X''</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Xd</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">ds'</span>›</span></span> Pbos
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">using</span></span> ManiPref.Pd_linear'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">Xd</span> <span class="skolem">x</span>"</span></span><span class="main">]</span> ManiPref.fp_cop_F_allocation<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span>
                  ManiPref'.fp_cop_F_allocation<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ManiPref'.mem_CD_on_Cd ManiPref'.Cd_Above_dX ManiPref.mem_CD_on_Cd
                               ManiPref.Cd_Above_dX dX_union dX_singular
                               TruePref.Pd_shuffle_to_top_Field TruePref.AboveS_Pd_Xd<span class="main">)</span>
               <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> TruePref.Pd_shuffle_to_top_simps insert_absorb <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> Above_Linear_singleton
                     <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> TruePref.Above_shuffle_to_top<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False
          <span class="keyword1"><span class="command">with</span></span> Pbos <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ManiPref'.mem_CD_on_Cd ManiPref'.Cd_greatest ManiPref.mem_CD_on_Cd
                                ManiPref.Cd_greatest TruePref.Pd_shuffle_to_top_simps<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> <span class="quoted"><span class="quoted">‹ManiPref'.blocking_on <span class="free">ds</span> <span class="var">?Y</span> <span class="skolem">h</span> <span class="skolem">X''</span>›</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main">:</span> ManiPref'.blocking_on_def›</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> ManiPref.Theorem_1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ManiPref.blocking_on_imp_not_stable<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">with</span></span> ManiPref'.stable_on_allocation <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> <span class="var">?Y</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">ds'</span><span class="main">}</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> <span class="var">?Y'</span><span class="main">.</span> <span class="free">Xd</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">ds'</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ManiPref'.Theorem_5<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span><span class="main"><span class="main">]</span></span>
              <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> TruePref.Pd_shuffle_to_top_simps TruePref.shuffle_to_top_def dX_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">from</span></span> ManiPref.stable_on_allocation<span class="main">[</span><span class="operator">OF</span> ManiPref.Theorem_1<span class="main">]</span> ZZZ
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Z</span> <span class="main">=</span> <span class="var">?Y'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> TruePref.Lemma_1<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> YYY ZZZ
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">unfolding</span></span> AboveS_def dX_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ex_in_conv<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> TruePref.Pd_range'<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ContractsWithSubstitutes<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

Again, this result does not directly apply to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"gfp_F"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> due to
the mechanism domain hypothesis.

Finally, \citet[Corollary~2]{HatfieldKojima:2010} (respectively,
\citet[Corollary~1]{HatfieldKojima:2009}) assert that the COP (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"gfp_F"<span class="antiquote"><span class="antiquote">}</span></span></span></span>) is ``weakly Pareto optimal'', i.e., that there is no <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"individually_rational"<span class="antiquote"><span class="antiquote">}</span></span></span></span> allocation that every doctor strictly prefers
to the doctor-optimal match.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> ContractsWithUnilateralSubstitutesAndIRCAndLAD
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">theorem</span></span> Corollary_2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">ds</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">Y</span><span class="main">.</span> individually_rational_on <span class="free">ds</span> <span class="bound">Y</span>
        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">d</span><span class="main">∈</span><span class="free">ds</span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="bound">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> AboveS <span class="main">(</span><span class="free">Pd</span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span>dX <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">unfold</span> individually_rational_on_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Y</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"CD_on <span class="free">ds</span> <span class="skolem">Y</span> <span class="main">=</span> <span class="skolem">Y</span>"</span></span> <span class="quoted"><span class="quoted">"CH <span class="skolem">Y</span> <span class="main">=</span> <span class="skolem">Y</span>"</span></span>
           <span class="keyword2"><span class="keyword">and</span></span> Z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d</span><span class="main">∈</span><span class="free">ds</span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="skolem">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> AboveS <span class="main">(</span><span class="free">Pd</span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span>dX <span class="main">(</span>cop <span class="free">ds</span><span class="main">)</span> <span class="bound">d</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹CD_on <span class="free">ds</span> <span class="skolem">Y</span> <span class="main">=</span> <span class="skolem">Y</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"allocation <span class="skolem">Y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> CD_on_inj_on_Xd<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹CD_on <span class="free">ds</span> <span class="skolem">Y</span> <span class="main">=</span> <span class="skolem">Y</span>›</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> Y<span class="main">:</span> ContractsWithUnilateralSubstitutesAndIRCAndLAD <span class="quoted"><span class="free">Xd</span></span> <span class="quoted"><span class="free">Xh</span></span> <span class="quoted"><span class="quoted">"Pd_singletons_for_ds <span class="skolem">Y</span> <span class="free">ds</span>"</span></span> <span class="quoted"><span class="free">Ch</span></span>
    <span class="keyword1"><span class="command">using</span></span> Ch_unilateral_substitutes Ch_irc Ch_lad Ch_range Ch_singular Pd_singletons_for_ds_range
          Pd_singletons_for_ds_linear<span class="main">[</span><span class="operator">OF</span> CD_on_inj_on_Xd<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Y.fp_cop_F_doctor_optimal_match Y.doctor_optimal_matchI
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"CH <span class="main">(</span>Y.fp_cop_F <span class="free">ds</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">Y</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Y.doctor_optimal_match_unique<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Y.stable_on <span class="free">ds</span> <span class="skolem">Y</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Y.stable_onI<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Y.individually_rational_on <span class="free">ds</span> <span class="skolem">Y</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Y.individually_rational_onI<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹CD_on <span class="free">ds</span> <span class="skolem">Y</span> <span class="main">=</span> <span class="skolem">Y</span>›</span></span> CD_on_Xd<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">Y</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> ds<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ds</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Y.CD_on <span class="free">ds</span> <span class="skolem">Y</span> <span class="main">=</span> <span class="skolem">Y</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> Y.CD_on_def CD_on_def
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Y.Cd_greatest Cd_greatest greatest_def Pd_singletons_for_ds_simps dX_def<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹CH <span class="skolem">Y</span> <span class="main">=</span> <span class="skolem">Y</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Y.CH <span class="skolem">Y</span> <span class="main">=</span> <span class="skolem">Y</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Y.stable_no_blocking_on <span class="free">ds</span> <span class="skolem">Y</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Y.stable_no_blocking_onI<span class="main"><span class="keyword3">,</span></span>
            <span class="operator">drule</span> subset_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ Y.CD_on_range<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span>
            <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd_singletons_for_ds_def dX_def Un_absorb1 subset_eq sup_commute<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">X</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X</span>"</span></span> <span class="quoted"><span class="quoted">"Y.stable_on <span class="free">ds</span> <span class="skolem">X</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> Y.Theorem_5<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ds</span></span> <span class="quoted"><span class="skolem">X</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> Pd_singletons_for_ds_linear<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹allocation <span class="skolem">Y</span>›</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="skolem">Y</span><span class="main">.</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> Pd_singletons_for_ds <span class="skolem">Y</span> <span class="free">ds</span> <span class="main">(</span><span class="free">Xd</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Pd_singletons_for_ds_simps Y.stable_on_Xd dX_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">from</span></span> Z <span class="quoted"><span class="quoted">‹CH <span class="main">(</span>Y.fp_cop_F <span class="free">ds</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">Y</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">using</span></span> group_strategy_proofD<span class="main">[</span><span class="operator">OF</span>
      fp_cop_F_group_strategy_proof
      ContractsWithUnilateralSubstitutesAndIRCAndLAD_axioms subset_refl
      <span class="quoted"><span class="quoted">‹<span class="free">ds</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span>
      Y.ContractsWithUnilateralSubstitutesAndIRCAndLAD_axioms<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> Pd_singletons_for_ds_def<span class="main"><span class="main">]</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> Pd_singletons_for_ds_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citet[\S4.4]{RothSotomayor:1990} discuss how the non-proposing agents
can strategise to improve their outcomes in one-to-one matches.

›</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div>