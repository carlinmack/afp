<div id="Helpers">
<div class="head">
<h1>Theory Helpers</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Helpers›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Helpers <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  First, we will prove a few lemmas unrelated to graphs or Menger's Theorem.  These lemmas
  will simplify some of the other proof steps.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  If two finite sets have different cardinality, then there exists an element in the larger set
  that is not in the smaller set.
›</span></span>
<span class="keyword1" id="Helpers-card_finite_less_ex"><span class="command">lemma</span></span> card_finite_less_ex<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finite_A<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> finite_B<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">B</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> card_AB<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="free">A</span> <span class="main">&lt;</span> card <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">b</span> <span class="main">∈</span> <span class="free">B</span><span class="main">.</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">B</span> <span class="main">-</span> <span class="free">A</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> finite_A finite_B card_AB
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Diff_eq_empty_iff card_eq_0_iff card_mono finite_Diff gr0I leD<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> finite_B
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Diff_eq_empty_iff card_0_eq finite_Diff neq_iff subsetI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The cardinality of the union of two disjoint finite sets is the sum of their cardinalities
  even if we intersect everything with a fixed set <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">X</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1" id="Helpers-card_intersect_sum_disjoint"><span class="command">lemma</span></span> card_intersect_sum_disjoint<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">B</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> <span class="free">B</span> <span class="main">∪</span> <span class="free">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">∩</span> <span class="free">C</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">A</span> <span class="main">∩</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span><span class="free">B</span> <span class="main">∩</span> <span class="free">X</span><span class="main">)</span> <span class="main">+</span> card <span class="main">(</span><span class="free">C</span> <span class="main">∩</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Un_Diff_Int assms card_Un_disjoint finite_Int inf.commute
      inf_sup_distrib2 sup_eq_bot_iff<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is in a list <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> but is not its last element, then it is also in
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"butlast <span class="free"><span class="free">xs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1" id="Helpers-set_butlast"><span class="command">lemma</span></span> set_butlast<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> set <span class="free">xs</span><span class="main">;</span> <span class="free">x</span> <span class="main">≠</span> last <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> butlast.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> in_set_butlast_appendI last.simps last_appendR
      list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> split_list_first<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  If a property <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is satisfiable and if we have a weight measure mapping into the natural
  numbers, then there exists an element of minimum weight satisfying <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> because the
  natural numbers are well-ordered.
›</span></span>
<span class="keyword1" id="Helpers-arg_min_ex"><span class="command">lemma</span></span> arg_min_ex<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">weight</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> nat"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">x</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">y</span> <span class="main">⟹</span> <span class="free">weight</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">weight</span> <span class="bound">y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">weight</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> that ex_least_nat_le<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">weight</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">n</span>"</span></span><span class="main">]</span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> not_le_imp_less<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Graph">
<div class="head">
<h1>Theory Graph</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Graphs›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Graph <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Let us now define digraphs, graphs, walks, paths, and related concepts.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the vertex type.›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> Edge <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> Walk <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>

<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'a</span> Graph <span class="main">=</span>
  verts <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">V</span>ı"</span><span class="main">)</span>
  arcs <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Edge set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">E</span>ı"</span><span class="main">)</span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">is_arc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Graph_scheme <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">→</span>ı"</span> 60<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main"><span class="free">→</span></span><span class="hidden">⇘</span><sub><span class="free"><span class="bound"><span class="entity">G</span></span></span></sub><span class="hidden">⇙</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="keyword1">E</span><span class="hidden">⇘</span><sub><span class="free"><span class="bound"><span class="entity">G</span></span></span></sub><span class="hidden">⇙</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We consider directed and undirected finite graphs.  Our graphs do not have multi-edges.
›</span></span>
<span class="keyword1"><span class="command">locale</span></span> Digraph <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Graph_scheme"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finite_vertex_set<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="keyword1">V</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> valid_edge_set<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">E</span> <span class="main">⊆</span> <span class="keyword1">V</span> <span class="main">×</span> <span class="keyword1">V</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> Digraph <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Graph-finite_edge_set"><span class="command">lemma</span></span> finite_edge_set <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="keyword1">E</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> finite_vertex_set valid_edge_set
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
<span class="keyword1" id="Graph-edges_are_in_V"><span class="command">lemma</span></span> edges_are_in_V<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">→</span><span class="free">w</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms valid_edge_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Walks›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A walk is sequence of vertices connected by edges.›</span></span>
<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">walk</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Walk <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
Nil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">walk</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> Singleton <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> <span class="keyword1">V</span> <span class="main">⟹</span> <span class="free">walk</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">]</span>"</span></span>
<span class="main">|</span> Cons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">→</span><span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">⟹</span> <span class="free">walk</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">⟹</span> <span class="free">walk</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Show a few composition/decomposition lemmas for walks.  These will greatly simplify the proofs
  that follow.›</span></span>
<span class="keyword1" id="Graph-walk_2"><span class="command">lemma</span></span> walk_2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">→</span><span class="free">w</span> <span class="main">⟹</span> walk <span class="main">[</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_are_in_V<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> walk.intros<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1" id="Graph-walk_comp"><span class="command">lemma</span></span> walk_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> walk <span class="free">xs</span><span class="main">;</span> walk <span class="free">ys</span><span class="main">;</span> <span class="free">xs</span> <span class="main">=</span> Nil <span class="main">∨</span> <span class="free">ys</span> <span class="main">=</span> Nil <span class="main">∨</span> last <span class="free">xs</span><span class="main">→</span>hd <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> walk.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk.intros<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">metis</span> list.exhaust_sel walk.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> walk.intros<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1" id="Graph-walk_tl"><span class="command">lemma</span></span> walk_tl<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span> <span class="main">⟹</span> walk <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> walk.induct<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1" id="Graph-walk_drop"><span class="command">lemma</span></span> walk_drop<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span> <span class="main">⟹</span> walk <span class="main">(</span>drop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> drop_Suc tl_drop walk_tl<span class="main">)</span>
<span class="keyword1" id="Graph-walk_take"><span class="command">lemma</span></span> walk_take<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span> <span class="main">⟹</span> walk <span class="main">(</span>take <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> walk.induct<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> Digraph.walk.simps Digraph_axioms take_Cons' take_eq_Nil<span class="main"><span class="keyword3">,</span></span>
      <span class="operator">metis</span> Digraph.walk.simps Digraph_axioms edges_are_in_V<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> take_Cons'<span class="main">)</span>
<span class="keyword1" id="Graph-walk_decomp"><span class="command">lemma</span></span> walk_decomp<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"walk <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms append_eq_conv_conj<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span>"</span></span><span class="main">]</span> walk_take walk_drop <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1" id="Graph-walk_in_V"><span class="command">lemma</span></span> walk_in_V<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span> <span class="main">⟹</span> set <span class="free">xs</span> <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> walk.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_are_in_V<span class="main">)</span>
<span class="keyword1" id="Graph-walk_first_edge"><span class="command">lemma</span></span> walk_first_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">→</span><span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> walk.cases <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1" id="Graph-walk_first_edge'"><span class="command">lemma</span></span> walk_first_edge'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> walk <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> Nil <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">→</span>hd <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> walk_first_edge <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> list.exhaust_sel<span class="main">)</span>
<span class="keyword1" id="Graph-walk_middle_edge"><span class="command">lemma</span></span> walk_middle_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">→</span><span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">@</span> <span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="free">ys</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> walk.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
     <span class="main">(</span><span class="operator">metis</span> list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> self_append_conv2 tl_append2<span class="main">)</span>
<span class="keyword1" id="Graph-walk_last_edge"><span class="command">lemma</span></span> walk_last_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> Nil<span class="main">;</span> <span class="free">ys</span> <span class="main">≠</span> Nil <span class="main">⟧</span> <span class="main">⟹</span> last <span class="free">xs</span><span class="main">→</span>hd <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> walk_middle_edge<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"butlast <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"hd <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"tl <span class="free">ys</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Cons_eq_appendI append_butlast_last_id append_eq_append_conv2 list.exhaust_sel self_append_conv<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Paths›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A path is a walk without repeated vertices.  This is simple enough, so most of the above lemmas
  transfer directly to paths.
›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">path</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Walk <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">path</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≡</span> walk <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">∧</span> distinct <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Graph-path_singleton"><span class="command">lemma</span></span> path_singleton <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span> <span class="main">⟹</span> path <span class="main">[</span><span class="free">v</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="Graph-path_2"><span class="command">lemma</span></span> path_2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span><span class="main">→</span><span class="free">w</span><span class="main">;</span> <span class="free">v</span> <span class="main">≠</span> <span class="free">w</span> <span class="main">⟧</span> <span class="main">⟹</span> path <span class="main">[</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="Graph-path_cons"><span class="command">lemma</span></span> path_cons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> path <span class="free">xs</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> Nil<span class="main">;</span> <span class="free">v</span><span class="main">→</span>hd <span class="free">xs</span><span class="main">;</span> <span class="free">v</span> <span class="main">∉</span> set <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> path <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> distinct.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> list.exhaust_sel walk.Cons<span class="main">)</span>
<span class="keyword1" id="Graph-path_comp"><span class="command">lemma</span></span> path_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> walk <span class="free">xs</span><span class="main">;</span> walk <span class="free">ys</span><span class="main">;</span> <span class="free">xs</span> <span class="main">=</span> Nil <span class="main">∨</span> <span class="free">ys</span> <span class="main">=</span> Nil <span class="main">∨</span> last <span class="free">xs</span><span class="main">→</span>hd <span class="free">ys</span><span class="main">;</span> distinct <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> path <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> walk_comp <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="Graph-path_tl"><span class="command">lemma</span></span> path_tl<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span> <span class="main">⟹</span> path <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> distinct_tl walk_tl<span class="main">)</span>
<span class="keyword1" id="Graph-path_drop"><span class="command">lemma</span></span> path_drop<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span> <span class="main">⟹</span> path <span class="main">(</span>drop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_drop<span class="main">)</span>
<span class="keyword1" id="Graph-path_take"><span class="command">lemma</span></span> path_take<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span> <span class="main">⟹</span> path <span class="main">(</span>take <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_take<span class="main">)</span>
<span class="keyword1" id="Graph-path_decomp"><span class="command">lemma</span></span> path_decomp<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> walk_decomp assms distinct_append <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1" id="Graph-path_decomp'"><span class="command">lemma</span></span> path_decomp'<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> path <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Singleton distinct.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> distinct1_rotate edges_are_in_V<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.discI list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
      not_distinct_conv_prefix path_decomp<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> rotate1.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> walk_comp walk_decomp<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span>
      walk_first_edge' walk_last_edge<span class="main">)</span>
<span class="keyword1" id="Graph-path_in_V"><span class="command">lemma</span></span> path_in_V<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span> <span class="main">⟹</span> set <span class="free">xs</span> <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_in_V<span class="main">)</span>
<span class="keyword1" id="Graph-path_length"><span class="command">lemma</span></span> path_length<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span> <span class="main">⟹</span> length <span class="free">xs</span> <span class="main">≤</span> card <span class="keyword1">V</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> card_mono distinct_card finite_vertex_set path_in_V<span class="main">)</span>
<span class="keyword1" id="Graph-path_first_edge"><span class="command">lemma</span></span> path_first_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">→</span><span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> walk_first_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="Graph-path_first_edge'"><span class="command">lemma</span></span> path_first_edge'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> path <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> Nil <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">→</span>hd <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> walk_first_edge' <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="Graph-path_middle_edge"><span class="command">lemma</span></span> path_middle_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">→</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> walk_middle_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="Graph-path_first_vertex"><span class="command">lemma</span></span> path_first_vertex<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∉</span> set <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="Graph-path_disjoint"><span class="command">lemma</span></span> path_disjoint<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> path <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> Nil<span class="main">;</span> <span class="free">x</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∉</span> set <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The Set of All Paths›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">all_paths</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">all_paths</span> <span class="main">≡</span> <span class="main">{</span> <span class="bound">xs</span> <span class="main">|</span> <span class="bound">xs</span><span class="main">.</span> path <span class="bound">xs</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Because paths have no repeated vertices, every graph has at most finitely many distinct paths.
  This will be useful later to easily derive that any set of paths is finite.
›</span></span>

<span class="keyword1" id="Graph-finitely_many_paths"><span class="command">lemma</span></span> finitely_many_paths<span class="main">:</span> <span class="quoted"><span class="quoted">"finite all_paths"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"all_paths <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="keyword1">V</span> <span class="main">∧</span> length <span class="bound">xs</span> <span class="main">≤</span> card <span class="keyword1">V</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> all_paths_def <span class="keyword1"><span class="command">using</span></span> path_length <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Collect_mono path_in_V<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> finite_lists_length_le<span class="main">[</span><span class="operator">OF</span> finite_vertex_set<span class="main">]</span> walk_in_V infinite_super <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹context Digraph›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We introduce shorthand notation for a path connecting two vertices.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">path_from_to</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Graph_scheme <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> Walk <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
  <span class="main">(</span><span class="quoted">"_ <span class="keyword1">↝</span>_<span class="keyword1">↝</span>ı _"</span> <span class="main">[</span>71<span class="main">,</span> 71<span class="main">,</span> 71<span class="main">]</span> 70<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">path_from_to</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> Digraph.path <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> Nil <span class="main">∧</span> hd <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∧</span> last <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> Digraph <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Graph-path_from_toI"><span class="command">lemma</span></span> path_from_toI <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> path <span class="free">xs</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> Nil<span class="main">;</span> hd <span class="free">xs</span> <span class="main">=</span> <span class="free">v</span><span class="main">;</span> last <span class="free">xs</span> <span class="main">=</span> <span class="free">w</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> path_from_toE <span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span> <span class="main">⟹</span> path <span class="free">xs</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">≠</span> Nil <span class="main">∧</span> hd <span class="free">xs</span> <span class="main">=</span> <span class="free">v</span> <span class="main">∧</span> last <span class="free">xs</span> <span class="main">=</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> path_from_to_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Graph-path_from_to_ends"><span class="command">lemma</span></span> path_from_to_ends<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">w</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span><span class="main">↝</span> <span class="free">w</span> <span class="main">⟹</span> <span class="free">ys</span> <span class="main">=</span> Nil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE distinct.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> last.simps last_appendR last_in_set list.discI path_decomp<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="Graph-path_from_to_combine"><span class="command">lemma</span></span> path_from_to_combine<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span><span class="main">↝</span> <span class="free">w</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v'</span> <span class="main">↝</span><span class="main">(</span><span class="free">ys</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">ys'</span><span class="main">)</span><span class="main">↝</span> <span class="free">w'</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">∩</span> set <span class="free">ys'</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">ys'</span><span class="main">)</span> <span class="main">↝</span> <span class="free">w'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">ys'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> disjoint_insert<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> distinct_append list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.set<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span>
        list.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> path_decomp<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> walk_comp walk_decomp<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> walk_last_edge<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">ys'</span><span class="main">)</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> hd_append list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"last <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">ys'</span><span class="main">)</span> <span class="main">=</span> <span class="free">w'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Graph-path_from_to_first"><span class="command">lemma</span></span> path_from_to_first<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∉</span> set <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE list.collapse path_first_vertex<span class="main">)</span>

<span class="keyword1" id="Graph-path_from_to_first'"><span class="command">lemma</span></span> path_from_to_first'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span><span class="main">↝</span> <span class="free">w</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∉</span> set <span class="free">xs'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE append_eq_append_conv2 distinct.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> hd_append list.exhaust_sel
      list.sel<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> list.set_sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span> list.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> path_disjoint self_append_conv<span class="main">)</span>

<span class="keyword1" id="Graph-path_from_to_last"><span class="command">lemma</span></span> path_from_to_last<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">∉</span> set <span class="main">(</span>butlast <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE append_butlast_last_id distinct_append not_distinct_conv_prefix<span class="main">)</span>

<span class="keyword1" id="Graph-path_from_to_last'"><span class="command">lemma</span></span> path_from_to_last'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span><span class="main">↝</span> <span class="free">w</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">∉</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE bex_empty last_appendR last_in_set list.set<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> path_disjoint<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Every walk contains a path connecting the same vertices.›</span></span>

<span class="keyword1" id="Graph-walk_to_path"><span class="command">lemma</span></span> walk_to_path<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> Nil"</span></span> <span class="quoted"><span class="quoted">"hd <span class="free">xs</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="free">xs</span> <span class="main">=</span> <span class="free">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">v</span> <span class="main">↝</span><span class="bound">ys</span><span class="main">↝</span> <span class="free">w</span> <span class="main">∧</span> set <span class="bound">ys</span> <span class="main">⊆</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We prove this by removing loops from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> until <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a path.
    We want to perform induction over <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"length <span class="free"><span class="free">xs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, but <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"set <span class="free"><span class="free">ys</span></span> <span class="main"><span class="main">⊆</span></span> set <span class="free"><span class="free">xs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> should not be part of the induction hypothesis. To accomplish this,
    we hide <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"set <span class="free"><span class="free">xs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> behind a definition for this specific part of the goal.›</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">target_set</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">target_set</span> <span class="main">≡</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> <span class="skolem">target_set</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">v</span> <span class="main">↝</span><span class="bound">ys</span><span class="main">↝</span> <span class="free">w</span> <span class="main">∧</span> set <span class="bound">ys</span> <span class="main">⊆</span> <span class="skolem">target_set</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> infinite_descent0<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>smaller <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> length <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"walk <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> Nil"</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs</span> <span class="main">=</span> <span class="free">w</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">⊆</span> <span class="skolem">target_set</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      hyp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">v</span> <span class="main">↝</span><span class="bound">ys</span><span class="main">↝</span> <span class="free">w</span> <span class="main">∧</span> set <span class="bound">ys</span> <span class="main">⊆</span> <span class="skolem">target_set</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is not a path, then <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is not distinct and we can decompose it.›</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="skolem"><span class="skolem">rest</span></span> <span class="skolem"><span class="skolem">u</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> xs_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="skolem">u</span> <span class="main">#</span> <span class="skolem">rest</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> not_distinct_conv_prefix <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toI<span class="main">)</span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> appears in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">ys</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, so we have a loop in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> starting from an
      occurrence of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">ys</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> ending in the vertex <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">u</span></span> <span class="main"><span class="main">#</span></span> <span class="skolem"><span class="skolem">rest</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
      We define <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">zs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> without this loop.›</span></span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ys'</span></span> <span class="skolem"><span class="skolem">ys_suffix</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      ys_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> <span class="skolem">ys'</span> <span class="main">@</span> <span class="skolem">u</span> <span class="main">#</span> <span class="skolem">ys_suffix</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> split_list xs_decomp<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">zs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">zs</span> <span class="main">≡</span> <span class="skolem">ys'</span> <span class="main">@</span> <span class="skolem">u</span> <span class="main">#</span> <span class="skolem">rest</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"walk <span class="skolem">zs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> zs_def <span class="keyword1"><span class="command">using</span></span> xs<span class="main">(</span>2<span class="main">)</span> xs_decomp<span class="main">(</span>3<span class="main">)</span> ys_decomp
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> walk_decomp list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> walk_comp walk_last_edge<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">zs</span> <span class="main">&lt;</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> zs_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xs<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> xs_decomp<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> ys_decomp<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">zs</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> zs_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_is_Nil_conv hd_append list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> xs<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> xs_decomp<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> ys_decomp<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">zs</span> <span class="main">=</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> zs_def <span class="keyword1"><span class="command">using</span></span> xs<span class="main">(</span>5<span class="main">)</span> xs_decomp<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">zs</span> <span class="main">⊆</span> <span class="skolem">target_set</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> zs_def <span class="keyword1"><span class="command">using</span></span> xs<span class="main">(</span>6<span class="main">)</span> xs_decomp<span class="main">(</span>3<span class="main">)</span> ys_decomp <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> zs_def hyp <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Edges of Walks›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The set of edges on a walk.  Note that this is empty for walks of length 0 or 1.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">edges_of_walk</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Walk <span class="main">⇒</span> <span class="tfree">'a</span> Edge set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">edges_of_walk</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">{</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">|</span> <span class="bound">v</span> <span class="bound">w</span> <span class="bound">xs_pre</span> <span class="bound">xs_post</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="bound">xs_pre</span> <span class="main">@</span> <span class="bound">v</span> <span class="main">#</span> <span class="bound">w</span> <span class="main">#</span> <span class="bound">xs_post</span> <span class="main">}</span>"</span></span>

<span class="keyword1" id="Graph-edges_of_walkE"><span class="command">lemma</span></span> edges_of_walkE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="free">xs</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">xs_pre</span> <span class="bound">xs_post</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> <span class="bound">xs_pre</span> <span class="main">@</span> <span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="bound">xs_post</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> edges_of_walk_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Graph-edges_of_walk_in_E"><span class="command">lemma</span></span> edges_of_walk_in_E<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span> <span class="main">⟹</span> edges_of_walk <span class="free">xs</span> <span class="main">⊆</span> <span class="keyword1">E</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> edges_of_walk_def <span class="keyword1"><span class="command">using</span></span> walk_middle_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Graph-edges_of_walk_finite"><span class="command">lemma</span></span> edges_of_walk_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span> <span class="main">⟹</span> finite <span class="main">(</span>edges_of_walk <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> edges_of_walk_in_E finite_edge_set finite_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Graph-edges_of_walk_empty"><span class="command">lemma</span></span> edges_of_walk_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">[]</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">[</span><span class="free">v</span><span class="main">]</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> edges_of_walk_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Graph-edges_of_walk_2"><span class="command">lemma</span></span> edges_of_walk_2<span class="main">:</span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">[</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">]</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v'</span> <span class="skolem">w'</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">w'</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="main">[</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs_pre</span></span> <span class="skolem"><span class="skolem">xs_post</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">xs_pre</span> <span class="main">@</span> <span class="skolem">v'</span> <span class="main">#</span> <span class="skolem">w'</span> <span class="main">#</span> <span class="skolem">xs_post</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> edges_of_walkE<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">v'</span></span> <span class="quoted"><span class="skolem">w'</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">]</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs_pre</span> <span class="main">=</span> Nil"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Nil_is_append_conv butlast.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> butlast_append list.discI<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v'</span><span class="main">,</span><span class="skolem">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs_decomp <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">[</span><span class="free">v</span><span class="main">,</span> <span class="free">w</span><span class="main">]</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subrelI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span><span class="main">}</span> <span class="main">⊆</span> edges_of_walk <span class="main">[</span><span class="free">v</span><span class="main">,</span> <span class="free">w</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> edges_of_walk_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Graph-edges_of_walk_edge"><span class="command">lemma</span></span> edges_of_walk_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> walk <span class="free">xs</span><span class="main">;</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">→</span><span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> edges_of_walkE walk_middle_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Graph-edges_of_walk_middle"><span class="command">lemma</span></span> edges_of_walk_middle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> edges_of_walk_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Graph-edges_of_comp1"><span class="command">lemma</span></span> edges_of_comp1<span class="main">:</span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="free">xs</span> <span class="main">⊆</span> edges_of_walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> edges_of_walk_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword1" id="Graph-edges_of_comp2"><span class="command">lemma</span></span> edges_of_comp2<span class="main">:</span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="free">ys</span> <span class="main">⊆</span> edges_of_walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">w</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys_pre</span> <span class="bound">ys_post</span><span class="main">.</span> <span class="free">ys</span> <span class="main">=</span> <span class="bound">ys_pre</span> <span class="main">@</span> <span class="skolem">v</span> <span class="main">#</span> <span class="skolem">w</span> <span class="main">#</span> <span class="bound">ys_post</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> edges_of_walkE<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> append.assoc edges_of_walk_def mem_Collect_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subrelI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Graph-walk_edges_decomp_simple"><span class="command">lemma</span></span> walk_edges_decomp_simple<span class="main">:</span>
  <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> edges_of_walk <span class="main">(</span><span class="free">w</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">=</span> <span class="var">?B</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">(</span><span class="free">w</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="var">?A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> edges_of_comp2<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">#</span> <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">v</span><span class="main">]</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_eq_Cons_conv edges_of_walk_middle<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?B</span> <span class="main">⊆</span> <span class="var">?A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v'</span> <span class="skolem">w'</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v'</span><span class="main">,</span><span class="skolem">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?A</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs_pre</span></span> <span class="skolem"><span class="skolem">xs_post</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="free">xs</span> <span class="main">=</span> <span class="skolem">xs_pre</span> <span class="main">@</span> <span class="skolem">v'</span> <span class="main">#</span> <span class="skolem">w'</span> <span class="main">#</span> <span class="skolem">xs_post</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> edges_of_walkE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v'</span><span class="main">,</span><span class="skolem">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?B</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs_pre</span> <span class="main">=</span> Nil"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> xs_decomp <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs_pre</span> <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Cons_eq_append_conv UnI2 edges_of_walk_middle xs_decomp<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">⊆</span> <span class="var">?B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Graph-walk_edges_decomp"><span class="command">lemma</span></span> walk_edges_decomp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span> <span class="main">=</span> edges_of_walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="main">∪</span> edges_of_walk <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">v</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> Nil"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> edges_of_walk_2 walk_edges_decomp_simple <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> Nil"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="skolem"><span class="skolem">xs_post</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">w</span> <span class="main">#</span> <span class="skolem">xs_post</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> list.exhaust_sel <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Cons.hyps walk_edges_decomp_simple <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_of_walk_empty<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="Graph-walk_edges_decomp'"><span class="command">lemma</span></span> walk_edges_decomp'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span> <span class="main">=</span> edges_of_walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">v</span><span class="main">]</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> edges_of_walk <span class="main">(</span><span class="free">w</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> walk_edges_decomp walk_edges_decomp_simple <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> sup.assoc<span class="main">)</span>

<span class="keyword1" id="Graph-walk_edges_vertices"><span class="command">lemma</span></span> walk_edges_vertices<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> set <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms edges_of_walkE <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Graph-walk_edges_subset"><span class="command">lemma</span></span> walk_edges_subset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> edges_subsets<span class="main">:</span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="free">xs</span> <span class="main">⊆</span> edges_of_walk <span class="free">ys</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> non_trivial<span class="main">:</span> <span class="quoted"><span class="quoted">"tl <span class="free">xs</span> <span class="main">≠</span> Nil"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> set <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs_pre</span></span> <span class="skolem"><span class="skolem">xs_post</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    xs_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="skolem">xs_pre</span> <span class="main">@</span> <span class="skolem">v</span> <span class="main">#</span> <span class="skolem">xs_post</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> split_list<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs_pre</span> <span class="main">=</span> Nil"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs_post</span> <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">using</span></span> xs_decomp non_trivial <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="skolem">xs_pre</span> <span class="main">@</span> <span class="skolem">v</span> <span class="main">#</span> hd <span class="skolem">xs_post</span> <span class="main">#</span> tl <span class="skolem">xs_post</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xs_decomp<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> hd <span class="skolem">xs_post</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> edges_of_walk_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> walk_edges_vertices<span class="main">(</span>1<span class="main">)</span> edges_subsets <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs_pre</span> <span class="main">≠</span> Nil"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> butlast <span class="skolem">xs_pre</span> <span class="main">@</span> last <span class="skolem">xs_pre</span> <span class="main">#</span> <span class="skolem">v</span> <span class="main">#</span> <span class="skolem">xs_post</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xs_decomp<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>last <span class="skolem">xs_pre</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> edges_of_walk_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> walk_edges_vertices<span class="main">(</span>2<span class="main">)</span> edges_subsets <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A path has no repeated vertices, so if we split a path at an edge we find that the two pieces
  do not contain this edge any more.
›</span></span>

<span class="keyword1" id="Graph-path_edges"><span class="command">lemma</span></span> path_edges<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">xs_pre</span> <span class="bound">xs_post</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> <span class="bound">xs_pre</span> <span class="main">@</span> <span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="bound">xs_post</span>
    <span class="main">∧</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∉</span> edges_of_walk <span class="main">(</span><span class="bound">xs_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">v</span><span class="main">]</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∉</span> edges_of_walk <span class="main">(</span><span class="free">w</span> <span class="main">#</span> <span class="bound">xs_post</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs_pre</span></span> <span class="skolem"><span class="skolem">xs_post</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    xs_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="skolem">xs_pre</span> <span class="main">@</span> <span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="skolem">xs_post</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> edges_of_walkE<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∉</span> edges_of_walk <span class="main">(</span><span class="skolem">xs_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">v</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> edges_of_walkE
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_to_ends list.discI path_decomp' path_from_toI snoc_eq_iff_butlast<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∉</span> edges_of_walk <span class="main">(</span><span class="free">w</span> <span class="main">#</span> <span class="skolem">xs_post</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span>  assms<span class="main">(</span>1<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> edges_of_walkE in_set_conv_decomp path_decomp<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> path_first_vertex xs_decomp<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> xs_decomp <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Graph-path_edges_remove_prefix"><span class="command">lemma</span></span> path_edges_remove_prefix<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> edges_of_walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span> <span class="main">-</span> edges_of_walk <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">w</span> <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> walk_edges_decomp<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">xs'</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∉</span> edges_of_walk <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> contra<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> walk_edges_vertices<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">≠</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms contra * 1
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_decomp<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> UnE edges_of_walkE edges_of_walk_edge list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
            path_2 path_disjoint path_first_vertex self_append_conv2 set_append walk_edges_vertices<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> * walk_edges_vertices<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span> <span class="main">-</span> edges_of_walk <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> walk_edges_decomp<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">xs'</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The First Edge of a Walk›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In the proof of Menger's Theorem, we will often talk about the first edge of a path.  Let us
  define this concept.
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">first_edge_of_walk</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">first_edge_of_walk</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">first_edge_of_walk</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">]</span> <span class="main">=</span> undefined"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">first_edge_of_walk</span> <span class="main">[]</span> <span class="main">=</span> undefined"</span></span>

<span class="keyword1" id="Graph-first_edge_in_edges"><span class="command">lemma</span></span> first_edge_in_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"tl <span class="free">xs</span> <span class="main">≠</span> Nil <span class="main">⟹</span> first_edge_of_walk <span class="free">xs</span> <span class="main">∈</span> edges_of_walk <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> edges_of_walk_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> first_edge_of_walk.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Graph-first_edge_hd_tl"><span class="command">lemma</span></span> first_edge_hd_tl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span><span class="main">;</span> tl <span class="free">xs</span> <span class="main">≠</span> Nil <span class="main">⟧</span> <span class="main">⟹</span> first_edge_of_walk <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> hd <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> first_edge_of_walk.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Graph-first_edge_first"><span class="command">lemma</span></span> first_edge_first<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w'</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"first_edge_of_walk <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> first_edge_of_walk.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">v</span> <span class="skolem">w</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_decomp<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> append_self_conv2 edges_of_walkE first_edge_of_walk.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
        hd_append hd_in_set not_distinct_conv_prefix path_from_toE<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">v</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> path_edges <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Distance›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The distance between two vertices is the minimum length of a path.  Note that this is not a
  symmetric function because we are on digraphs.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">distance</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">distance</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> Min <span class="main">{</span> length <span class="bound">xs</span> <span class="main">|</span> <span class="bound">xs</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span><span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Min<span class="antiquote"><span class="antiquote">}</span></span></span></span> operator applies only to finite sets, so let us prove that this is the case.
›</span></span>
<span class="keyword1" id="Graph-distance_lengths_finite"><span class="command">lemma</span></span> distance_lengths_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span> length <span class="bound">xs</span> <span class="main">|</span> <span class="bound">xs</span><span class="main">.</span> <span class="free">v</span><span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span><span class="free">w</span> <span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span> length <span class="bound">xs</span> <span class="main">|</span> <span class="bound">xs</span><span class="main">.</span> <span class="free">v</span><span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span><span class="free">w</span> <span class="main">}</span> <span class="main">⊆</span> <span class="main">{</span> <span class="bound">n</span> <span class="main">|</span> <span class="bound">n</span><span class="main">.</span> <span class="bound">n</span> <span class="main">≤</span> card <span class="keyword1">V</span> <span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> path_length <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> finite_Collect_le_nat <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> finite_subset<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  If we have a concrete path from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">w</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, then the length of this path bounds the
  distance from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">w</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1" id="Graph-distance_upper_bound"><span class="command">lemma</span></span> distance_upper_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">↝</span><span class="free">xs</span><span class="main">↝</span><span class="free">w</span> <span class="main">⟹</span> distance <span class="free">v</span> <span class="free">w</span> <span class="main">≤</span> length <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> distance_def <span class="keyword1"><span class="command">using</span></span> Min_le<span class="main">[</span><span class="operator">OF</span> distance_lengths_finite<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Another characterization of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> distance<span class="antiquote"><span class="antiquote">}</span></span></span></span>: If we have a concrete minimal path from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">w</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, this defines the distance.
›</span></span>

<span class="keyword1" id="Graph-distance_witness"><span class="command">lemma</span></span> distance_witness<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> xs_min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs'</span><span class="main">.</span> <span class="free">v</span> <span class="main">↝</span><span class="bound">xs'</span><span class="main">↝</span> <span class="free">w</span> <span class="main">⟹</span> length <span class="free">xs</span> <span class="main">≤</span> length <span class="bound">xs'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"distance <span class="free">v</span> <span class="free">w</span> <span class="main">=</span> length <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">d</span><span class="main">.</span> <span class="bound">d</span> <span class="main">∈</span> <span class="main">{</span>length <span class="bound">xs</span> <span class="main">|</span> <span class="bound">xs</span><span class="main">.</span> <span class="free">v</span> <span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span> <span class="free">w</span><span class="main">}</span> <span class="main">⟹</span> length <span class="free">xs</span> <span class="main">≤</span> <span class="bound">d</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs_min <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> distance_def <span class="keyword1"><span class="command">using</span></span> Min_eqI
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> distance_lengths_finite xs mem_Collect_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Subgraphs›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We only need one kind of subgraph: The subgraph obtained by removing a single vertex.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">remove_vertex</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Graph_scheme"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">remove_vertex</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="free">G</span><span class="main">⦇</span> verts <span class="main">:=</span> <span class="keyword1">V</span> <span class="main">-</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">}</span><span class="main">,</span> arcs <span class="main">:=</span> Restr <span class="keyword1">E</span> <span class="main">(</span><span class="keyword1">V</span> <span class="main">-</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">}</span><span class="main">)</span> <span class="main">⦈</span>"</span></span>

<span class="keyword1" id="Graph-remove_vertex_V"><span class="command">lemma</span></span> remove_vertex_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span><span class="hidden">⇘</span><sub>remove_vertex <span class="free">x</span></sub><span class="hidden">⇙</span> <span class="main">=</span> <span class="keyword1">V</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> remove_vertex_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="Graph-remove_vertex_V'"><span class="command">lemma</span></span> remove_vertex_V'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span><span class="hidden">⇘</span><sub>remove_vertex <span class="free">x</span></sub><span class="hidden">⇙</span> <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> remove_vertex_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="Graph-remove_vertex_E"><span class="command">lemma</span></span> remove_vertex_E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">E</span><span class="hidden">⇘</span><sub>remove_vertex <span class="free">x</span></sub><span class="hidden">⇙</span> <span class="main">=</span> Restr <span class="keyword1">E</span> <span class="main">(</span><span class="keyword1">V</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> remove_vertex_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="Graph-remove_vertex_E'"><span class="command">lemma</span></span> remove_vertex_E'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">→</span><span class="hidden">⇘</span><sub>remove_vertex <span class="free">x</span></sub><span class="hidden">⇙</span> <span class="free">w</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">→</span><span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> remove_vertex_E<span class="main">)</span>
<span class="keyword1" id="Graph-remove_vertex_E''"><span class="command">lemma</span></span> remove_vertex_E''<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span><span class="main">→</span><span class="free">w</span><span class="main">;</span> <span class="free">v</span> <span class="main">≠</span> <span class="free">x</span><span class="main">;</span> <span class="free">w</span> <span class="main">≠</span> <span class="free">x</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">→</span><span class="hidden">⇘</span><sub>remove_vertex <span class="free">x</span></sub><span class="hidden">⇙</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_are_in_V remove_vertex_E<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Of course, this is still a digraph.›</span></span>
<span class="keyword1" id="Graph-remove_vertex_Digraph"><span class="command">lemma</span></span> remove_vertex_Digraph<span class="main">:</span> <span class="quoted"><span class="quoted">"Digraph <span class="main">(</span>remove_vertex <span class="free">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?V</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span><span class="hidden">⇘</span><sub>remove_vertex <span class="free">v</span></sub><span class="hidden">⇙</span>"</span></span> <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?E</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">E</span><span class="hidden">⇘</span><sub>remove_vertex <span class="free">v</span></sub><span class="hidden">⇙</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?V</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> remove_vertex_def <span class="keyword1"><span class="command">using</span></span> finite_vertex_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?E</span> <span class="main">⊆</span> <span class="var">?V</span> <span class="main">×</span> <span class="var">?V</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">e</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">∈</span> <span class="var">?E</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">∈</span> <span class="main">(</span><span class="keyword1">V</span> <span class="main">-</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="keyword1">V</span> <span class="main">-</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Int_iff remove_vertex_E<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">∈</span> <span class="var">?V</span> <span class="main">×</span> <span class="var">?V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> remove_vertex_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?E</span><span class="main">;</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∉</span> <span class="keyword1">E</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?E</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> remove_vertex_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We are also going to need a few lemmas about how walks and paths behave when we remove a vertex.

  First, if we remove a vertex that is not on a walk <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, then <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is still a walk
  after removing this vertex.
›</span></span>

<span class="keyword1" id="Graph-remove_vertex_walk"><span class="command">lemma</span></span> remove_vertex_walk<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Digraph.walk <span class="main">(</span>remove_vertex <span class="free">x</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> H<span class="main">:</span> Digraph <span class="quoted"><span class="quoted">"remove_vertex <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> remove_vertex_Digraph <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> walk.induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Singleton <span class="skolem">v</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="keyword1">V</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> remove_vertex_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">v</span> <span class="skolem">w</span> <span class="skolem">vs</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">→</span><span class="hidden">⇘</span><sub>remove_vertex <span class="free">x</span></sub><span class="hidden">⇙</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> remove_vertex_E'' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Cons.hyps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> Cons.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> H.Cons assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> list.set_intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The same holds for paths.›</span></span>

<span class="keyword1" id="Graph-remove_vertex_path_from_to"><span class="command">lemma</span></span> remove_vertex_path_from_to<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span><span class="main">;</span> <span class="free">x</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">;</span> <span class="free">x</span> <span class="main">∉</span> set <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span><span class="hidden">⇘</span><sub>remove_vertex <span class="free">x</span></sub><span class="hidden">⇙</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> path_from_to_def remove_vertex_walk <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Conversely, if something was a walk or a path in the subgraph, then it is also a walk or a path
  in the supergraph.
›</span></span>
<span class="keyword1" id="Graph-remove_vertex_walk_add"><span class="command">lemma</span></span> remove_vertex_walk_add<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Digraph.walk <span class="main">(</span>remove_vertex <span class="free">x</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> H<span class="main">:</span> Digraph <span class="quoted"><span class="quoted">"remove_vertex <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> remove_vertex_Digraph <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> H.walk.induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Singleton <span class="skolem">v</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Digraph.Singleton Digraph_axioms remove_vertex_V' subsetD<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">v</span> <span class="skolem">w</span> <span class="skolem">vs</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Digraph.Cons Digraph_axioms remove_vertex_E'<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Graph-remove_vertex_path_from_to_add"><span class="command">lemma</span></span> remove_vertex_path_from_to_add<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span><span class="hidden">⇘</span><sub>remove_vertex <span class="free">x</span></sub><span class="hidden">⇙</span> <span class="free">w</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> path_from_to_def remove_vertex_walk_add <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹context Digraph›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Two Distinguished Distinct Non-adjacent Vertices.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The setup for Menger's Theorem requires two distinguished distinct non-adjacent vertices
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v0</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  Let us pin down this concept with the following locale.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> v0_v1_Digraph <span class="main">=</span> Digraph <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">v0</span> <span class="free">v1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> v0_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> v1_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> v0_nonadj_v1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">v0</span><span class="main">→</span><span class="free">v1</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> v0_neq_v1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The only lemma we need about <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> v0_v1_Digraph<span class="antiquote"><span class="antiquote">}</span></span></span></span> for now is that it is closed under removing
  a vertex that is not <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v0</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> v0_v1_Digraph<span class="main">)</span> remove_vertices_v0_v1_Digraph<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">v0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"v0_v1_Digraph <span class="main">(</span>remove_vertex <span class="free">v</span><span class="main">)</span> <span class="free">v0</span> <span class="free">v1</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> v0_v1_Digraph.intro<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"v0_v1_Digraph_axioms <span class="main">(</span>remove_vertex <span class="free">v</span><span class="main">)</span> <span class="free">v0</span> <span class="free">v1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms v0_nonadj_v1 v0_neq_v1 v0_V v1_V remove_vertex_V remove_vertex_E'
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> remove_vertex_Digraph<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Undirected Graphs›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We represent undirecteded graphs as a special case of digraphs where every undirected edge
  is represented as an edge in both directions.  We also exclude loops because loops are uncommon
  in undirected graphs.

  As we will explain in the next paragraph, all of this has no bearing on the validity of
  Menger's Theorem for undirected graphs.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> Graph <span class="main">=</span> Digraph <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> undirected<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">→</span><span class="free">w</span> <span class="main">=</span> <span class="free">w</span><span class="main">→</span><span class="free">v</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> no_loops<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">v</span><span class="main">→</span><span class="free">v</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We observe that this makes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> Digraph<span class="antiquote"><span class="antiquote">}</span></span></span></span> a sublocale of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> Graph<span class="antiquote"><span class="antiquote">}</span></span></span></span>, meaning that every
  theorem we prove for digraphs automatically holds for undirected graphs, although it may not make
  sense because for example ``connectedness'' (if we were to define it) would need different
  definitions for directed and undirected graphs.

  Fortunately, the notions of ``separator'' and ``internally vertex-disjoint paths'' on directed
  graphs are the same for undirected graphs.  So Menger's Theorem, when we eventually prove it in
  the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> Digraph<span class="antiquote"><span class="antiquote">}</span></span></span></span> locale, will apply automatically to the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> Graph<span class="antiquote"><span class="antiquote">}</span></span></span></span> locale without
  any additional work.

  For this reason we will not use the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Graph</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> locale again in this proof development and it
  exists merely to show that undirected graphs are covered as a special case by our definitions.
›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Separations">
<div class="head">
<h1>Theory Separations</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Separations›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Separations <span class="keyword2"><span class="keyword">imports</span></span> <a href="Helpers.html">Helpers</a> <a href="Graph.html">Graph</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> Separation <span class="main">=</span> v0_v1_Digraph <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> S_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> v0_notin_S<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∉</span> <span class="free">S</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> v1_notin_S<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">∉</span> <span class="free">S</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> S_separates<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="free">v0</span><span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span><span class="free">v1</span> <span class="main">⟹</span> set <span class="bound">xs</span> <span class="main">∩</span> <span class="free">S</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Separation<span class="main">)</span> finite_S <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> S_V finite_subset finite_vertex_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> v0_v1_Digraph<span class="main">)</span> subgraph_separation_extend<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">v0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Separation <span class="main">(</span>remove_vertex <span class="free">v</span><span class="main">)</span> <span class="free">v0</span> <span class="free">v1</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Separation <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="main">(</span>insert <span class="free">v</span> <span class="free">S</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> Separation.intro<span class="main">)</span>
  <span class="keyword1"><span class="command">interpret</span></span> G<span class="main">:</span> Separation <span class="quoted"><span class="quoted">"remove_vertex <span class="free">v</span>"</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="free">S</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"v0_v1_Digraph <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v0_v1_Digraph_axioms <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Separation_axioms <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="main">(</span>insert <span class="free">v</span> <span class="free">S</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"insert <span class="free">v</span> <span class="free">S</span> <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> G.S_V assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> insert_subsetI remove_vertex_V' subset_trans<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∉</span> insert <span class="free">v</span> <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> G.v0_notin_S assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">∉</span> insert <span class="free">v</span> <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> G.v1_notin_S assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="skolem">xs</span><span class="main">↝</span> <span class="free">v1</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">∩</span> insert <span class="free">v</span> <span class="free">S</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∉</span> set <span class="skolem">xs</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="skolem">xs</span><span class="main">↝</span><span class="hidden">⇘</span><sub>remove_vertex <span class="free">v</span></sub><span class="hidden">⇙</span> <span class="free">v1</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> remove_vertex_path_from_to <span class="quoted"><span class="quoted">‹<span class="free">v0</span> <span class="main">↝</span><span class="skolem">xs</span><span class="main">↝</span> <span class="free">v1</span>›</span></span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> G.S_separates<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> v0_v1_Digraph<span class="main">)</span> subgraph_separation_min_size<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">v0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> no_small_separation<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">S</span><span class="main">.</span> Separation <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">S</span> <span class="main">⟹</span> card <span class="bound">S</span> <span class="main">≥</span> Suc <span class="free">n</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Separation <span class="main">(</span>remove_vertex <span class="free">v</span><span class="main">)</span> <span class="free">v0</span> <span class="free">v1</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="free">S</span> <span class="main">≥</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> subgraph_separation_extend
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Separation.finite_S Suc_leD assms card_insert_disjoint insert_absorb not_less_eq_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> v0_v1_Digraph<span class="main">)</span> path_exists_if_no_separation<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∉</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">∉</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>Separation <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">xs</span><span class="main">.</span> <span class="free">v0</span><span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span><span class="free">v1</span> <span class="main">∧</span> set <span class="bound">xs</span> <span class="main">∩</span> <span class="free">S</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> assms Separation.intro Separation_axioms.intro v0_v1_Digraph_axioms<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="DisjointPaths">
<div class="head">
<h1>Theory DisjointPaths</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Internally Vertex-Disjoint Paths›</span></span>

<span class="keyword1"><span class="command">theory</span></span> DisjointPaths <span class="keyword2"><span class="keyword">imports</span></span> <a href="Separations.html">Separations</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Menger's Theorem talks about internally vertex-disjoint <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v0</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>-<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>-paths.  Let us
  define this concept.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> DisjointPaths <span class="main">=</span> v0_v1_Digraph <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">paths</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Walk set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> paths<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="free">paths</span> <span class="main">⟹</span> <span class="free">v0</span><span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span><span class="free">v1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> paths_disjoint<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span> <span class="bound">v</span><span class="main">.</span>
    <span class="main">⟦</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="free">paths</span><span class="main">;</span> <span class="bound">ys</span> <span class="main">∈</span> <span class="free">paths</span><span class="main">;</span> <span class="bound">xs</span> <span class="main">≠</span> <span class="bound">ys</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="bound">xs</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="bound">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">v</span> <span class="main">=</span> <span class="free">v0</span> <span class="main">∨</span> <span class="bound">v</span> <span class="main">=</span> <span class="free">v1</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Properties›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The empty set of paths trivially satisfies the conditions.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> v0_v1_Digraph<span class="main">)</span> DisjointPaths_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DisjointPaths.intro DisjointPaths_axioms_def v0_v1_Digraph_axioms<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Re-adding a deleted vertex is fine.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> v0_v1_Digraph<span class="main">)</span> DisjointPaths_supergraph<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"DisjointPaths <span class="main">(</span>remove_vertex <span class="free">v</span><span class="main">)</span> <span class="free">v0</span> <span class="free">v1</span> <span class="free">paths</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="free">paths</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> H<span class="main">:</span> DisjointPaths <span class="quoted"><span class="quoted">"remove_vertex <span class="free">v</span>"</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="free">paths</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="free">paths</span> <span class="main">⟹</span> <span class="free">v0</span> <span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> remove_vertex_path_from_to_add H.paths <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span> <span class="bound">v</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="free">paths</span><span class="main">;</span> <span class="bound">ys</span> <span class="main">∈</span> <span class="free">paths</span><span class="main">;</span> <span class="bound">xs</span> <span class="main">≠</span> <span class="bound">ys</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="bound">xs</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="bound">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">v</span> <span class="main">=</span> <span class="free">v0</span> <span class="main">∨</span> <span class="bound">v</span> <span class="main">=</span> <span class="free">v1</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> DisjointPaths.paths_disjoint H.DisjointPaths_axioms<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> DisjointPaths <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="DisjointPaths-paths_in_all_paths"><span class="command">lemma</span></span> paths_in_all_paths<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">paths</span> <span class="main">⊆</span> all_paths"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> all_paths_def <span class="keyword1"><span class="command">using</span></span> paths <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="DisjointPaths-finite_paths"><span class="command">lemma</span></span> finite_paths<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">paths</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> finitely_many_paths infinite_super paths_in_all_paths <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="DisjointPaths-paths_edge_finite"><span class="command">lemma</span></span> paths_edge_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> <span class="free">paths</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> <span class="free">paths</span><span class="main">)</span> <span class="main">⊆</span> <span class="keyword1">E</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> edges_of_walk_in_E paths <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> finite_edge_set finite_subset<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="DisjointPaths-paths_tl_notnil"><span class="command">lemma</span></span> paths_tl_notnil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">∈</span> <span class="free">paths</span> <span class="main">⟹</span> tl <span class="free">xs</span> <span class="main">≠</span> Nil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE hd_Cons_tl last_ConsL paths v0_neq_v1<span class="main">)</span>

<span class="keyword1" id="DisjointPaths-paths_second_in_V"><span class="command">lemma</span></span> paths_second_in_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">∈</span> <span class="free">paths</span> <span class="main">⟹</span> hd <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> paths edges_are_in_V<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> list.exhaust_sel path_from_toE paths_tl_notnil walk_first_edge'<span class="main">)</span>

<span class="keyword1" id="DisjointPaths-paths_second_not_v0"><span class="command">lemma</span></span> paths_second_not_v0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">∈</span> <span class="free">paths</span> <span class="main">⟹</span> hd <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span> <span class="main">≠</span> <span class="free">v0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> distinct.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> hd_in_set list.exhaust_sel path_from_to_def paths paths_tl_notnil<span class="main">)</span>

<span class="keyword1" id="DisjointPaths-paths_second_not_v1"><span class="command">lemma</span></span> paths_second_not_v1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">∈</span> <span class="free">paths</span> <span class="main">⟹</span> hd <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> paths paths_tl_notnil v0_nonadj_v1 walk_first_edge' <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="DisjointPaths-paths_second_disjoint"><span class="command">lemma</span></span> paths_second_disjoint<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">xs</span> <span class="main">∈</span> <span class="free">paths</span><span class="main">;</span> <span class="free">ys</span> <span class="main">∈</span> <span class="free">paths</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> hd <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span> <span class="main">≠</span> hd <span class="main">(</span>tl <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> paths_disjoint Nil_tl hd_in_set list.set_sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span>
      paths_second_not_v0 paths_second_not_v1 paths_tl_notnil<span class="main">)</span>

<span class="keyword1" id="DisjointPaths-paths_edge_disjoint"><span class="command">lemma</span></span> paths_edge_disjoint<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">∈</span> <span class="free">paths</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">∈</span> <span class="free">paths</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="free">xs</span> <span class="main">∩</span> edges_of_walk <span class="free">ys</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="free">xs</span> <span class="main">∩</span> edges_of_walk <span class="free">ys</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> v_w<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> set <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> set <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> walk_edges_vertices<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="free">v0</span> <span class="main">∨</span> <span class="skolem">v</span> <span class="main">=</span> <span class="free">v1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">=</span> <span class="free">v0</span> <span class="main">∨</span> <span class="skolem">w</span> <span class="main">=</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms paths_disjoint <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> v_w<span class="main">(</span>1<span class="main">)</span> assms<span class="main">(</span>1<span class="main">)</span> v0_nonadj_v1 edges_of_walk_edge path_edges
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> distinct_length_2_or_more path_decomp<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> path_from_to_def path_from_to_ends paths<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Specify the conditions for adding a new disjoint path to the set of disjoint paths.›</span></span>
<span class="keyword1" id="DisjointPaths-DisjointPaths_extend"><span class="command">lemma</span></span> DisjointPaths_extend<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> P_path<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">↝</span><span class="free">P</span><span class="main">↝</span><span class="free">v1</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> P_disjoint<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">v</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="free">paths</span><span class="main">;</span> <span class="bound">xs</span> <span class="main">≠</span> <span class="free">P</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="bound">xs</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="free">P</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">v</span> <span class="main">=</span> <span class="free">v0</span> <span class="main">∨</span> <span class="bound">v</span> <span class="main">=</span> <span class="free">v1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="main">(</span>insert <span class="free">P</span> <span class="free">paths</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">v</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> insert <span class="free">P</span> <span class="free">paths</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">∈</span> insert <span class="free">P</span> <span class="free">paths</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">ys</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="free">v0</span> <span class="main">∨</span> <span class="skolem">v</span> <span class="main">=</span> <span class="free">v1</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DisjointPaths.paths_disjoint DisjointPaths_axioms P_disjoint insert_iff<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">∈</span> insert <span class="free">P</span> <span class="free">paths</span> <span class="main">⟹</span> <span class="free">v0</span> <span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span> <span class="free">v1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> P_path paths <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="DisjointPaths-DisjointPaths_reduce"><span class="command">lemma</span></span> DisjointPaths_reduce<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">paths'</span> <span class="main">⊆</span> <span class="free">paths</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="free">paths'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> <span class="free">paths'</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="skolem">xs</span><span class="main">↝</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms paths <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">v</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> <span class="free">paths'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">∈</span> <span class="free">paths'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">ys</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="free">v0</span> <span class="main">∨</span> <span class="skolem">v</span> <span class="main">=</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> assms paths_disjoint subsetCE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Second Vertices›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Let us now define the set of second vertices of the paths.  We are going to need this in order
  to find a path avoiding the old paths on its first edge.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">second_vertex</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">second_vertex</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">xs</span> <span class="main">::</span> <span class="tfree">'a</span> Walk<span class="main">.</span> hd <span class="main">(</span>tl <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">second_vertices</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">second_vertices</span> <span class="main">≡</span> second_vertex <span class="main">`</span> <span class="free">paths</span>"</span></span>

<span class="keyword1" id="DisjointPaths-second_vertex_inj"><span class="command">lemma</span></span> second_vertex_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on second_vertex <span class="free">paths</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> second_vertex_def <span class="keyword1"><span class="command">using</span></span> paths_second_disjoint <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> inj_onI<span class="main">)</span>

<span class="keyword1" id="DisjointPaths-second_vertices_card"><span class="command">lemma</span></span> second_vertices_card<span class="main">:</span> <span class="quoted"><span class="quoted">"card second_vertices <span class="main">=</span> card <span class="free">paths</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> second_vertices_def <span class="keyword1"><span class="command">using</span></span> finite_paths card_image second_vertex_inj <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="DisjointPaths-second_vertices_in_V"><span class="command">lemma</span></span> second_vertices_in_V<span class="main">:</span> <span class="quoted"><span class="quoted">"second_vertices <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> second_vertex_def second_vertices_def <span class="keyword1"><span class="command">using</span></span> paths_second_in_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="DisjointPaths-v0_v1_notin_second_vertices"><span class="command">lemma</span></span> v0_v1_notin_second_vertices<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∉</span> second_vertices"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">∉</span> second_vertices"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> second_vertices_def second_vertex_def
  <span class="keyword1"><span class="command">using</span></span> paths_second_not_v0 paths_second_not_v1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="DisjointPaths-second_vertices_new_path"><span class="command">lemma</span></span> second_vertices_new_path<span class="main">:</span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span> <span class="main">∉</span> second_vertices <span class="main">⟹</span> <span class="free">xs</span> <span class="main">∉</span> <span class="free">paths</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> image_iff second_vertex_def second_vertices_def<span class="main">)</span>

<span class="keyword1" id="DisjointPaths-second_vertices_first_edge"><span class="command">lemma</span></span> second_vertices_first_edge<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">xs</span> <span class="main">∈</span> <span class="free">paths</span><span class="main">;</span> first_edge_of_walk <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">∈</span> second_vertices"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> second_vertices_def second_vertex_def
  <span class="keyword1"><span class="command">using</span></span> first_edge_hd_tl paths paths_tl_notnil <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  If we have no small separations, then the set of second vertices is not a separator and we can
  find a path avoiding this set.
›</span></span>
<span class="keyword1" id="DisjointPaths-disjoint_paths_new_path"><span class="command">lemma</span></span> disjoint_paths_new_path<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_small_separations<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">S</span><span class="main">.</span> Separation <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">S</span> <span class="main">⟹</span> card <span class="bound">S</span> <span class="main">≥</span> Suc <span class="main">(</span>card <span class="free">paths</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">P_new</span><span class="main">.</span> <span class="free">v0</span><span class="main">↝</span><span class="bound">P_new</span><span class="main">↝</span><span class="free">v1</span> <span class="main">∧</span> set <span class="bound">P_new</span> <span class="main">∩</span> second_vertices <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>Separation <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> second_vertices"</span></span>
    <span class="keyword1"><span class="command">using</span></span> no_small_separations second_vertices_card <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_exists_if_no_separation second_vertices_in_V v0_v1_notin_second_vertices<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We need the following predicate to find the first vertex on a new path that hits one of the
  other paths.  We add the condition <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">v1</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to cover the case <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">paths</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">{}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hitting_paths</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hitting_paths</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="free">v0</span> <span class="main">∧</span> <span class="main">(</span><span class="main">(</span><span class="main">∃</span><span class="bound">xs</span> <span class="main">∈</span> <span class="free">paths</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="bound">xs</span><span class="main">)</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">v1</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹DisjointPaths›</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹One More Path›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Let us define a set of disjoint paths with one more path.  Except for the first and last vertex,
  the new path must be disjoint from all other paths.  The first vertex must be <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v0</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and the
  last vertex must be on some other path.  In the ideal case, the last vertex will be <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  in which case we are already done because we have found a new disjoint path between <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v0</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">locale</span></span> DisjointPathsPlusOne <span class="main">=</span> DisjointPaths <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P_new</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Walk"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> P_new<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="free">P_new</span><span class="main">↝</span> <span class="main">(</span>last <span class="free">P_new</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> tl_P_new<span class="main">:</span>
    <span class="quoted"><span class="quoted">"tl <span class="free">P_new</span> <span class="main">≠</span> Nil"</span></span>
    <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl <span class="free">P_new</span><span class="main">)</span> <span class="main">∉</span> second_vertices"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> last_P_new<span class="main">:</span>
    <span class="quoted"><span class="quoted">"hitting_paths <span class="main">(</span>last <span class="free">P_new</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="free">P_new</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">¬</span>hitting_paths <span class="bound">v</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Characterizing the New Path›</span></span>

<span class="keyword1" id="DisjointPaths-P_new_hd_disjoint"><span class="command">lemma</span></span> P_new_hd_disjoint<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="free">paths</span> <span class="main">⟹</span> hd <span class="main">(</span>tl <span class="free">P_new</span><span class="main">)</span> <span class="main">≠</span> hd <span class="main">(</span>tl <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> tl_P_new<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> second_vertices_def second_vertex_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="DisjointPaths-P_new_new"><span class="command">lemma</span></span> P_new_new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P_new</span> <span class="main">∉</span> <span class="free">paths</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> P_new_hd_disjoint <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">paths_with_new</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">paths_with_new</span> <span class="main">≡</span> insert <span class="free">P_new</span> <span class="free">paths</span>"</span></span>

<span class="keyword1" id="DisjointPaths-card_paths_with_new"><span class="command">lemma</span></span> card_paths_with_new<span class="main">:</span> <span class="quoted"><span class="quoted">"card paths_with_new <span class="main">=</span> Suc <span class="main">(</span>card <span class="free">paths</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> paths_with_new_def <span class="keyword1"><span class="command">using</span></span> P_new_new <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_paths<span class="main">)</span>

<span class="keyword1" id="DisjointPaths-paths_with_new_no_Nil"><span class="command">lemma</span></span> paths_with_new_no_Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"Nil <span class="main">∉</span> paths_with_new"</span></span>
  <span class="keyword1"><span class="command">using</span></span> P_new paths_tl_notnil paths_with_new_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="DisjointPaths-paths_with_new_path"><span class="command">lemma</span></span> paths_with_new_path<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">∈</span> paths_with_new <span class="main">⟹</span> path <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> P_new paths paths_with_new_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="DisjointPaths-paths_with_new_start_in_v0"><span class="command">lemma</span></span> paths_with_new_start_in_v0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">∈</span> paths_with_new <span class="main">⟹</span> hd <span class="free">xs</span> <span class="main">=</span> <span class="free">v0</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> P_new paths paths_with_new_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The Last Vertex of the New Path›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  McCuaig in \cite{DBLP:journals/jgt/McCuaig84} calls the last vertex of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P_new</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> by the name
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  However, this name is somewhat confusing because it is so short and it will be visible
  in most places from now on, so let us give this vertex the more descriptive name of
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">new_last</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">new_pre</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">new_pre</span> <span class="main">≡</span> butlast <span class="free">P_new</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">new_last</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">new_last</span> <span class="main">≡</span> last <span class="free">P_new</span>"</span></span>

<span class="keyword1" id="DisjointPaths-P_new_decomp"><span class="command">lemma</span></span> P_new_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P_new</span> <span class="main">=</span> new_pre <span class="main">@</span> <span class="main">[</span>new_last<span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> new_pre_def append_butlast_last_id list.sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> tl_P_new<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> new_last_def<span class="main">)</span>

<span class="keyword1" id="DisjointPaths-new_pre_not_Nil"><span class="command">lemma</span></span> new_pre_not_Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"new_pre <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">using</span></span> P_new<span class="main">(</span>1<span class="main">)</span> hitting_paths_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> P_new_decomp list.sel<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> self_append_conv2 tl_P_new<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="DisjointPaths-new_pre_hitting"><span class="command">lemma</span></span> new_pre_hitting<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x'</span> <span class="main">∈</span> set new_pre <span class="main">⟹</span> <span class="main">¬</span>hitting_paths <span class="free">x'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> new_pre_def last_P_new<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="DisjointPaths-P_hit"><span class="command">lemma</span></span> P_hit<span class="main">:</span> <span class="quoted"><span class="quoted">"hitting_paths new_last"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> last_P_new<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> new_last_def<span class="main">)</span>

<span class="keyword1" id="DisjointPaths-new_last_neq_v0"><span class="command">lemma</span></span> new_last_neq_v0<span class="main">:</span> <span class="quoted"><span class="quoted">"new_last <span class="main">≠</span> <span class="free">v0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> hitting_paths_def P_hit <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1" id="DisjointPaths-new_last_in_V"><span class="command">lemma</span></span> new_last_in_V<span class="main">:</span> <span class="quoted"><span class="quoted">"new_last <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> P_new new_last_def path_in_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="DisjointPaths-new_last_to_v1"><span class="command">lemma</span></span> new_last_to_v1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">R</span><span class="main">.</span> new_last <span class="main">↝</span><span class="bound">R</span><span class="main">↝</span><span class="hidden">⇘</span><sub>remove_vertex <span class="free">v0</span></sub><span class="hidden">⇙</span> <span class="free">v1</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">=</span> <span class="free">v1</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">↝</span><span class="main">[</span><span class="free">v1</span><span class="main">]</span><span class="main">↝</span><span class="hidden">⇘</span><sub>remove_vertex <span class="free">v0</span></sub><span class="hidden">⇙</span> <span class="free">v1</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> last.simps list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.set<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.simps<span class="main"><span class="main">(</span></span>15<span class="main"><span class="main">)</span></span> list.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> path_from_to_def
        path_singleton remove_vertex_path_from_to singletonD v0_V v0_neq_v1 v1_V<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">≠</span> <span class="free">v1</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> <span class="free">paths</span>"</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">∈</span> set <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> hitting_paths_def last_P_new<span class="main">(</span>1<span class="main">)</span> new_last_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs_pre</span></span> <span class="skolem"><span class="skolem">xs_post</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">xs_pre</span> <span class="main">@</span> new_last <span class="main">#</span> <span class="skolem">xs_post</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> split_list<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">↝</span><span class="main">(</span>new_last <span class="main">#</span> <span class="skolem">xs_post</span><span class="main">)</span><span class="main">↝</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">xs</span> <span class="main">∈</span> <span class="free">paths</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> paths last_appendR list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> path_decomp<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> path_from_to_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">↝</span><span class="main">(</span>new_last <span class="main">#</span> <span class="skolem">xs_post</span><span class="main">)</span><span class="main">↝</span><span class="hidden">⇘</span><sub>remove_vertex <span class="free">v0</span></sub><span class="hidden">⇙</span> <span class="free">v1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> remove_vertex_path_from_to
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> paths Set.set_insert xs_decomp xs<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> disjoint_insert<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> distinct_append hd_append
        hitting_paths_def last_P_new<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.set_sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> path_from_to_def v0_V new_last_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="DisjointPaths-paths_plus_one_disjoint"><span class="command">lemma</span></span> paths_plus_one_disjoint<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">∈</span> paths_with_new"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">∈</span> paths_with_new"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> set <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> set <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">v0</span> <span class="main">∨</span> <span class="free">v</span> <span class="main">=</span> <span class="free">v1</span> <span class="main">∨</span> <span class="free">v</span> <span class="main">=</span> new_last"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">∈</span> <span class="free">paths</span> <span class="main">∨</span> <span class="free">ys</span> <span class="main">∈</span> <span class="free">paths</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">,</span>3<span class="main">)</span> paths_with_new_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hitting_paths <span class="free">v</span> <span class="main">∨</span> <span class="free">v</span> <span class="main">=</span> <span class="free">v0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">,</span>4<span class="main">,</span>5<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> hitting_paths_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms last_P_new<span class="main">(</span>2<span class="main">)</span> set_butlast paths_disjoint
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insert_iff paths_with_new_def new_last_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹If the new path is disjoint, we are happy.›</span></span>

<span class="keyword1" id="DisjointPaths-P_new_solves_if_disjoint"><span class="command">lemma</span></span> P_new_solves_if_disjoint<span class="main">:</span>
  <span class="quoted"><span class="quoted">"new_last <span class="main">=</span> <span class="free">v1</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">paths'</span><span class="main">.</span> DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths'</span> <span class="main">∧</span> card <span class="bound">paths'</span> <span class="main">=</span> Suc <span class="main">(</span>card <span class="free">paths</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> DisjointPaths_extend P_new<span class="main">(</span>1<span class="main">)</span> paths_plus_one_disjoint card_paths_with_new
  <span class="keyword1"><span class="command">unfolding</span></span> paths_with_new_def new_last_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Removing the Last Vertex›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">H_x</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">H_x</span> <span class="main">≡</span> remove_vertex new_last"</span></span>

<span class="keyword1" id="DisjointPaths-H_x_Digraph"><span class="command">lemma</span></span> H_x_Digraph<span class="main">:</span> <span class="quoted"><span class="quoted">"Digraph H_x"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> H_x_def <span class="keyword1"><span class="command">using</span></span> remove_vertex_Digraph <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="DisjointPaths-H_x_v0_v1_Digraph"><span class="command">lemma</span></span> H_x_v0_v1_Digraph<span class="main">:</span> <span class="quoted"><span class="quoted">"new_last <span class="main">≠</span> <span class="free">v1</span> <span class="main">⟹</span> v0_v1_Digraph H_x <span class="free">v0</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> H_x_def
  <span class="keyword1"><span class="command">using</span></span> remove_vertices_v0_v1_Digraph hitting_paths_def P_hit <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> H_x_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹A New Path Following the Other Paths›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The following lemma is one of the most complicated technical lemmas in the proof of Menger's
  Theorem.

  Suppose we have a non-trivial path whose edges are all in the edge set of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">path_with_new</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  and whose first edge equals the first edge of some <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">P</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">path_with_new</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  Also suppose that
  the path does not contain <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">new_last</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  Then it follows by induction that this
  path is an initial segment of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

  Note that McCuaig does not mention this statement at all in his proof because it looks so obvious.
›</span></span>

<span class="keyword1" id="DisjointPaths-new_path_follows_old_paths"><span class="command">lemma</span></span> new_path_follows_old_paths<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span>"</span></span> <span class="quoted"><span class="quoted">"tl <span class="free">xs</span> <span class="main">≠</span> Nil"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">∉</span> set <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">∉</span> set <span class="free">xs</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">∈</span> paths_with_new"</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> hd <span class="main">(</span>tl <span class="free">P</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> edges_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="free">xs</span> <span class="main">⊆</span> <span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> paths_with_new<span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="free">xs</span> <span class="main">⊆</span> edges_of_walk <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> xs P<span class="main">(</span>2<span class="main">)</span> edges_subset <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">w</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> xs<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span> <span class="skolem">xs</span> <span class="skolem">w</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Suc.hyps<span class="main">(</span>2<span class="main">)</span> Suc.prems<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE Nitpick.size_list_simp<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Suc_inject length_0_conv<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> Suc <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> v_w<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> Suc.hyps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> length_0_conv length_Suc_conv<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="free">v0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Suc.prems<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">=</span> hd <span class="main">(</span>tl <span class="free">P</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Suc.prems<span class="main">(</span>5<span class="main">)</span> v_w <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="skolem">xs</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">w</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v_w edges_of_walk_2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v0</span><span class="main">,</span> hd <span class="main">(</span>tl <span class="free">P</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> P tl_P_new<span class="main">(</span>1<span class="main">)</span> P_new paths
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> first_edge_hd_tl first_edge_in_edges insert_iff paths_tl_notnil paths_with_new_def<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≠</span> Suc <span class="main">0</span>"</span></span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">xs'</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE Suc.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> append_butlast_last_id<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> length <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs' <span class="keyword1"><span class="command">using</span></span> Suc.hyps<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> xs'_path<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="skolem">xs'</span><span class="main">↝</span> last <span class="skolem">xs'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> xs' Suc.prems<span class="main">(</span>1<span class="main">)</span> <span class="quoted"><span class="quoted">‹tl <span class="skolem">xs</span> <span class="main">≠</span> Nil›</span></span> walk_decomp<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> distinct_append hd_append list.sel<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> path_from_to_def self_append_conv2<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tl <span class="skolem">xs'</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">≠</span> Suc <span class="main">0</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE Nitpick.size_list_simp<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> calculation<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">∉</span> set <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs' Suc.prems<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">∉</span> set <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs' Suc.prems<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl <span class="skolem">xs'</span><span class="main">)</span> <span class="main">=</span> hd <span class="main">(</span>tl <span class="free">P</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> xs' <span class="quoted"><span class="quoted">‹tl <span class="skolem">xs'</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> Suc.prems<span class="main">(</span>5<span class="main">)</span> calculation<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="skolem">xs'</span> <span class="main">⊆</span> <span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> paths_with_new<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> xs' Suc.prems<span class="main">(</span>6<span class="main">)</span> edges_of_comp1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> xs'_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="skolem">xs'</span> <span class="main">⊆</span> edges_of_walk <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Suc.hyps<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="skolem">xs</span> <span class="main">=</span> edges_of_walk <span class="skolem">xs'</span> <span class="main">∪</span> <span class="main">{</span> <span class="main">(</span>last <span class="skolem">xs'</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> xs' <span class="keyword1"><span class="command">using</span></span> walk_edges_decomp'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"butlast <span class="skolem">xs'</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs'</span>"</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted">Nil</span><span class="main">]</span> xs'_path
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE Un_empty_right append_assoc append_butlast_last_id butlast.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span>
          edges_of_walk_empty<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> last_ConsL last_ConsR list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>last <span class="skolem">xs'</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> contra<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>last <span class="skolem">xs'</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∉</span> edges_of_walk <span class="free">P</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> xs_last_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>last <span class="skolem">xs'</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="skolem">xs</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> xs' calculation<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">P'</span></span> <span class="keyword2"><span class="keyword">where</span></span>
        P'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">P'</span> <span class="main">∈</span> paths_with_new"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>last <span class="skolem">xs'</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="skolem">P'</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> Suc.prems<span class="main">(</span>6<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">≠</span> <span class="skolem">P'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> contra <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs'</span> <span class="main">∈</span> set <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs_last_edge xs'_edges <span class="quoted"><span class="quoted">‹tl <span class="skolem">xs'</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> xs'_path
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE last_in_set subsetCE walk_edges_subset<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs'</span> <span class="main">∈</span> set <span class="skolem">P'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> P'<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> walk_edges_vertices<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs'</span> <span class="main">=</span> <span class="free">v0</span> <span class="main">∨</span> last <span class="skolem">xs'</span> <span class="main">=</span> <span class="free">v1</span> <span class="main">∨</span> last <span class="skolem">xs'</span> <span class="main">=</span> new_last"</span></span>
        <span class="keyword1"><span class="command">using</span></span> paths_plus_one_disjoint P'<span class="main">(</span>1<span class="main">)</span> P paths_with_new_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> Suc.prems<span class="main">(</span>3<span class="main">)</span> <span class="quoted"><span class="quoted">‹new_last <span class="main">∉</span> set <span class="skolem">xs'</span>›</span></span> <span class="quoted"><span class="quoted">‹tl <span class="skolem">xs'</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> xs' xs'_path
         <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE butlast_snoc in_set_butlastD last_in_set last_tl path_from_to_first<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">locale</span> DisjointPathsPlusOne<span class="antiquote">}</span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="MengerInduction">
<div class="head">
<h1>Theory MengerInduction</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Induction of Menger's Theorem›</span></span>

<span class="keyword1"><span class="command">theory</span></span> MengerInduction <span class="keyword2"><span class="keyword">imports</span></span> <a href="Separations.html">Separations</a> <a href="DisjointPaths.html">DisjointPaths</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹No Small Separations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this section we set up the general structure of the proof of Menger's Theorem.
  The proof is based on induction over <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">sep_size</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (called <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">n</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in McCuaig's proof), the
  minimum size of a separator.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> NoSmallSeparationsInduct <span class="main">=</span> v0_v1_Digraph <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">sep_size</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="comment1">― ‹The size of a minimum separator.›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_small_separations<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">S</span><span class="main">.</span> Separation <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">S</span> <span class="main">⟹</span> card <span class="bound">S</span> <span class="main">≥</span> Suc <span class="free">sep_size</span>"</span></span>
  <span class="comment1">― ‹The induction hypothesis.›</span>
  <span class="keyword2"><span class="keyword">and</span></span> no_small_separations_hyp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">G'</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Graph_scheme<span class="main">.</span>
    <span class="main">(</span><span class="main">⋀</span><span class="bound">S</span><span class="main">.</span> Separation <span class="bound">G'</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">S</span> <span class="main">⟹</span> card <span class="bound">S</span> <span class="main">≥</span> <span class="free">sep_size</span><span class="main">)</span>
    <span class="main">⟹</span> v0_v1_Digraph <span class="bound">G'</span> <span class="free">v0</span> <span class="free">v1</span>
    <span class="main">⟹</span> <span class="main">∃</span><span class="bound">paths</span><span class="main">.</span> DisjointPaths <span class="bound">G'</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths</span> <span class="main">∧</span> card <span class="bound">paths</span> <span class="main">=</span> <span class="free">sep_size</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Next, we want to combine this with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> DisjointPathsPlusOne<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

  If a minimum separator has size at least <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Suc <span class="free"><span class="free">sep_size</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, then it follows immediately from
  the induction hypothesis that we have <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">sep_size</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> many disjoint paths.  We then observe
  that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">second_vertices</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of these paths is not a separator because
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"card <span class="free"><span class="free">second_vertices</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">sep_size</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  So there exists a new path from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v0</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> whose second vertex is not in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">second_vertices</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

  If this path is disjoint from the other paths, we have found <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Suc <span class="free"><span class="free">sep_size</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> many disjoint
  paths, so assume it is not disjoint.  Then there exist a vertex <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> on the new path that is
  not <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v0</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> such that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">new_last</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> hits one of the other paths.  Let
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P_new</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> be the initial segment of the new path up to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  We call <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  the last vertex of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P_new</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, now <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">new_last</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

  We then assume that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">paths</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P_new</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> have been chosen in such a way that
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">distance</span></span> <span class="free"><span class="free">new_last</span></span> <span class="free"><span class="free">v1</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is minimal.

  First, we define a locale that expresses that we have no small separators (with the corresponding
  induction hypothesis) as well as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">sep_size</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> many internally vertex-disjoint paths (with
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">sep_size</span></span> <span class="main"><span class="main">≠</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">0</span></span> <span class="main"><span class="main">::</span></span> nat<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> because the other case is trivial) and also one additional path
  that starts in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, whose second vertex is not among <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">second_vertices</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and whose last
  vertex is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">new_last</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

  We will add the assumption <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">new_last</span></span> <span class="main"><span class="main">≠</span></span> <span class="free"><span class="free">v1</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> soon.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ProofStepInduct <span class="main">=</span>
  NoSmallSeparationsInduct <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="free">sep_size</span></span> <span class="main">+</span> DisjointPathsPlusOne <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="free">paths</span></span> <span class="quoted"><span class="free">P_new</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">v0</span> <span class="free">v1</span> <span class="free">paths</span> <span class="free">P_new</span> <span class="free">sep_size</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sep_size_not0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sep_size</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> paths_sep_size<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="free">paths</span> <span class="main">=</span> <span class="free">sep_size</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ProofStepInduct<span class="main">)</span> hitting_paths_v1<span class="main">:</span> <span class="quoted"><span class="quoted">"hitting_paths <span class="free">v1</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hitting_paths_def <span class="keyword1"><span class="command">using</span></span> paths v0_neq_v1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Choosing Paths Avoiding $new\_last$›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Let us now consider only the non-trivial case that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">new_last</span></span> <span class="main"><span class="main">≠</span></span> <span class="free"><span class="free">v1</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ProofStepInduct_NonTrivial <span class="main">=</span> ProofStepInduct <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> new_last_neq_v1<span class="main">:</span> <span class="quoted"><span class="quoted">"new_last <span class="main">≠</span> <span class="free">v1</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The next step is the observation that in the graph <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"remove_vertex new_last"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which 
  we called <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">H_x</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, there are also <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">sep_size</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> many internally vertex-disjoint paths,
  again by the induction hypothesis.
›</span></span>
<span class="keyword1" id="MengerInduction-Q_exists"><span class="command">lemma</span></span> Q_exists<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">Q</span><span class="main">.</span> DisjointPaths H_x <span class="free">v0</span> <span class="free">v1</span> <span class="bound">Q</span> <span class="main">∧</span> card <span class="bound">Q</span> <span class="main">=</span> <span class="free">sep_size</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">S</span><span class="main">.</span> Separation H_x <span class="free">v0</span> <span class="free">v1</span> <span class="bound">S</span> <span class="main">⟹</span> card <span class="bound">S</span> <span class="main">≥</span> <span class="free">sep_size</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> subgraph_separation_min_size paths walk_in_V P_hit new_last_neq_v1 no_small_separations
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> H_x_def new_last_in_V new_last_neq_v0<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> H_x_v0_v1_Digraph new_last_neq_v1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> no_small_separations_hyp<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We want to choose these paths in a clever way, too.  Our goal is to choose these paths such that
  the number of edges in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="main"><span class="main">⋃</span></span><span class="main"><span class="main">(</span></span>edges_of_walk <span class="main"><span class="main">`</span></span> <span class="free"><span class="free">Q</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">∩</span></span> <span class="main"><span class="main">(</span></span><span class="keyword1"><span class="keyword1">E</span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">⋃</span></span><span class="main"><span class="main">(</span></span>edges_of_walk <span class="main"><span class="main">`</span></span> paths_with_new<span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  is minimal.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">B</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">≡</span> <span class="keyword1">E</span> <span class="main">-</span> <span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> paths_with_new<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Q_weight</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_weight</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">Q</span><span class="main">.</span> card <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> <span class="bound">Q</span><span class="main">)</span> <span class="main">∩</span> B<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Q_good</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_good</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">Q</span><span class="main">.</span> DisjointPaths H_x <span class="free">v0</span> <span class="free">v1</span> <span class="bound">Q</span> <span class="main">∧</span> card <span class="bound">Q</span> <span class="main">=</span> <span class="free">sep_size</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∀</span><span class="bound">Q'</span><span class="main">.</span> DisjointPaths H_x <span class="free">v0</span> <span class="free">v1</span> <span class="bound">Q'</span> <span class="main">∧</span> card <span class="bound">Q'</span> <span class="main">=</span> <span class="free">sep_size</span> <span class="main">⟶</span> Q_weight <span class="bound">Q</span> <span class="main">≤</span> Q_weight <span class="bound">Q'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Q</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">≡</span> <span class="keyword1">SOME</span> <span class="bound">Q</span><span class="main">.</span> Q_good <span class="bound">Q</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It is easy to show that such a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Q<span class="antiquote"><span class="antiquote">}</span></span></span></span> exists.›</span></span>

<span class="keyword1" id="MengerInduction-Q"><span class="command">lemma</span></span> Q<span class="main">:</span> <span class="quoted"><span class="quoted">"DisjointPaths H_x <span class="free">v0</span> <span class="free">v1</span> Q"</span></span> <span class="quoted"><span class="quoted">"card Q <span class="main">=</span> <span class="free">sep_size</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Q_min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Q'</span><span class="main">.</span> DisjointPaths H_x <span class="free">v0</span> <span class="free">v1</span> <span class="bound">Q'</span> <span class="main">∧</span> card <span class="bound">Q'</span> <span class="main">=</span> <span class="free">sep_size</span> <span class="main">⟹</span> Q_weight Q <span class="main">≤</span> Q_weight <span class="bound">Q'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Q'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"DisjointPaths H_x <span class="free">v0</span> <span class="free">v1</span> <span class="skolem">Q'</span>"</span></span> <span class="quoted"><span class="quoted">"card <span class="skolem">Q'</span> <span class="main">=</span> <span class="free">sep_size</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Q''</span><span class="main">.</span> DisjointPaths H_x <span class="free">v0</span> <span class="free">v1</span> <span class="bound">Q''</span> <span class="main">∧</span> card <span class="bound">Q''</span> <span class="main">=</span> <span class="free">sep_size</span> <span class="main">⟹</span> Q_weight <span class="skolem">Q'</span> <span class="main">≤</span> Q_weight <span class="bound">Q''</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> arg_min_ex<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">Q</span><span class="main">.</span> DisjointPaths H_x <span class="free">v0</span> <span class="free">v1</span> <span class="bound">Q</span> <span class="main">∧</span> card <span class="bound">Q</span> <span class="main">=</span> <span class="free">sep_size</span>"</span></span> <span class="quoted">Q_weight</span><span class="main">]</span>
      new_last_neq_v1 Q_exists <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Q_good <span class="skolem">Q'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q_good_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"DisjointPaths H_x <span class="free">v0</span> <span class="free">v1</span> Q"</span></span> <span class="quoted"><span class="quoted">"card Q <span class="main">=</span> <span class="free">sep_size</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Q'</span><span class="main">.</span> DisjointPaths H_x <span class="free">v0</span> <span class="free">v1</span> <span class="bound">Q'</span> <span class="main">∧</span> card <span class="bound">Q'</span> <span class="main">=</span> <span class="free">sep_size</span> <span class="main">⟹</span> Q_weight Q <span class="main">≤</span> Q_weight <span class="bound">Q'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> someI<span class="main">[</span><span class="operator">of</span> <span class="quoted">Q_good</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Q_def Q_good_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> Q<span class="main">:</span> DisjointPaths <span class="quoted">H_x</span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted">Q</span> <span class="keyword1"><span class="command">using</span></span> Q<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Finding a Path Avoiding $Q$›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Because <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Q<span class="antiquote"><span class="antiquote">}</span></span></span></span> contains only <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">sep_size</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> many paths, we have
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"card Q.second_vertices <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">sep_size</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  So there exists a path <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P_k</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> among the
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Suc <span class="free"><span class="free">sep_size</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> many paths in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">paths_with_new</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> such that the second vertex of
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P_k</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is not among <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Q.second_vertices</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">P_k</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P_k</span> <span class="main">≡</span> <span class="keyword1">SOME</span> <span class="bound">P_k</span><span class="main">.</span> <span class="bound">P_k</span> <span class="main">∈</span> paths_with_new <span class="main">∧</span> hd <span class="main">(</span>tl <span class="bound">P_k</span><span class="main">)</span> <span class="main">∉</span> Q.second_vertices"</span></span>

<span class="keyword1" id="MengerInduction-P_k"><span class="command">lemma</span></span> P_k<span class="main">:</span> <span class="quoted"><span class="quoted">"P_k <span class="main">∈</span> paths_with_new"</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl P_k<span class="main">)</span> <span class="main">∉</span> Q.second_vertices"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> insert <span class="main">(</span>hd <span class="main">(</span>tl <span class="free">P_new</span><span class="main">)</span><span class="main">)</span> second_vertices"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> Q.second_vertices"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl <span class="free">P_new</span><span class="main">)</span> <span class="main">∉</span> second_vertices"</span></span> <span class="keyword1"><span class="command">using</span></span> P_new_decomp tl_P_new<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card second_vertices <span class="main">=</span> card Q.second_vertices"</span></span> <span class="keyword1"><span class="command">using</span></span> Q<span class="main">(</span>2<span class="main">)</span> paths_sep_size
      <span class="keyword1"><span class="command">using</span></span> Q.second_vertices_card second_vertices_card <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> new_last_neq_v1<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>insert <span class="main">(</span>hd <span class="main">(</span>tl <span class="free">P_new</span><span class="main">)</span><span class="main">)</span> second_vertices<span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>card Q.second_vertices<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> finite_paths second_vertices_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> that card_finite_less_ex
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Q.finite_paths Q.second_vertices_def Zero_not_Suc card.infinite finite_imageI lessI<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">P_k</span><span class="main">.</span> <span class="bound">P_k</span> <span class="main">∈</span> paths_with_new <span class="main">∧</span> hd <span class="main">(</span>tl <span class="bound">P_k</span><span class="main">)</span> <span class="main">∉</span> Q.second_vertices"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> image_iff insertCI insertE paths_with_new_def second_vertex_def
        second_vertices_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"P_k <span class="main">∈</span> paths_with_new"</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl P_k<span class="main">)</span> <span class="main">∉</span> Q.second_vertices"</span></span>
    <span class="keyword1"><span class="command">using</span></span> someI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">P_k</span><span class="main">.</span> <span class="bound">P_k</span> <span class="main">∈</span> paths_with_new <span class="main">∧</span> hd <span class="main">(</span>tl <span class="bound">P_k</span><span class="main">)</span> <span class="main">∉</span> Q.second_vertices"</span></span><span class="main">]</span> P_k_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MengerInduction-path_P_k"><span class="command">lemma</span></span> path_P_k <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"path P_k"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> P_k<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> paths_with_new_path<span class="main">)</span>
<span class="keyword1" id="MengerInduction-hd_P_k_v0"><span class="command">lemma</span></span> hd_P_k_v0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hd P_k <span class="main">=</span> <span class="free">v0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> P_k<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> paths_with_new_start_in_v0<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hitting_Q_or_new_last</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hitting_Q_or_new_last</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≠</span> <span class="free">v0</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">y</span> <span class="main">=</span> new_last <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">Q_hit</span> <span class="main">∈</span> Q<span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> set <span class="bound">Q_hit</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">P_k</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> hits a vertex in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Q</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> or it hits <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">new_last</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> because it either ends in
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> or in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">new_last</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1" id="MengerInduction-P_k_hits_Q"><span class="command">lemma</span></span> P_k_hits_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> set P_k<span class="main">.</span> hitting_Q_or_new_last <span class="bound">y</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"P_k <span class="main">≠</span> <span class="free">P_new</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">∈</span> set P_k"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> P_k<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> insertE last_in_set path_from_toE paths paths_with_new_def<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">Q_witness</span><span class="main">.</span> <span class="bound">Q_witness</span> <span class="main">∈</span> Q"</span></span> <span class="keyword1"><span class="command">using</span></span> Q<span class="main">(</span>2<span class="main">)</span> sep_size_not0 finite.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> Q.paths path_from_toE hitting_Q_or_new_last_def v0_neq_v1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">metis</span> P_new new_last_neq_v0 hitting_Q_or_new_last_def last_in_set path_from_toE new_last_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">locale</span> ProofStepInduct_NonTrivial<span class="antiquote">}</span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Decomposing $P_k$›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Having established with the previous lemma that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P_k</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> hits <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Q</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">new_last</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  let <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">y</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> be the first such vertex on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P_k</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  Then we can split <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P_k</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> at
  this vertex.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ProofStepInduct_NonTrivial_P_k_pre <span class="main">=</span> ProofStepInduct_NonTrivial <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P_k_pre</span> <span class="free">y</span> <span class="free">P_k_post</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> P_k_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"P_k <span class="main">=</span> <span class="free">P_k_pre</span> <span class="main">@</span> <span class="free">y</span> <span class="main">#</span> <span class="free">P_k_post</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"hitting_Q_or_new_last <span class="free">y</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> y_min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y'</span><span class="main">.</span> <span class="bound">y'</span> <span class="main">∈</span> set <span class="free">P_k_pre</span> <span class="main">⟹</span> <span class="main">¬</span>hitting_Q_or_new_last <span class="bound">y'</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We can always go from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> ProofStepInduct_NonTrivial<span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> ProofStepInduct_NonTrivial_P_k_pre<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ProofStepInduct_NonTrivial<span class="main">)</span> ProofStepInduct_NonTrivial_P_k_pre_exists<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">P_k_pre</span> <span class="bound">y</span> <span class="bound">P_k_post</span><span class="main">.</span>
     ProofStepInduct_NonTrivial_P_k_pre <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="free">paths</span> <span class="free">P_new</span> <span class="free">sep_size</span> <span class="bound">P_k_pre</span> <span class="bound">y</span> <span class="bound">P_k_post</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="skolem"><span class="skolem">P_k_pre</span></span> <span class="skolem"><span class="skolem">P_k_post</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"P_k <span class="main">=</span> <span class="skolem">P_k_pre</span> <span class="main">@</span> <span class="skolem">y</span> <span class="main">#</span> <span class="skolem">P_k_post</span>"</span></span> <span class="quoted"><span class="quoted">"hitting_Q_or_new_last <span class="skolem">y</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y'</span><span class="main">.</span> <span class="bound">y'</span> <span class="main">∈</span> set <span class="skolem">P_k_pre</span> <span class="main">⟹</span> <span class="main">¬</span>hitting_Q_or_new_last <span class="bound">y'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> P_k_hits_Q split_list_first_prop<span class="main">[</span><span class="operator">of</span> <span class="quoted">P_k</span> <span class="quoted">hitting_Q_or_new_last</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ProofStepInduct_NonTrivial_P_k_pre <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="free">paths</span> <span class="free">P_new</span> <span class="free">sep_size</span> <span class="skolem">P_k_pre</span> <span class="skolem">y</span> <span class="skolem">P_k_post</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> ProofStepInduct_NonTrivial_P_k_pre <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1" id="MengerInduction-y_neq_v0"><span class="command">lemma</span></span> y_neq_v0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">≠</span> <span class="free">v0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> hitting_Q_or_new_last_def y <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="MengerInduction-P_k_pre_not_Nil"><span class="command">lemma</span></span> P_k_pre_not_Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P_k_pre</span> <span class="main">≠</span> Nil"</span></span>
    <span class="keyword1"><span class="command">using</span></span> P_k_decomp hd_P_k_v0 hitting_Q_or_new_last_def y <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="MengerInduction-second_P_k_pre_not_in_Q"><span class="command">lemma</span></span> second_P_k_pre_not_in_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl <span class="main">(</span><span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">∉</span> Q.second_vertices"</span></span>
    <span class="keyword1"><span class="command">using</span></span> P_k<span class="main">(</span>2<span class="main">)</span> P_k_decomp P_k_pre_not_Nil
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_eq_append_conv2 append_self_conv hd_append2 list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> tl_append2<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">H</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">H</span> <span class="main">≡</span> remove_vertex <span class="free">v0</span>"</span></span>
  <span class="keyword1"><span class="command">sublocale</span></span> H<span class="main">:</span> Digraph <span class="quoted">H</span> <span class="keyword1"><span class="command">unfolding</span></span> H_def <span class="keyword1"><span class="command">using</span></span> remove_vertex_Digraph <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1" id="MengerInduction-y_eq_v1_implies_P_k_neq_P_new"><span class="command">lemma</span></span> y_eq_v1_implies_P_k_neq_P_new<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> <span class="free">v1</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"P_k <span class="main">≠</span> <span class="free">P_new</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> contra<span class="main">:</span> <span class="quoted"><span class="quoted">"P_k <span class="main">=</span> <span class="free">P_new</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="main">(</span>new_pre <span class="main">@</span> <span class="main">[</span>new_last<span class="main">]</span><span class="main">)</span><span class="main">↝</span> new_last"</span></span>
      <span class="keyword1"><span class="command">using</span></span> P_new<span class="main">(</span>1<span class="main">)</span> P_new_decomp new_last_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span>P_k<span class="main">↝</span> new_last"</span></span> <span class="keyword1"><span class="command">using</span></span> P_new_decomp contra <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"P_k <span class="main">=</span> <span class="free">P_k_pre</span> <span class="main">@</span> <span class="free">v1</span> <span class="main">#</span> <span class="free">P_k_post</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> P_k_decomp assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="main">(</span><span class="free">P_k_pre</span> <span class="main">@</span> <span class="free">v1</span> <span class="main">#</span> <span class="free">P_k_post</span><span class="main">)</span><span class="main">↝</span> new_last"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">∈</span> set <span class="free">P_new</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms contra P_k_decomp in_set_conv_decomp<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">=</span> <span class="free">v1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> hitting_paths_v1 assms last_P_new<span class="main">(</span>2<span class="main">)</span> set_butlast new_last_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> new_last_neq_v1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">v1</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, then we are done.›</span></span>
  <span class="keyword1" id="MengerInduction-y_eq_v1_solves"><span class="command">lemma</span></span> y_eq_v1_solves<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> <span class="free">v1</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">paths</span><span class="main">.</span> DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths</span> <span class="main">∧</span> card <span class="bound">paths</span> <span class="main">=</span> Suc <span class="free">sep_size</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"P_k <span class="main">≠</span> <span class="free">P_new</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> y_eq_v1_implies_P_k_neq_P_new assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"P_k <span class="main">=</span> <span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> P_k<span class="main">(</span>1<span class="main">)</span> P_k_decomp paths assms paths_with_new_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="main">(</span><span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span><span class="main">↝</span> <span class="free">v1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> paths P_k<span class="main">(</span>1<span class="main">)</span> <span class="quoted"><span class="quoted">‹P_k <span class="main">≠</span> <span class="free">P_new</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> paths_with_new_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">∉</span> set <span class="free">P_k_pre</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> hitting_Q_or_new_last_def y_min new_last_neq_v0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="main">(</span><span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span><span class="main">↝</span><span class="hidden">⇘</span><sub>H_x</sub><span class="hidden">⇙</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> remove_vertex_path_from_to
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> H_x_def assms new_last_in_V new_last_neq_v1<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">v</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> Q"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="free">v0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="free">P_k_pre</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>hitting_Q_or_new_last <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> y_min <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">xs</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">xs</span> <span class="main">∈</span> Q›</span></span> hitting_Q_or_new_last_def <span class="quoted"><span class="quoted">‹<span class="skolem">v</span> <span class="main">≠</span> <span class="free">v0</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"DisjointPaths H_x <span class="free">v0</span> <span class="free">v1</span> <span class="main">(</span>insert <span class="main">(</span><span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> Q<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> Q.DisjointPaths_extend <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="main">(</span>insert <span class="main">(</span><span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> Q<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> DisjointPaths_supergraph H_x_def new_last_in_V new_last_neq_v0 new_last_neq_v1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>insert <span class="main">(</span><span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> Q<span class="main">)</span> <span class="main">=</span> Suc <span class="free">sep_size</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span> <span class="main">∉</span> Q"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> P_k<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Q.second_vertices_def <span class="quoted"><span class="quoted">‹P_k <span class="main">=</span> <span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span>›</span></span> image_iff second_vertex_def<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Q<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Q.finite_paths<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">locale</span> ProofStepInduct_NonTrivial_P_k_pre<span class="antiquote">}</span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Y_eq_new_last">
<div class="head">
<h1>Theory Y_eq_new_last</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹The case $y = new\_last$›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Y_eq_new_last <span class="keyword2"><span class="keyword">imports</span></span> <a href="MengerInduction.html">MengerInduction</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We may assume <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y</span></span> <span class="main"><span class="main">≠</span></span> <span class="free"><span class="free">v1</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> now because <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> ProofStepInduct_NonTrivial_P_k_pre.y_eq_v1_solves<span class="antiquote"><span class="antiquote">}</span></span></span></span>
  shows that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">v1</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> already gives us <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Suc <span class="free"><span class="free">sep_size</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> many disjoint paths.

  We also assume that we have chosen the previous paths optimally in the sense that the distance
  from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">new_last</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is minimal.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ProofStepInduct_y_eq_new_last <span class="main">=</span> ProofStepInduct_NonTrivial_P_k_pre <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> y_neq_v1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y_eq_new_last<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> new_last"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> optimal_paths<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">paths'</span> <span class="bound">P_new'</span><span class="main">.</span>
            ProofStepInduct <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths'</span> <span class="bound">P_new'</span> <span class="free">sep_size</span>
            <span class="main">⟹</span> H.distance <span class="main">(</span>last <span class="free">P_new</span><span class="main">)</span> <span class="free">v1</span> <span class="main">≤</span> H.distance <span class="main">(</span>last <span class="bound">P_new'</span><span class="main">)</span> <span class="free">v1</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Let <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">R</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> be a shortest path from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">new_last</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">R</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">≡</span>
  <span class="keyword1">SOME</span> <span class="bound">R</span><span class="main">.</span> new_last <span class="main">↝</span><span class="bound">R</span><span class="main">↝</span><span class="hidden">⇘</span><sub>H</sub><span class="hidden">⇙</span> <span class="free">v1</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">R'</span><span class="main">.</span> new_last <span class="main">↝</span><span class="bound">R'</span><span class="main">↝</span><span class="hidden">⇘</span><sub>H</sub><span class="hidden">⇙</span> <span class="free">v1</span> <span class="main">⟶</span> length <span class="bound">R</span> <span class="main">≤</span> length <span class="bound">R'</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Y_eq_new_last-R"><span class="command">lemma</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"new_last <span class="main">↝</span>R<span class="main">↝</span><span class="hidden">⇘</span><sub>H</sub><span class="hidden">⇙</span> <span class="free">v1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">R'</span><span class="main">.</span> new_last <span class="main">↝</span><span class="bound">R'</span><span class="main">↝</span><span class="hidden">⇘</span><sub>H</sub><span class="hidden">⇙</span> <span class="free">v1</span> <span class="main">⟹</span> length R <span class="main">≤</span> length <span class="bound">R'</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">R'</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    R'<span class="main">:</span> <span class="quoted"><span class="quoted">"new_last <span class="main">↝</span><span class="skolem">R'</span><span class="main">↝</span><span class="hidden">⇘</span><sub>H</sub><span class="hidden">⇙</span> <span class="free">v1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">R''</span><span class="main">.</span> new_last <span class="main">↝</span><span class="bound">R''</span><span class="main">↝</span><span class="hidden">⇘</span><sub>H</sub><span class="hidden">⇙</span> <span class="free">v1</span> <span class="main">⟹</span> length <span class="skolem">R'</span> <span class="main">≤</span> length <span class="bound">R''</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> arg_min_ex<span class="main">[</span><span class="operator">OF</span> new_last_to_v1<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> H_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">↝</span>R<span class="main">↝</span><span class="hidden">⇘</span><sub>H</sub><span class="hidden">⇙</span> <span class="free">v1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">R'</span><span class="main">.</span> new_last <span class="main">↝</span><span class="bound">R'</span><span class="main">↝</span><span class="hidden">⇘</span><sub>H</sub><span class="hidden">⇙</span> <span class="free">v1</span> <span class="main">⟹</span> length R <span class="main">≤</span> length <span class="bound">R'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> someI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">R</span><span class="main">.</span> new_last <span class="main">↝</span><span class="bound">R</span><span class="main">↝</span><span class="hidden">⇘</span><sub>H</sub><span class="hidden">⇙</span> <span class="free">v1</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">R'</span><span class="main">.</span> new_last <span class="main">↝</span><span class="bound">R'</span><span class="main">↝</span><span class="hidden">⇘</span><sub>H</sub><span class="hidden">⇙</span> <span class="free">v1</span> <span class="main">⟶</span> length <span class="bound">R</span> <span class="main">≤</span> length <span class="bound">R'</span><span class="main">)</span>"</span></span><span class="main">]</span>
      R_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Y_eq_new_last-v1_in_Q"><span class="command">lemma</span></span> v1_in_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">Q_hit</span> <span class="main">∈</span> Q<span class="main">.</span> <span class="free">v1</span> <span class="main">∈</span> set <span class="bound">Q_hit</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> Q"</span></span> <span class="keyword1"><span class="command">using</span></span> Q<span class="main">(</span>2<span class="main">)</span> sep_size_not0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Q.paths last_in_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Y_eq_new_last-R_hits_Q"><span class="command">lemma</span></span> R_hits_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> set R<span class="main">.</span> Q.hitting_paths <span class="bound">z</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">∈</span> set R"</span></span> <span class="keyword1"><span class="command">using</span></span> R<span class="main">(</span>1<span class="main">)</span> last_in_set <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_to_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q.hitting_paths_def <span class="keyword1"><span class="command">using</span></span> v0_neq_v1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Y_eq_new_last-R_decomp_exists"><span class="command">lemma</span></span> R_decomp_exists<span class="main">:</span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">R_pre</span> <span class="free">z</span> <span class="free">R_post</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"R <span class="main">=</span> <span class="free">R_pre</span> <span class="main">@</span> <span class="free">z</span> <span class="main">#</span> <span class="free">R_post</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Q.hitting_paths <span class="free">z</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">z'</span><span class="main">.</span> <span class="bound">z'</span> <span class="main">∈</span> set <span class="free">R_pre</span> <span class="main">⟹</span> <span class="main">¬</span>Q.hitting_paths <span class="bound">z'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> R_hits_Q split_list_first_prop<span class="main">[</span><span class="operator">of</span> <span class="quoted">R</span> <span class="quoted">Q.hitting_paths</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We open an anonymous context in order to hide all but the final lemma.  This also gives us the
  decomposition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">R</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> whose existence we established above.
›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">R_pre</span> <span class="free">z</span> <span class="free">R_post</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> R_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"R <span class="main">=</span> <span class="free">R_pre</span> <span class="main">@</span> <span class="free">z</span> <span class="main">#</span> <span class="free">R_post</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"Q.hitting_paths <span class="free">z</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> z_min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">z'</span><span class="main">.</span> <span class="bound">z'</span> <span class="main">∈</span> set <span class="free">R_pre</span> <span class="main">⟹</span> <span class="main">¬</span>Q.hitting_paths <span class="bound">z'</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_eq_new_last-z_neq_v0"><span class="command">lemma</span></span> z_neq_v0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">≠</span> <span class="free">v0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> z Q.hitting_paths_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_eq_new_last-z_neq_new_last"><span class="command">lemma</span></span> z_neq_new_last<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">≠</span> new_last"</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">=</span> new_last"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Q_hit</span></span> <span class="keyword2"><span class="keyword">where</span></span> Q_hit<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Q_hit</span> <span class="main">∈</span> Q"</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">∈</span> set <span class="skolem">Q_hit</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> z Q.hitting_paths_def y_eq_new_last y_neq_v1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Q.path <span class="skolem">Q_hit</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Q.paths path_from_to_def<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">Q_hit</span> <span class="main">⊆</span> <span class="keyword1">V</span> <span class="main">-</span> <span class="main">{</span>new_last<span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Q.walk_in_V H_x_def remove_vertex_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> Q_hit<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_eq_new_last-R_pre_neq_Nil"><span class="command">lemma</span></span> R_pre_neq_Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R_pre</span> <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">using</span></span> z_neq_new_last R_decomp R<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_eq_new_last-z_closer_than_new_last"><span class="command">lemma</span></span> z_closer_than_new_last<span class="main">:</span> <span class="quoted"><span class="quoted">"H.distance <span class="free">z</span> <span class="free">v1</span> <span class="main">&lt;</span> H.distance new_last <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"H.distance new_last <span class="free">v1</span> <span class="main">=</span> length R"</span></span> <span class="keyword1"><span class="command">using</span></span> H.distance_witness R <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">↝</span><span class="main">(</span><span class="free">z</span> <span class="main">#</span> <span class="free">R_post</span><span class="main">)</span><span class="main">↝</span><span class="hidden">⇘</span><sub>H</sub><span class="hidden">⇙</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> R_decomp R<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> H.walk_decomp<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> distinct_append last_appendR list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
          list.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> path_from_to_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length R <span class="main">&gt;</span> length <span class="main">(</span><span class="free">z</span> <span class="main">#</span> <span class="free">R_post</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> R_decomp <span class="keyword1"><span class="command">using</span></span> R_pre_neq_Nil <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> H.distance_upper_bound <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">R'_walk</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">R'_walk</span> <span class="main">≡</span> <span class="free">P_k_pre</span> <span class="main">@</span> <span class="free">R_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">z</span><span class="main">]</span>"</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_eq_new_last-R'_walk_not_Nil"><span class="command">lemma</span></span> R'_walk_not_Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"R'_walk <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">using</span></span> R'_walk_def R<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_eq_new_last-R'_walk_no_Q"><span class="command">lemma</span></span> R'_walk_no_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span> <span class="main">∈</span> set R'_walk<span class="main">;</span> <span class="free">v</span> <span class="main">≠</span> <span class="free">z</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">¬</span>Q.hitting_paths <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set R'_walk"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="free">z</span>"</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="free">P_k_pre</span> <span class="main">⟹</span> <span class="main">¬</span>Q.hitting_paths <span class="skolem">v</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> Q.hitting_paths_def hitting_Q_or_new_last_def y_min v1_in_Q <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="free">R_pre</span> <span class="main">⟹</span> <span class="main">¬</span>Q.hitting_paths <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> z_min <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>Q.hitting_paths <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> R'_walk_def <span class="keyword1"><span class="command">using</span></span> R'_walk_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    The original proof goes like this:
    ``Let <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">z</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> be the first vertex of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">R</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> on some path in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Q</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
    Then the distance in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"H"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">z</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is less than the distance
    from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">new_last</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  This contradicts the choice of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">paths</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P_new</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.''

    It does not say exactly why it contradicts the choice of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">paths</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P_new</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
    It seems we can choose <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Q</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> together with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">R'_walk</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as our new paths plus
    extrapath. But this seems to be wrong because we cannot show that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">R'_walk</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a path:
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P_k_pre</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">R_pre</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> could intersect.

    So we use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> walk_to_path<span class="antiquote"><span class="antiquote">}</span></span></span></span> to transform <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">R'_walk</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> into a path <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">R'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">R'</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">R'</span> <span class="main">≡</span> <span class="keyword1">SOME</span> <span class="bound">R'</span><span class="main">.</span> hd <span class="main">(</span>tl R'_walk<span class="main">)</span> <span class="main">↝</span><span class="bound">R'</span><span class="main">↝</span> <span class="free">z</span> <span class="main">∧</span> set <span class="bound">R'</span> <span class="main">⊆</span> set <span class="main">(</span>tl R'_walk<span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_eq_new_last-R'"><span class="command">lemma</span></span> R'<span class="main">:</span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl R'_walk<span class="main">)</span> <span class="main">↝</span>R'<span class="main">↝</span> <span class="free">z</span>"</span></span> <span class="quoted"><span class="quoted">"set R' <span class="main">⊆</span> set <span class="main">(</span>tl R'_walk<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tl R'_walk <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> P_k_pre_not_Nil R'_walk_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last R'_walk <span class="main">=</span> <span class="free">z</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> R'_walk_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"walk <span class="main">(</span>tl R'_walk<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> path_from_toE walk_tl H_def P_k_decomp R'_walk_def R<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
          R_decomp path_P_k y_eq_new_last hd_append list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> path_decomp'
          remove_vertex_path_from_to_add walk_comp walk_decomp<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> walk_last_edge<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">R''</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl R'_walk<span class="main">)</span> <span class="main">↝</span><span class="skolem">R''</span><span class="main">↝</span> <span class="free">z</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">R''</span> <span class="main">⊆</span> set <span class="main">(</span>tl R'_walk<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> walk_to_path<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"tl R'_walk"</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl R'_walk<span class="main">)</span>"</span></span> <span class="quoted"><span class="free">z</span></span><span class="main">]</span> last_tl <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl R'_walk<span class="main">)</span> <span class="main">↝</span>R'<span class="main">↝</span> <span class="free">z</span>"</span></span> <span class="quoted"><span class="quoted">"set R' <span class="main">⊆</span> set <span class="main">(</span>tl R'_walk<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> R'_def
      <span class="keyword1"><span class="command">using</span></span> someI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">R'</span><span class="main">.</span> hd <span class="main">(</span>tl R'_walk<span class="main">)</span> <span class="main">↝</span><span class="bound">R'</span><span class="main">↝</span> <span class="free">z</span> <span class="main">∧</span> set <span class="bound">R'</span> <span class="main">⊆</span> set <span class="main">(</span>tl R'_walk<span class="main">)</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_eq_new_last-hd_R'"><span class="command">lemma</span></span> hd_R'<span class="main">:</span> <span class="quoted"><span class="quoted">"hd R' <span class="main">=</span> hd <span class="main">(</span>tl P_k<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl R'_walk<span class="main">)</span> <span class="main">=</span> hd <span class="main">(</span>tl P_k<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"tl <span class="free">P_k_pre</span> <span class="main">=</span> Nil"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> R'_walk_def <span class="keyword1"><span class="command">using</span></span> P_k_decomp R<span class="main">(</span>1<span class="main">)</span> P_k_pre_not_Nil y_eq_new_last
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> H.path_from_toE R_decomp hd_append list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> tl_append2<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"tl <span class="free">P_k_pre</span> <span class="main">≠</span> Nil"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> R'_walk_def <span class="keyword1"><span class="command">using</span></span> P_k_pre_not_Nil <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> P_k_decomp<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> R'<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_eq_new_last-R'_no_Q"><span class="command">lemma</span></span> R'_no_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span> <span class="main">∈</span> set R'<span class="main">;</span> <span class="free">v</span> <span class="main">≠</span> <span class="free">z</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">¬</span>Q.hitting_paths <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> R'_walk_no_Q <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> R'<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> R'_walk_not_Nil list.set_sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> subsetCE<span class="main">)</span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_eq_new_last-v0_R'_path"><span class="command">lemma</span></span> v0_R'_path<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span><span class="main">↝</span> <span class="free">z</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">→</span>hd R'"</span></span> <span class="keyword1"><span class="command">using</span></span> hd_R' hd_P_k_v0
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Nil_is_append_conv P_k_decomp P_k_pre_not_Nil path_P_k list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
          list.exhaust_sel path_first_edge' tl_append2<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∉</span> set R'"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∉</span> set R"</span></span> <span class="keyword1"><span class="command">using</span></span> R<span class="main">(</span>1<span class="main">)</span> H_def H.path_in_V remove_vertex_V
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_from_to_def subset_Diff_insert<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∉</span> set <span class="free">R_pre</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> R_decomp <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∉</span> set <span class="main">(</span>tl <span class="free">P_k_pre</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> hd_P_k_v0 path_P_k path_first_vertex
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> P_k_decomp P_k_pre_not_Nil hd_append list.exhaust_sel path_decomp<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> R'<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> R'_walk_def
        <span class="keyword1"><span class="command">using</span></span> P_k_pre_not_Nil z_neq_v0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> path_cons
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> R'<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> last.simps list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> path_from_to_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">corollary</span></span> z_last_R'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">=</span> last <span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v0_R'_path <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_eq_new_last-z_eq_v1_solves"><span class="command">lemma</span></span> z_eq_v1_solves<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">=</span> <span class="free">v1</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">paths</span><span class="main">.</span> DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths</span> <span class="main">∧</span> card <span class="bound">paths</span> <span class="main">=</span> Suc <span class="free">sep_size</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> Q'<span class="main">:</span> DisjointPaths <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted">Q</span>
      <span class="keyword1"><span class="command">using</span></span> DisjointPaths_supergraph H_x_def Q.DisjointPaths_axioms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span><span class="main">↝</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms v0_R'_path <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">v</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> Q"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> <span class="free">v0</span> <span class="main">#</span> R'"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="free">v0</span> <span class="main">∨</span> <span class="skolem">v</span> <span class="main">=</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> R'_no_Q Q.hitting_paths_def <span class="quoted"><span class="quoted">‹<span class="free">z</span> <span class="main">=</span> <span class="free">v1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="main">(</span>insert <span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span> Q<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> Q'.DisjointPaths_extend <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>insert <span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span> Q<span class="main">)</span> <span class="main">=</span> Suc <span class="free">sep_size</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> P_k<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Q<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Q.finite_paths Q.second_vertices_new_path hd_R'<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_eq_new_last-z_neq_v1_solves"><span class="command">lemma</span></span> z_neq_v1_solves<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">paths</span><span class="main">.</span> DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths</span> <span class="main">∧</span> card <span class="bound">paths</span> <span class="main">=</span> Suc <span class="free">sep_size</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ProofStepInduct <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> Q <span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span> <span class="free">sep_size</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ProofStepInduct.intro<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"DisjointPathsPlusOne <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> Q <span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> DisjointPathsPlusOne.intro<span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> Q"</span></span>
          <span class="keyword1"><span class="command">using</span></span> DisjointPaths_supergraph H_x_def Q.DisjointPaths_axioms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"DisjointPathsPlusOne_axioms <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> Q <span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span><span class="main">↝</span> last <span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v0_R'_path <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"tl <span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> R'<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl <span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span><span class="main">)</span> <span class="main">∉</span> Q.second_vertices"</span></span> <span class="keyword1"><span class="command">using</span></span> hd_R' P_k<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Q.hitting_paths <span class="main">(</span>last <span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> z z_last_R' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>Q.hitting_paths <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> R'_no_Q path_from_to_last<span class="main">[</span><span class="operator">OF</span> v0_R'_path<span class="main">]</span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Q.hitting_paths_def in_set_butlastD set_ConsD<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ProofStepInduct_axioms Q <span class="free">sep_size</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> sep_size_not0 Q<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">insert</span> NoSmallSeparationsInduct_axioms<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"H.distance <span class="main">(</span>last <span class="free">P_new</span><span class="main">)</span> <span class="free">v1</span> <span class="main">≤</span> H.distance <span class="main">(</span>last <span class="main">(</span><span class="free">v0</span> <span class="main">#</span> R'<span class="main">)</span><span class="main">)</span> <span class="free">v1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> H_def optimal_paths<span class="main">[</span><span class="operator">of</span> <span class="quoted">Q</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">#</span> R'"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> z_last_R' new_last_def z_closer_than_new_last <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">corollary</span></span> with_optimal_paths_solves'<span class="main">:</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">paths</span><span class="main">.</span> DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths</span> <span class="main">∧</span> card <span class="bound">paths</span> <span class="main">=</span> Suc <span class="free">sep_size</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> optimal_paths z_eq_v1_solves z_neq_v1_solves <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹anonymous context›</span>

<span class="keyword1"><span class="command">corollary</span></span> with_optimal_paths_solves<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">paths</span><span class="main">.</span> DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths</span> <span class="main">∧</span> card <span class="bound">paths</span> <span class="main">=</span> Suc <span class="free">sep_size</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> optimal_paths with_optimal_paths_solves' R_decomp_exists <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">locale</span> ProofStepInduct_y_eq_new_last<span class="antiquote">}</span></span>›</span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Y_neq_new_last">
<div class="head">
<h1>Theory Y_neq_new_last</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹The case $y \neq new\_last$›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Y_neq_new_last <span class="keyword2"><span class="keyword">imports</span></span> <a href="MengerInduction.html">MengerInduction</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Let us now consider the case that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y</span></span> <span class="main"><span class="main">≠</span></span> <span class="free"><span class="free">v1</span></span> <span class="main"><span class="main">∧</span></span> <span class="free"><span class="free">y</span></span> <span class="main"><span class="main">≠</span></span> <span class="free"><span class="free">new_last</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  Our goal is to show that
  this is inconsistent: The following locale will be unsatisfiable, proving that
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">v1</span></span> <span class="main"><span class="main">∨</span></span> <span class="free"><span class="free">y</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">new_last</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> holds.
›</span></span>
<span class="keyword1"><span class="command">locale</span></span> ProofStepInduct_y_neq_new_last <span class="main">=</span> ProofStepInduct_NonTrivial_P_k_pre <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> y_neq_v1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y_neq_new_last<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">≠</span> new_last"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Y_neq_new_last-Q_hit_exists"><span class="command">lemma</span></span> Q_hit_exists<span class="main">:</span> <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">Q_hit</span> <span class="free">Q_hit_pre</span> <span class="free">Q_hit_post</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Q_hit</span> <span class="main">∈</span> Q"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> set <span class="free">Q_hit</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_hit</span> <span class="main">=</span> <span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="free">y</span> <span class="main">#</span> <span class="free">Q_hit_post</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Q_hit</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Q_hit</span> <span class="main">∈</span> Q"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> set <span class="skolem">Q_hit</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> hitting_Q_or_new_last_def y y_neq_v1 y_neq_new_last <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> split_list<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We open an anonymous context because we do not want to export any lemmas except the final lemma
  proving the contradiction.  This is also an easy way to get the decomposition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Q_hit</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  whose existence we have established above.
›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Q_hit</span> <span class="free">Q_hit_pre</span> <span class="free">Q_hit_post</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Q_hit<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q_hit</span> <span class="main">∈</span> Q"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> set <span class="free">Q_hit</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> Q_hit_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q_hit</span> <span class="main">=</span> <span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="free">y</span> <span class="main">#</span> <span class="free">Q_hit_post</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_neq_new_last-Q_hit_v0_v1"><span class="command">lemma</span></span> Q_hit_v0_v1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="free">Q_hit</span><span class="main">↝</span><span class="hidden">⇘</span><sub>H_x</sub><span class="hidden">⇙</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Q.paths Q_hit<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_neq_new_last-Q_hit_vertices"><span class="command">lemma</span></span> Q_hit_vertices<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="free">Q_hit</span> <span class="main">⊆</span> <span class="keyword1">V</span> <span class="main">-</span> <span class="main">{</span>new_last<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Q.walk_in_V H_x_def path_from_to_def remove_vertex_V Q_hit_v0_v1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_neq_new_last-Q_hit_pre_not_Nil"><span class="command">lemma</span></span> Q_hit_pre_not_Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q_hit_pre</span> <span class="main">≠</span> Nil"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Q_hit_v0_v1 y_neq_v0 <span class="keyword1"><span class="command">unfolding</span></span> Q_hit_decomp <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_neq_new_last-tl_Q_hit_pre"><span class="command">lemma</span></span> tl_Q_hit_pre<span class="main">:</span> <span class="quoted"><span class="quoted">"tl <span class="main">(</span><span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">using</span></span> Q_hit_pre_not_Nil <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_neq_new_last-Q_hit_pre_edges"><span class="command">lemma</span></span> Q_hit_pre_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">(</span><span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">∩</span> B <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">(</span><span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">∩</span> B <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">(</span><span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">⊆</span> <span class="keyword1">E</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Q.paths H_x_def Q_hit<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Q_hit_decomp edges_of_walk_in_E path_decomp'
          path_from_to_def remove_vertex_walk_add<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> Q_hit_pre_edges<span class="main">:</span>
      <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">(</span><span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> paths_with_new<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> B_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"first_edge_of_walk <span class="main">(</span><span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> paths_with_new<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> tl_Q_hit_pre first_edge_in_edges <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">v'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">≡</span> hd <span class="main">(</span>tl <span class="main">(</span><span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> v'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v0</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">=</span> first_edge_of_walk <span class="main">(</span><span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> first_edge_hd_tl Q_hit_pre_not_Nil tl_Q_hit_pre
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Q.path_from_toE Q_hit_decomp Q_hit_v0_v1 first_edge_of_walk.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
          hd_Cons_tl hd_append snoc_eq_iff_butlast<span class="main">)</span>

    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">P_i</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      P_i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">P_i</span> <span class="main">∈</span> paths_with_new"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v0</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="skolem">P_i</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> P_i_first<span class="main">:</span> <span class="quoted"><span class="quoted">"first_edge_of_walk <span class="skolem">P_i</span> <span class="main">=</span> <span class="main">(</span><span class="free">v0</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> first_edge_first paths_with_new_def paths P_new <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insert_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"first_edge_of_walk P_k <span class="main">=</span> <span class="main">(</span><span class="free">v0</span><span class="main">,</span> hd <span class="main">(</span>tl P_k<span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> P_k_decomp P_k_pre_not_Nil append_is_Nil_conv first_edge_of_walk.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
          hd_P_k_v0 list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.exhaust_sel tl_append2<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">P_i</span> <span class="main">≠</span> P_k"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Q.first_edge_first P_k<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Q.second_vertices_first_edge Q_hit<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Q_hit_decomp
          Q_hit_v0_v1 Un_iff v' tl_Q_hit_pre first_edge_in_edges walk_edges_decomp<span class="main">)</span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
      Then <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">P_k</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">P_i</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> intersect in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">y</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which is not one of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v0</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">new_last</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  So we get a contradiction because these two paths should be
      disjoint on all other vertices.
›</span></span>

    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">∉</span> set <span class="main">(</span><span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> Q_hit_v0_v1 Q_hit_decomp y_neq_v1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Q.path_from_to_last'<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">∉</span> set <span class="main">(</span><span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">∉</span> set <span class="free">Q_hit_pre</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Q_hit_decomp Q_hit_vertices <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> y_neq_new_last <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl <span class="main">(</span><span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> hd <span class="main">(</span>tl <span class="skolem">P_i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl <span class="skolem">P_i</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">v'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> P_i_first P_i<span class="main">(</span>1<span class="main">)</span> tl_P_new<span class="main">(</span>1<span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Pair_inject first_edge_of_walk.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> insert_iff list.collapse
            paths_tl_notnil paths_with_new_def tl_Nil<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> v'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="main">(</span><span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span><span class="main">↝</span> <span class="free">y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Q.path_decomp' H_x_def Q_hit_decomp Q_hit_v0_v1 Q_hit_pre_not_Nil
          hd_append2 path_from_to_def remove_vertex_walk_add snoc_eq_iff_butlast<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">(</span><span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">⊆</span> edges_of_walk <span class="skolem">P_i</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> new_path_follows_old_paths tl_Q_hit_pre P_i<span class="main">(</span>1<span class="main">)</span> Q_hit_pre_edges <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> walk_edges_subset<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> set <span class="skolem">P_i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tl_Q_hit_pre<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> set P_k"</span></span> <span class="keyword1"><span class="command">using</span></span> P_k_decomp <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command">using</span></span> y_neq_v0 y_neq_v1 y_neq_new_last <span class="quoted"><span class="quoted">‹<span class="skolem">P_i</span> <span class="main">≠</span> P_k›</span></span>
        paths_plus_one_disjoint<span class="main">[</span><span class="operator">OF</span> P_i<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted">P_k</span> <span class="quoted"><span class="free">y</span></span><span class="main">]</span> P_k<span class="main">(</span>1<span class="main">)</span> P_new_decomp <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_neq_new_last-P_k_pre_edges"><span class="command">lemma</span></span> P_k_pre_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">(</span><span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">∩</span> B <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">(</span><span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> paths_with_new<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"P_k <span class="main">=</span> <span class="free">P_new</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">(</span><span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">⊆</span> edges_of_walk <span class="free">P_new</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> P_k_decomp edges_of_comp1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> paths_with_new_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"P_k <span class="main">≠</span> <span class="free">P_new</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"P_k <span class="main">∈</span> <span class="free">paths</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> P_k<span class="main">(</span>1<span class="main">)</span> paths_with_new_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="main">(</span><span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> <span class="free">paths</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> edges_of_comp1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span>"</span></span><span class="main">]</span> P_k_decomp <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> paths_with_new_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> B_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">Q_hit'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_hit'</span> <span class="main">≡</span> <span class="free">P_k_pre</span> <span class="main">@</span> <span class="free">y</span> <span class="main">#</span> <span class="free">Q_hit_post</span>"</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_neq_new_last-Q_hit'_v0_v1"><span class="command">lemma</span></span> Q_hit'_v0_v1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span>Q_hit'<span class="main">↝</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="free">P_k_pre</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>Q.hitting_paths <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Q.paths Q_hit<span class="main">(</span>1<span class="main">)</span> y_min
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Q.hitting_paths_def hitting_Q_or_new_last_def last_in_set path_from_to_def<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∉</span> set <span class="free">Q_hit_post</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Q.path_from_to_first' Q_hit_v0_v1
        <span class="keyword1"><span class="command">unfolding</span></span> Q_hit_decomp <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> set <span class="free">Q_hit_post</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q.hitting_paths_def
        <span class="keyword1"><span class="command">using</span></span> Q_hit<span class="main">(</span>1<span class="main">)</span> Q_hit_decomp <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="free">P_k_pre</span> <span class="main">∩</span> set <span class="free">Q_hit_post</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q_hit'_def <span class="keyword1"><span class="command">using</span></span> path_from_to_combine
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> H_x_def P_k_decomp P_k_pre_not_Nil Q_hit_decomp Q_hit_v0_v1 append_is_Nil_conv
          hd_P_k_v0 path_P_k path_from_toI remove_vertex_path_from_to_add<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_neq_new_last-Q_hit'_v0_v1_H_x"><span class="command">lemma</span></span> Q_hit'_v0_v1_H_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span>Q_hit'<span class="main">↝</span><span class="hidden">⇘</span><sub>H_x</sub><span class="hidden">⇙</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">∉</span> set <span class="free">P_k_pre</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> new_last_neq_v0 hitting_Q_or_new_last_def y_min <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">∉</span> set <span class="free">Q_hit_post</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Q_hit_vertices <span class="keyword1"><span class="command">unfolding</span></span> Q_hit_decomp <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">∉</span> set Q_hit'"</span></span> <span class="keyword1"><span class="command">using</span></span> y_neq_new_last Q_hit'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> remove_vertex_path_from_to<span class="main">[</span><span class="operator">OF</span> Q_hit'_v0_v1<span class="main">]</span> H_x_def new_last_in_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">Q'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q'</span> <span class="main">≡</span> insert Q_hit' <span class="main">(</span>Q <span class="main">-</span> <span class="main">{</span><span class="free">Q_hit</span><span class="main">}</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_neq_new_last-Q_hit_edges_disjoint"><span class="command">lemma</span></span> Q_hit_edges_disjoint<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> <span class="main">(</span>Q <span class="main">-</span> <span class="main">{</span><span class="free">Q_hit</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> edges_of_walk <span class="free">Q_hit</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> DiffD1 Q.paths_edge_disjoint Q_hit<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_neq_new_last-Q_hit'_notin_Q_minus_Q_hit"><span class="command">lemma</span></span> Q_hit'_notin_Q_minus_Q_hit<span class="main">:</span> <span class="quoted"><span class="quoted">"Q_hit' <span class="main">∉</span> Q <span class="main">-</span> <span class="main">{</span><span class="free">Q_hit</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl Q_hit'<span class="main">)</span> <span class="main">∉</span> Q.second_vertices"</span></span> <span class="keyword1"><span class="command">using</span></span> P_k<span class="main">(</span>2<span class="main">)</span> P_k_decomp
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> P_k_pre_not_Nil Q_hit'_def append_eq_append_conv2 append_self_conv hd_append2
          list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> tl_append2<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Q.second_vertices_new_path<span class="main">[</span><span class="operator">of</span> <span class="quoted">Q_hit'</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_neq_new_last-Q_weight_smaller"><span class="command">lemma</span></span> Q_weight_smaller<span class="main">:</span> <span class="quoted"><span class="quoted">"Q_weight Q' <span class="main">&lt;</span> Q_weight Q"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">Q_edges</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Q_edges</span> <span class="main">≡</span> <span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> Q<span class="main">)</span> <span class="main">∩</span> B"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">Q'_edges</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Q'_edges</span> <span class="main">≡</span> <span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> Q'<span class="main">)</span> <span class="main">∩</span> B"</span></span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">w</span> <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Q'_edges</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">Q_edges</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> v_w_in_B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> B"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q'_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Q'_v_w_witness</span></span> <span class="keyword2"><span class="keyword">where</span></span> Q'_v_w_witness<span class="main">:</span>
        <span class="quoted"><span class="quoted">"<span class="skolem">Q'_v_w_witness</span> <span class="main">∈</span> Q'"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="skolem">Q'_v_w_witness</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> *<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> Q'_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Q'_v_w_witness</span> <span class="main">≠</span> Q_hit'"</span></span> <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Q'_v_w_witness</span> <span class="main">=</span> Q_hit'"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges_of_walk <span class="skolem">Q'_v_w_witness</span> <span class="main">=</span>
            edges_of_walk <span class="main">(</span><span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">∪</span> edges_of_walk <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">Q_hit_post</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> Q_hit'_def <span class="keyword1"><span class="command">using</span></span> walk_edges_decomp<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">P_k_pre</span></span> <span class="quoted"><span class="free">y</span></span> <span class="quoted"><span class="free">Q_hit_post</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∉</span> edges_of_walk <span class="main">(</span><span class="free">P_k_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> P_k_pre_edges v_w_in_B <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∉</span> edges_of_walk <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">Q_hit_post</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">Q_hit_post</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="free">Q_hit</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> Q_hit_decomp <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> UnCI walk_edges_decomp<span class="main">)</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> *<span class="main">(</span>2<span class="main">)</span> v_w_in_B Q_hit<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> Q_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> Q'_v_w_witness<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Q'_v_w_witness</span> <span class="main">∈</span> Q"</span></span> <span class="keyword1"><span class="command">using</span></span> Q'_v_w_witness<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> Q'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> *<span class="main">(</span>2<span class="main">)</span> v_w_in_B Q'_v_w_witness<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> Q_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">e</span> <span class="main">∈</span> <span class="skolem">Q_edges</span><span class="main">.</span> <span class="bound">e</span> <span class="main">∉</span> <span class="skolem">Q'_edges</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> v_w<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="main">(</span><span class="free">Q_hit_pre</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">∩</span> B"</span></span>
        <span class="keyword1"><span class="command">using</span></span> Q_hit_pre_edges <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> v_w_in_Q_hit<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="free">Q_hit</span> <span class="main">∩</span> B"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q_hit_decomp
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Int_iff UnCI walk_edges_decomp<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Q_edges</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q_edges_def <span class="keyword1"><span class="command">using</span></span> Q_hit<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">Q'_edges</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Q'_edges</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk Q_hit'"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q'_edges_def Q'_def
          <span class="keyword1"><span class="command">using</span></span> IntD1 v_w_in_Q_hit Q_hit_edges_disjoint <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges_of_walk <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">Q_hit_post</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q_hit'_def
          <span class="keyword1"><span class="command">using</span></span> v_w P_k_pre_edges
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> IntD2 UnE disjoint_iff_not_equal walk_edges_decomp<span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> v_w Q_hit<span class="main">(</span>1<span class="main">)</span> Q.paths Q_hit_decomp
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DiffE Q.path_edges_remove_prefix IntD1 path_from_to_def<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">Q_edges</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q_edges_def B_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">Q'_edges</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q'_edges_def B_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="skolem">Q'_edges</span> <span class="main">&lt;</span> card <span class="skolem">Q_edges</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> card_seteq not_le subrelI<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> Q'<span class="main">)</span> <span class="main">∩</span> B<span class="main">)</span> <span class="main">&lt;</span> card <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>edges_of_walk <span class="main">`</span> Q<span class="main">)</span> <span class="main">∩</span> B<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> Q_edges_def Q'_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q_weight_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_neq_new_last-DisjointPaths_Q'"><span class="command">lemma</span></span> DisjointPaths_Q'<span class="main">:</span> <span class="quoted"><span class="quoted">"DisjointPaths H_x <span class="free">v0</span> <span class="free">v1</span> Q'"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> Q_reduced<span class="main">:</span> DisjointPaths <span class="quoted">H_x</span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="quoted">"Q <span class="main">-</span> <span class="main">{</span><span class="free">Q_hit</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> Q.DisjointPaths_reduce<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Q <span class="main">-</span> <span class="main">{</span><span class="free">Q_hit</span><span class="main">}</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">v</span>
      <span class="keyword3"><span class="command">assume</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> Q <span class="main">-</span> <span class="main">{</span><span class="free">Q_hit</span><span class="main">}</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set Q_hit'"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="free">v0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> set <span class="free">P_k_pre</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="free">P_k_pre</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>hitting_Q_or_new_last <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> y_min <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> new_last"</span></span> <span class="keyword1"><span class="command">using</span></span> v<span class="main">(</span>2<span class="main">)</span> calculation hitting_Q_or_new_last_def v<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">unfolding</span></span> hitting_Q_or_new_last_def <span class="keyword1"><span class="command">using</span></span> v<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> xs <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="free">y</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DiffE Q.paths_disjoint Q_hit y_neq_v0 y_neq_v1 insert_iff v<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> xs<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> set <span class="free">Q_hit_post</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="free">Q_hit_post</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="free">Q_hit</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q_hit_decomp <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> Q.paths_disjoint<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">Q_hit</span></span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">]</span> xs Q_hit<span class="main">(</span>1<span class="main">)</span> v <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> v<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> Q_hit'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Q_reduced.DisjointPaths_extend Q_hit'_v0_v1_H_x
      <span class="keyword1"><span class="command">unfolding</span></span> Q'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Y_neq_new_last-card_Q'"><span class="command">lemma</span></span> card_Q'<span class="main">:</span> <span class="quoted"><span class="quoted">"card Q' <span class="main">=</span> <span class="free">sep_size</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Suc <span class="main">(</span>card <span class="main">(</span>Q <span class="main">-</span> <span class="main">{</span><span class="free">Q_hit</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> card Q"</span></span>
      <span class="keyword1"><span class="command">using</span></span> Q_hit<span class="main">(</span>1<span class="main">)</span> Q.finite_paths <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> card_Suc_Diff1<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Q<span class="main">(</span>2<span class="main">)</span> Q.finite_paths Q_hit'_notin_Q_minus_Q_hit
      <span class="keyword1"><span class="command">unfolding</span></span> Q'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Y_neq_new_last-contradiction'"><span class="command">lemma</span></span> contradiction'<span class="main">:</span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> Q_weight_smaller DisjointPaths_Q' card_Q' Q_min
    <span class="keyword1"><span class="command">using</span></span> Suc_leI not_less_eq_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹anonymous context›</span>

<span class="keyword1"><span class="command">corollary</span></span> contradiction<span class="main">:</span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> Q_hit_exists contradiction' <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">locale</span> ProofStepInduct_y_neq_new_last<span class="antiquote">}</span></span>›</span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Menger">
<div class="head">
<h1>Theory Menger</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Menger's Theorem›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Menger <span class="keyword2"><span class="keyword">imports</span></span> <a href="Y_eq_new_last.html">Y_eq_new_last</a> <a href="Y_neq_new_last.html">Y_neq_new_last</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this section, we combine the cases and finally prove Menger's Theorem.›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ProofStepInductOptimalPaths <span class="main">=</span> ProofStepInduct <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> optimal_paths<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">paths'</span> <span class="bound">P_new'</span><span class="main">.</span> ProofStepInduct <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths'</span> <span class="bound">P_new'</span> <span class="free">sep_size</span>
      <span class="main">⟹</span> Digraph.distance <span class="main">(</span>remove_vertex <span class="free">v0</span><span class="main">)</span> <span class="main">(</span>last <span class="free">P_new</span><span class="main">)</span> <span class="free">v1</span>
       <span class="main">≤</span> Digraph.distance <span class="main">(</span>remove_vertex <span class="free">v0</span><span class="main">)</span> <span class="main">(</span>last <span class="bound">P_new'</span><span class="main">)</span> <span class="free">v1</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Menger-one_more_paths_exists_trivial"><span class="command">lemma</span></span> one_more_paths_exists_trivial<span class="main">:</span>
  <span class="quoted"><span class="quoted">"new_last <span class="main">=</span> <span class="free">v1</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">paths</span><span class="main">.</span> DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths</span> <span class="main">∧</span> card <span class="bound">paths</span> <span class="main">=</span> Suc <span class="free">sep_size</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> P_new_solves_if_disjoint paths_sep_size <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Menger-one_more_paths_exists_nontrivial"><span class="command">lemma</span></span> one_more_paths_exists_nontrivial<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"new_last <span class="main">≠</span> <span class="free">v1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">paths</span><span class="main">.</span> DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths</span> <span class="main">∧</span> card <span class="bound">paths</span> <span class="main">=</span> Suc <span class="free">sep_size</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> ProofStepInduct_NonTrivial <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="free">paths</span></span> <span class="quoted"><span class="free">P_new</span></span> <span class="quoted"><span class="free">sep_size</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms new_last_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">P_k_pre</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="skolem"><span class="skolem">P_k_post</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"ProofStepInduct_NonTrivial_P_k_pre <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="free">paths</span> <span class="free">P_new</span> <span class="free">sep_size</span> <span class="skolem">P_k_pre</span> <span class="skolem">y</span> <span class="skolem">P_k_post</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> ProofStepInduct_NonTrivial_P_k_pre_exists <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> ProofStepInduct_NonTrivial_P_k_pre <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="free">paths</span></span> <span class="quoted"><span class="free">P_new</span></span> <span class="quoted"><span class="free">sep_size</span></span> <span class="quoted"><span class="skolem">P_k_pre</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="skolem">P_k_post</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> new_last"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> ProofStepInduct_y_eq_new_last <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="free">paths</span></span> <span class="quoted"><span class="free">P_new</span></span> <span class="quoted"><span class="free">sep_size</span></span> <span class="quoted"><span class="skolem">P_k_pre</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="skolem">P_k_post</span></span>
      <span class="keyword1"><span class="command">using</span></span> optimal_paths<span class="main">[</span><span class="operator">folded</span> H_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> with_optimal_paths_solves <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≠</span> new_last"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> ProofStepInduct_y_neq_new_last <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="free">paths</span></span> <span class="quoted"><span class="free">P_new</span></span> <span class="quoted"><span class="free">sep_size</span></span> <span class="quoted"><span class="skolem">P_k_pre</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="skolem">P_k_post</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> contradiction <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> y_eq_v1_solves <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">corollary</span></span> one_more_paths_exists<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">paths</span><span class="main">.</span> DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths</span> <span class="main">∧</span> card <span class="bound">paths</span> <span class="main">=</span> Suc <span class="free">sep_size</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> one_more_paths_exists_trivial one_more_paths_exists_nontrivial <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ProofStepInduct<span class="main">)</span> one_more_paths_exists<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">paths</span><span class="main">.</span> DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths</span> <span class="main">∧</span> card <span class="bound">paths</span> <span class="main">=</span> Suc <span class="free">sep_size</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">paths_weight</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">paths_weight</span> <span class="main">≡</span>
    <span class="main">λ</span><span class="main">(</span><span class="bound">paths'</span> <span class="main">::</span> <span class="tfree">'a</span> Walk set<span class="main">,</span> <span class="bound">P_new'</span><span class="main">)</span><span class="main">.</span> Digraph.distance <span class="main">(</span>remove_vertex <span class="free">v0</span><span class="main">)</span> <span class="main">(</span>last <span class="bound">P_new'</span><span class="main">)</span> <span class="free">v1</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">paths_good</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">paths_good</span> <span class="main">≡</span>
    <span class="main">λ</span><span class="main">(</span><span class="bound">paths'</span><span class="main">,</span> <span class="bound">P_new'</span><span class="main">)</span><span class="main">.</span> ProofStepInduct <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths'</span> <span class="bound">P_new'</span> <span class="free">sep_size</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">paths'</span> <span class="bound">P_new'</span><span class="main">.</span> <span class="skolem">paths_good</span> <span class="main">(</span><span class="bound">paths'</span><span class="main">,</span> <span class="bound">P_new'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> paths_good_def <span class="keyword1"><span class="command">using</span></span> ProofStepInduct_axioms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">P'</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    P'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">paths_good</span> <span class="skolem">P'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">P''</span><span class="main">.</span> <span class="skolem">paths_good</span> <span class="bound">P''</span> <span class="main">⟹</span> <span class="skolem">paths_weight</span> <span class="skolem">P'</span> <span class="main">≤</span> <span class="skolem">paths_weight</span> <span class="bound">P''</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> arg_min_ex<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">paths_good</span></span> <span class="quoted"><span class="skolem">paths_weight</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">paths'</span></span> <span class="skolem"><span class="skolem">P_new'</span></span> <span class="keyword2"><span class="keyword">where</span></span> P'_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">P'</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">paths'</span><span class="main">,</span> <span class="skolem">P_new'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> surj_pair<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> optimal_paths_good<span class="main">:</span> <span class="quoted"><span class="quoted">"ProofStepInduct <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="skolem">paths'</span> <span class="skolem">P_new'</span> <span class="free">sep_size</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> P'<span class="main">(</span>1<span class="main">)</span> P'_decomp <span class="keyword1"><span class="command">unfolding</span></span> paths_good_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">paths''</span> <span class="bound">P_new''</span><span class="main">.</span> <span class="skolem">paths_good</span> <span class="main">(</span><span class="bound">paths''</span><span class="main">,</span> <span class="bound">P_new''</span><span class="main">)</span>
    <span class="main">⟹</span> <span class="skolem">paths_weight</span> <span class="skolem">P'</span> <span class="main">≤</span> <span class="skolem">paths_weight</span> <span class="main">(</span><span class="bound">paths''</span><span class="main">,</span> <span class="bound">P_new''</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> P'<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> optimal_paths_min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">paths''</span> <span class="bound">P_new''</span><span class="main">.</span> ProofStepInduct <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths''</span> <span class="bound">P_new''</span> <span class="free">sep_size</span>
    <span class="main">⟹</span> Digraph.distance <span class="main">(</span>remove_vertex <span class="free">v0</span><span class="main">)</span> <span class="main">(</span>last <span class="skolem">P_new'</span><span class="main">)</span> <span class="free">v1</span>
        <span class="main">≤</span> Digraph.distance <span class="main">(</span>remove_vertex <span class="free">v0</span><span class="main">)</span> <span class="main">(</span>last <span class="bound">P_new''</span><span class="main">)</span> <span class="free">v1</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> paths_good_def paths_weight_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> P'_decomp<span class="main">)</span>

  <span class="keyword1"><span class="command">interpret</span></span> G<span class="main">:</span> ProofStepInductOptimalPaths <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="skolem">paths'</span></span> <span class="quoted"><span class="skolem">P_new'</span></span> <span class="quoted"><span class="free">sep_size</span></span>
    <span class="keyword1"><span class="command">using</span></span> optimal_paths_good optimal_paths_min
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ProofStepInductOptimalPaths.intro ProofStepInductOptimalPaths_axioms.intro<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> G.one_more_paths_exists <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Menger's Theorem›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> v0_v1_Digraph<span class="main">)</span> menger<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">S</span><span class="main">.</span> Separation <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">S</span> <span class="main">⟹</span> card <span class="bound">S</span> <span class="main">≥</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">paths</span><span class="main">.</span> DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">paths</span> <span class="main">∧</span> card <span class="bound">paths</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms v0_v1_Digraph_axioms <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">G</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>0 <span class="skolem">G</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> v0_v1_Digraph.DisjointPaths_empty<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">G</span></span><span class="main">]</span> card.empty <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span> <span class="skolem">G</span><span class="main">)</span>
  <span class="keyword1"><span class="command">interpret</span></span> G<span class="main">:</span> v0_v1_Digraph <span class="quoted"><span class="skolem">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="keyword1"><span class="command">using</span></span> Suc<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">S</span><span class="main">.</span> Separation <span class="skolem">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">S</span> <span class="main">⟹</span> <span class="skolem">n</span> <span class="main">≤</span> card <span class="bound">S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Suc.prems Suc_leD <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">paths</span></span> <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"DisjointPaths <span class="skolem">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="skolem">paths</span>"</span></span> <span class="quoted"><span class="quoted">"card <span class="skolem">paths</span> <span class="main">=</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Suc<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">interpret</span></span> G<span class="main">:</span> DisjointPaths <span class="quoted"><span class="skolem">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="skolem">paths</span></span> <span class="keyword1"><span class="command">using</span></span> P<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">P_new</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    P_new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="skolem">P_new</span><span class="main">↝</span><span class="hidden">⇘</span><sub><span class="skolem">G</span></sub><span class="hidden">⇙</span> <span class="free">v1</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">P_new</span> <span class="main">∩</span> G.second_vertices <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> G.disjoint_paths_new_path P<span class="main">(</span>2<span class="main">)</span> Suc.prems<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> P_new_new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">P_new</span> <span class="main">∉</span> <span class="skolem">paths</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> G.paths_tl_notnil G.second_vertex_def G.second_vertices_def G.path_from_toE IntI
        P_new empty_iff image_eqI list.set_sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.set_sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"G.hitting_paths <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> G.hitting_paths_def <span class="keyword1"><span class="command">using</span></span> v0_neq_v1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> set <span class="skolem">P_new</span><span class="main">.</span> G.hitting_paths <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> P_new<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">new_pre</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">new_post</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    P_new_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">P_new</span> <span class="main">=</span> <span class="skolem">new_pre</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">new_post</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"G.hitting_paths <span class="skolem">x</span>"</span></span>
           <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> set <span class="skolem">new_pre</span> <span class="main">⟹</span> <span class="main">¬</span>G.hitting_paths <span class="bound">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> split_list_first_prop<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"DisjointPathsPlusOne <span class="skolem">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="skolem">paths</span> <span class="main">(</span><span class="skolem">new_pre</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">↝</span><span class="main">(</span><span class="skolem">new_pre</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span><span class="main">↝</span><span class="hidden">⇘</span><sub><span class="skolem">G</span></sub><span class="hidden">⇙</span> last <span class="main">(</span><span class="skolem">new_pre</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> P_new<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> G.path_decomp' P_new_decomp append_is_Nil_conv hd_append2 list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
          list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> path_from_to_def self_append_conv2<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"tl <span class="main">(</span><span class="skolem">new_pre</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DisjointPaths.hitting_paths_def G.DisjointPaths_axioms G.path_from_toE
          butlast.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> butlast_snoc list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> self_append_conv2
          tl_append2 x<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">new_pre</span> <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">using</span></span> G.hitting_paths_def P_new<span class="main">(</span>1<span class="main">)</span> P_new_decomp x<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl <span class="main">(</span><span class="skolem">new_pre</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> hd <span class="main">(</span>tl <span class="skolem">P_new</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> P_new_decomp hd_append<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>tl <span class="main">(</span><span class="skolem">new_pre</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">∉</span> G.second_vertices"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> P_new<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> P_new_decomp <span class="quoted"><span class="quoted">‹<span class="skolem">new_pre</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> append_is_Nil_conv disjoint_iff_not_equal
          list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.set_sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.set_sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> tl_append2<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"G.hitting_paths <span class="main">(</span>last <span class="main">(</span><span class="skolem">new_pre</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="main">(</span><span class="skolem">new_pre</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">¬</span>G.hitting_paths <span class="bound">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> x<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"NoSmallSeparationsInduct <span class="skolem">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="skolem">n</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> G.v0_v1_Digraph_axioms NoSmallSeparationsInduct.intro
        NoSmallSeparationsInduct_axioms_def Suc.hyps Suc.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> not_case<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="var">?case</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="free">v1</span>"</span></span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">paths'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">paths'</span> <span class="main">=</span> insert <span class="skolem">P_new</span> <span class="skolem">paths</span>"</span></span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">v</span>
        <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> <span class="skolem">paths</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">P_new</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="free">v0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">new_pre</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> *<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">,</span></span>5<span class="main"><span class="main">)</span></span> G.path_from_to_ends G.path_from_toE P_new<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> P_new_decomp
              <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="free">v1</span>›</span></span> butlast_snoc set_butlast<span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> *<span class="main">(</span>1<span class="main">,</span>2<span class="main">,</span>4<span class="main">)</span> G.hitting_paths_def x<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"DisjointPaths <span class="skolem">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="skolem">paths'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> paths'_def
        <span class="keyword1"><span class="command">using</span></span> G.DisjointPaths_extend P_new<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="skolem">paths'</span> <span class="main">=</span> Suc <span class="skolem">n</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> P_new_new <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> G.finite_paths P<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> paths'_def<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> not_case <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ProofStepInduct_axioms <span class="skolem">paths</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> G.DisjointPaths_extend G.finite_paths P<span class="main">(</span>2<span class="main">)</span> P_new<span class="main">(</span>1<span class="main">)</span> not_case card_insert_disjoint
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">insert</span> P<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ProofStepInduct <span class="skolem">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="skolem">paths</span> <span class="main">(</span><span class="skolem">new_pre</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span> <span class="skolem">n</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> 1 2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ProofStepInduct.intro<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> ProofStepInduct.one_more_paths_exists not_case <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The previous theorem was the difficult direction of Menger's Theorem.  Let us now prove the other
  direction: If we have <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">n</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> disjoint paths, than every separator must contain at least
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">n</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> vertices.  This direction is rather trivial because every separator needs to separate
  at least the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">n</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> paths, so we do not need induction or an elaborate setup to prove this.
›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> v0_v1_Digraph<span class="main">)</span> menger_trivial<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="free">paths</span>"</span></span> <span class="quoted"><span class="quoted">"card <span class="free">paths</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">S</span><span class="main">.</span> Separation <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">S</span> <span class="main">⟹</span> card <span class="bound">S</span> <span class="main">≥</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> DisjointPaths <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="free">paths</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">S</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Separation <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="skolem">S</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> S<span class="main">:</span> Separation <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="skolem">S</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    Our plan is to show <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"card <span class="skolem"><span class="skolem">S</span></span> <span class="main"><span class="main">≥</span></span> <span class="free"><span class="free">n</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> by defining an injective function from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">paths</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
    into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">S</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  Because we have <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"card <span class="free"><span class="free">paths</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">n</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the result follows.

    For the injective function, we simply use the observation stated above: Every path needs to
    be separated by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">S</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> at some vertex, so we can choose such a vertex.
›</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="keyword1">SOME</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">∈</span> <span class="skolem">S</span> <span class="main">∧</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="bound">xs</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> f_good<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="free">paths</span> <span class="main">⟹</span> <span class="skolem">f</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="skolem">S</span> <span class="main">∧</span> <span class="skolem">f</span> <span class="bound">xs</span> <span class="main">∈</span> set <span class="bound">xs</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> <span class="free">paths</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">xs</span> <span class="main">∩</span> <span class="skolem">S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> S.S_separates paths <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">xs</span> <span class="main">∈</span> <span class="skolem">S</span> <span class="main">∧</span> <span class="skolem">f</span> <span class="skolem">xs</span> <span class="main">∈</span> set <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> f_def
      <span class="keyword1"><span class="command">using</span></span> someI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">∈</span> <span class="skolem">S</span> <span class="main">∧</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">f</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is injective because no two paths intersect in the same vertex.›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="skolem">f</span> <span class="free">paths</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span>
    <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> <span class="free">paths</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">∈</span> <span class="free">paths</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">ys</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="skolem">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">ys</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> f_good <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> *<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> paths_disjoint S.v0_notin_S S.v1_notin_S <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"card <span class="skolem">S</span> <span class="main">≥</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> f_good
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> S.finite_S finite_paths image_subsetI inj_on_iff_card_le<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Self-contained Statement of the Main Theorem›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Let us state both directions of Menger's Theorem again in a more self-contained way in the
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> Digraph<span class="antiquote"><span class="antiquote">}</span></span></span></span> locale. Stating the theorems in a self-contained way helps avoiding mistakes
  due to wrong definitions hidden in one of the numerous locales we used and also significantly
  reduces the work needed to review this formalization.

  With the statements below, all you need to do in order to verify that this formalization
  actually expresses Menger's Theorem (and not something else), is to look into the assumptions
  and definitions of the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> Digraph<span class="antiquote"><span class="antiquote">}</span></span></span></span> locale.
›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Digraph<span class="main">)</span> menger<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">v0</span> <span class="free">v1</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> v0_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> v1_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> v0_nonadj_v1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">v0</span><span class="main">→</span><span class="free">v1</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> v0_neq_v1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> no_small_separators<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">S</span><span class="main">.</span>
        <span class="main">⟦</span> <span class="bound">S</span> <span class="main">⊆</span> <span class="keyword1">V</span><span class="main">;</span> <span class="free">v0</span> <span class="main">∉</span> <span class="bound">S</span><span class="main">;</span> <span class="free">v1</span> <span class="main">∉</span> <span class="bound">S</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="free">v0</span> <span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span> <span class="free">v1</span> <span class="main">⟹</span> set <span class="bound">xs</span> <span class="main">∩</span> <span class="bound">S</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟧</span> <span class="main">⟹</span> card <span class="bound">S</span> <span class="main">≥</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">paths</span><span class="main">.</span> card <span class="bound">paths</span> <span class="main">=</span> <span class="free">n</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">xs</span> <span class="main">∈</span> <span class="bound">paths</span><span class="main">.</span>
    <span class="free">v0</span> <span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span> <span class="free">v1</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">ys</span> <span class="main">∈</span> <span class="bound">paths</span> <span class="main">-</span> <span class="main">{</span><span class="bound">xs</span><span class="main">}</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> set <span class="bound">xs</span> <span class="main">∩</span> set <span class="bound">ys</span><span class="main">.</span> <span class="bound">v</span> <span class="main">=</span> <span class="free">v0</span> <span class="main">∨</span> <span class="bound">v</span> <span class="main">=</span> <span class="free">v1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> v0_v1_Digraph <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="keyword1"><span class="command">using</span></span> v0_V v1_V v0_nonadj_v1 v0_neq_v1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">S</span><span class="main">.</span> Separation <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="bound">S</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">≤</span> card <span class="bound">S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> no_small_separators
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Separation.S_V Separation.S_separates Separation.v0_notin_S Separation.v1_notin_S<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">paths</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    paths<span class="main">:</span> <span class="quoted"><span class="quoted">"DisjointPaths <span class="free">G</span> <span class="free">v0</span> <span class="free">v1</span> <span class="skolem">paths</span>"</span></span> <span class="quoted"><span class="quoted">"card <span class="skolem">paths</span> <span class="main">=</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> no_small_separators menger <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DiffD1 DiffD2 DisjointPaths.paths DisjointPaths.paths_disjoint IntD1 IntD2 singletonI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Digraph<span class="main">)</span> menger_trivial<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">v0</span> <span class="free">v1</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> v0_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> v1_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> v0_nonadj_v1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">v0</span><span class="main">→</span><span class="free">v1</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> v0_neq_v1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">≠</span> <span class="free">v1</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> n_paths<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="free">paths</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> paths_disjoint<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span> <span class="main">∈</span> <span class="free">paths</span><span class="main">.</span>
        <span class="free">v0</span> <span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span> <span class="free">v1</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">ys</span> <span class="main">∈</span> <span class="free">paths</span> <span class="main">-</span> <span class="main">{</span><span class="bound">xs</span><span class="main">}</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> set <span class="bound">xs</span> <span class="main">∩</span> set <span class="bound">ys</span><span class="main">.</span> <span class="bound">v</span> <span class="main">=</span> <span class="free">v0</span> <span class="main">∨</span> <span class="bound">v</span> <span class="main">=</span> <span class="free">v1</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">S</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">S</span> <span class="main">⊆</span> <span class="keyword1">V</span><span class="main">;</span> <span class="free">v0</span> <span class="main">∉</span> <span class="bound">S</span><span class="main">;</span> <span class="free">v1</span> <span class="main">∉</span> <span class="bound">S</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="free">v0</span> <span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span> <span class="free">v1</span> <span class="main">⟹</span> set <span class="bound">xs</span> <span class="main">∩</span> <span class="bound">S</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟧</span> <span class="main">⟹</span> card <span class="bound">S</span> <span class="main">≥</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> v0_v1_Digraph <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="keyword1"><span class="command">using</span></span> v0_V v1_V v0_nonadj_v1 v0_neq_v1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">interpret</span></span> DisjointPaths <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="free">paths</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="free">paths</span> <span class="main">⟹</span> <span class="free">v0</span> <span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> paths_disjoint <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">v</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> <span class="free">paths</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">∈</span> <span class="free">paths</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">ys</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> <span class="free">paths</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">∈</span> <span class="free">paths</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">xs</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">xs</span> <span class="main">∩</span> set <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="free">v0</span> <span class="main">∨</span> <span class="skolem">v</span> <span class="main">=</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> paths_disjoint <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">S</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∉</span> <span class="skolem">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">∉</span> <span class="skolem">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="free">v0</span> <span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span> <span class="free">v1</span> <span class="main">⟹</span> set <span class="bound">xs</span> <span class="main">∩</span> <span class="skolem">S</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Separation <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">v1</span></span> <span class="quoted"><span class="skolem">S</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"card <span class="skolem">S</span> <span class="main">≥</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> menger_trivial DisjointPaths_axioms Separation_axioms n_paths <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>