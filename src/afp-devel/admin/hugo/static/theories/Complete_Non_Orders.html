<div id="Binary_Relations">
<div class="head"><h1>Theory Binary_Relations</h1>
<span class="command">theory</span> <span class="name">Binary_Relations</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
Author:  Akihisa Yamada (2018-2019)
License: LGPL (see file COPYING.LESSER)
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Binary Relations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We start with basic properties of binary relations.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Binary_Relations</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* uses mainly concepts from the theories Complete_Partial_Order, Wellfounded, Partial_Function *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Below we introduce an Isabelle-notation for $\{ \ldots x\ldots \mid x \in X \}$.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_range"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ pttrn ⇒ 'a set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1{_ /|./ _})"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_image"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ pttrn ⇒ 'a set ⇒ 'a set"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1{_ /|./ (_/ ∈ _)})"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{e |. p}"</span></span></span><span> </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST range (λp. e)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{e |. p ∈ A}"</span></span></span><span> </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST image (λp. e) A"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>image_constant</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ∈ I ⟹ f i = y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` I = (if I = {} then {} else {y})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Various Definitions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Here we introduce various definitions for binary relations.
The first one is our abbreviation for the dual of a relation.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>dual</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_<span class="hidden">⇧</span><sup>-</sup>)"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">]</span><span> </span><span>1000</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r<span class="hidden">⇧</span><sup>-</sup> x y ≡ r y x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conversep_as_dual</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"conversep r = r<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Monotonicity is already defined in the library.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monotone_dual</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone r s f ⟹ monotone r<span class="hidden">⇧</span><sup>-</sup> s<span class="hidden">⇧</span><sup>-</sup> f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>monotone_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monotone_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone r r id"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>monotone_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹So is the chain, but it is somehow hidden. We reactivate it.›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chain ≡ Complete_Partial_Order.chain"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>r</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Here we define the following notions in a standard manner:
(upper) bounds of a set:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound X b ≡ ∀x ∈ X. x ⊑ b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>boundI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀x. x ∈ X ⟹ x ⊑ b) ⟹ bound X b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>boundE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bound X b ⟹ ((⋀x. x ∈ X ⟹ x ⊑ b) ⟹ thesis) ⟹ thesis"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bound_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bound_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bound {} = (λx. True)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bound_insert</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (insert x X) b ⟷ x ⊑ b ∧ bound X b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bound_cmono</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ⊆ Y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound Y x ⟹ bound X x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Extreme (greatest) elements in a set:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme X e ≡ e ∈ X ∧ (∀x ∈ X. x ⊑ e)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extremeI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ X ⟹ (⋀x. x ∈ X ⟹ x ⊑ e) ⟹ extreme X e"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>extremeD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme X e ⟹ e ∈ X"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme X e ⟹ (⋀x. x ∈ X ⟹ x ⊑ e)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>extremeE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme X e ⟹ (e ∈ X ⟹ (⋀x. x ∈ X ⟹ x ⊑ e) ⟹ thesis) ⟹ thesis"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extreme_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_UNIV</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme UNIV t ⟷ (∀x. x ⊑ t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extremes_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme X b ⟹ extreme X c ⟹ b ⊑ c ∧ c ⊑ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Directed sets:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"directed X ≡ ∀x ∈ X. ∀ y ∈ X. ∃z ∈ X. x ⊑ z ∧ y ⊑ z"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>directedE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"directed X"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ X"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ X"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀z. z ∈ X ⟹ x ⊑ z ⟹ y ⊑ z ⟹ thesis"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"thesis"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>directed_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>directedI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. x ∈ X ⟹ y ∈ X ⟹ ∃z ∈ X. x ⊑ z ∧ y ⊑ z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"directed X"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>directed_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chain_imp_directed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chain (⊑) X ⟹ directed X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>directedI</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>chainE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹And sets of elements which are self-related:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reflexive_on X ≡ ∀x ∈ X. x ⊑ x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reflexive_onI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. x ∈ X ⟹ x ⊑ x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reflexive_on X"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>reflexive_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reflexive_onE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reflexive_on X"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀x. x ∈ X ⟹ x ⊑ x) ⟹ thesis"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>reflexive_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chain_imp_reflexive</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chain (⊑) X ⟹ reflexive_on X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>chainE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>r</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Now suprema and infima are given uniformly as follows. ›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound X ≡ extreme (λx y. y ⊑ x) {b. bound (⊑) X b}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_boundI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀b. bound (⊑) X b ⟹ s ⊑ b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. x ∈ X ⟹ x ⊑ s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound X s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_bound_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>XY</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ⊆ Y"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound X bX"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bY</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound Y bY"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bX ⊑ bY"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) X bY"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>XY</span><span> </span><span>bY</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>bX</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_bound_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound X b ⟷ (∀c. (∀x∈X. x ⊑ c) ⟶ b ⊑ c) ∧ (∀x ∈ X. x ⊑ b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extreme_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_bound_singleton_refl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"extreme_bound {x} x ⟷ x ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_bound_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound X b ⟹ c ∈ X ⟹ b ⊑ c ⟹ c ⊑ b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_bound_image_const</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ⊑ x ⟹ C ≠ {} ⟹ (⋀i. i ∈ C ⟹ f i = x) ⟹ extreme_bound (f ` C) x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_constant</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_bound_UN_const</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ⊑ x ⟹ C ≠ {} ⟹ (⋀i y. i ∈ C ⟹ P i y ⟷ x = y) ⟹
  extreme_bound (⋃i∈C. {y. P i y}) x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>r</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fun_ordI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀x. f x ⊑ g x) ⟹ fun_ord (⊑) f g"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fun_ordD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fun_ord (⊑) f g ⟹ f x ⊑ g x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_ord_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dual_fun_ord</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fun_ord (⊑))<span class="hidden">⇧</span><sup>-</sup> = fun_ord (⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>ext</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_ord_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fun_extreme_bound_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (fun_ord (⊑)) F e ⟷ (∀x. extreme_bound (⊑) {f x |. f ∈ F} (e x))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l ⟷ ?r"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span> </span><span>allI</span><span> </span><span>extreme_boundI</span><span> </span><span>fun_ordI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?r</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {f x |. f ∈ F} (e x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ F ⟹ f x ⊑ e x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extremeD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>e</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (fun_ord (⊑)) F f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) {f x |. f ∈ F} (f x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_ord_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e x ⊑ f x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="var">?l</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ F ⟹ f x ⊑ e x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span>extremeD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_ord_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ {f x |. f ∈ F} ⟹ y ⊑ e x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) {f x |. f ∈ F} y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>extremeD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>l</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (fun_ord (⊑)) F (e(x:=y))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_ord_def</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span>boundE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>l</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fun_ord (⊑) e (e(x:=y))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fun_ordD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e x ⊑ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ir</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i ⇒ 'i ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≼"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (≼) (⊑) f"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monotone_chain_image</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>chain</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chain (≼) C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chain (⊑) (f ` C)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>chainI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ f ` C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ f ` C"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ij</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ C"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = f i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = f j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>chain</span><span> </span><span>ij</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≼ j ∨ j ≼ i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>chainE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ij</span><span> </span><span>mono</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y ∨ y ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>monotoneD</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monotone_directed_image</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>dir</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"directed (≼) D"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"directed (⊑) (f ` D)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>directedI</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ D"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ D"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>dir</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ D"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≼ z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≼ z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>directedE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mono</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ⊑ f z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f y ⊑ f z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>monotoneD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>z</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃fz ∈ f ` D. f x ⊑ fz ∧ f y ⊑ fz"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>e</span><span> </span><span>C</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme (≼) C e"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monotone_extreme_imp_extreme_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) (f ` C) (f e)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>monotoneD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono</span><span class="delimiter">]</span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>extreme_boundI</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span>extremeE</span><span> </span><span>boundE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monotone_extreme_extreme_boundI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x = f e ⟹ extreme_bound (⊑) (f ` C) x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>monotone_extreme_imp_extreme_bound</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Locales for Binary Relations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We now define basic properties of binary relations,
in form of \emph{locales}~\cite{Kammuller00,locale}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Syntactic Locales›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following locales do not assume anything, but provide infix notations for
relations. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">=</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>less_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>less_syntax</span><span> </span><span class="delimiter">=</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>less</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊏"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>equivalence_syntax</span><span> </span><span class="delimiter">=</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>equiv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∼"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>equiv_class</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"[_]<span class="hidden">⇩</span><sub>∼</sub>"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[x]<span class="hidden">⇩</span><sub>∼</sub> ≡ { y. x ∼ y }"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next ones introduce abbreviations for dual etc.
To avoid needless constants, one should be careful when declaring them as sublocales.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>less_eq_dualize</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>greater_eq</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊒"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊒ y ≡ y ⊑ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>equiv</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∼"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∼ y ≡ x ⊑ y ∧ y ⊑ x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equiv_sym</span><span class="delimiter">[</span><span>sym</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∼ y ⟹ y ∼ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>less_dualize</span><span> </span><span class="delimiter">=</span><span> </span><span>less_syntax</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>greater</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊐"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊐ y ≡ y ⊏ x"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic Properties of Relations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In the following we define basic properties in form of locales.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>reflexive</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>refl</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_implies</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y ⟹ x ⊑ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_singleton</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme (⊑) {x} y ⟷ x = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_bound_singleton</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {x} x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>reflexiveI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>reflexive.intro</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>irreflexive</span><span> </span><span class="delimiter">=</span><span> </span><span>less_syntax</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>irrefl</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ x ⊏ x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>implies_not_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊏ y ⟹ x ≠ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>irreflexiveI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>irreflexive.intro</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>transitive</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y ⟹ y ⊑ z ⟹ x ⊑ z"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>transitive.intro</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>symmetric</span><span> </span><span class="delimiter">=</span><span> </span><span>equivalence_syntax</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sym</span><span class="delimiter">[</span><span>sym</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∼ y ⟹ y ∼ x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dual_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∼)<span class="hidden">⇧</span><sup>-</sup> = (∼)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>symmetric.intro</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>antisymmetric</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>antisym</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y ⟹ y ⊑ x ⟹ x = y"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>less_eq_dualize</span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equiv_iff_eq_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∼ y ⟷ x = y ∧ y ⊑ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_unique</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme (⊑) X x ⟹ extreme (⊑) X y ⟷ x = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>extremeE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ex_extreme_iff_ex1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme (⊑) X) ⟷ Ex1 (extreme (⊑) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extreme_unique</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ex_extreme_iff_the</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme (⊑) X) ⟷ extreme (⊑) X (The (extreme (⊑) X))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span>  </span><span>theI'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extreme_unique</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>antisymmetricI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>antisymmetric.intro</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following notion is new, generalizing antisymmetry and transitivity.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>semiattractive</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>attract</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y ⟹ y ⊑ x ⟹ x ⊑ z ⟹ y ⊑ z"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>less_eq_dualize</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equiv_trans</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>xy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∼ y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>yz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∼ z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∼ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>attract</span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>x</span><span> </span><span>z</span><span class="delimiter">]</span><span> </span><span>attract</span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>xy</span><span> </span><span>yz</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_bound_quasi_const</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>const</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y ∈ C. y ∼ x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) C x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>extreme_boundI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>C</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>const</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∼ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) C b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>attract</span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span> </span><span>x</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span>cb</span><span> </span><span>cx</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ C"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>const</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_bound_quasi_const_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>const</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z ∈ C. z ∼ x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) C y ⟷ x ∼ y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) C y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>const</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∼ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>C</span><span> </span><span>extreme_bound_quasi_const</span><span> </span><span>extremes_equiv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∼ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>const</span><span> </span><span>equiv_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Cy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z ∈ C. z ∼ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) C y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extreme_bound_quasi_const</span><span class="delimiter">[</span><span>OF</span><span> </span><span>C</span><span> </span><span>Cy</span><span class="delimiter">]</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>attractive</span><span> </span><span class="delimiter">=</span><span> </span><span>semiattractive</span><span> </span><span class="delimiter">+</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>semiattractive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>transitive</span><span> </span><span class="delimiter">⊆</span><span> </span><span>attractive</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>antisymmetric</span><span> </span><span class="delimiter">⊆</span><span> </span><span>attractive</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>asymmetric</span><span> </span><span class="delimiter">=</span><span> </span><span>irreflexive</span><span> </span><span class="delimiter">+</span><span> </span><span>strict</span><span class="delimiter">:</span><span> </span><span>antisymmetric</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>asym</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊏ y ⟹ y ⊏ x ⟹ thesis"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>less</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊏"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>asymmetricI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. x ⊏ y ⟹ y ⊏ x ⟹ False"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"asymmetric (⊏)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>asymmetric_def'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"asymmetric (⊏) ≡ ∀x y. ¬ (x ⊏ y ∧ y ⊏ x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atomize_eq</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>asymmetric.asym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>well_founded</span><span> </span><span class="delimiter">=</span><span> </span><span>less_syntax</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>induct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀P a. (⋀x. (⋀y. y ⊏ x ⟹ P y) ⟹ P x) ⟹ P a"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wfP</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (⊏)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>induct</span><span> </span><span>wfPUNIVI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>asymmetric</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>asymmetricI</span><span> </span><span>notI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊏ y ⟹ y ⊏ x ⟹ False"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Combined Properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Some combinations of the above basic properties are given names.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>quasi_order</span><span> </span><span class="delimiter">=</span><span> </span><span>reflexive</span><span> </span><span class="delimiter">+</span><span> </span><span>transitive</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>near_order</span><span> </span><span class="delimiter">=</span><span> </span><span>antisymmetric</span><span> </span><span class="delimiter">+</span><span> </span><span>transitive</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>pseudo_order</span><span> </span><span class="delimiter">=</span><span> </span><span>reflexive</span><span> </span><span class="delimiter">+</span><span> </span><span>antisymmetric</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equiv_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y ∧ y ⊑ x ⟷ x = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_bound_singleton_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {x} y ⟷ x = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y ⟷ x ⊑ y ∧ y ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_order_iff_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme (⊑) {x. x ⊑ e} s ⟷ e = s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>partial_order</span><span> </span><span class="delimiter">=</span><span> </span><span>quasi_order</span><span> </span><span class="delimiter">+</span><span> </span><span>antisymmetric</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>partial_order</span><span> </span><span class="delimiter">⊆</span><span> </span><span>pseudo_order</span><span> </span><span class="delimiter">+</span><span> </span><span>near_order</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>strict_order</span><span> </span><span class="delimiter">=</span><span> </span><span>irreflexive</span><span> </span><span class="delimiter">+</span><span> </span><span>transitive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>strict_order</span><span> </span><span class="delimiter">⊆</span><span> </span><span>asymmetric</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>strict_order</span><span> </span><span class="delimiter">⊆</span><span> </span><span>near_order</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>well_founded_order</span><span> </span><span class="delimiter">=</span><span> </span><span>well_founded</span><span> </span><span class="delimiter">+</span><span> </span><span>transitive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>well_founded_order</span><span> </span><span class="delimiter">⊆</span><span> </span><span>strict_order</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>tolerance</span><span> </span><span class="delimiter">=</span><span> </span><span>equivalence_syntax</span><span> </span><span class="delimiter">+</span><span> </span><span>reflexive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∼)"</span></span></span><span> </span><span class="delimiter">+</span><span> </span><span>symmetric</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∼)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>partial_equivalence</span><span> </span><span class="delimiter">=</span><span> </span><span>equivalence_syntax</span><span> </span><span class="delimiter">+</span><span> </span><span>symmetric</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∼)"</span></span></span><span> </span><span class="delimiter">+</span><span> </span><span>transitive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∼)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>equivalence</span><span> </span><span class="delimiter">=</span><span> </span><span>equivalence_syntax</span><span> </span><span class="delimiter">+</span><span> </span><span>symmetric</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∼)"</span></span></span><span> </span><span class="delimiter">+</span><span> </span><span>quasi_order</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∼)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>equivalence</span><span> </span><span class="delimiter">⊆</span><span> </span><span>partial_equivalence</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Some combinations lead to uninteresting relations.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span> </span><span>reflexive_irreflexive_is_empty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reflexive r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irreflexive r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = (λx y. False)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>irreflexive</span><span> </span><span>r</span><span> </span><span class="delimiter">+</span><span> </span><span>reflexive</span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>irrefl</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>refl</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span> </span><span>symmetric_antisymmetric_imp_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"symmetric r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"antisymmetric r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r x y ⟹ x = y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>symmetric</span><span> </span><span>r</span><span> </span><span class="delimiter">+</span><span> </span><span>antisymmetric</span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>sym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span> </span><span>nontolerance</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>r</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⨝"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irreflexive (⨝) ∧ symmetric (⨝) ⟷ tolerance (λx y. ¬ x ⨝ y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irreflexive (⨝)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"symmetric (⨝)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>irreflexive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨝)"</span></span></span><span> </span><span class="delimiter">+</span><span> </span><span>symmetric</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨝)"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tolerance (λx y. ¬ x ⨝ y)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tolerance (λx y. ¬ x ⨝ y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>tolerance</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx y. ¬ x ⨝ y"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irreflexive (⨝)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"symmetric (⨝)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span> </span><span>irreflexive_transitive_symmetric_is_empty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irreflexive r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"transitive r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"symmetric r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = (λx y. False)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>strict_order</span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>strict_order_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>symmetric</span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>sym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r x x"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Totality›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>total</span><span> </span><span class="delimiter">=</span><span> </span><span>less_syntax</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>total</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊏ y ∨ x = y ∨ y ⊏ x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cases</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>less</span><span> </span><span>eq</span><span> </span><span>greater</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊏ y ⟹ P"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y ⟹ P"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ⊏ x ⟹ P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>total</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>neqE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ y ⟹ (x ⊏ y ⟹ P) ⟹ (y ⊏ x ⟹ P) ⟹ P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cases</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>totalI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>total.intro</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Totality is negated antisymmetry \cite[Proposition 2.2.4]{Schmidt1993}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span> </span><span>total_iff_neg_antisymmetric</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>less</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊏"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"total (⊏) ⟷ antisymmetric (λx y. ¬ x ⊏ y)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l ⟷ ?r"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span> </span><span>totalI</span><span> </span><span>antisymmetricI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?l</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>total</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ x ⊏ y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ y ⊏ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cases</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?r</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>neg</span><span class="delimiter">:</span><span> </span><span>antisymmetric</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx y. ¬ x ⊏ y)"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊏ y ∨ x = y ∨ y ⊏ x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg.antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>total_irreflexive</span><span> </span><span class="delimiter">=</span><span> </span><span>total</span><span> </span><span class="delimiter">+</span><span> </span><span>irreflexive</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>neq_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ y ⟷ x ⊏ y ∨ y ⊏ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>neqE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>total_reflexive</span><span> </span><span class="delimiter">=</span><span> </span><span>reflexive</span><span> </span><span class="delimiter">+</span><span> </span><span>weak</span><span class="delimiter">:</span><span> </span><span>total</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comparable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y ∨ y ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span>weak.cases</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comparable_cases</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>le</span><span> </span><span>ge</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y ⟹ P"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ⊑ x ⟹ P"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>comparable</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chain_UNIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chain (⊑) UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>chainI</span><span> </span><span>comparable</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>less_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>total_reflexiveI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. x ⊑ y ∨ y ⊑ x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"total_reflexive (⊑)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>total_reflexive_def'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"total_reflexive (⊑) ≡ ∀x y. x ⊑ y ∨ y ⊑ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>atomize_eq</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>total_reflexive.comparable</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>total_pseudo_order</span><span> </span><span class="delimiter">=</span><span> </span><span>total_reflexive</span><span> </span><span class="delimiter">+</span><span> </span><span>antisymmetric</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>pseudo_order</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_weak_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ y ⊑ x ⟷ x ⊑ y ∧ x ≠ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span>comparable_cases</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>total_quasi_order</span><span> </span><span class="delimiter">=</span><span> </span><span>total_reflexive</span><span> </span><span class="delimiter">+</span><span> </span><span>transitive</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>quasi_order</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>total_order</span><span> </span><span class="delimiter">=</span><span> </span><span>total_quasi_order</span><span> </span><span class="delimiter">+</span><span> </span><span>antisymmetric</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>partial_order</span><span> </span><span class="delimiter">+</span><span> </span><span>total_pseudo_order</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A strict total order defines a total weak order, so we will formalize
it after giving locales for pair of weak and strict parts.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Order Pairs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>compatible_ordering</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">+</span><span> </span><span>less_syntax</span><span> </span><span class="delimiter">+</span><span> </span><span>reflexive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)"</span></span></span><span> </span><span class="delimiter">+</span><span> </span><span>irreflexive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>weak_strict_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y ⟹ y ⊏ z ⟹ x ⊏ z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>strict_weak_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊏ y ⟹ y ⊑ z ⟹ x ⊏ z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>strict_implies_weak</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊏ y ⟹ x ⊑ y"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The strict part is necessarily transitive.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>strict</span><span class="delimiter">:</span><span> </span><span>transitive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weak_strict_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>strict_implies_weak</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following sequence of declarations are in order to obtain fact names in a manner
similar to the Isabelle/HOL facts of orders.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>strict_order</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>strict</span><span class="delimiter">:</span><span> </span><span>near_order</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>asymmetric</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>strict_order</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>strict.antisym</span><span> </span><span>strict.trans</span><span> </span><span>asym</span><span> </span><span>irrefl</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_implies_not_weak</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊏ y ⟹ ¬ y ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>strict_weak_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>attractive_ordering</span><span> </span><span class="delimiter">=</span><span> </span><span>compatible_ordering</span><span> </span><span class="delimiter">+</span><span> </span><span>attractive</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>pseudo_ordering</span><span> </span><span class="delimiter">=</span><span> </span><span>compatible_ordering</span><span> </span><span class="delimiter">+</span><span> </span><span>antisymmetric</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>pseudo_order</span><span> </span><span class="delimiter">+</span><span> </span><span>attractive_ordering</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>quasi_ordering</span><span> </span><span class="delimiter">=</span><span> </span><span>compatible_ordering</span><span> </span><span class="delimiter">+</span><span> </span><span>transitive</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>quasi_order</span><span> </span><span class="delimiter">+</span><span> </span><span>attractive_ordering</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>partial_ordering</span><span> </span><span class="delimiter">=</span><span> </span><span>compatible_ordering</span><span> </span><span class="delimiter">+</span><span> </span><span>near_order</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>partial_order</span><span> </span><span class="delimiter">+</span><span> </span><span>pseudo_ordering</span><span> </span><span class="delimiter">+</span><span> </span><span>quasi_ordering</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>well_founded_ordering</span><span> </span><span class="delimiter">=</span><span> </span><span>quasi_ordering</span><span> </span><span class="delimiter">+</span><span> </span><span>well_founded</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>total_ordering</span><span> </span><span class="delimiter">=</span><span> </span><span>compatible_ordering</span><span> </span><span class="delimiter">+</span><span> </span><span>total_order</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>partial_ordering</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>strict_total_ordering</span><span> </span><span class="delimiter">=</span><span> </span><span>partial_ordering</span><span> </span><span class="delimiter">+</span><span> </span><span>total</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>total_irreflexive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>total_reflexive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y ∨ y ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cases</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>strict_implies_weak</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>total_ordering</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>old</span><span class="delimiter">:</span><span> </span><span>ordering</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ⊑ b ⟹ a ≠ b ⟹ a ⊏ b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cases</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>strict_implies_weak</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordering (⊑) (⊏)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>strict_implies_weak</span><span> </span><span>trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_weak</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ x ⊑ y ⟷ y ⊏ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_weak_iff</span><span> </span><span>old.strict_iff_order</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_strict</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ x ⊏ y ⟷ y ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>old.strict_iff_order</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A locale which defines an equivalence relation. Be careful when declaring simp rules etc.,
as the equivalence will often be rewritten to equality.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>quasi_order_equivalence</span><span> </span><span class="delimiter">=</span><span> </span><span>quasi_order</span><span> </span><span class="delimiter">+</span><span> </span><span>equivalence_syntax</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>equiv_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∼ y ⟷ x ⊑ y ∧ y ⊑ x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>equiv</span><span class="delimiter">:</span><span> </span><span>equivalence</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>equiv_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>equiv_weak_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∼ y ⟹ y ⊑ z ⟹ x ⊑ z"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>weak_equiv_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y ⟹ y ∼ z ⟹ x ⊑ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>equiv_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_order_iff_equiv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme (⊑) {x. x ⊑ e} y ⟷ e ∼ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>equiv_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>extremeI</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_bound_iff_equiv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) X b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) X c ⟷ b ∼ c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bX</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) X b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>leastb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. bound (⊑) X x ⟹ b ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) X c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cbounds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) X c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>leastc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀b. bound (⊑) X b ⟹ c ⊑ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>leastb</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cbounds</span><span class="delimiter">]</span><span> </span><span>leastc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bX</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∼ c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>equiv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>bc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∼ c"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) X c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>extreme_boundI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ X"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>bX</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>bc</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>trans</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>equiv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) X x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>leastb</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>bc</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>trans</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>equiv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extremes_are_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme (⊑) X x ⟹ extreme (⊑) X y ⟹ x ∼ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>equiv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>quasi_ordering_equivalence</span><span> </span><span class="delimiter">=</span><span> </span><span>compatible_ordering</span><span> </span><span class="delimiter">+</span><span> </span><span>quasi_order_equivalence</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>equiv_strict_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∼ y ⟹ y ⊏ z ⟹ x ⊏ z"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>strict_equiv_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊏ y ⟹ y ∼ z ⟹ x ⊏ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>equiv_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>weak_strict_trans</span><span> </span><span>strict_weak_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Relating to Classes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In Isabelle 2019 (and earlier), we should declare sublocales in class before declaring dual
sublocales, since otherwise facts would be prefixed by ``dual.dual.''›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>ord</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>upper_bound</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"upper_bound ≡ bound (≤)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>least</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"least ≡ extreme (λx y. y ≤ x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>lower_bound</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lower_bound ≡ bound (λx y. y ≤ x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>greatest</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"greatest ≡ extreme (≤)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>supremum</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"supremum ≡ extreme_bound (≤)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>infimum</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"infimum ≡ extreme_bound (λx y. y ≤ x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Least_eq_The_least</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Least P = The (least {x. P x})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Least_def</span><span> </span><span>extreme_def</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>atomize_eq</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>ext</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Greatest_eq_The_greatest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Greatest P = The (greatest {x. P x})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Greatest_def</span><span> </span><span>extreme_def</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>atomize_eq</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>ext</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fun_ord_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fun_ord (≤) = (≤)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_ord_def</span><span> </span><span>le_fun_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fun_ord_ge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fun_ord (≥) = (≥)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_ord_def</span><span> </span><span>le_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fun_supremum_iff</span><span> </span><span class="delimiter">=</span><span> </span><span>fun_extreme_bound_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤)"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>fun_ord_le</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fun_infimum_iff</span><span> </span><span class="delimiter">=</span><span> </span><span>fun_extreme_bound_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(≥)"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>fun_ord_ge</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>compat</span><span> </span><span class="delimiter">=</span><span> </span><span>ord</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compatible_ordering (≤) (&lt;)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>compatible_ordering</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compat_axioms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>class.compat_def</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We should have imported locale-based facts in classes, e.g.:›</span></span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>order.trans</span><span> </span><span>order.strict.trans</span><span> </span><span>order.refl</span><span> </span><span>order.irrefl</span><span> </span><span>order.asym</span><span> </span><span>order.extreme_bound_singleton</span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>attractive_order</span><span> </span><span class="delimiter">=</span><span> </span><span>ord</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"attractive_ordering (≤) (&lt;)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>attractive_ordering</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>attractive_order_axioms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>class.attractive_order_def</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>compat</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>attractive_ordering</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>order.extreme_bound_quasi_const</span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>psorder</span><span> </span><span class="delimiter">=</span><span> </span><span>ord</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pseudo_ordering (≤) (&lt;)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We need to declare subclasses before sublocales in order to preserve facts for superclasses.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>pseudo_ordering</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>psorder_axioms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>class.psorder_def</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>attractive_order</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>pseudo_ordering</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>qorder</span><span> </span><span class="delimiter">=</span><span> </span><span>ord</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"quasi_ordering (≤) (&lt;)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>quasi_ordering</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qorder_axioms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>class.qorder_def</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>attractive_order</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>quasi_ordering</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>porder</span><span> </span><span class="delimiter">=</span><span> </span><span>ord</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"partial_ordering (≤) (&lt;)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>partial_ordering</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>porder_axioms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>class.porder_def</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>psorder</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>qorder</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>partial_ordering</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>wf_qorder</span><span> </span><span class="delimiter">=</span><span> </span><span>ord</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"well_founded_ordering (≤) (&lt;)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>well_founded_ordering</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_qorder_axioms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>class.wf_qorder_def</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>qorder</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>well_founded_ordering</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>totalorder</span><span> </span><span class="delimiter">=</span><span> </span><span>ord</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"total_ordering (≤) (&lt;)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>total_ordering</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>totalorder_axioms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>class.totalorder_def</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>porder</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>total_ordering</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Isabelle/HOL's @{class preorder} belongs to @{class qorder}, but not vice versa.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>preorder</span><span class="delimiter">)</span><span> </span><span>qorder</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>le_less_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>less_le_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>less_imp_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>order</span><span class="delimiter">)</span><span> </span><span>porder</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>wellorder</span><span class="delimiter">)</span><span> </span><span>wf_qorder</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>fact</span><span> </span><span>less_induct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Isabelle/HOL's @{class linorder} is equivalent to our locale @{locale strict_total_ordering}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>linorder</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>strict_total_ordering</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>totalorder</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>strict_total_ordering</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Tests: facts should be available in the most general classes.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>order.strict.trans</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a::compat"</span></span></span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>order.extreme_bound_quasi_const</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a::attractive_order"</span></span></span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>order.extreme_bound_singleton_eq</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a::psorder"</span></span></span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>order.trans</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a::qorder"</span></span></span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>order.comparable_cases</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a::totalorder"</span></span></span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>order.cases</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a::linorder"</span></span></span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Declaring Duals›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹At this point, we declare dual as sublocales.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>less_eq_syntax</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>reflexive</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>reflexive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>attractive</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>attractive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>irreflexive</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>irreflexive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>transitive</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>transitive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>antisymmetric</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>antisymmetric</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>asymmetric</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>asymmetric</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>total</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>total</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>total_reflexive</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>total_reflexive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>total_irreflexive</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>total_irreflexive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>pseudo_order</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>pseudo_order</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>quasi_order</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>quasi_order</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>partial_order</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>partial_order</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In the following dual sublocale declaration, ``rewrites'' eventually cleans up redundant
facts.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>symmetric</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>symmetric</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∼)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">rewrites</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∼)<span class="hidden">⇧</span><sup>-</sup> = (∼)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>symmetric_axioms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dual_sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>equivalence</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>equivalence</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∼)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">rewrites</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∼)<span class="hidden">⇧</span><sup>-</sup> = (∼)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dual_sym</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>total_pseudo_order</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>total_pseudo_order</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>total_quasi_order</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>total_quasi_order</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>compatible_ordering</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>compatible_ordering</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weak_strict_trans</span><span> </span><span>strict_weak_trans</span><span> </span><span>strict_implies_weak</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>attractive_ordering</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>attractive_ordering</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>pseudo_ordering</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>pseudo_ordering</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>quasi_ordering</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>quasi_ordering</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>partial_ordering</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>partial_ordering</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>total_ordering</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>total_ordering</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊏)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>antisymmetric</span><span class="delimiter">)</span><span> </span><span>monotone_extreme_imp_extreme_bound_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ir</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≼"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (≼) (⊑) f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme (≼) C i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) (f ` C) x ⟷ f i = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dual.extreme_unique</span><span> </span><span>monotone_extreme_extreme_boundI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Instantiations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we instantiate our classes for sanity check.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>nat</span><span> </span><span class="delimiter">::</span><span> </span><span>linorder</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pointwise ordering of functions are compatible only if the weak part is transitive.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fun"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>type</span><span class="delimiter">,</span><span>qorder</span><span class="delimiter">)</span><span> </span><span>compat</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro_classes</span><span class="delimiter">,</span><span> </span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>le_fun_def</span><span> </span><span>less_fun_def</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span>h</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>fg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ≤ g"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; h"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f &lt; h"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>less_fun_def</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conjI</span><span> </span><span>le_funI</span><span> </span><span>notI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ≤ g x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>gh</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g x ≤ h x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ≤ h x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h ≤ f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h x ≤ f x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ≤ g x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ≤ g"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>gh</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>fg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f &lt; g"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g ≤ h"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f &lt; h"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>less_fun_def</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conjI</span><span> </span><span>le_funI</span><span> </span><span>notI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ≤ g x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>gh</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g x ≤ h x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ≤ h x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h ≤ f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h x ≤ f x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>gh</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g x ≤ h x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ≤ f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fg</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f &lt; g ⟹ f ≤ g"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬f &lt; f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ≤ f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fun"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>type</span><span class="delimiter">,</span><span>qorder</span><span class="delimiter">)</span><span> </span><span>qorder</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro_classes</span><span class="delimiter">,</span><span> </span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>le_fun_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fun"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>type</span><span class="delimiter">,</span><span>porder</span><span class="delimiter">)</span><span> </span><span>porder</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro_classes</span><span class="delimiter">,</span><span> </span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_fun_def</span><span> </span><span>le_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Complete_Relations">
<div class="head"><h1>Theory Complete_Relations</h1>
<span class="command">theory</span> <span class="name">Complete_Relations</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Real.html"><span class="name">Real</span></a> <a href="Binary_Relations.html"><span class="name">Binary_Relations</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
Author:  Akihisa Yamada (2018-2019)
License: LGPL (see file COPYING.LESSER)
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Completeness of Relations ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Here we formalize various order-theoretic completeness conditions.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Complete_Relations</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>HOL.Real</span><span> </span><span>Binary_Relations</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Completeness Conditions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Order-theoretic completeness demands certain subsets of elements to admit suprema or infima.

A related set $\tp{A,\SLE}$ is called \emph{bounded} if there is a ``top'' element $\top \in A$,
a greatest element in $A$.
Note that there might be multiple tops if $(\SLE)$ is not antisymmetric.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>bounded</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bounded</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃t. ∀x. x ⊑ t"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ex_bound</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (bound (⊑) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bounded</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ex_extreme_UNIV</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme (⊑) UNIV)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bounded</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>UNIV_complete</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) UNIV)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bounded</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dual_empty_complete</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑)<span class="hidden">⇧</span><sup>-</sup> {})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bound_empty</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>less_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded_iff_extreme_UNIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bounded (⊑) ⟷ Ex (extreme (⊑) UNIV)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>bounded_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Boundedness can be also seen as a completeness condition,
since it is equivalent to saying that the universe has a supremum.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded_iff_UNIV_complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bounded (⊑) ⟷ Ex (extreme_bound (⊑) UNIV)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>bounded_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The dual notion of bounded is called ``pointed'', equivalently ensuring a supremum
of the empty set.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pointed_iff_empty_complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bounded (⊑) ⟷ Ex (extreme_bound (⊑)<span class="hidden">⇧</span><sup>-</sup> {})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>bounded_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹One of the most well-studied notion of completeness would be the semilattice condition:
every pair of elements $x$ and $y$ has a supremum $x \sqcup y$
(not necessarily unique if the underlying relation is not antisymmetric).›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>pair_complete</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>pair_complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) {x,y})"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>directed_UNIV</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"directed (⊑) UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'a</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pair_complete</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z ∈ UNIV. x ⊑ z ∧ y ⊑ z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>total_reflexive</span><span> </span><span class="delimiter">⊆</span><span> </span><span>pair_complete</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) {x, y})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span>comparable_cases</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The next one assumes that every nonempty finite set has a supremum.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>finite_complete</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite_nonempty_complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite X ⟹ X ≠ {} ⟹ Ex (extreme_bound (⊑) X)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>finite_complete</span><span> </span><span class="delimiter">⊆</span><span> </span><span>pair_complete</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>finite_nonempty_complete</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The next one assumes that every nonempty bounded set has a supremum.
It is also called the Dedekind completeness.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>conditionally_complete</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bounded_nonempty_complete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ex (bound (⊑) X) ⟹ X ≠ {} ⟹ Ex (extreme_bound (⊑) X)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded_nonemptyE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (bound (⊑) X)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) X) ⟹ X ≠ {} ⟹ thesis"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>bounded_nonempty_complete</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonempty_imp_complete_iff_bounded</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≠ {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) X) ⟷ Ex (bound (⊑) X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>bounded_nonempty_complete</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The $\omega$-completeness condition demands a supremum for an $\omega$-chain,
  $a_1 \sqsubseteq a_2 \sqsubseteq \dots$.
  We model $\omega$-chain as the range of a monotone map $f : i \mapsto a_i$.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>omega_complete</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>monotone_seq_complete</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀f :: nat ⇒ 'a. monotone (≤) (⊑) f ⟹ Ex (extreme_bound (⊑) (range f))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>chain_complete</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>chain_nonempty_complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chain (⊑) X ⟹ X ≠ {} ⟹ Ex (extreme_bound (⊑) X)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monotone_chain_complete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>C0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>chain</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chain r C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone r (⊑) f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) (f ` C))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>chain_nonempty_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>monotone_chain_image</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono</span><span> </span><span>chain</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>chain_complete</span><span> </span><span class="delimiter">⊆</span><span> </span><span>omega_complete</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>monotone_chain_complete</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>chainI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹\emph{Directed completeness} is an important notion in domain theory~\cite{abramski94},
asserting that every nonempty directed set has a supremum.
Here, a set $X$ is \emph{directed} if any pair of two elements in $X$ has a bound in $X$.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>directed_complete</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>directed_nonempty_complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"directed (⊑) X ⟹ X ≠ {} ⟹ Ex (extreme_bound (⊑) X)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monotone_directed_complete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>dir</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"directed r C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone r (⊑) f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) (f ` C))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>directed_nonempty_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>monotone_directed_image</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono</span><span> </span><span>dir</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>directed_complete</span><span> </span><span class="delimiter">⊆</span><span> </span><span>chain_complete</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>directed_nonempty_complete</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>chain_imp_directed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The next one is quite complete, only the empty set may fail to have a supremum.
The terminology follows \cite{Bergman2015},
although there it is defined more generally depending on a cardinal $\alpha$
such that a nonempty set $X$ of cardinality below $\alpha$ has a supremum.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>semicomplete</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonempty_complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≠ {} ⟹ Ex (extreme_bound (⊑) X)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>semicomplete</span><span> </span><span class="delimiter">⊆</span><span> </span><span>conditionally_complete</span><span> </span><span class="delimiter">+</span><span> </span><span>finite_complete</span><span> </span><span class="delimiter">+</span><span> </span><span>directed_complete</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>nonempty_complete</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>semicomplete</span><span> </span><span class="delimiter">⊆</span><span> </span><span>bounded</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bounded_iff_UNIV_complete</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nonempty_complete</span><span class="delimiter">[</span><span>of</span><span> </span><span>UNIV</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pointed Ones›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The term `pointed' refers to the dual notion of boundedness, i.e., there is a global least element.
  This serves as the supremum of the empty set.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>pointed_chain_complete</span><span> </span><span class="delimiter">=</span><span> </span><span>chain_complete</span><span> </span><span class="delimiter">+</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>bounded</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chain_complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chain (⊑) X ⟹ Ex (extreme_bound (⊑) X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"X = {}"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>chain_nonempty_complete</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pointed_chain_complete_def'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>less_eq</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pointed_chain_complete (⊑) ≡ ∀X. chain (⊑) X ⟶ Ex (extreme_bound (⊑) X)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l ≡ ?r"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>atomize_eq</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>pointed_chain_complete.chain_complete</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>chain_empty</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pointed_iff_empty_complete</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>bounded_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>pointed_directed_complete</span><span> </span><span class="delimiter">=</span><span> </span><span>directed_complete</span><span> </span><span class="delimiter">+</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>bounded</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>directed_complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"directed (⊑) X ⟹ Ex (extreme_bound (⊑) X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"X = {}"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>directed_nonempty_complete</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>pointed_chain_complete</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pointed_directed_complete_def'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>less_eq</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pointed_directed_complete (⊑) ≡ ∀X. directed (⊑) X ⟶ Ex (extreme_bound (⊑) X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>atomize_eq</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>pointed_directed_complete.directed_complete</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pointed_iff_empty_complete</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>bounded_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹``Bounded complete'' refers to pointed conditional complete,
but this notion is just the dual of semicompleteness. We prove this later.

Following is the strongest completeness that requires any subset of elements to have suprema
and infima.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>complete</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_syntax</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) X)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>semicomplete</span><span> </span><span class="delimiter">+</span><span> </span><span>pointed_directed_complete</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pointed_directed_complete_def'</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>semicomplete.intro</span><span> </span><span>complete</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Relations between Completeness Conditions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>less_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>less_eq_dualize</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pair-completeness implies that the universe is directed. Thus, with directed completeness
implies boundedness.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span> </span><span>directed_complete_pair_complete_imp_bounded</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"directed_complete (⊑)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pair_complete (⊑)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bounded (⊑)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>directed_complete</span><span> </span><span class="delimiter">+</span><span> </span><span>pair_complete</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) UNIV)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>directed_nonempty_complete</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) UNIV t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. x ⊑ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Semicomplete is conditional complete and bounded.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span> </span><span>semicomplete_iff_conditionally_complete_bounded</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semicomplete (⊑) ⟷ conditionally_complete (⊑) ∧ bounded (⊑)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l ⟷ ?r"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?r</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>conditionally_complete</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)"</span></span></span><span> </span><span class="delimiter">+</span><span> </span><span>bounded</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>bounded_nonempty_complete</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?l</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>semicomplete</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span> </span><span>complete_iff_pointed_semicomplete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"complete (⊑) ⟷ semicomplete (⊑) ∧ bounded (⊒)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l ⟷ ?r"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"complete (⊑)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>complete</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?r</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>semicomplete</span><span> </span><span class="delimiter">+</span><span> </span><span>bounded</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊒)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?l</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"X = {}"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>nonempty_complete</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Conditional completeness only lacks top and bottom to be complete.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span> </span><span>complete_iff_conditionally_complete_bounded_pointed</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"complete (⊑) ⟷ conditionally_complete (⊑) ∧ bounded (⊑) ∧ bounded (⊒)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>complete_iff_pointed_semicomplete</span><span>
</span><span>    </span><span>semicomplete_iff_conditionally_complete_bounded</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If the universe is directed, then every pair is bounded, and thus has a supremum.
  On the other hand, supremum gives an upper bound, witnessing directedness.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>conditionally_complete</span><span class="delimiter">)</span><span> </span><span>pair_complete_iff_directed</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pair_complete (⊑) ⟷ directed (⊑) UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"directed (⊑) UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pair_complete (⊑)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>bounded_nonempty_complete</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>directedE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pair_complete (⊑)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>pair_complete</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"directed (⊑) UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>directedI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pair_complete</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {x,y} z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z∈UNIV. x ⊑ z ∧ y ⊑ z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Completeness Results Requiring Order-Like Properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Above results hold without any assumption on the relation.
This part demands some order-like properties.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹It is well known that in a semilattice, i.e., a pair-complete partial order,
every finite nonempty subset of elements has a supremum.
We prove the result assuming transitivity, but only that.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>trans_semilattice</span><span> </span><span class="delimiter">=</span><span> </span><span>transitive</span><span> </span><span class="delimiter">+</span><span> </span><span>pair_complete</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>trans_semilattice</span><span> </span><span class="delimiter">⊆</span><span> </span><span>finite_complete</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>X</span><span> </span><span>rule</span><span class="delimiter">:</span><span>finite_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>x</span><span> </span><span>X</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"X = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {x,x} x'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pair_complete</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x'</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>insert</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) X b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pair_complete</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {x,b} c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>extreme_boundI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ⊑ c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xb ∈ insert x X ⟹ xb ⊑ c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>trans</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>d</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) (insert x X) d"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) {x,b} d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Gierz et al.~\cite{gierz03} showed that a directed complete partial order is semicomplete
if and only if it is also a semilattice.
We generalize the claim so that the underlying relation is only transitive.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>transitive</span><span class="delimiter">)</span><span> </span><span>semicomplete_iff_directed_complete_pair_complete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semicomplete (⊑) ⟷ directed_complete (⊑) ∧ pair_complete (⊑)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l ⟷ ?r"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span> </span><span>semicomplete.intro</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?l</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>semicomplete</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?r</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>directed_complete</span><span> </span><span class="delimiter">+</span><span> </span><span>pair_complete</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>trans_semilattice</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"directed (⊑) {x. ∃Y ⊆ X. finite Y ∧ Y ≠ {} ∧ extreme_bound (⊑) Y x}"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"directed _ ?B"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>directedI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ ?B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) A a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊆ X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) B b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (A ∪ B)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∪ B ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∪ B ⊆ X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>finite_nonempty_complete</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) (A ∪ B))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) (A ∪ B) c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃c ∈ ?B. a ⊑ c ∧ b ⊑ c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>bexI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ⊑ c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ⊑ c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extreme_bound_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>AB</span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ ?B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∪ B"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite_nonempty_complete</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {x} x'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xX</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x'B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ∈ ?B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}"</span></span></span><span class="delimiter">]</span><span> </span><span>extreme_boundI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?B ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>directed_nonempty_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) ?B b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>extreme_boundI</span><span> </span><span>UNIV_I</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite_nonempty_complete</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {x} c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c</span><span> </span><span>xX</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ ?B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}"</span></span></span><span class="delimiter">]</span><span> </span><span>extreme_boundI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xc</span><span> </span><span>cb</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>trans</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Here transitivity is needed. ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Xx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) X x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) ?B x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>boundI</span><span> </span><span>UNIV_I</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span> </span><span>Y</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite Y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>YX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ⊆ X"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ≠ {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) Y c"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>YX</span><span> </span><span>Xx</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) Y x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The last argument in the above proof requires transitivity,
but if we had reflexivity then $x$ itself is a supremum of $\set{x}$
(see @{thm reflexive.extreme_bound_singleton}) and so $x \SLE s$ would be immediate.
Thus we can replace transitivity by reflexivity,
but then pair-completeness does not imply finite completeness.
We obtain the following result.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>reflexive</span><span class="delimiter">)</span><span> </span><span>semicomplete_iff_directed_complete_finite_complete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semicomplete (⊑) ⟷ directed_complete (⊑) ∧ finite_complete (⊑)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l ⟷ ?r"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span> </span><span>semicomplete.intro</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?l</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>semicomplete</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>safe</span><span class="delimiter">,</span><span> </span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?r</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>directed_complete</span><span> </span><span class="delimiter">+</span><span> </span><span>finite_complete</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"directed (⊑) {x. ∃Y ⊆ X. finite Y ∧ Y ≠ {} ∧ extreme_bound (⊑) Y x}"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"directed _ ?B"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>directedI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ ?B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) A a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊆ X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) B b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (A ∪ B)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∪ B ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∪ B ⊆ X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>finite_nonempty_complete</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) (A ∪ B))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) (A ∪ B) c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃c ∈ ?B. a ⊑ c ∧ b ⊑ c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>bexI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ⊑ c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ⊑ c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extreme_bound_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>AB</span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ ?B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∪ B"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {x} x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xX</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?B ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>directed_nonempty_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) ?B b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>extreme_boundI</span><span> </span><span>UNIV_I</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {x} x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x</span><span> </span><span>xX</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Xx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) X x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) ?B x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>boundI</span><span> </span><span>UNIV_I</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span> </span><span>Y</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite Y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>YX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ⊆ X"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ≠ {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) Y c"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>YX</span><span> </span><span>Xx</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) Y x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>complete_attractive</span><span> </span><span class="delimiter">=</span><span> </span><span>complete</span><span> </span><span class="delimiter">+</span><span> </span><span>attractive</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>complete_antisymmetric</span><span> </span><span class="delimiter">=</span><span> </span><span>complete</span><span> </span><span class="delimiter">+</span><span> </span><span>antisymmetric</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>complete_antisymmetric</span><span> </span><span class="delimiter">⊆</span><span> </span><span>complete_attractive</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Complete pseudo orders are called complete trellises~\cite{trellis},
but let us reserve the name for introducing classes (in the future).›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>complete_pseudo_order</span><span> </span><span class="delimiter">=</span><span> </span><span>complete</span><span> </span><span class="delimiter">+</span><span> </span><span>pseudo_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>complete_pseudo_order</span><span> </span><span class="delimiter">⊆</span><span> </span><span>complete_antisymmetric</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we (re)define complete lattices as a complete partial order.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>complete_partial_order</span><span> </span><span class="delimiter">=</span><span> </span><span>complete</span><span> </span><span class="delimiter">+</span><span> </span><span>partial_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>complete_partial_order</span><span> </span><span class="delimiter">⊆</span><span> </span><span>trans_semilattice</span><span> </span><span class="delimiter">+</span><span> </span><span>complete_pseudo_order</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Relating to Classes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>ccomplete</span><span> </span><span class="delimiter">=</span><span> </span><span>ord</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conditionally_complete (≤)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>conditionally_complete</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ccomplete_axioms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>class.ccomplete_def</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>complete_ord</span><span> </span><span class="delimiter">=</span><span> </span><span>ord</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"complete (≤)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>complete</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>complete_ord_axioms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>class.complete_ord_def</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>ccomplete</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>complete</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Isabelle's class @{class conditionally_complete_lattice} is @{class ccomplete}.
The other direction does not hold, since for the former,
@{term "Sup {}"} and @{term "Inf {}"} are arbitrary even if there are top or bottom elements.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>conditionally_complete_lattice</span><span class="delimiter">)</span><span> </span><span>ccomplete</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (upper_bound X)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bdd_above X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>cSup_upper</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>cSup_least</span><span class="delimiter">[</span><span>OF</span><span> </span><span>X0</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"supremum X (Sup X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>extremeI</span><span> </span><span>boundI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (supremum X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Isabelle's class @{class complete_lattice} is precisely @{locale complete_partial_order}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>complete_lattice</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>complete_partial_order</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Sup_upper</span><span> </span><span>Sup_least</span><span> </span><span>Inf_lower</span><span> </span><span>Inf_greatest</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>complete_ord</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>order</span><span class="delimiter">:</span><span> </span><span>complete_partial_order</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Duality of Completeness Conditions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Conditional completeness is symmetric.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>conditionally_complete</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>conditionally_complete</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>less_eq_dualize</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (bound (⊒) X)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nonemp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (bound (⊑) {b. bound (⊒) X b})"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{b. bound (⊒) X b} ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bounded_nonempty_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {b. bound (⊒) X b} s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊒) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>extremeI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Full completeness is symmetric.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>complete</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>complete</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {b. bound (⊑)<span class="hidden">⇧</span><sup>-</sup> X b} s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>complete</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑)<span class="hidden">⇧</span><sup>-</sup> X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>extreme_boundI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>complete_attractive</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>complete_attractive</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>complete_antisymmetric</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>complete_antisymmetric</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>complete_pseudo_order</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>complete_pseudo_order</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>complete_partial_order</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>complete_partial_order</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)<span class="hidden">⇧</span><sup>-</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Now we show that bounded completeness is the dual of semicompleteness.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>less_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>less_eq_dualize</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bounded_complete ≡ ∀X. Ex (bound (⊑) X) ⟶ Ex (extreme_bound (⊑) X)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pointed_conditionally_complete_iff_bounded_complete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"conditionally_complete (⊑) ∧ bounded (⊒) ⟷ bounded_complete"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bounded_complete"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>*</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>bounded_complete_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>*</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conditionally_complete (⊑)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>*</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bounded (⊒)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>bound_empty</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conditionally_complete (⊑)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bounded (⊒)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>conditionally_complete</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)"</span></span></span><span> </span><span class="delimiter">+</span><span> </span><span>dual</span><span class="delimiter">:</span><span> </span><span>bounded</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊒)"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bounded_complete"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bounded_complete_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (bound (⊑) X)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) X)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"X = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>bounded_nonempty_complete</span><span> </span><span>X</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span> </span><span>bounded_complete_iff_dual_semicomplete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bounded_complete ⟷ semicomplete (⊒)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>pointed_conditionally_complete_iff_bounded_complete</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conditionally_complete (⊑)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bounded (⊒)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>conditionally_complete</span><span> </span><span class="delimiter">+</span><span> </span><span>bounded</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊒)"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dual.conditionally_complete_axioms</span><span> </span><span>bounded_axioms</span><span>
</span><span>    </span><span>semicomplete_iff_conditionally_complete_bounded</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semicomplete (⊒)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semicomplete (⊒)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>semicomplete</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊒)"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conditionally_complete (⊑)"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bounded (⊒)"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Completeness in Function Spaces›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Here we lift completeness to functions. As we do not assume an operator to choose suprema,
we need the axiom of choice for most of the following results. In antisymmetric cases we do not
need the axiom but we do not formalize this fact.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>bounded</span><span class="delimiter">)</span><span> </span><span>bounded_fun</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bounded (fun_ord (⊑))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bounded</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. x ⊑ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f. fun_ord (⊑) f (λx. t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>fun_ordI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>bounded.intro</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>pair_complete</span><span class="delimiter">)</span><span> </span><span>pair_complete_fun</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pair_complete (fun_ord (⊑) :: ('i ⇒ _) ⇒ _)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pair_complete</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. ∃sx. extreme_bound (⊑) {f x, g x} sx"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>choice</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. extreme_bound (⊑) {f x, g x} (s x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (fun_ord (⊑)) {f, g})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>fun_extreme_bound_iff</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>1</span><span> </span><span>4</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>finite_complete</span><span class="delimiter">)</span><span> </span><span>finite_complete_fun</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"finite_complete (fun_ord (⊑) :: ('i ⇒ 'a) ⇒ _)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i ⇒ 'a) set"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite F"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>finite_nonempty_complete</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. ∃sx. extreme_bound (⊑) {f x |. f ∈ F} sx"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>choice</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (fun_ord (⊑)) F)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>fun_extreme_bound_iff</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>omega_complete</span><span class="delimiter">)</span><span> </span><span>omega_complete_fun</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"omega_complete (fun_ord (⊑) :: ('i ⇒ 'a) ⇒ _)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'i ⇒ 'a"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (≤) (fun_ord (⊑)) ff"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. Ex (extreme_bound (⊑) {ff n i |. n})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>monotone_seq_complete</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>monotone_def</span><span> </span><span>fun_ord_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>choice</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. extreme_bound (⊑) {ff n i |. n} (s i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (fun_ord (⊑)) (range ff) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_extreme_bound_iff</span><span> </span><span>image_image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (fun_ord (⊑)) (range ff))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>chain_complete</span><span class="delimiter">)</span><span> </span><span>chain_complete_fun</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"chain_complete (fun_ord (⊑) :: ('i ⇒ 'a) ⇒ _)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i ⇒ 'a) set"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chain (fun_ord (⊑)) F"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. Ex (extreme_bound (⊑) {f i |. f ∈ F})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>chain_nonempty_complete</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>chain_def</span><span> </span><span>fun_ord_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>choice</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. extreme_bound (⊑) {f i |. f ∈ F} (s i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (fun_ord (⊑)) F)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_extreme_bound_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>directed_complete</span><span class="delimiter">)</span><span> </span><span>directed_complete_fun</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"directed_complete (fun_ord (⊑) :: ('i ⇒ 'a) ⇒ _)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i ⇒ 'a) set"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>dir</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"directed (fun_ord (⊑)) F"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"F ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. Ex (extreme_bound (⊑) {f i |. f ∈ F})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>directed_nonempty_complete</span><span> </span><span>directedI</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ F"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ F"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>dir</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h ∈ F"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fun_ord (⊑) f h"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fun_ord (⊑) g h"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>directedE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f i ⊑ h i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g i ⊑ h i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>fun_ordD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>h</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃hi∈{f i |. f ∈ F}. f i ⊑ hi ∧ g i ⊑ hi"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"h i"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>F0</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>choice</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. extreme_bound (⊑) {f i |. f ∈ F} (s i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (fun_ord (⊑)) F)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_extreme_bound_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>conditionally_complete</span><span class="delimiter">)</span><span> </span><span>conditionally_complete_fun</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"conditionally_complete (fun_ord (⊑) :: ('i ⇒ 'a) ⇒ _)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i ⇒ 'a) set"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>bF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (bound (fun_ord (⊑)) F)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"F ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bF</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (fun_ord (⊑)) F b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. ∃sx. extreme_bound (⊑) {f x |. f ∈ F} sx"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) {f x |. f ∈ F} (b x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_ord_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>bounded_nonempty_complete</span><span> </span><span>F</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) {f x |. f ∈ F})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>choice</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (fun_ord (⊑)) F)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>fun_extreme_bound_iff</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semicomplete</span><span class="delimiter">)</span><span> </span><span>semicomplete_fun</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"semicomplete (fun_ord (⊑))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>semicomplete_iff_conditionally_complete_bounded</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>pointed_chain_complete</span><span class="delimiter">)</span><span> </span><span>pointed_chain_complete_fun</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pointed_chain_complete (fun_ord (⊑))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>pointed_chain_complete.intro</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dual_fun_ord</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>pointed_directed_complete</span><span class="delimiter">)</span><span> </span><span>pointed_directed_complete_fun</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pointed_directed_complete (fun_ord (⊑))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>pointed_directed_complete.intro</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dual_fun_ord</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>complete</span><span class="delimiter">)</span><span> </span><span>complete_fun</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"complete (fun_ord (⊑))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>complete_iff_pointed_semicomplete</span><span> </span><span>dual_fun_ord</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Interpretations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>complete_lattice</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Sup_eq_The_supremum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup X = The (supremum X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>order.complete</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>order.dual.ex_extreme_iff_ex1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>the1_equality</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Sup_upper</span><span> </span><span>Sup_least</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inf_eq_The_infimum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inf X = The (infimum X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>order.dual.complete</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>order.ex_extreme_iff_ex1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>the1_equality</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Inf_lower</span><span> </span><span>Inf_greatest</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>real</span><span> </span><span class="delimiter">::</span><span> </span><span>ccomplete</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro_classes</span><span class="delimiter">,</span><span> </span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fun"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>type</span><span class="delimiter">,</span><span> </span><span>ccomplete</span><span class="delimiter">)</span><span> </span><span>ccomplete</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro_classes</span><span class="delimiter">,</span><span> </span><span>fold</span><span> </span><span>fun_ord_le</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fun"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>type</span><span class="delimiter">,</span><span> </span><span>complete_ord</span><span class="delimiter">)</span><span> </span><span>complete_ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro_classes</span><span class="delimiter">,</span><span> </span><span>fold</span><span> </span><span>fun_ord_le</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Fixed_Points">
<div class="head"><h1>Theory Fixed_Points</h1>
<span class="command">theory</span> <span class="name">Fixed_Points</span><br/>
<span class="keyword">imports</span> <a href="Complete_Relations.html"><span class="name">Complete_Relations</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
Author:  Jérémy Dubut (2019)
Author:  Akihisa Yamada (2019)
License: LGPL (see file COPYING.LESSER)
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Knaster--Tarski-Style Fixed-Point Theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Fixed_Points</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Complete_Relations</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Given a monotone map
$f : A \to A$ on a complete lattice $\tp{A,\SLE}$,
the Knaster--Tarski theorem~\cite{tarski55} states that
\begin{enumerate}
\item $f$ has a fixed point in $A$, and
\item the set of fixed points forms a complete lattice.
\end{enumerate}
Stauti and Maaden \cite{SM13} generalized statement (1) where $\tp{A,\SLE}$
is a complete \emph{trellis}---a complete pseudo-order---%
relaxing transitivity.
They also proved a restricted version of (2),
namely there exists a least (and by duality a greatest) fixed point in $A$.

In the following Section~\ref{sec:qfp-exists} we further generalize claim (1)
so that any complete relation
admits a \emph{quasi-fixed point} $f(x) \sim x$, that is, $f(x) \SLE x$ and $x \SLE f(x)$.
Quasi-fixed points are fixed points for antisymmetric relations;
hence the Stauti--Maaden theorem is further generalized by relaxing reflexivity.

In Section \ref{sec:qfp-complete}
we also generalize claim (2) so that only a mild condition, which we call \emph{attractivity},
is assumed. In this attractive setting quasi-fixed points are complete.
Since attractivity is implied by either of transitivity or antisymmetry,
in particular fixed points are complete in complete trellis,
thus completing Stauti and Maaden's result. We then further generalize the result, proving that
antisymmetry is sufficient for \emph{strict} fixed points
$f(x) = x$ to be complete.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Completeness of a Subset›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We start by formalizing what it means for a subset to have an extreme bound inside 
a set, and for this subset to be complete. We prove that this completeness is also auto-dual.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>less_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>less_eq_dualize</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound_in S X ≡ extreme (⊒) {b ∈ S. bound (⊑) X b}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extreme_bound_inI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀b. bound (⊑) X b ⟹ b ∈ S ⟹ s ⊑ b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. x ∈ X ⟹ x ⊑ s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound_in S X s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in S ≡ ∀X ⊆ S. Ex (extreme_bound_in S X)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>complete_inE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀X. X ⊆ S ⟹ Ex (extreme_bound_in S X)) ⟹ thesis"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"thesis"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>complete_in_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>complete_inD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in S ⟹ X ⊆ S ⟹ Ex (extreme_bound_in S X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>complete_in_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>complete_inI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀X. X ⊆ S ⟹ Ex (extreme_bound_in S X)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>complete_in_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>less_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>less_eq_dualize</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>complete_in_dual</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in (⊑) S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in (⊒) S"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊆ S"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ≡ {b∈S. bound (⊒) A b}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound_in (⊑) S B b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>complete</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AS</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound_in (⊒) S A)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>extreme_def</span><span> </span><span>B_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Existence of Quasi-Fixed Points›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\label{sec:qfp-exists}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following proof is simplified and generalized from
  Stouti--Maaden \cite{SM13}. We generalize so that the underlying 
relation is not even reflexive or antisymmetric.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>fixed_point_proof</span><span> </span><span class="delimiter">=</span><span> </span><span>less_eq_dualize</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (⊑) (⊑) f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f_closed_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` S ⊆ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>S_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in (⊑) S"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>AA</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"AA ≡
  {A. A ⊆ S ∧ f ` A ⊆ A ∧ (∀B ⊆ A. ∀b. extreme_bound_in (⊑) S B b ⟶ b ∈ A)}"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≡ ⋂ AA"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">qualified</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_AA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∈ AA"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AA_def</span><span> </span><span>f_closed_S</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">qualified</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>C_AA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∈ AA"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span>  </span><span>AA_def</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>CollectI</span><span> </span><span>conjI</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ⊆ S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_def</span><span> </span><span>S_AA</span><span> </span><span>f_closed_S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` C ⊆ C"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_def</span><span> </span><span>AA_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>B</span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>BC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>EBS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound_in (⊑) S B b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ AA"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>EBS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b∈X"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>AA_def</span><span class="delimiter">,</span><span>safe</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BC</span><span> </span><span>C_def</span><span> </span><span>Inf_lower</span><span> </span><span>subset_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>C_def</span><span> </span><span>AA_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quasi_fixed_point_in_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃c ∈ C. f c ∼ c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound_in (⊑) S C c"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_comp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>complete_in_def</span><span> </span><span>C_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>InterE</span><span> </span><span>S_AA</span><span> </span><span>subset_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃c ∈ C. f c ∼ c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>bexI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>cCS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ C"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AA_def</span><span> </span><span>C_AA</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f c ∈ C"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AA_def</span><span> </span><span>C_AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f c ⊑ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_closed_S</span><span> </span><span>cS</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ f c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D ≡ {x ∈ C. x ⊑ f c}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D ∈ AA"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span>  </span><span>AA_def</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>CollectI</span><span> </span><span>conjI</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D ⊆ S"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D_def</span><span> </span><span>C_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_AA</span><span> </span><span>f_closed_S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fxC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ C ⟹ x ⊑ f c ⟹ f x ∈ C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_AA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AA_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` D ⊆ D"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>D_def</span><span class="delimiter">,</span><span> </span><span>safe</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>fxC</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ C"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span>xC</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ⊑ f c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>monotoneD</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D ⊆ C"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>B</span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>BD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ D"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>BS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound_in (⊑) S B b"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ C"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DC</span><span> </span><span>BD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ C"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_AA</span><span> </span><span>BS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AA_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bfc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a∈B. a ⊑ f c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BD</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>f_closed_S</span><span> </span><span>cS</span><span> </span><span>BS</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ⊑ f c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extreme_def</span><span> </span><span>image_subset_iff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>bC</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ D"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ⊆ D"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ f c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cCS</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quasi_fixed_point</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s ∈ S. f s ∼ s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>quasi_fixed_point_in_C</span><span> </span><span>S_AA</span><span> </span><span>C_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ex_extreme_quasi_fixed_point</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>attract</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀q x. f q ∼ q ⟶ x ⊑ f q ⟶ x ⊑ q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme (⊒) {q ∈ S. f q ∼ q})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≡ {a ∈ S. ∀s ∈ S. f s ∼ s ⟶ a ⊑ s}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ AA"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>AA_def</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>CollectI</span><span> </span><span>conjI</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>AS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊆ S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ A"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ∈ A"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>A_def</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>CollectI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xA</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_closed_S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f s ∼ s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xA</span><span> </span><span>sS</span><span> </span><span>sf</span><span> </span><span>A_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ⊑ s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>attract</span><span> </span><span>mono</span><span>  
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>monotoneD</span><span> </span><span>sf</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s∈S. f s ∼ s ⟶ f x ⊑ s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` A ⊆ A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>B</span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>BA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound_in (⊑) S B b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BA</span><span> </span><span>AS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>BA</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f s ∼ s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) B s"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sS</span><span> </span><span>BA</span><span> </span><span>b</span><span> </span><span>A_def</span><span> </span><span>sf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s∈S. f s ∼ s ⟶ b ⊑ s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>A_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ⊆ A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>C_def</span><span> </span><span>Inf_lower</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃a ∈ A. f a ∼ a"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>quasi_fixed_point_in_C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>aA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>faa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f a ∼ a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>aA</span><span> </span><span>A_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme (⊒) {q ∈ S. f q ∼ q} a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extreme_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>complete</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>complete_in_UNIV</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in (⊑) UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>complete_in_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>complete</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>fixed_point_proof</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>monotone_imp_ex_quasi_fixed_point</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (⊑) (⊑) f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s. f s ∼ s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Ucl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` UNIV ⊆ UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ C f UNIV"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f s ∼ s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>quasi_fixed_point_in_C</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono</span><span> </span><span>Ucl</span><span> </span><span>complete_in_UNIV</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s. f s ∼ s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>complete_antisymmetric</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>monotone_imp_ex_fixed_point</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (⊑) (⊑) f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s. f s = s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>monotone_imp_ex_quasi_fixed_point</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Completeness of Quasi-Fixed Points›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\label{sec:qfp-complete}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We now show that fixed points are complete in a complete trellis,
which strengthens the existing result by Stouti and Maaden who showed the existence of
the least fixed point. Below we derive an even more general result by dropping reflexivity.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We first prove that, under attractivity, the set of quasi-fixed points is complete.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>fixed_point_proof</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>attract_imp_qfp_complete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"complete (⊑)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (⊑) (⊑) f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>attract</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀q x. f q ∼ q ⟶ x ⊑ f q ⟶ x ⊑ q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>dual_attract</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀q x. f q ∼ q ⟶ f q ⊑ x ⟶ q ⊑ x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in (⊑) {s. f s ∼ s}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>complete_inI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>complete</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Afix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊆ {s. f s ∼ s}"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ≡ {s. ∀a ∈ A. a ⊑ s}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a ∈ A. a ⊑ s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>aA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ⊑ f s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>dual_attract</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ⊑ s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as</span><span> </span><span>aA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f a ⊑ f s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monotone_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f a ∼ a"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Afix</span><span> </span><span>aA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f_closed_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` S ⊆ S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp_S_dual</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in (⊒) S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>complete_in_def</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>BS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊒) B b"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dual.complete</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound_in (⊒) S B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>extreme_bound_inI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>aA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ A"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀c ∈ B. a ⊑ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BS</span><span> </span><span>aA</span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ⊑ b"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bB</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ B ⟹ b ⊑ x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bB</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊒) B c"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ b"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bB</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in (⊑) S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>complete_in_dual</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>LefpS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme (⊒) {q ∈ S. f q ∼ q} L"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_extreme_quasi_fixed_point</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono</span><span> </span><span>f_closed_S</span><span> </span><span>comp_S</span><span> </span><span>attract</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound_in (⊑) {s. f s ∼ s} A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>extreme_bound_inI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L ∈ {s. f s ∼ s}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LefpS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>LefpS</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ⊑ L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) A c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cfix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ {s. f s ∼ s}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>cfix</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L ⊑ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LefpS</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>complete_attractive</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>fixed_point_proof</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>monotone_imp_quasi_fixed_points_complete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (⊑) (⊑) f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in (⊑) {s. f s ∼ s}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>attract_imp_qfp_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>complete_axioms</span><span> </span><span>mono</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>attract</span><span> </span><span>dual.attract</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The next lemma shows that in a complete relation, two related sets of
strict fixed points have a quasi-fixed point in between.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>fixed_point_proof</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>qfp_interpolant</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"complete (⊑)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (⊑) (⊑) f"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a ∈ A. ∀b ∈ B. a ⊑ b"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Afp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a ∈ A. f a = a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Bfp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀b ∈ B. f b = b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃t. (f t ∼ t) ∧ (∀a ∈ A. a ⊑ t) ∧ (∀b ∈ B. t ⊑ b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>complete</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp</span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ≡ {t. (∀a ∈ A. a ⊑ t) ∧ (∀b ∈ B. t ⊑ b)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f_closed_T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` T ⊆ T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f t ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>T_def</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>aA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ A"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>tT</span><span> </span><span>monotoneD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f a ⊑ f t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>T_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Afp</span><span> </span><span>aA</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ⊑ f t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>bB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ B"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>tT</span><span> </span><span>monotoneD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f t ⊑ f b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>T_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Bfp</span><span> </span><span>bB</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f t ⊑ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>T_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in (⊑) T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>UT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) (U ∪ A) k"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>complete</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound_in (⊑) T U k"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>extreme_bound_inI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ B"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AB</span><span> </span><span>T_def</span><span> </span><span>UT</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ U ∪ A. x ⊑ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ⊑ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>k</span><span> </span><span>T_def</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ∈ T"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ U"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>k</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>l</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) U l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ∈ T"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a ∈ U ∪ A. a ⊑ l"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>T_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>k</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ⊑ l"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound_in (⊑) T U)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f t ∼ t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>quasi_fixed_point</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>T_comp</span><span> </span><span>f_closed_T</span><span> </span><span>mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>T_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹From this, we deduce that the set of strict fixed-points is also complete, assuming
only antisymmetry and attractivity.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>complete_antisymmetric</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>fixed_point_proof</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (⊑) (⊑) f"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>monotone_imp_fixed_points_complete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in (⊑) {s. f s = s}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊆ {s. f s = s}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Afp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a∈A. f a = a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ≡ {s. ∀a ∈ A. a ⊑ s}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f_closed_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` S ⊆ S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f s ∈ S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>S_def</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>aA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ A"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f a ⊑ f s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_def</span><span> </span><span>sS</span><span> </span><span>mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>monotoneD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ⊑ f s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Afp</span><span> </span><span>aA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in (⊒) S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>BS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ S"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>BL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊒) B L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>dual.complete</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound_in (⊒) S B L"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>extreme_bound_inI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>aA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ A"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s ∈ B. a ⊑ s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BS</span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a ∈ A. a ⊑ L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extreme_bound_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ B ⟹ L ⊑ b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀c. bound (⊒) B c ⟹ c ⊑ L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>boundE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound_in (⊒) S B)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"complete_in (⊑) S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>complete_in_dual</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme (⊒) {q ∈ S. f q ∼ q})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ex_extreme_quasi_fixed_point</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono</span><span> </span><span>f_closed_S</span><span> </span><span>comp_S</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme (⊒) {q ∈ S. f q ⊑ q ∧ q ⊑ f q} q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound_in (⊑) {s. f s = s} A q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>extreme_bound_inI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>qfp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q ∈ {s. f s = s}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>Aq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a. a ∈ A ⟹ a ⊑ q"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>q</span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) A c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ {s. f s = s}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cfp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f c = c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Ac</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a ∈ A. a ⊑ c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D ≡ {c,q}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a ∈ A. ∀d ∈ D. a ⊑ d"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Aq</span><span> </span><span>Ac</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Dfp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀d∈D. f d = d"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qfp</span><span> </span><span>cfp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f t ∼ t) ∧ (∀a ∈ A. a ⊑ t) ∧ (∀d ∈ D. t ⊑ d)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qfp_interpolant</span><span class="delimiter">[</span><span>OF</span><span> </span><span>complete_axioms</span><span> </span><span>mono</span><span> </span><span>AD</span><span> </span><span>Afp</span><span> </span><span>Dfp</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊑ q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ⊑ t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t</span><span> </span><span>q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>tq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q = t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊑ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ⊑ c"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound_in (⊑) {s. f s = s} A)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>monotone_imp_ex_extreme_fixed_point</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme (⊒) {s. f s = s})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>complete_inD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>monotone_imp_fixed_points_complete</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Kleene-Style Fixed Point Theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Kleene's fixed-point theorem states that,
for a pointed directed complete partial order $\tp{A,\SLE}$
and a Scott-continuous map $f: A \to A$,
the supremum of $\set{f^n(\bot) \mid n\in\Nat}$ exists in $A$ and is a least 
fixed point.
Mashburn \cite{mashburn83} generalized the result so that
$\tp{A,\SLE}$ is a $\omega$-complete partial order
and $f$ is $\omega$-continuous.

In this section we further generalize the result and show that
for $\omega$-complete relation $\tp{A,\SLE}$
and for every bottom element $\bot \in A$,
the set $\set{f^n(\bot) \mid n\in\Nat}$ has suprema (not necessarily unique, of 
course) and, 
they are quasi-fixed points.
Moreover, if $(\SLE)$ is attractive, then the suprema are precisely the least 
quasi-fixed points.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Scott Continuity, $\omega$-Completeness, $\omega$-Continuity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In this Section, we formalize $\omega$-completeness, Scott continuity and $\omega$-continuity.
We then prove that a Scott continuous map is $\omega$-continuous and that an $\omega$-continuous 
map is ``nearly'' monotone.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>less_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"omega_continuous f ≡ ∀c :: nat ⇒ 'a. ∀ b.
  monotone (≤) (⊑) c ⟶
  extreme_bound (⊑) (range c) b ⟶ extreme_bound (⊑) (f ` range c) (f b)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omega_continuousI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀c :: nat ⇒ 'a. ⋀ b.
   monotone (≤) (⊑) c ⟹
   extreme_bound (⊑) (range c) b ⟹ extreme_bound (⊑) (f ` range c) (f b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"omega_continuous f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>omega_continuous_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omega_continuousE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"omega_continuous f"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀c :: nat ⇒ 'a. ⋀ b. monotone (≤) (⊑) c ⟹
         extreme_bound (⊑) (range c) b ⟹ extreme_bound (⊑) (f ` range c) (f b)
         ) ⟹ thesis"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"thesis"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>omega_continuous_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omega_continuous_imp_mono_refl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cont</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"omega_continuous f"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>yy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ⊑ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ⊑ f y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ≡ λi. if i = 0 then x else y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xx</span><span> </span><span>xy</span><span> </span><span>yy</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>monoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (≤) (⊑) c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>c_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>monotoneI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) (range c) y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xy</span><span> </span><span>yy</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>c_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fboy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) (f ` range c) (f y)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>monoc</span><span> </span><span>cont</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ⊑ f y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>c_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"scott_continuous f ≡
  ∀D b. directed (⊑) D ⟶ extreme_bound (⊑) D b ⟶ extreme_bound (⊑) (f ` D) (f b)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>scott_continuousI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀D b. directed (⊑) D ⟹ extreme_bound (⊑) D b ⟹ extreme_bound (⊑) (f ` D) (f b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"scott_continuous f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>scott_continuous_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>scott_continuousE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"scott_continuous f"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀D b. directed (⊑) D ⟹
         extreme_bound (⊑) D b ⟹ extreme_bound (⊑) (f ` D) (f b)) ⟹ thesis"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"thesis"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>scott_continuous_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>scott_continuous_imp_mono_refl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>scott</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"scott_continuous f"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>yy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ⊑ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ⊑ f y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D ≡ {x,y}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xy</span><span> </span><span>yy</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dir_D</span><span>
</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"directed (⊑) D"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>D_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>y</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) D y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xy</span><span> </span><span>yy</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>D_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fboy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) (f ` D) (f y)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dir_D</span><span> </span><span>scott</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ⊑ f y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>D_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>scott_continuous_imp_omega_continuous</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>scott</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"scott_continuous f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"omega_continuous f"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (≤) (⊑) c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>monotone_directed_image</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>order.dual.dual.directed_UNIV</span><span class="delimiter">]</span><span> </span><span>scott</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) (range c) b ⟹ extreme_bound (⊑) (f ` range c) (f b)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Kleene's Fixed-Point Theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The first part of Kleene's theorem demands to prove that the set 
$\set{f^n(\bot) \mid n \in \Nat}$ has a supremum and 
that all such are quasi-fixed points. We prove this claim without assuming 
anything on the relation $\SLE$ besides $\omega$-completeness and one bottom element.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>fixed_point_proof</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"omega_complete (⊑)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cont</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"omega_continuous (⊑) f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>bot</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">⊥</span>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bot</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀q. <span class="hidden">❙</span><span class="bold">⊥</span> ⊑ q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>omega_complete</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊑)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>fn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fn n ≡ (f ^^ n) <span class="hidden">❙</span><span class="bold">⊥</span>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fn ≡ range fn"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fn_ref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fn n ⊑ fn n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>omega_continuous_imp_mono_refl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cont</span><span class="delimiter">]</span><span> </span><span>bot</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fn_monotone</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (≤) (⊑) fn"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>le_Suc_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m = n + k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bot</span><span> </span><span>fn_ref</span><span> </span><span>omega_continuous_imp_mono_refl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cont</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fn n ⊑ fn m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>m</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ex_kleene_fixed_point</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ex (extreme_bound (⊑) Fn)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>monotone_seq_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fn_monotone</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kleene_fixed_point_is_fixed</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) Fn q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f q ∼ q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) (f ` Fn) (f q)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>q</span><span> </span><span>cont</span><span> </span><span>fn_monotone</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>bot</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fn n ⊑ f q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extreme_bound_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ⊑ f q"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (fn n) ∈ range fn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>range_eqI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` Fn ⊆ Fn"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f q ⊑ q"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>q</span><span> </span><span>fq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>bound_cmono</span><span> </span><span>extreme_def</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kleene_fixed_point_is_dual_extreme</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>attract</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀q x. f q ∼ q ⟶ x ⊑ f q ⟶ x ⊑ q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) Fn q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme (⊒) {s. f s ∼ s} q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>extremeI</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>kleene_fixed_point_is_fixed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>q</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>cqfp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f c ∼ c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fn n ⊑ c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bot</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>attract</span><span> </span><span>cqfp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fn (Suc n) ⊑ f c"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>omega_continuous_imp_mono_refl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cont</span><span class="delimiter">]</span><span> </span><span>fn_ref</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>attract</span><span> </span><span>cqfp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ⊑ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kleene_fixed_point_iff_dual_extreme</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>attract</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀q x. f q ∼ q ⟶ x ⊑ f q ⟶ x ⊑ q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>dual_attract</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p q x. p ∼ q ⟶ q ⊑ x ⟶ p ⊑ x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) Fn = extreme (⊒) {s. f s ∼ s}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span> </span><span>iffI</span><span> </span><span>kleene_fixed_point_is_dual_extreme</span><span class="delimiter">[</span><span>OF</span><span> </span><span>attract</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>q</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme (⊒) {s. f s ∼ s} q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>q</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fqq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f q ∼ q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ex_kleene_fixed_point</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) Fn k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q ∼ k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>kleene_fixed_point_is_fixed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>k</span><span class="delimiter">]</span><span> </span><span>q</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ⊑ k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>kleene_fixed_point_is_dual_extreme</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>k</span><span class="delimiter">]</span><span> </span><span>q</span><span> </span><span>attract</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ⊑ q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) Fn q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>extreme_boundI</span><span class="delimiter">,</span><span>safe</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(f ^^ n) <span class="hidden">❙</span><span class="bold">⊥</span> ⊑ q"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>bot</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>attract</span><span> </span><span>fn_ref</span><span> </span><span>fqq</span><span> </span><span>omega_continuous_imp_mono_refl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cont</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bound (⊑) Fn x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>kx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>dual_attract</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>qk</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>omega_complete</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>fixed_point_proof</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>kleene_quasi_fixed_point</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"omega_continuous (⊑) f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. bo ⊑ x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p. extreme_bound (⊑) {(f ^^ n) bo |. n :: nat} p"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {(f ^^ n) bo |. n :: nat} p ⟹ f p ∼ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_kleene_fixed_point</span><span class="delimiter">[</span><span>OF</span><span> </span><span>omega_complete_axioms</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kleene_fixed_point_is_fixed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>omega_complete_axioms</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Kleene's theorem also states that the quasi-fixed point found this way is a least one.
Again, attractivity is needed to prove this statement.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>attractive</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>fixed_point_proof</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>kleene_quasi_fixed_point_dual_extreme</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"omega_complete (⊑)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"omega_continuous (⊑) f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. bo ⊑ x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {(f ^^ n) bo |. n :: nat} = extreme (⊒) {s. f s ∼ s}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>kleene_fixed_point_iff_dual_extreme</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>attract</span><span> </span><span>dual.attract</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>antisymmetric</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>fixed_point_proof</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>kleene_fixed_point_is_fixed</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"omega_complete (⊑)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"omega_continuous (⊑) f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. bo ⊑ x"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extreme_bound (⊑) {(f ^^ n) bo |. n :: nat} p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f p = p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kleene_fixed_point_is_fixed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div>