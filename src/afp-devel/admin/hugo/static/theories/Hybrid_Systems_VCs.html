<div id="HS_Preliminaries">
<div class="head"><h1>Theory HS_Preliminaries</h1>
<span class="command">theory</span> <span class="name">HS_Preliminaries</span><br/>
<span class="keyword">imports</span> <a href="Picard_Lindeloef_Qualitative.html"><span class="name">Picard_Lindeloef_Qualitative</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Preliminaries for hybrid systems verification
    Author:      Jonathan Julián Huerta y Munive, 2019
    Maintainer:  Jonathan Julián Huerta y Munive &lt;jjhuertaymunive1@sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Hybrid Systems Preliminaries ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Hybrid systems combine continuous dynamics with discrete control. This section contains
auxiliary lemmas for verification of hybrid systems.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HS_Preliminaries</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ordinary_Differential_Equations.Picard_Lindeloef_Qualitative"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Real numbers ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>abs_le_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r::real) &gt; 0 ⟹ (¦x¦ &lt; r) = (-r &lt; x ∧ x &lt; r)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r::real) &gt; 0 ⟹ (¦x¦ ≤ r) = (-r ≤ x ∧ x ≤ r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>real_ivl_eqs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ball x r = {x-r&lt;--&lt; x+r}"</span></span></span><span>         </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x-r&lt;--&lt; x+r} = {x-r&lt;..&lt; x+r}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ball (r / 2) (r / 2) = {0&lt;--&lt;r}"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{0&lt;--&lt;r} = {0&lt;..&lt;r}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ball 0 r = {-r&lt;--&lt;r}"</span></span></span><span>             </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{-r&lt;--&lt;r} = {-r&lt;..&lt;r}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cball x r = {x-r--x+r}"</span></span></span><span>           </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x-r--x+r} = {x-r..x+r}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cball (r / 2) (r / 2) = {0--r}"</span></span></span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{0--r} = {0..r}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cball 0 r = {-r--r}"</span></span></span><span>              </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{-r--r} = {-r..r}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>open_segment_eq_real_ivl</span><span> </span><span>closed_segment_eq_real_ivl</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cball_def</span><span> </span><span>ball_def</span><span> </span><span>dist_norm</span><span> </span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_rotate_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a:: {banach,real_normed_field}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x * cos t - y * sin t)<span class="hidden">⇧</span><sup>2</sup> + (x * sin t + y * cos t)<span class="hidden">⇧</span><sup>2</sup> = x<span class="hidden">⇧</span><sup>2</sup> + y<span class="hidden">⇧</span><sup>2</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x * cos t + y * sin t)<span class="hidden">⇧</span><sup>2</sup> + (y * cos t - x * sin t)<span class="hidden">⇧</span><sup>2</sup> = x<span class="hidden">⇧</span><sup>2</sup> + y<span class="hidden">⇧</span><sup>2</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x * cos t - y * sin t)<span class="hidden">⇧</span><sup>2</sup> = x<span class="hidden">⇧</span><sup>2</sup> * (cos t)<span class="hidden">⇧</span><sup>2</sup> + y<span class="hidden">⇧</span><sup>2</sup> * (sin t)<span class="hidden">⇧</span><sup>2</sup> - 2 * (x * cos t) * (y * sin t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>power2_diff</span><span> </span><span>power_mult_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x * sin t + y * cos t)<span class="hidden">⇧</span><sup>2</sup> = y<span class="hidden">⇧</span><sup>2</sup> * (cos t)<span class="hidden">⇧</span><sup>2</sup> + x<span class="hidden">⇧</span><sup>2</sup> * (sin t)<span class="hidden">⇧</span><sup>2</sup> + 2 * (x * cos t) * (y * sin t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>power2_sum</span><span> </span><span>power_mult_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x * cos t - y * sin t)<span class="hidden">⇧</span><sup>2</sup> + (x * sin t + y * cos t)<span class="hidden">⇧</span><sup>2</sup> = x<span class="hidden">⇧</span><sup>2</sup> + y<span class="hidden">⇧</span><sup>2</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>right_diff_distrib</span><span> </span><span>sin_squared_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x * cos t + y * sin t)<span class="hidden">⇧</span><sup>2</sup> + (y * cos t - x * sin t)<span class="hidden">⇧</span><sup>2</sup> = x<span class="hidden">⇧</span><sup>2</sup> + y<span class="hidden">⇧</span><sup>2</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span> </span><span>add.left_commute</span><span> </span><span>power2_diff</span><span> </span><span>power2_sum</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Single variable derivatives ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>has_derivative</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1(D _ ↦ (_))/ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>65</span><span class="delimiter">,</span><span>65</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>has_vderiv_on</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1 D _ = (_)/ on _)"</span></span></span><span> </span><span class="delimiter">[</span><span>65</span><span class="delimiter">,</span><span>65</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>norm</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1∥_∥)"</span></span></span><span> </span><span class="delimiter">[</span><span>65</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">thy_deps</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>poly_derivatives</span><span> </span><span class="string"><span class="delete"><span class="delete">"compilation of optimised miscellaneous derivative rules."</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>has_vderiv_on_const</span><span> </span><span class="delimiter">[</span><span>poly_derivatives</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>has_vderiv_on_id</span><span> </span><span class="delimiter">[</span><span>poly_derivatives</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>has_vderiv_on_add</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>has_vderiv_on_eq_rhs</span><span class="delimiter">,</span><span> </span><span>poly_derivatives</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>has_vderiv_on_diff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>has_vderiv_on_eq_rhs</span><span class="delimiter">,</span><span> </span><span>poly_derivatives</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>has_vderiv_on_mult</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>has_vderiv_on_eq_rhs</span><span class="delimiter">,</span><span> </span><span>poly_derivatives</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_vderiv_on_compose_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D f = f' on g ` T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" D g = g' on T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h = (λx. g' x *<span class="hidden">⇩</span><sub>R</sub> f' (g x))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λt. f (g t)) = h on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ssubst</span><span class="delimiter">[</span><span>of</span><span> </span><span>h</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>has_vderiv_on_compose</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vderiv_on_compose_add</span><span> </span><span class="delimiter">[</span><span>derivative_intros</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D x = x' on (λτ. τ + t) ` T"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λτ. x (τ + t)) = (λτ. x' (τ + t)) on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>has_vderiv_on_compose_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>derivative_intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_vderiv_on_divide_cnst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ 0 ⟹ D (λt. t/a) = (λt. 1/a) on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>f'1</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λt. t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g'1</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ x. 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>has_derivative_divide</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>has_derivative_eq_rhs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>derivative_eq_intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_vderiv_on_power</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≥ 1 ⟹ D (λt. t ^ n) = (λt. n * (t ^ (n - 1))) on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>derivative_eq_intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_vderiv_on_exp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λt. exp t) = (λt. exp t) on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>derivative_intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_vderiv_on_cos_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"D (f::real ⇒ real) = f' on T ⟹ D (λt. cos (f t)) = (λt. - (f' t) * sin (f t)) on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>has_vderiv_on_compose_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λt. cos t"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>derivative_eq_intros</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_vderiv_on_sin_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"D (f::real ⇒ real) = f' on T ⟹ D (λt. sin (f t)) = (λt. (f' t) * cos (f t)) on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>has_vderiv_on_compose_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λt. sin t"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>derivative_eq_intros</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_vderiv_on_exp_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"D (f::real ⇒ real) = f' on T ⟹ D (λt. exp (f t)) = (λt. (f' t) * exp (f t)) on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>has_vderiv_on_compose_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λt. exp t"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>has_vderiv_on_exp</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult.commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vderiv_uminus_intro</span><span> </span><span class="delimiter">[</span><span>poly_derivatives</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"D f = f' on T ⟹ g = (λt. - f' t) ⟹ D (λt. - f t) = g on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>has_vderiv_on_uminus</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vderiv_div_cnst_intro</span><span> </span><span class="delimiter">[</span><span>poly_derivatives</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a::real) ≠ 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D f = f' on T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g = (λt. (f' t)/a)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λt. (f t)/a) = g on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>has_vderiv_on_compose_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λt. t/a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λt. 1/a"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>has_vderiv_on_divide_cnst</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vderiv_npow_intro</span><span> </span><span class="delimiter">[</span><span>poly_derivatives</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≥ 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D f = f' on T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g = (λt. n * (f' t) * (f t)^(n-1))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λt. (f t)^n) = g on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>has_vderiv_on_compose_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λt. t^n"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>has_vderiv_on_power</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vderiv_cos_intro</span><span> </span><span class="delimiter">[</span><span>poly_derivatives</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (f::real ⇒ real) = f' on T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g = (λt. - (f' t) * sin (f t))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λt. cos (f t)) = g on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>has_vderiv_on_cos_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vderiv_sin_intro</span><span> </span><span class="delimiter">[</span><span>poly_derivatives</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (f::real ⇒ real) = f' on T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g = (λt. (f' t) * cos (f t))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λt. sin (f t)) = g on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>has_vderiv_on_sin_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vderiv_exp_intro</span><span> </span><span class="delimiter">[</span><span>poly_derivatives</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (f::real ⇒ real) = f' on T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g = (λt. (f' t) * exp (f t))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λt. exp (f t)) = g on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>has_vderiv_on_exp_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment">― ‹Examples for checking derivatives›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λt. a * t<span class="hidden">⇧</span><sup>2</sup> / 2 + v * t + x) = (λt. a * t + v) on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λt. v * t - a * t<span class="hidden">⇧</span><sup>2</sup> / 2 + x) = (λx. v - a * x) on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ≠ 0 ⟹ D (λt. a5 * t^5 + a3 * (t^3 / c) - a2 * exp (t^2) + a1 * cos t + a0) =
  (λt. 5 * a5 * t^4 + 3 * a3 * (t^2 / c) - 2 * a2 * t * exp (t^2) - a1 * sin t) on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ≠ 0 ⟹ D (λt. - a3 * exp (t^3 / c) + a1 * sin t + a2 * t^2) =
  (λt. a1 * cos t + 2 * a2 * t - 3 * a3 * t^2 / c * exp (t^3 / c)) on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>poly_derivatives</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ≠ 0 ⟹ D (λt. exp (a * sin (cos (t^4) / c))) =
(λt. - 4 * a * t^3 * sin (t^4) / c * cos (cos (t^4) / c) * exp (a * sin (cos (t^4) / c))) on T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>poly_derivatives</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Intermediate Value Theorem ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IVT_two_functions</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::{linear_continuum_topology, real_vector}) ⇒ 
  ('b::{linorder_topology,real_normed_vector,ordered_ab_group_add})"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>conts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"continuous_on {a..b} f"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"continuous_on {a..b} g"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ahyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f a &lt; g a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bhyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g b &lt; f b "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ b"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x∈{a..b}. f x = g x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h x"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"f x - g x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h a ≤ 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h b ≥ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ahyp</span><span> </span><span>bhyp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"continuous_on {a..b} ?h"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conts</span><span> </span><span>continuous_on_diff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h x = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IVT'</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"?h"</span></span></span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ≤ b›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ≤ b›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IVT_two_functions_real_ivl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>conts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"continuous_on {a--b} f"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"continuous_on {a--b} g"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ahyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f a &lt; g a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bhyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g b &lt; f b "</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x∈{a--b}. f x = g x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ b"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IVT_two_functions</span><span> </span><span>assms</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>closed_segment_eq_real_ivl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≥ b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"continuous_on {b..a} f"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"continuous_on {b..a} g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conts</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>closed_segment_eq_real_ivl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x∈{b..a}. g x = f x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IVT_two_functions</span><span class="delimiter">[</span><span>of</span><span> </span><span>b</span><span> </span><span>a</span><span> </span><span>g</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ≥ b›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>closed_segment_eq_real_ivl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Filters ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eventually_at_within_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ interior T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ⊆ S"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eventually P (at t within T)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eventually P (at t within S)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>eventually_within_interior</span><span> </span><span>interior_mono</span><span> </span><span>subsetD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>netlimit_at_within_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::{perfect_space,t2_space}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ interior T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ⊆ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"netlimit (at t within S) = t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>interior_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹T ⊆ S›</span></span></span><span class="delimiter">]</span><span> </span><span>netlimit_within_interior</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_derivative_at_within_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t::real) ∈ interior T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ⊆ S"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D f ↦ f' at t within T"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D f ↦ f' at t within S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>has_derivative_def</span><span> </span><span>tendsto_iff</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>netlimit_at_within_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>netlimit_within_interior</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eventually_at_within_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eventually_all_finite2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>P</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::finite) ⇒ 'b ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>h</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀i. eventually (P i) F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eventually (λx. ∀i. P i x) F"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>eventually_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?F</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_filter F"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. ?F (P i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F (λx. ∀i ∈ UNIV. P i x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>eventually_conj</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obs</span><span> </span><span>h</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F (λx. ∀i. P i x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eventually_all_finite_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>P</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::finite) ⇒ 'b ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. eventually (P i) F"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. (∀i. (P i x)) ⟶ Q x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eventually Q F"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eventually (λx. ∀i. P i x) F"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h1</span><span> </span><span>eventually_all_finite2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eventually Q F"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eventually_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h2</span><span> </span><span>eventually_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Multivariable derivatives ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>frechet_vec_lambda</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real ⇒ ('a::banach)^('m::finite)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x<span class="hidden">⇩</span><sub>0</sub> ≡ netlimit (at x within T)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≡ real CARD('m)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. ((λy. (f y $ i - f x<span class="hidden">⇩</span><sub>0</sub> $ i - (y - x<span class="hidden">⇩</span><sub>0</sub>) *<span class="hidden">⇩</span><sub>R</sub> f' x $ i) /<span class="hidden">⇩</span><sub>R</sub> (∥y - x<span class="hidden">⇩</span><sub>0</sub>∥)) ⤏ 0) (at x within T)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((λy. (f y - f x<span class="hidden">⇩</span><sub>0</sub> - (y - x<span class="hidden">⇩</span><sub>0</sub>) *<span class="hidden">⇩</span><sub>R</sub> f' x) /<span class="hidden">⇩</span><sub>R</sub> (∥y - x<span class="hidden">⇩</span><sub>0</sub>∥)) ⤏ 0) (at x within T)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tendsto_iff</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ε</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; ε"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Δ"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λy. y - x<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Δf"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λy. f y - f x<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λi e y. inverse ¦?Δ y¦ * (∥f y $ i - f x<span class="hidden">⇩</span><sub>0</sub> $ i - ?Δ y *<span class="hidden">⇩</span><sub>R</sub> f' x $ i∥) &lt; e"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λy. inverse ¦?Δ y¦ * (∥?Δf y - ?Δ y *<span class="hidden">⇩</span><sub>R</sub> f' x∥) &lt; ε"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; ε / sqrt m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; ε›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. eventually (λy. ?P i (ε / sqrt m) y) (at x within T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tendsto_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eventually ?Q (at x within T)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>eventually_all_finite_mono</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>real</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?c</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"inverse ¦t - x<span class="hidden">⇩</span><sub>0</sub>¦"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?u t"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λi. f t $ i - f x<span class="hidden">⇩</span><sub>0</sub> $ i - ?Δ t *<span class="hidden">⇩</span><sub>R</sub> f' x $ i"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀i. ?c * (∥?u t i∥) &lt; ε / sqrt m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. (?c *<span class="hidden">⇩</span><sub>R</sub> (∥?u t i∥))<span class="hidden">⇧</span><sup>2</sup> &lt; (ε / sqrt m)<span class="hidden">⇧</span><sup>2</sup>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>power_strict_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. ?c<span class="hidden">⇧</span><sup>2</sup> * ((∥?u t i∥))<span class="hidden">⇧</span><sup>2</sup> &lt; ε<span class="hidden">⇧</span><sup>2</sup> / m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>power_mult_distrib</span><span> </span><span>power_divide</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. ?c<span class="hidden">⇧</span><sup>2</sup> * ((∥?u t i∥))<span class="hidden">⇧</span><sup>2</sup> &lt; ε<span class="hidden">⇧</span><sup>2</sup> / m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"({}::'m set) ≠ UNIV ∧ finite (UNIV :: 'm set)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈UNIV. ?c<span class="hidden">⇧</span><sup>2</sup> * ((∥?u t i∥))<span class="hidden">⇧</span><sup>2</sup>) &lt; (∑(i::'m)∈UNIV. ε<span class="hidden">⇧</span><sup>2</sup> / m)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>sum_strict_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?c<span class="hidden">⇧</span><sup>2</sup> * (∑i∈UNIV. (∥?u t i∥)<span class="hidden">⇧</span><sup>2</sup>) = (∑i∈UNIV. ?c<span class="hidden">⇧</span><sup>2</sup> *  (∥?u t i∥)<span class="hidden">⇧</span><sup>2</sup>)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_distrib_left</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?c<span class="hidden">⇧</span><sup>2</sup> * (∑i∈UNIV. (∥?u t i∥)<span class="hidden">⇧</span><sup>2</sup>) &lt; ε<span class="hidden">⇧</span><sup>2</sup>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sqrt (?c<span class="hidden">⇧</span><sup>2</sup> * (∑i∈UNIV. (∥?u t i∥)<span class="hidden">⇧</span><sup>2</sup>)) &lt; sqrt (ε<span class="hidden">⇧</span><sup>2</sup>)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>real_sqrt_less_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ε"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; ε›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?c * sqrt (∑i∈UNIV. (∥?u t i∥)<span class="hidden">⇧</span><sup>2</sup>) = sqrt (?c<span class="hidden">⇧</span><sup>2</sup> * (∑i∈UNIV. (∥?u t i∥)<span class="hidden">⇧</span><sup>2</sup>))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>real_sqrt_mult</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?c * sqrt (∑i∈UNIV. (∥?u t i∥)<span class="hidden">⇧</span><sup>2</sup>) &lt; ε"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tendsto_norm_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀x. ∥G x - L∥ ≤ ∥F x - L∥ ⟹ (F ⤏ L) net ⟹ (G ⤏ L) net"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>tendsto_iff</span><span> </span><span>dist_norm</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λx. ∥F x - L∥ &lt; e"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>eventually_mono</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>e</span><span> </span><span>z</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>z</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tendsto_zero_norm_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀x. ∥G x∥ ≤ ∥F x∥ ⟹ (F ⤏ 0) net ⟹ (G ⤏ 0) net"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>tendsto_iff</span><span> </span><span>dist_norm</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λx. ∥F x∥ &lt; e"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>eventually_mono</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>e</span><span> </span><span>z</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>z</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>frechet_vec_nth</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real ⇒ ('a::real_normed_vector)^'m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((λx. (f x - f x<span class="hidden">⇩</span><sub>0</sub> - (x - x<span class="hidden">⇩</span><sub>0</sub>) *<span class="hidden">⇩</span><sub>R</sub> f' t) /<span class="hidden">⇩</span><sub>R</sub> (∥x - x<span class="hidden">⇩</span><sub>0</sub>∥)) ⤏ 0) (at t within T)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((λx. (f x $ i - f x<span class="hidden">⇩</span><sub>0</sub> $ i - (x - x<span class="hidden">⇩</span><sub>0</sub>) *<span class="hidden">⇩</span><sub>R</sub> f' t $ i) /<span class="hidden">⇩</span><sub>R</sub> (∥x - x<span class="hidden">⇩</span><sub>0</sub>∥)) ⤏ 0) (at t within T)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>F</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"(λx. (f x - f x<span class="hidden">⇩</span><sub>0</sub> - (x - x<span class="hidden">⇩</span><sub>0</sub>) *<span class="hidden">⇩</span><sub>R</sub> f' t) /<span class="hidden">⇩</span><sub>R</sub> (∥x - x<span class="hidden">⇩</span><sub>0</sub>∥))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>tendsto_zero_norm_bound</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>mult_left_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Finite_Cartesian_Product.norm_nth_le</span><span> </span><span>vector_minus_component</span><span> </span><span>vector_scaleR_component</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_derivative_vec_lambda</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real ⇒ ('a::banach)^('n::finite)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. D (λt. f t $ i) ↦ (λ h. h *<span class="hidden">⇩</span><sub>R</sub> f' x $ i) (at x within T)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D f ↦ (λh. h *<span class="hidden">⇩</span><sub>R</sub> f' x) at x within T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>has_derivative_def</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bounded_linear_def</span><span> </span><span>bounded_linear_axioms_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>frechet_vec_lambda</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>T</span><span> </span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_derivative_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_derivative_vec_nth</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D f ↦ (λh. h *<span class="hidden">⇩</span><sub>R</sub> f' x) at x within T"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λt. f t $ i) ↦ (λh. h *<span class="hidden">⇩</span><sub>R</sub> f' x $ i) at x within T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>has_derivative_def</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bounded_linear_def</span><span> </span><span>bounded_linear_axioms_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>frechet_vec_nth</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_derivative_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_vderiv_on_vec_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real ⇒ ('a::banach)^('n::finite)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(D x = x' on T) = (∀i. D (λt. x t $ i) = (λt. x' t $ i) on T)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>has_derivative_vec_nth</span><span> </span><span>has_derivative_vec_lambda</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="HS_ODEs">
<div class="head"><h1>Theory HS_ODEs</h1>
<span class="command">theory</span> <span class="name">HS_ODEs</span><br/>
<span class="keyword">imports</span> <a href="HS_Preliminaries.html"><span class="name">HS_Preliminaries</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       ODEs and Dynamical Systems for HS verification
    Author:      Jonathan Julián Huerta y Munive, 2019
    Maintainer:  Jonathan Julián Huerta y Munive &lt;jjhuertaymunive1@sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Ordinary Differential Equations ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Vector fields @{text "f::real ⇒ 'a ⇒ ('a::real_normed_vector)"} represent systems 
of ordinary differential equations (ODEs). Picard-Lindeloef's theorem guarantees existence 
and uniqueness of local solutions to initial value problems involving Lipschitz continuous 
vector fields. A (local) flow @{text "φ::real ⇒ 'a ⇒ ('a::real_normed_vector)"} for such 
a system is the function that maps initial conditions to their unique solutions. In dynamical 
systems, the set of all points @{text "φ t s::'a"} for a fixed @{text "s::'a"} is the flow's 
orbit. If the orbit of each @{text "s ∈ I"} is conatined in @{text I}, then @{text I} is an 
invariant set of this system. This section formalises these concepts with a focus on hybrid 
systems (HS) verification.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HS_ODEs</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HS_Preliminaries"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Initial value problems and orbits ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>image</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"𝒫"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>image_le_pred</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(𝒫 f A ⊆ {s. G s}) = (∀x∈A. G (f x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ivp_sols</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(real ⇒ 'a ⇒ ('a::real_normed_vector)) ⇒ real set ⇒ 'a set ⇒ 
  real ⇒ 'a ⇒ (real ⇒ 'a) set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Sols"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sols f T S t<span class="hidden">⇩</span><sub>0</sub> s = {X |X. (D X = (λt. f t (X t)) on T) ∧ X t<span class="hidden">⇩</span><sub>0</sub> = s ∧ X ∈ T → S}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ivp_solsI</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D X = (λt. f t (X t)) on T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t<span class="hidden">⇩</span><sub>0</sub> = s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ T → S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ Sols f T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ivp_sols_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ivp_solsD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ Sols f T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D X = (λt. f t (X t)) on T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t<span class="hidden">⇩</span><sub>0</sub> = s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ T → S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ivp_sols_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"down T t ≡ {τ∈T. τ≤ t}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>g_orbit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::ord) ⇒ 'b) ⇒ ('b ⇒ bool) ⇒ 'a set ⇒ 'b set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"γ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"γ X G T = ⋃{𝒫 X (down T t) |t. 𝒫 X (down T t) ⊆ {s. G s}}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>g_orbit_eq</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('a::preorder) ⇒ 'b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"γ X G T = {X t |t. t ∈ T ∧ (∀τ∈down T t. G (X τ))}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_orbit_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_left_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>g_orbital</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a) ⇒ ('a ⇒ bool) ⇒ real set ⇒ 'a set ⇒ real ⇒ 
  ('a::real_normed_vector) ⇒ 'a set"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s = ⋃{γ X G T |X. X ∈ ivp_sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>g_orbital_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s = 
  {X t |t X. t ∈ T ∧ 𝒫 X (down T t) ⊆ {s. G s} ∧ X ∈ Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s }"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_orbital_def</span><span> </span><span>ivp_sols_def</span><span> </span><span>g_orbit_eq</span><span> </span><span>image_le_pred</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>g_orbitalI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(𝒫 X (down T t) ⊆ {s. G s})"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t ∈ g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_orbital_eq</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>g_orbitalD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t = s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(𝒫 X (down T t) ⊆ {s. G s})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_orbital_def</span><span> </span><span>g_orbit_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>g_orbit</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"γ"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Differential Invariants ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>diff_invariant</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ bool) ⇒ (('a::real_normed_vector) ⇒ 'a) ⇒ real set ⇒ 
  'a set ⇒ real ⇒ ('a ⇒ bool) ⇒ bool"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f T S t<span class="hidden">⇩</span><sub>0</sub> G ≡ (⋃ ∘ (𝒫 (g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub>))) {s. I s} ⊆ {s. I s}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_invariant_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f T S t<span class="hidden">⇩</span><sub>0</sub> G = 
  (∀s. I s ⟶ (∀X∈Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s. (∀t∈T.(∀τ∈(down T t). G (X τ)) ⟶ I (X t))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_invariant_def</span><span> </span><span>g_orbital_eq</span><span> </span><span>image_le_pred</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_inv_eq_inv_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f T S t<span class="hidden">⇩</span><sub>0</sub> G = (∀s. I s ⟶ (g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s) ⊆ {s. I s})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_invariant_eq</span><span> </span><span>g_orbital_eq</span><span> </span><span>image_le_pred</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>diff_invariant_rules</span><span> </span><span class="string"><span class="delete"><span class="delete">"rules for certifying differential invariants."</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_invariant_eq_rule</span><span> </span><span class="delimiter">[</span><span>diff_invariant_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Thyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>0</sub> ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀X. (D X = (λτ. f (X τ)) on T) ⟶ (D (λτ. μ (X τ) - ν (X τ)) = ((*<span class="hidden">⇩</span><sub>R</sub>) 0) on T)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant (λs. μ s = ν s) f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>diff_invariant_eq</span><span> </span><span>ivp_sols_def</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span> </span><span>τ</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tHyp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"τ ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_ivp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"D X = (λτ. f (X τ)) on T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"μ (X t<span class="hidden">⇩</span><sub>0</sub>) = ν (X t<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>obs1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈T. D (λτ. μ (X τ) - ν (X τ)) ↦ (λτ. τ *<span class="hidden">⇩</span><sub>R</sub> 0) at t within T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{t<span class="hidden">⇩</span><sub>0</sub>--τ} ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closed_segment_subset_interval</span><span> </span><span>tHyp</span><span> </span><span>Thyp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λτ. μ (X τ) - ν (X τ)) = (λτ. τ *<span class="hidden">⇩</span><sub>R</sub> 0) on {t<span class="hidden">⇩</span><sub>0</sub>--τ}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obs1</span><span> </span><span>x_ivp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>has_derivative_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>obs2</span><span class="delimiter">]</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ {t<span class="hidden">⇩</span><sub>0</sub>--τ}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"μ (X τ) - ν (X τ) - (μ (X t<span class="hidden">⇩</span><sub>0</sub>) - ν (X t<span class="hidden">⇩</span><sub>0</sub>)) = (τ - t<span class="hidden">⇩</span><sub>0</sub>) * t *<span class="hidden">⇩</span><sub>R</sub> 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mvt_very_simple_closed_segmentE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"μ (X τ) = ν (X τ)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>x_ivp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_invariant_leq_rule</span><span> </span><span class="delimiter">[</span><span>diff_invariant_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>μ</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::banach ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Thyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>0</sub> ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀X. (D X = (λτ. f (X τ)) on T) ⟶ (∀τ∈T. (τ &gt; t<span class="hidden">⇩</span><sub>0</sub> ⟶ μ' (X τ) ≥ ν' (X τ)) ∧ 
  (τ &lt; t<span class="hidden">⇩</span><sub>0</sub> ⟶ μ' (X τ) ≤ ν' (X τ))) ∧ (D (λτ. μ (X τ) - ν (X τ)) = (λτ. μ' (X τ) - ν' (X τ)) on T)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant (λs. ν s ≤ μ s) f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>diff_invariant_eq</span><span> </span><span>ivp_sols_def</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span> </span><span>τ</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_ivp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"D X = (λτ. f (X τ)) on T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν (X t<span class="hidden">⇩</span><sub>0</sub>) ≤ μ (X t<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ≠ t<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>primed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀τ. τ ∈ T ⟹ τ &gt; t<span class="hidden">⇩</span><sub>0</sub> ⟹ μ' (X τ) ≥ ν' (X τ)"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀τ. τ ∈ T ⟹ τ &lt; t<span class="hidden">⇩</span><sub>0</sub> ⟹ μ' (X τ) ≤ ν' (X τ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_ivp</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈T. D (λτ. μ (X τ) - ν (X τ)) ↦ (λτ. τ *<span class="hidden">⇩</span><sub>R</sub> (μ' (X t) - ν' (X t))) at t within T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>x_ivp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{t<span class="hidden">⇩</span><sub>0</sub>&lt;--&lt;τ} ⊆ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{t<span class="hidden">⇩</span><sub>0</sub>--τ} ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ∈ T›</span></span></span><span> </span><span>Thyp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ≠ t<span class="hidden">⇩</span><sub>0</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>convex_contains_open_segment</span><span> 
</span><span>        </span><span>is_interval_convex_1</span><span> </span><span>closed_segment_subset_interval</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λτ. μ (X τ) - ν (X τ)) = (λτ. μ' (X τ) - ν' (X τ)) on {t<span class="hidden">⇩</span><sub>0</sub>--τ}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obs1</span><span> </span><span>x_ivp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>has_derivative_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>obs2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ {t<span class="hidden">⇩</span><sub>0</sub>&lt;--&lt;τ}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(μ (X τ) - ν (X τ)) - (μ (X t<span class="hidden">⇩</span><sub>0</sub>) - ν (X t<span class="hidden">⇩</span><sub>0</sub>)) = (λτ. τ * (μ' (X t) -  ν' (X t))) (τ - t<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mvt_simple_closed_segmentE</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ≠ t<span class="hidden">⇩</span><sub>0</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>mvt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"μ (X τ) - ν (X τ) = (τ - t<span class="hidden">⇩</span><sub>0</sub>) * (μ' (X t) -  ν' (X t)) + (μ (X t<span class="hidden">⇩</span><sub>0</sub>) - ν (X t<span class="hidden">⇩</span><sub>0</sub>))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"τ &gt; t<span class="hidden">⇩</span><sub>0</sub> ⟹ t &gt; t<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ t<span class="hidden">⇩</span><sub>0</sub> ≤ τ ⟹ t &lt; t<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ {t<span class="hidden">⇩</span><sub>0</sub>&lt;--&lt;τ}›</span></span></span><span> </span><span>obs2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>open_segment_eq_real_ivl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt; t<span class="hidden">⇩</span><sub>0</sub> ⟹ (μ' (X t) -  ν' (X t)) ≥ 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &lt; t<span class="hidden">⇩</span><sub>0</sub> ⟹ (μ' (X t) -  ν' (X t)) ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>primed</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ - t<span class="hidden">⇩</span><sub>0</sub>) * (μ' (X t) -  ν' (X t)) ≥ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ≥ t<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split_mult_pos_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ - t<span class="hidden">⇩</span><sub>0</sub>) * (μ' (X t) -  ν' (X t)) + (μ (X t<span class="hidden">⇩</span><sub>0</sub>) - ν (X t<span class="hidden">⇩</span><sub>0</sub>)) ≥ 0"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>x_ivp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν (X τ) ≤ μ (X τ)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mvt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν (X τ) ≤ μ (X τ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_ivp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_invariant_less_rule</span><span> </span><span class="delimiter">[</span><span>diff_invariant_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>μ</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::banach ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Thyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>0</sub> ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ X. (D X = (λτ. f (X τ)) on T) ⟶ (∀τ∈T. (τ &gt; t<span class="hidden">⇩</span><sub>0</sub> ⟶ μ' (X τ) ≥ ν' (X τ)) ∧ 
  (τ &lt; t<span class="hidden">⇩</span><sub>0</sub> ⟶ μ' (X τ) ≤ ν' (X τ))) ∧ (D (λτ. μ (X τ) - ν (X τ)) = (λτ. μ' (X τ) - ν' (X τ)) on T)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant (λs. ν s &lt; μ s) f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>diff_invariant_eq</span><span> </span><span>ivp_sols_def</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span> </span><span>τ</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_ivp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"D X = (λτ. f (X τ)) on T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν (X t<span class="hidden">⇩</span><sub>0</sub>) &lt; μ (X t<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ≠ t<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>primed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀τ. τ ∈ T ⟹ τ &gt; t<span class="hidden">⇩</span><sub>0</sub> ⟹ μ' (X τ) ≥ ν' (X τ)"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀τ. τ ∈ T ⟹ τ &lt; t<span class="hidden">⇩</span><sub>0</sub> ⟹ μ' (X τ) ≤ ν' (X τ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_ivp</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈T. D (λτ. μ (X τ) - ν (X τ)) ↦ (λτ. τ *<span class="hidden">⇩</span><sub>R</sub> (μ' (X t) - ν' (X t))) at t within T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>x_ivp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{t<span class="hidden">⇩</span><sub>0</sub>&lt;--&lt;τ} ⊆ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{t<span class="hidden">⇩</span><sub>0</sub>--τ} ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ∈ T›</span></span></span><span> </span><span>Thyp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ≠ t<span class="hidden">⇩</span><sub>0</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>convex_contains_open_segment</span><span> 
</span><span>        </span><span>is_interval_convex_1</span><span> </span><span>closed_segment_subset_interval</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λτ. μ (X τ) - ν (X τ)) = (λτ. μ' (X τ) - ν' (X τ)) on {t<span class="hidden">⇩</span><sub>0</sub>--τ}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obs1</span><span> </span><span>x_ivp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>has_derivative_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>obs2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ {t<span class="hidden">⇩</span><sub>0</sub>&lt;--&lt;τ}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(μ (X τ) - ν (X τ)) - (μ (X t<span class="hidden">⇩</span><sub>0</sub>) - ν (X t<span class="hidden">⇩</span><sub>0</sub>)) = (λτ. τ * (μ' (X t) -  ν' (X t))) (τ - t<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mvt_simple_closed_segmentE</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ≠ t<span class="hidden">⇩</span><sub>0</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>mvt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"μ (X τ) - ν (X τ) = (τ - t<span class="hidden">⇩</span><sub>0</sub>) * (μ' (X t) -  ν' (X t)) + (μ (X t<span class="hidden">⇩</span><sub>0</sub>) - ν (X t<span class="hidden">⇩</span><sub>0</sub>))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"τ &gt; t<span class="hidden">⇩</span><sub>0</sub> ⟹ t &gt; t<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ t<span class="hidden">⇩</span><sub>0</sub> ≤ τ ⟹ t &lt; t<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ {t<span class="hidden">⇩</span><sub>0</sub>&lt;--&lt;τ}›</span></span></span><span> </span><span>obs2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>open_segment_eq_real_ivl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt; t<span class="hidden">⇩</span><sub>0</sub> ⟹ (μ' (X t) -  ν' (X t)) ≥ 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &lt; t<span class="hidden">⇩</span><sub>0</sub> ⟹ (μ' (X t) -  ν' (X t)) ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>primed</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ - t<span class="hidden">⇩</span><sub>0</sub>) * (μ' (X t) -  ν' (X t)) ≥ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ≥ t<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split_mult_pos_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ - t<span class="hidden">⇩</span><sub>0</sub>) * (μ' (X t) -  ν' (X t)) + (μ (X t<span class="hidden">⇩</span><sub>0</sub>) - ν (X t<span class="hidden">⇩</span><sub>0</sub>)) &gt; 0"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_ivp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν (X τ) &lt; μ (X τ)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mvt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν (X τ) &lt; μ (X τ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_ivp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_invariant_nleq_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>μ</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::banach ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant (λs. ¬ ν s ≤ μ s) f T S t<span class="hidden">⇩</span><sub>0</sub> G ⟷ diff_invariant (λs. ν s &gt; μ s) f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_invariant_eq</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>s</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>X</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ballE</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_invariant_neq_rule</span><span> </span><span class="delimiter">[</span><span>diff_invariant_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>μ</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::banach ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant (λs. ν s &lt; μ s) f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant (λs. ν s &gt; μ s) f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant (λs. ν s ≠ μ s) f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>diff_invariant_eq</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span class="delimiter">::</span><span class="tfree">'a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>real</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν s ≠ μ s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Xhyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>thyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Ghyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ. τ ∈ T ∧ τ ≤ t ⟶ G (X τ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν s &lt; μ s ∨ ν s &gt; μ s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν s &lt; μ s ⟹ ν (X t) &lt; μ (X t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Xhyp</span><span> </span><span>thyp</span><span> </span><span>Ghyp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_invariant_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν s &gt; μ s ⟹ ν (X t) &gt; μ (X t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Xhyp</span><span> </span><span>thyp</span><span> </span><span>Ghyp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_invariant_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν (X t) = μ (X t) ⟹ False"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_invariant_neq_rule_converse</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>μ</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::banach ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Thyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>0</sub> ∈ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈T. t<span class="hidden">⇩</span><sub>0</sub> ≤ t"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>conts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀X. (D X = (λτ. f (X τ)) on T) ⟶ 
  continuous_on (𝒫 X T) ν ∧ continuous_on (𝒫 X T) μ"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dIhyp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"diff_invariant (λs. ν s ≠ μ s) f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant (λs. ν s &lt; μ s) f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>diff_invariant_eq</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span class="delimiter">::</span><span class="tfree">'a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>real</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ineq0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ν s &lt; μ s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Xhyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Ghyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ. τ ∈ T ∧ τ ≤ t ⟶ G (X τ)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>thyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t∈T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ineq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ν (X t<span class="hidden">⇩</span><sub>0</sub>) &lt; μ (X t<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ivp_solsD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>0</sub> ≤ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"μ (X t) ≠ ν (X t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span> </span><span>Thyp</span><span> </span><span>dIhyp</span><span> </span><span>thyp</span><span> </span><span>Xhyp</span><span> </span><span>Ghyp</span><span> </span><span>ineq0</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_invariant_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ineq2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ν (X t) &gt; μ (X t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>continuous_on_compose</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vderiv_on_continuous_on</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ivp_solsD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Xhyp</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"continuous_on T (ν ∘ X)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"continuous_on T (μ ∘ X)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ivp_solsD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Xhyp</span><span class="delimiter">]</span><span> </span><span>conts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{t<span class="hidden">⇩</span><sub>0</sub>--t} ⊆ T"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyp</span><span> </span><span>thyp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>closed_segment_subset_interval</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"continuous_on {t<span class="hidden">⇩</span><sub>0</sub>--t} (λτ. ν (X τ))"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"continuous_on {t<span class="hidden">⇩</span><sub>0</sub>--t} (λτ. μ (X τ))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>continuous_on_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>τ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ {t<span class="hidden">⇩</span><sub>0</sub>--t}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"μ (X τ) = ν (X τ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IVT_two_functions_real_ivl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>ineq1</span><span> </span><span>ineq2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀r∈down T τ. G (X r)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ T"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ghyp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ∈ {t<span class="hidden">⇩</span><sub>0</sub>--t}›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t<span class="hidden">⇩</span><sub>0</sub> ≤ t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{t<span class="hidden">⇩</span><sub>0</sub>--t} ⊆ T›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closed_segment_eq_real_ivl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"μ (X τ) ≠ ν (X τ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dIhyp</span><span> </span><span>Xhyp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ν s &lt; μ s›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_invariant_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹μ (X τ) = ν (X τ)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν (X t) &lt; μ (X t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_invariant_conj_rule</span><span> </span><span class="delimiter">[</span><span>diff_invariant_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I<span class="hidden">⇩</span><sub>1</sub> f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I<span class="hidden">⇩</span><sub>2</sub> f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant (λs. I<span class="hidden">⇩</span><sub>1</sub> s ∧ I<span class="hidden">⇩</span><sub>2</sub> s) f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_invariant_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_invariant_disj_rule</span><span> </span><span class="delimiter">[</span><span>diff_invariant_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I<span class="hidden">⇩</span><sub>1</sub> f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I<span class="hidden">⇩</span><sub>2</sub> f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant (λs. I<span class="hidden">⇩</span><sub>1</sub> s ∨ I<span class="hidden">⇩</span><sub>2</sub> s) f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_invariant_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Picard-Lindeloef ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ A locale with the assumptions of Picard-Lindeloef theorem. It extends 
@{term "ll_on_open_it"} by providing an initial time @{term "t<span class="hidden">⇩</span><sub>0</sub> ∈ T"}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>picard_lindeloef</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real ⇒ ('a::{heine_borel,banach}) ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t<span class="hidden">⇩</span><sub>0</sub></span><span class="delimiter">::</span><span>real</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>open_domain</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"open T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open S"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>interval_time</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>init_time</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>0</sub> ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cont_vec_field</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s ∈ S. continuous_on T (λt. f t s)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lipschitz_vec_field</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_lipschitz T S f"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>ll_on_open_it</span><span> </span><span>T</span><span> </span><span>f</span><span> </span><span>S</span><span> </span><span>t<span class="hidden">⇩</span><sub>0</sub></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cont_vec_field</span><span> </span><span>lipschitz_vec_field</span><span> </span><span>interval_time</span><span> </span><span>open_domain</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>subintervalI</span><span> </span><span class="delimiter">=</span><span> </span><span>closed_segment_subset_domain</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>csols_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"csols t<span class="hidden">⇩</span><sub>0</sub> s = {(X, t). t ∈ T ∧  X ∈ Sols f {t<span class="hidden">⇩</span><sub>0</sub>--t} S t<span class="hidden">⇩</span><sub>0</sub> s}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ivp_sols_def</span><span> </span><span>csols_def</span><span> </span><span>solves_ode_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subintervalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>init_time</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_ivl s ≡ existence_ivl t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unique_solution</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>xivp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D X = (λt. f t (X t)) on {t<span class="hidden">⇩</span><sub>0</sub>--t}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t<span class="hidden">⇩</span><sub>0</sub> = s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ {t<span class="hidden">⇩</span><sub>0</sub>--t} → S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>yivp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D Y = (λt. f t (Y t)) on {t<span class="hidden">⇩</span><sub>0</sub>--t}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y t<span class="hidden">⇩</span><sub>0</sub> = s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ∈ {t<span class="hidden">⇩</span><sub>0</sub>--t} → S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t = Y t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(X, t) ∈ csols t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xivp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>csols_eq</span><span> </span><span>ivp_sols_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ivl_fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{t<span class="hidden">⇩</span><sub>0</sub>--t} ⊆ ex_ivl s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>existence_ivl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀z T'. t<span class="hidden">⇩</span><sub>0</sub> ∈ T' ∧ is_interval T' ∧ T' ⊆ ex_ivl s ∧ (z solves_ode f) T' S ⟹ 
  z t<span class="hidden">⇩</span><sub>0</sub> = flow t<span class="hidden">⇩</span><sub>0</sub> s t<span class="hidden">⇩</span><sub>0</sub> ⟹ (∀t∈T'. z t = flow t<span class="hidden">⇩</span><sub>0</sub> s t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>flow_usolves_ode</span><span class="delimiter">[</span><span>OF</span><span> </span><span>init_time</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>usolves_ode_from_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈{t<span class="hidden">⇩</span><sub>0</sub>--t}. X τ = flow t<span class="hidden">⇩</span><sub>0</sub> s τ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obs</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{t<span class="hidden">⇩</span><sub>0</sub>--t}"</span></span></span><span> </span><span>X</span><span class="delimiter">]</span><span> </span><span>xivp</span><span> </span><span>ivl_fact</span><span> </span><span>flow_initial_time</span><span class="delimiter">[</span><span>OF</span><span> </span><span>init_time</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>solves_ode_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈{t<span class="hidden">⇩</span><sub>0</sub>--t}. Y τ = flow t<span class="hidden">⇩</span><sub>0</sub> s τ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obs</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{t<span class="hidden">⇩</span><sub>0</sub>--t}"</span></span></span><span> </span><span>Y</span><span class="delimiter">]</span><span> </span><span>yivp</span><span> </span><span>ivl_fact</span><span> </span><span>flow_initial_time</span><span class="delimiter">[</span><span>OF</span><span> </span><span>init_time</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>solves_ode_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t = Y t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>solution_eq_flow</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>xivp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D X = (λt. f t (X t)) on ex_ivl s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t<span class="hidden">⇩</span><sub>0</sub> = s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ ex_ivl s → S"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ ex_ivl s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t = flow t<span class="hidden">⇩</span><sub>0</sub> s t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀z T'. t<span class="hidden">⇩</span><sub>0</sub> ∈ T' ∧ is_interval T' ∧ T' ⊆ ex_ivl s ∧ (z solves_ode f) T' S ⟹ 
  z t<span class="hidden">⇩</span><sub>0</sub> = flow t<span class="hidden">⇩</span><sub>0</sub> s t<span class="hidden">⇩</span><sub>0</sub> ⟹ (∀t∈T'. z t = flow t<span class="hidden">⇩</span><sub>0</sub> s t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>flow_usolves_ode</span><span class="delimiter">[</span><span>OF</span><span> </span><span>init_time</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>usolves_ode_from_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈ex_ivl s. X τ = flow t<span class="hidden">⇩</span><sub>0</sub> s τ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obs</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_ivl s"</span></span></span><span> </span><span>X</span><span class="delimiter">]</span><span> </span><span>existence_ivl_initial_time</span><span class="delimiter">[</span><span>OF</span><span> </span><span>init_time</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>xivp</span><span> </span><span>flow_initial_time</span><span class="delimiter">[</span><span>OF</span><span> </span><span>init_time</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>solves_ode_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t = flow t<span class="hidden">⇩</span><sub>0</sub> s t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ ex_ivl s›</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_lipschitz_add</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f1</span><span> </span><span>f2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ 'a::banach ⇒ 'a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_lipschitz T S f1"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_lipschitz T S f2"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_lipschitz T S (λt s. f1 t s + f2 t s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>local_lipschitz_def</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ε<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>L1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ε<span class="hidden">⇩</span><sub>1</sub> &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀τ. τ∈cball t ε<span class="hidden">⇩</span><sub>1</sub> ∩ T ⟹ L1-lipschitz_on (cball s ε<span class="hidden">⇩</span><sub>1</sub> ∩ S) (f1 τ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local_lipschitzE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ε<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>L2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ε<span class="hidden">⇩</span><sub>2</sub> &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀τ. τ∈cball t ε<span class="hidden">⇩</span><sub>2</sub> ∩ T ⟹ L2-lipschitz_on (cball s ε<span class="hidden">⇩</span><sub>2</sub> ∩ S) (f2 τ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local_lipschitzE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ballH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cball s (min ε<span class="hidden">⇩</span><sub>1</sub> ε<span class="hidden">⇩</span><sub>2</sub>) ∩ S ⊆ cball s ε<span class="hidden">⇩</span><sub>1</sub> ∩ S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cball s (min ε<span class="hidden">⇩</span><sub>1</sub> ε<span class="hidden">⇩</span><sub>2</sub>) ∩ S ⊆ cball s ε<span class="hidden">⇩</span><sub>2</sub> ∩ S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈cball t ε<span class="hidden">⇩</span><sub>1</sub> ∩ T. L1-lipschitz_on (cball s (min ε<span class="hidden">⇩</span><sub>1</sub> ε<span class="hidden">⇩</span><sub>2</sub>) ∩ S) (f1 τ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lipschitz_on_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>L1</span><span> </span><span>ballH</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈cball t ε<span class="hidden">⇩</span><sub>2</sub> ∩ T. L2-lipschitz_on (cball s (min ε<span class="hidden">⇩</span><sub>1</sub> ε<span class="hidden">⇩</span><sub>2</sub>) ∩ S) (f2 τ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lipschitz_on_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>L2</span><span> </span><span>ballH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈cball t (min ε<span class="hidden">⇩</span><sub>1</sub> ε<span class="hidden">⇩</span><sub>2</sub>) ∩ T. 
    (L1 + L2)-lipschitz_on (cball s (min ε<span class="hidden">⇩</span><sub>1</sub> ε<span class="hidden">⇩</span><sub>2</sub>) ∩ S) (λs. f1 τ s + f2 τ s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lipschitz_on_add</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃u&gt;0. ∃L. ∀t∈cball t u ∩ T. L-lipschitz_on (cball s u ∩ S) (λs. f1 t s + f2 t s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"min ε<span class="hidden">⇩</span><sub>1</sub> ε<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ε<span class="hidden">⇩</span><sub>1</sub> &gt; 0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ε<span class="hidden">⇩</span><sub>2</sub> &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>picard_lindeloef_add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"picard_lindeloef f1 T S t<span class="hidden">⇩</span><sub>0</sub> ⟹ picard_lindeloef f2 T S t<span class="hidden">⇩</span><sub>0</sub> ⟹ 
  picard_lindeloef (λt s. f1 t s + f2 t s) T S t<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>picard_lindeloef_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>continuous_on_add</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local_lipschitz_add</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>picard_lindeloef_constant</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"picard_lindeloef (λt s. c) UNIV UNIV t<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local_lipschitz_def</span><span> </span><span>lipschitz_on_def</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"1/2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Flows for ODEs ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ A locale designed for verification of hybrid systems. The user can select the interval 
of existence and the defining flow equation via the variables @{term "T"} and @{term "φ"}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>local_flow</span><span> </span><span class="delimiter">=</span><span> </span><span>picard_lindeloef</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λ t. f)"</span></span></span><span> </span><span>T</span><span> </span><span>S</span><span> </span><span>0</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::{heine_borel,banach} ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span>S</span><span> </span><span>L</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>φ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ 'a ⇒ 'a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ivp</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀ t s. t ∈ T ⟹ s ∈ S ⟹ D (λt. φ t s) = (λt. f (φ t s)) on {0--t}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀ s. s ∈ S ⟹ φ 0 s = s"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀ t s. t ∈ T ⟹ s ∈ S ⟹ (λt. φ t s) ∈ {0--t} → S"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_ivp_sols_ivl</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λt. φ t s) ∈ Sols (λt. f) {0--t} S 0 s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ivp_solsI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ivp</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_solution_ivl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>xivp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D X = (λt. f (X t)) on {0--t}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X 0 = s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ {0--t} → S"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>indom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t = φ t s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>unique_solution</span><span class="delimiter">[</span><span>OF</span><span> </span><span>xivp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span> </span><span>ivp</span><span> </span><span>indom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ex_ivl_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_ivl s = T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>existence_ivl_subset</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>existence_ivl_def</span><span> </span><span>csols_eq</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_ivp_sols_ivl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_derivative_on_open1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"t &gt; 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λτ. φ τ s) ↦ (λτ. τ *<span class="hidden">⇩</span><sub>R</sub> f (φ t s)) at t within B"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rHyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r &gt; 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ball t r ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>open_contains_ball_eq</span><span> </span><span>open_domain</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t + r/2 &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r &gt; 0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{0--t} ⊆ T"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subintervalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>init_time</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{0&lt;--&lt;t + r/2} ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>abs_le_eq</span><span> </span><span>abs_le_eq</span><span> </span><span>real_ivl_eqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t &gt; 0›</span></span></span><span class="delimiter">]</span><span> </span><span>real_ivl_eqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t + r/2 &gt; 0›</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarify</span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &lt; x"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cball_def</span><span> </span><span>ball_def</span><span> </span><span>dist_norm</span><span> </span><span>subset_eq</span><span> </span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t + r/2 ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rHyp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>real_ivl_eqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rHyp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subset_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{0--t + r/2} ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subintervalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>init_time</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(D (λt. φ t s) = (λt. f (φ t s)) on {0--(t + r/2)})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ivp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>vderiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(D (λt. φ t s) = (λt. f (φ t s)) on {0&lt;--&lt;t + r/2})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>has_vderiv_on_subset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>real_ivl_eqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t + r/2 &gt; 0›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ {0&lt;--&lt;t + r/2}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>real_ivl_eqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t + r/2 &gt; 0›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rHyp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λτ. φ τ s) ↦ (λτ. τ *<span class="hidden">⇩</span><sub>R</sub> f (φ t s)) (at t within {0&lt;--&lt;t + r/2})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vderiv</span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open {0&lt;--&lt;t + r/2}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>real_ivl_eqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t + r/2 &gt; 0›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subs</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_derivative_on_open2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &lt; 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λτ. φ τ s) ↦ (λτ. τ *<span class="hidden">⇩</span><sub>R</sub> f (φ t s)) at t within B"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rHyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r &gt; 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ball t r ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>open_contains_ball_eq</span><span> </span><span>open_domain</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t - r/2 &lt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r &gt; 0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t &lt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{0--t} ⊆ T"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subintervalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>init_time</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{0&lt;--&lt;t - r/2} ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>open_segment_eq_real_ivl</span><span> </span><span>closed_segment_eq_real_ivl</span><span>
</span><span>      </span><span>real_ivl_eqs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rHyp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subset_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t - r/2 ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rHyp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>real_ivl_eqs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subset_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{0--t - r/2} ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subintervalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>init_time</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(D (λt. φ t s) = (λt. f (φ t s)) on {0--(t - r/2)})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ivp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>vderiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(D (λt. φ t s) = (λt. f (φ t s)) on {0&lt;--&lt;t - r/2})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>has_vderiv_on_subset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>open_segment_eq_real_ivl</span><span> </span><span>closed_segment_eq_real_ivl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ {0&lt;--&lt;t - r/2}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>open_segment_eq_real_ivl</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rHyp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t &lt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λτ. φ τ s) ↦ (λτ. τ *<span class="hidden">⇩</span><sub>R</sub> f (φ t s)) (at t within {0&lt;--&lt;t - r/2})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vderiv</span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open {0&lt;--&lt;t - r/2}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>open_segment_eq_real_ivl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subs</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_derivative_on_open3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ∈ B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λτ. φ τ s) ↦ (λτ. τ *<span class="hidden">⇩</span><sub>R</sub> f (φ 0 s)) at 0 within B"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rHyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r &gt; 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ball 0 r ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>open_contains_ball_eq</span><span> </span><span>open_domain</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>init_time</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r/2 ∈ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"-r/2 ∈ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r/2 &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>real_ivl_eqs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>subs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{0--r/2} ⊆ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{0--(-r/2)} ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subintervalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>init_time</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(D (λt. φ t s) = (λt. f (φ t s)) on {0--r/2})"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(D (λt. φ t s) = (λt. f (φ t s)) on {0--(-r/2)})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ivp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{0--r/2} = {0--r/2} ∪ closure {0--r/2} ∩ closure {0--(-r/2)}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"{0--(-r/2)} = {0--(-r/2)} ∪ closure {0--r/2} ∩ closure {0--(-r/2)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>closed_segment_eq_real_ivl</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r/2 &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vderivs</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(D (λt. φ t s) = (λt. f (φ t s)) on {0--r/2} ∪ closure {0--r/2} ∩ closure {0--(-r/2)})"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(D (λt. φ t s) = (λt. f (φ t s)) on {0--(-r/2)} ∪ closure {0--r/2} ∩ closure {0--(-r/2)})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>closed_segment_eq_real_ivl</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r/2 &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ∈ {-r/2&lt;--&lt;r/2}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>open_segment_eq_real_ivl</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r/2 &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{-r/2--r/2} = {0--r/2} ∪ {0--(-r/2)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>closed_segment_eq_real_ivl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(D (λt. φ t s) = (λt. f (φ t s)) on {-r/2--r/2})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>has_vderiv_on_union</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vderivs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(D (λt. φ t s) = (λt. f (φ t s)) on {-r/2&lt;--&lt;r/2})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>has_vderiv_on_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>segment_open_subset_closed</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"-r/2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r/2"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λτ. φ τ s) ↦ (λτ. τ *<span class="hidden">⇩</span><sub>R</sub> f (φ 0 s)) (at 0 within {-r/2&lt;--&lt;r/2})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open {-r/2&lt;--&lt;r/2}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>open_segment_eq_real_ivl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{-r/2&lt;--&lt;r/2} ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subs</span><span> </span><span>union</span><span> </span><span>segment_open_subset_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obs</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_derivative_on_open</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λτ. φ τ s) ↦ (λτ. τ *<span class="hidden">⇩</span><sub>R</sub> f (φ t s)) at t within B"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &lt; 0 ∨ t = 0 ∨ t &gt; 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>has_derivative_on_open1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>has_derivative_on_open2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>    </span><span>has_derivative_on_open3</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_domain</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λt. φ t s) ∈ T → S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ex_ivl_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>existence_ivl_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.mem_existence_ivl_subset</span><span> </span><span>ivp</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_vderiv_on_domain</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λt. φ t s) = (λt. f (φ t s)) on T"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>has_vderiv_on_def</span><span> </span><span>has_vector_derivative_def</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ T"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Dhyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λt. φ t s) ↦ (λτ. τ *<span class="hidden">⇩</span><sub>R</sub> f (φ t s)) at t within B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>has_derivative_on_open</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ interior B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>interior_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (λt. φ t s) ↦ (λτ. τ *<span class="hidden">⇩</span><sub>R</sub> f (φ t s)) at t within T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>has_derivative_at_within_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B ⊆ T›</span></span></span><span> </span><span>Dhyp</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_ivp_sols</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λt. φ t s) ∈ Sols (λt. f) T S 0 s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>has_vderiv_on_domain</span><span> </span><span>ivp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>in_domain</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ivp_solsI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_solution</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ Sols (λt. f) T S 0 s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t = φ t s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D X = (λt. f (X t)) on (ex_ivl s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X 0 = s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ (ex_ivl s) → S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ivp_solsD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ex_ivl_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>solution_eq_flow</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t = flow 0 s t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ex_ivl_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ t s = flow 0 s t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>solution_eq_flow</span><span> </span><span>ivp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>ivp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ex_ivl_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_vderiv_on_domain</span><span> </span><span>assms</span><span> </span><span>in_domain</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t = φ t s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ivp_sols_collapse</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T = UNIV"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sols (λt. f) T S 0 s = {(λt. φ t s)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_ivp_sols</span><span> </span><span>eq_solution</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>additive_in_ivp_sols</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒫 (λτ. τ + t) T ⊆ T"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λτ. φ (τ + t) s) ∈ Sols (λt. f) T S 0 (φ (0 + t) s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ivp_solsI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>vderiv_on_compose_add</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>has_vderiv_on_domain</span><span> </span><span>has_vderiv_on_subset</span><span> </span><span>assms</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_domain</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_monoid_action</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T = UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ 0 s = s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ (t<span class="hidden">⇩</span><sub>1</sub> + t<span class="hidden">⇩</span><sub>2</sub>) s = φ t<span class="hidden">⇩</span><sub>1</sub> (φ t<span class="hidden">⇩</span><sub>2</sub> s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ 0 s = s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ivp</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ (0 + t<span class="hidden">⇩</span><sub>2</sub>) s = φ t<span class="hidden">⇩</span><sub>2</sub> s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ t<span class="hidden">⇩</span><sub>2</sub> s ∈ S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_domain</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ (t<span class="hidden">⇩</span><sub>1</sub> + t<span class="hidden">⇩</span><sub>2</sub>) s = φ t<span class="hidden">⇩</span><sub>1</sub> (φ t<span class="hidden">⇩</span><sub>2</sub> s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_solution</span><span class="delimiter">[</span><span>OF</span><span> </span><span>additive_in_ivp_sols</span><span class="delimiter">]</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>orbit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"γ<span class="hidden">⇧</span><sup>φ</sup>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"γ<span class="hidden">⇧</span><sup>φ</sup> s = g_orbital f (λs. True) T S 0 s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>orbit_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"γ<span class="hidden">⇧</span><sup>φ</sup> s = {φ t s| t. t ∈ T}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_solution</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>orbit_def</span><span> </span><span>g_orbital_eq</span><span> </span><span>ivp_sols_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>has_vderiv_on_domain</span><span> </span><span>ivp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>in_domain</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>g_orbital_collapses</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g_orbital f G T S 0 s = {φ t s| t. t ∈ T ∧ (∀τ∈down T t. G (φ τ s))}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subset_antisym</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>subset_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?gorbit</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{φ t s |t. t ∈ T ∧ (∀τ∈down T t. G (φ τ s))}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s'</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ g_orbital f G T S 0 s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x_ivp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"X ∈ Sols (λt. f) T S 0 s"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t = s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>guard</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(𝒫 X (down T t) ⊆ {s. G s})"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_orbital_def</span><span> </span><span>g_orbit_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀τ∈(down T t). X τ = φ τ s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_solution</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x_ivp</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒫 (λt. φ t s) (down T t) ⊆ {s. G s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>guard</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ t s = X t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_solution</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x_ivp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ ?gorbit"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹X t = s'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s'∈ g_orbital f G T S 0 s. s' ∈ ?gorbit"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?gorbit</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{φ t s |t. t ∈ T ∧ (∀τ∈down T t. G (φ τ s))}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s'</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ ?gorbit"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒫 (λt. φ t s) (down T t) ⊆ {s. G s}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ t s = s'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ g_orbital f G T S 0 s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>g_orbitalI</span><span> </span><span>in_ivp_sols</span><span class="delimiter">)</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s'∈?gorbit. s' ∈ g_orbital f G T S 0 s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>line_is_local_flow</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"0 ∈ T ⟹ is_interval T ⟹ open T ⟹ local_flow (λ s. c) T UNIV (λ t s. s + t *<span class="hidden">⇩</span><sub>R</sub> c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local_lipschitz_def</span><span> </span><span>lipschitz_on_def</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"1/2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>f'1</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ s. 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g'1</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ s. c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>has_vderiv_on_add</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>has_vderiv_on_eq_rhs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>derivative_intros</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="HS_VC_Spartan">
<div class="head"><h1>Theory HS_VC_Spartan</h1>
<span class="command">theory</span> <span class="name">HS_VC_Spartan</span><br/>
<span class="keyword">imports</span> <a href="HS_ODEs.html"><span class="name">HS_ODEs</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Verification components for hybrid systems 
    Author:      Jonathan Julián Huerta y Munive, 2019
    Maintainer:  Jonathan Julián Huerta y Munive &lt;jjhuertaymunive1@sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Verification components for hybrid systems ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ A light-weight version of the verification components. We define the forward box 
operator to compute weakest liberal preconditions (wlps) of hybrid programs. Then we 
introduce three methods for verifying correctness specifications of the continuous 
dynamics of a HS. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HS_VC_Spartan</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>HS_ODEs</span><span>
</span><span>                        
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>pred</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>Transitive_Closure.rtrancl</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">]</span><span> </span><span>999</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>Union</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"μ"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g_orbital</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _ on _ _ @ _)"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"skip ≡ (λs. {s})"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification of regular programs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First we add lemmas for computation of weakest liberal preconditions (wlps).›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fbox</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b set) ⇒ 'b pred ⇒ 'a pred"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"|_] _"</span></span></span><span> </span><span class="delimiter">[</span><span>61</span><span class="delimiter">,</span><span>81</span><span class="delimiter">]</span><span> </span><span>82</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|F] P = (λs. (∀s'. s' ∈ F s ⟶ P s'))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_iso</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ Q ⟹ |F] P ≤ |F] Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_invariants</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ |F] I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J ≤ |F] J"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λs. I s ∧ J s) ≤ |F] (λs. I s ∧ J s)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λs. I s ∨ J s) ≤ |F] (λs. I s ∨ J s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Now, we compute wlps for specific programs starting with @{text "skip"}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_eta</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fbox skip P = P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next, we introduce assignments and their wlps.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vec_upd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a^'n ⇒ 'n ⇒ 'a ⇒ 'a^'n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_upd s i a = (χ j. ((($) s)(i := a)) j)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>assign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'n ⇒ ('a^'n ⇒ 'a) ⇒ 'a^'n ⇒ ('a^'n) set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(2_ ::= _)"</span></span></span><span> </span><span class="delimiter">[</span><span>70</span><span class="delimiter">,</span><span> </span><span>65</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ::= e) = (λs. {vec_upd s x (e s)})"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_assign</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|x ::= e] Q = (λs. Q (χ j. ((($) s)(x := (e s))) j))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vec_upd_def</span><span> </span><span>assign_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>fbox_def</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The wlp of a (kleisli) composition is just the composition of the wlps.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>kcomp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b set) ⇒ ('b ⇒ 'c set) ⇒ ('a  ⇒ 'c set)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>75</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"F ; G = μ ∘ 𝒫 G ∘ F"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kcomp_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f ; g) x = ⋃ {g y |y. y ∈ f x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kcomp_def</span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_kcomp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|G ; F] P = |G] |F] P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_def</span><span> </span><span>kcomp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoare_kcomp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |G] R"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R ≤ |F] Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |G ; F] Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>fbox_kcomp</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fbox_iso</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We also have an implementation of the conditional operator and its wlp.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ifthenelse</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ ('a ⇒ 'b set) ⇒ ('a ⇒ 'b set) ⇒ ('a ⇒ 'b set)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"IF _ THEN _ ELSE _"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"IF P THEN X ELSE Y ≡ (λs. if P s then X s else Y s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_if_then_else</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"|IF T THEN X ELSE Y] Q = (λs. (T s ⟶ ( |X] Q) s) ∧ (¬ T s ⟶ ( |Y] Q) s))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_def</span><span> </span><span>ifthenelse_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoare_if_then_else</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λs. P s ∧ T s) ≤ |X] Q"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λs. P s ∧ ¬ T s) ≤ |Y] Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |IF T THEN X ELSE Y] Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_def</span><span> </span><span>ifthenelse_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The final wlp we add is that of the finite iteration.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>kpower</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a set) ⇒ nat ⇒ ('a ⇒ 'a set)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kpower f n = (λs. ((;) f ^^ n) skip s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kpower_base</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kpower f 0 s = {s}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kpower f (Suc 0) s = f s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kpower_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>kcomp_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kpower_simp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"kpower f (Suc n) s = (f ; kpower f n) s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kcomp_eq</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kpower_base</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subset_antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kpower_def</span><span> </span><span>kcomp_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>kleene_star</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a set) ⇒ ('a ⇒ 'a set)"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">]</span><span> </span><span>999</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(f<span class="hidden">⇧</span><sup>*</sup>) s = ⋃ {kpower f n s |n. n ∈ UNIV}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kpower_inv</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. I s ⟶ (∀s'. s' ∈ F s ⟶ I s')"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. I s ⟶ (∀s'. s' ∈ (kpower F n s) ⟶ I s')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kpower_base</span><span> </span><span>kpower_simp</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>kcomp_eq</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"I y"</span></span></span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kstar_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ |F] I ⟹ I ≤ |F<span class="hidden">⇧</span><sup>*</sup>] I"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kleene_star_def</span><span> </span><span>fbox_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>le_fun_def</span><span class="delimiter">,</span><span> </span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. I x ⟶ (∀s'. s' ∈ F x ⟶ I s')"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kpower_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>I</span><span> </span><span>F</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_kstarI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ |F] I"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |F<span class="hidden">⇧</span><sup>*</sup>] Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ |F<span class="hidden">⇧</span><sup>*</sup>] I"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>kstar_inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |F<span class="hidden">⇧</span><sup>*</sup>] I"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|F<span class="hidden">⇧</span><sup>*</sup>] I ≤ |F<span class="hidden">⇧</span><sup>*</sup>] Q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fbox_iso</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>loopi</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a set) ⇒ 'a pred ⇒ ('a ⇒ 'a set)"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"LOOP _ INV _ "</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LOOP F INV I ≡ (F<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_loopI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ I ⟹ I ≤ Q ⟹ I ≤ |F] I ⟹ P ≤ |LOOP F INV I] Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>loopi_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fbox_kstarI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification of hybrid programs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification by providing evolution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>g_evol</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::ord) ⇒ 'b ⇒ 'b) ⇒ 'b pred ⇒ 'a set ⇒ ('b ⇒ 'b set)"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"EVOL"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"EVOL φ G T = (λs. g_orbit (λt. φ t s) G T)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_g_evol</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>φ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::preorder) ⇒ 'b ⇒ 'b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|EVOL φ G T] Q = (λs. (∀t∈T. (∀τ∈down T t. G (φ τ s)) ⟶ Q (φ t s)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_evol_def</span><span> </span><span>g_orbit_eq</span><span> </span><span>fbox_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification by providing solutions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_g_orbital</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|x´=f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] Q = 
  (λs. ∀X∈Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s. ∀t∈T. (∀τ∈down T t. G (X τ)) ⟶ Q (X t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_def</span><span> </span><span>g_orbital_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>local_flow</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_g_ode</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|x´=f &amp; G on T S @ 0] Q = 
  (λs. s ∈ S ⟶ (∀t∈T. (∀τ∈down T t. G (φ τ s)) ⟶ Q (φ t s)))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?wlp"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_g_orbital</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λt. φ t s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ballE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_ivp_sols</span><span> 
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>init_time</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈down T t. X τ = φ τ s"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_solution</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_time</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_g_ode_ivl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≥ 0 ⟹ t ∈ T ⟹ |x´=f &amp; G on {0..t} S @ 0] Q = 
  (λs. s ∈ S ⟶ (∀t∈{0..t}. (∀τ∈{0..t}. G (φ τ s)) ⟶ Q (φ t s)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_g_orbital</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λt. φ t s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ballE</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_ivp_sols_ivl</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closed_segment_eq_real_ivl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_ivp_sols_ivl</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈{0..t}. (∀τ∈{0..t}. X τ = φ τ s)"</span></span></span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_solution_ivl</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>has_vderiv_on_subset</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closed_segment_eq_real_ivl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closed_segment_eq_real_ivl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>interval_time</span><span> </span><span>init_time</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>is_interval_1</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_time</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_orbit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|γ<span class="hidden">⇧</span><sup>φ</sup>] Q = (λs. s ∈ S ⟶ (∀ t ∈ T. Q (φ t s)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>orbit_def</span><span> </span><span>fbox_g_ode</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Verification with differential invariants ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>g_ode_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::banach)⇒'a) ⇒ 'a pred ⇒ real set ⇒ 'a set ⇒ 
  real ⇒ 'a pred ⇒ ('a ⇒ 'a set)"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _ on _ _ @ _ DINV _ )"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub> DINV I) = (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_g_orbital_guard</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H = (λs. G s ∧ Q s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|x´=f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] Q = |x´=f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] H "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_g_orbital</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_g_orbital_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ |x´=f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |x´=f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fbox_iso</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_diff_inv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(I ≤ |x´=f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] I) = diff_invariant I f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>diff_invariant_def</span><span> </span><span>ivp_sols_def</span><span> </span><span>fbox_def</span><span> </span><span>g_orbital_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_inv_guard_ignore</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ |x´= f &amp; (λs. True) on T S @ t<span class="hidden">⇩</span><sub>0</sub>] I"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ |x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] I"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_diff_inv</span><span> </span><span>diff_invariant_eq</span><span> </span><span>image_le_pred</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>local_flow</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_diff_inv_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f T S 0 (λs. True) = 
  ((λs. s ∈ S ⟶ I s) = |x´= f &amp; (λs. True) on T S @ 0] (λs. s ∈ S ⟶ I s))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_diff_inv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>fbox_g_orbital</span><span> </span><span>le_fun_def</span><span> </span><span>fun_eq_iff</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_time</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subset_eq</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>safe</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ivp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λt. φ t x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_domain</span><span> </span><span>has_vderiv_on_domain</span><span> </span><span>ivp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>init_time</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_inv_eq_inv_set</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f T S 0 (λs. True) = (∀s. I s ⟶ γ<span class="hidden">⇧</span><sup>φ</sup> s ⊆ {s. I s})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_inv_eq_inv_set</span><span> </span><span>orbit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_g_odei</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ I ⟹ I ≤ |x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] I ⟹ (λs. I s ∧ G s) ≤ Q ⟹ 
  P ≤ |x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub> DINV I] Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_ode_inv_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>b</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"|x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>fbox_g_orbital_inv</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>fbox_g_orbital_guard</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fbox_iso</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Derivation of the rules of dL ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ We derive domain specific rules of differential dynamic logic (dL). First we present a 
generalised version, then we show the rules as instances of the general ones.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_solve_axiom</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::{heine_borel, banach}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open T"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|x´=(λs. c) &amp; G on T UNIV @ 0] Q = 
  (λs. ∀t∈T. (𝒫 (λτ. s + τ *<span class="hidden">⇩</span><sub>R</sub> c) (down T t) ⊆ {s. G s}) ⟶ Q (s + t *<span class="hidden">⇩</span><sub>R</sub> c))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>local_flow.fbox_g_ode</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λs. c"</span></span></span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λt s. s + t *<span class="hidden">⇩</span><sub>R</sub> c)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>line_is_local_flow</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_solve_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow f T UNIV φ"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. P s ⟶ (∀ t∈T. (𝒫 (λt. φ t s) (down T t) ⊆ {s. G s}) ⟶ Q (φ t s))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |x´= f &amp; G on T UNIV @ 0] Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>local_flow.fbox_g_ode</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_weak_axiom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] Q = |x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] (λs. G s ⟶ Q s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_g_orbital</span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_weak_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G ≤ Q ⟹ P ≤ |x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>g_orbitalD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>le_fun_def</span><span> </span><span>g_orbital_eq</span><span> </span><span>fbox_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_g_orbital_eq_univD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] C = (λs. True)"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈(down T t). x τ ∈ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈(down T t). C (x τ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>τ</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ (down T t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x τ ∈ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s'. s' ∈ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s ⟶ C s'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C (x τ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_cut_axiom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Thyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>0</sub> ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] C = (λs. True)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] Q = |x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>] Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ x. |x] Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>HOL.arg_cong</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>subset_antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s'</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>τ</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x_ivp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X τ = s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>guard_x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"𝒫 X (down T τ) ⊆ {s. G s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalD</span><span class="delimiter">[</span><span>of</span><span> </span><span>s'</span><span> </span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span> </span><span>G</span><span> </span><span>T</span><span> </span><span>S</span><span> </span><span>t<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span>s</span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). 𝒫 X (down T t) ⊆ {s. G s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>guard_x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). t ∈ T"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ∈ T›</span></span></span><span> </span><span>Thyp</span><span> </span><span>closed_segment_subset_interval</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). X t ∈ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x_ivp</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). C (X t)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fbox_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ (x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x_ivp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ∈ T›</span></span></span><span class="delimiter">]</span><span> </span><span>guard_x</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹X τ = s'›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s ⊆ (x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s. (x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s ⊆ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_orbital_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_cut_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Thyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>0</sub> ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fbox_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] C"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fbox_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>] Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>] Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>fbox_def</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>g_orbital_eq</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_ivp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"X ∈ Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>guard_x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀τ. τ ∈ T ∧ τ ≤ t ⟶ G (X τ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈(down T t). X τ ∈ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x_ivp</span><span class="delimiter">]</span><span> </span><span>guard_x</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>image_le_pred</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈(down T t). C (X τ)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fbox_C</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P s›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>fbox_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t ∈ (x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>guard_x</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>g_orbitalI</span><span> </span><span>x_ivp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q (X t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P s›</span></span></span><span> </span><span>fbox_Q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>fbox_def</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The rules of dL›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>g_global_orbit</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"(('a::banach)⇒'a) ⇒ 'a pred ⇒ 'a ⇒ 'a set"</span></span></span><span> 
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _)"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´=f &amp; G) ≡ (x´=f &amp; G on UNIV UNIV @ 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>g_global_ode_inv</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"(('a::banach)⇒'a) ⇒ 'a pred ⇒ 'a pred ⇒ 'a ⇒ 'a set"</span></span></span><span> 
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _ DINV _)"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´=f &amp; G DINV I) ≡ (x´=f &amp; G on UNIV UNIV @ 0 DINV I)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>solve</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow f UNIV UNIV φ"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. P s ⟶ (∀t. (∀τ≤t. G (φ τ s)) ⟶ Q (φ t s))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |x´= f &amp; G] Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_solve_rule</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>image_le_pred</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DS</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::{heine_borel, banach}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|x´=(λs. c) &amp; G] Q = (λx. ∀t. (∀τ≤t. G (x + τ *<span class="hidden">⇩</span><sub>R</sub> c)) ⟶ Q (x + t *<span class="hidden">⇩</span><sub>R</sub> c))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>diff_solve_axiom</span><span class="delimiter">[</span><span>of</span><span> </span><span>UNIV</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DW</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|x´= f &amp; G] Q = |x´= f &amp; G] (λs. G s ⟶ Q s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_weak_axiom</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dW</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G ≤ Q ⟹ P ≤ |x´= f &amp; G] Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_weak_rule</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|x´= f &amp; G] C = (λs. True)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|x´= f &amp; G] Q = |x´= f &amp; (λs. G s ∧ C s)] Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_cut_axiom</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |x´= f &amp; G] C"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |x´= f &amp; (λs. G s ∧ C s)] Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |x´= f &amp; G] Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_cut_rule</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f UNIV UNIV 0 G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ |x´= f &amp; G] Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fbox_g_orbital_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="HS_VC_Examples">
<div class="head"><h1>Theory HS_VC_Examples</h1>
<span class="command">theory</span> <span class="name">HS_VC_Examples</span><br/>
<span class="keyword">imports</span> <a href="HS_VC_Spartan.html"><span class="name">HS_VC_Spartan</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Examples of hybrid systems verifications
    Author:      Jonathan Julián Huerta y Munive, 2019
    Maintainer:  Jonathan Julián Huerta y Munive &lt;jjhuertaymunive1@sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Examples ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ We prove partial correctness specifications of some hybrid systems with our
verification components.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HS_VC_Examples</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>HS_VC_Spartan</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pendulum›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ The ODEs @{text "x' t = y t"} and {text "y' t = - x t"} describe the circular motion of
a mass attached to a string looked from above. We use @{text "s$1"} to represent the x-coordinate
and @{text "s$2"} for the y-coordinate. We prove that this motion remains circular. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>fpend</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f s ≡ (χ i. if i = 1 then s$2 else -s$1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>pend_flow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ t s ≡ (χ i. if i = 1 then s$1 * cos t + s$2 * sin t else - s$1 * sin t + s$2 * cos t)"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Verified with annotated dynamics. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pendulum_dyn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>) ≤ |EVOL φ G T] (λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="comment">― ‹Verified with differential invariants. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pendulum_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>) ≤ |x´= f &amp; G] (λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>diff_invariant_rules</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹Verified with the flow. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_flow_pend</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow f UNIV UNIV φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local_lipschitz_def</span><span> </span><span>lipschitz_on_def</span><span> </span><span>vec_eq_iff</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dist_norm</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span> </span><span>power2_commute</span><span> </span><span>UNIV_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>forall_2</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pendulum_flow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>) ≤ |x´=f &amp; G] (λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>local_flow.fbox_g_ode</span><span class="delimiter">[</span><span>OF</span><span> </span><span>local_flow_pend</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>fpend</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pend_flow</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Bouncing Ball ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ A ball is dropped from rest at an initial height @{text "h"}. The motion is described with
the free-fall equations @{text "x' t = v t"} and @{text "v' t = g"} where @{text "g"} is the
constant acceleration due to gravity. The bounce is modelled with a variable assigntment that
flips the velocity, thus it is a completely elastic collision with the ground. We use @{text "s$1"}
to ball's height and @{text "s$2"} for its velocity. We prove that the ball remains above ground
and below its initial resting position. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>fball</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f g s ≡ (χ i. if i = 1 then s$2 else g)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ball_flow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real ⇒ real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ g t s ≡ (χ i. if i = 1 then g * t ^ 2/2 + s$2 * t + s$1 else g * t + s$2)"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Verified with differential invariants. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>bb_real_arith</span><span> </span><span class="string"><span class="delete"><span class="delete">"real arithmetic properties for the bouncing ball."</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_imp_pos_le</span><span class="delimiter">[</span><span>bb_real_arith</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &gt; g"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * x - 2 * g * h = v * v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::real) ≤ h"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v * v = 2 * g * x - 2 * g * h ∧ 0 &gt; g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &gt; g›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"v * v = 2 * g * (x - h) ∧ 0 &gt; g ∧ v * v ≥ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>left_diff_distrib</span><span> </span><span>mult.commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>zero_le_square</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v * v)/(2 * g) = (x - h)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>obs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v * v)/(2 * g) ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>divide_nonneg_neg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h - x ≥ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bouncing_ball_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0 ⟹ h ≥ 0 ⟹
  (λs. s$1 = h ∧ s$2 = 0) ≤
  |LOOP (
    (x´=(f g) &amp; (λ s. s$1 ≥ 0) DINV (λs. 2 * g * s$1 - 2 * g * h - s$2 * s$2 = 0)) ;
    (IF (λ s. s$1 = 0) THEN (2 ::= (λs. - s$2)) ELSE skip))
  INV (λs. 0 ≤ s$1 ∧2 * g * s$1 - 2 * g * h - s$2 * s$2 = 0)]
  (λs. 0 ≤ s$1 ∧ s$1 ≤ h)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>fbox_loopI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bb_real_arith</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fbox_g_odei</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span> </span><span>diff_invariant_rules</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹Verified with annotated dynamics. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_conserv_at_ground</span><span class="delimiter">[</span><span>bb_real_arith</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * x = 2 * g * h + v * v"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g * τ<span class="hidden">⇧</span><sup>2</sup> / 2 + v * τ + (x::real) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * h + (g * τ + v) * (g * τ + v) = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pos</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g * τ<span class="hidden">⇧</span><sup>2</sup>  + 2 * v * τ + 2 * x = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup>  + 2 * g * v * τ + 2 * g * x = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>mult_zero_right</span><span>
</span><span>        </span><span>monoid_mult_class.power2_eq_square</span><span> </span><span>semiring_class.distrib_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup> + 2 * g * v * τ + v<span class="hidden">⇧</span><sup>2</sup> + 2 * g * h = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invar</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monoid_mult_class.power2_eq_square</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(g * τ + v)<span class="hidden">⇧</span><sup>2</sup> + 2 * g * h = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>power2_sum</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Groups.add_ac</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span> </span><span>3</span><span class="delimiter">)</span><span>
</span><span>        </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span> </span><span>3</span><span class="delimiter">)</span><span> </span><span>monoid_mult_class.power2_eq_square</span><span> </span><span>nat_distrib</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * h + (g * τ + v) * (g * τ + v) = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span> </span><span>distrib_right</span><span> </span><span>power2_eq_square</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_conserv_at_air</span><span class="delimiter">[</span><span>bb_real_arith</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * x = 2 * g * h + v * v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * (g * τ<span class="hidden">⇧</span><sup>2</sup> / 2 + v * τ + (x::real)) =
  2 * g * h + (g * τ + v) * (g * τ + v)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup> + 2 * g * v * τ + 2 * g * x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>29</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup> + 2 * g * v * τ + 2 * g * h + v * v"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ?middle"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>invar</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?middle"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rhs = g * g * (τ * τ) + 2 * g * v * τ + 2 * g * h + v * v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>semiring_class.distrib_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ?middle"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>29</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rhs = ?middle"</span></span></span><span class="keyword1"><span class="command">.</span></span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bouncing_ball_dyn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0 ⟹ h ≥ 0 ⟹
  (λs. s$1 = h ∧ s$2 = 0) ≤
  |LOOP (
    (EVOL (φ g) (λ s. s$1 ≥ 0) T) ;
    (IF (λ s. s$1 = 0) THEN (2 ::= (λs. - s$2)) ELSE skip))
  INV (λs. 0 ≤ s$1 ∧2 * g * s$1 = 2 * g * h + s$2 * s$2)]
  (λs. 0 ≤ s$1 ∧ s$1 ≤ h)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fbox_loopI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bb_real_arith</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹Verified with the flow. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_flow_ball</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow (f g) UNIV UNIV (φ g)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local_lipschitz_def</span><span> </span><span>lipschitz_on_def</span><span> </span><span>vec_eq_iff</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"1/2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dist_norm</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span> </span><span>UNIV_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>forall_2</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bouncing_ball_flow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0 ⟹ h ≥ 0 ⟹
  (λs. s$1 = h ∧ s$2 = 0) ≤
  |LOOP (
    (x´=(f g) &amp; (λ s. s$1 ≥ 0)) ;
    (IF (λ s. s$1 = 0) THEN (2 ::= (λs. - s$2)) ELSE skip))
  INV (λs. 0 ≤ s$1 ∧2 * g * s$1 = 2 * g * h + s$2 * s$2)]
  (λs. 0 ≤ s$1 ∧ s$1 ≤ h)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fbox_loopI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bb_real_arith</span><span> </span><span>local_flow.fbox_g_ode</span><span class="delimiter">[</span><span>OF</span><span> </span><span>local_flow_ball</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>fball</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ball_flow</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Thermostat ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ A thermostat has a chronometer, a thermometer and a switch to turn on and off a heater.
At most every @{text "t"} minutes, it sets its chronometer to @{term "0::real"}, it registers
the room temperature, and it turns the heater on (or off) based on this reading. The temperature
follows the ODE @{text "T' = - a * (T - U)"} where @{text "U"} is @{text "L ≥ 0"} when the heater
is on, and @{text "0"} when it is off. We use @{term "1::4"} to denote the room's temperature,
@{term "2::4"} is time as measured by the thermostat's chronometer, @{term "3::4"} is the
temperature detected by the thermometer, and @{term "4::4"} states whether the heater is on
(@{text "s$4 = 1"}) or off (@{text "s$4 = 0"}). We prove that the thermostat keeps the room's
temperature between @{text "Tmin"} and @{text "Tmax"}. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>temp_vec_field</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real ⇒ real^4 ⇒ real^4"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f a L s ≡ (χ i. if i = 2 then 1 else (if i = 1 then - a * (s$1 - L) else 0))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>temp_flow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real ⇒ real ⇒ real^4 ⇒ real^4"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ a L t s ≡ (χ i. if i = 1 then - exp(-a * t) * (L - s$1) + L else
  (if i = 2 then t + s$2 else s$i))"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Verified with the flow. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_diff_temp_dyn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; a ⟹ ∥f a L s<span class="hidden">⇩</span><sub>1</sub> - f a L s<span class="hidden">⇩</span><sub>2</sub>∥ = ¦a¦ * ¦s<span class="hidden">⇩</span><sub>1</sub>$1 - s<span class="hidden">⇩</span><sub>2</sub>$1¦"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>UNIV_4</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀r ra. ¦(r::real) + - ra¦ = ¦ra + - r¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>abs_minus_commute</span><span> </span><span>minus_real_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀r ra rb. (r::real) * ra + - (r * rb) = r * (ra + - rb)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>minus_real_def</span><span> </span><span>right_diff_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦a * (s<span class="hidden">⇩</span><sub>1</sub>$1 + - L) + - (a * (s<span class="hidden">⇩</span><sub>2</sub>$1 + - L))¦ = a * ¦s<span class="hidden">⇩</span><sub>1</sub>$1 + - s<span class="hidden">⇩</span><sub>2</sub>$1¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_mult</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦a * (s<span class="hidden">⇩</span><sub>2</sub>$1 - L) - a * (s<span class="hidden">⇩</span><sub>1</sub>$1 - L)¦ = a * ¦s<span class="hidden">⇩</span><sub>1</sub>$1 - s<span class="hidden">⇩</span><sub>2</sub>$1¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>minus_real_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_lipschitz_temp_dyn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; (a::real)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_lipschitz UNIV UNIV (λt::real. f a L)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>local_lipschitz_def</span><span> </span><span>lipschitz_on_def</span><span> </span><span>dist_norm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>a</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_diff_temp_dyn</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>UNIV_4</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>real_sqrt_abs</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>real_le_lsqrt</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_flow_temp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0 ⟹ local_flow (f a L) UNIV UNIV (φ a L)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span> </span><span>local_lipschitz_temp_dyn</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>forall_4</span><span> </span><span>vec_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>temp_dyn_down_real_arith</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; Tmin"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ (t::real)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈{0..t}. τ ≤ - (ln (Tmin / T) / a) "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ exp (-a * t) * T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp (-a * t) * T ≤ Tmax"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t ∧ t ≤ - (ln (Tmin / T) / a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln (Tmin / T) ≤ - a * t ∧ - a * t ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>divide_le_cancel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin / T &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin / T ≤ exp (-a * t)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp (-a * t) ≤ 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exp_ln</span><span> </span><span>exp_le_one_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>exp_less_cancel_iff</span><span> </span><span>not_less</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ exp (-a * t) * T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pos_divide_le_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp (-a * t) * T ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span>mult_left_le_one_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>exp_ge_zero</span><span> </span><span>obs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>      </span><span>less_eq_real_def</span><span> </span><span>order_trans_rules</span><span class="delimiter">(</span><span>23</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>temp_dyn_up_real_arith</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ≤ Tmax"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmax &lt; (L::real)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈{0..t}. τ ≤ - (ln ((L - Tmax) / (L - T)) / a) "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - Tmax ≤ exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - exp (-(a * t)) * (L - T) ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ L - exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t ∧ t ≤ - (ln ((L - Tmax) / (L - T)) / a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln ((L - Tmax) / (L - T)) ≤ - a * t ∧ - a * t ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>divide_le_cancel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) / (L - T) &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) / (L - T) ≤ exp (-a * t) ∧ exp (-a * t) ≤ 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exp_ln</span><span> </span><span>exp_le_one_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>exp_less_cancel_iff</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - T &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) ≤ exp (-a * t) * (L - T) ∧ exp (-a * t) * (L - T) ≤ (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pos_divide_le_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) ≤ exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - exp (-(a * t)) * (L - T) ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ L - exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>obs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fbox_temp_dyn</span><span> </span><span class="delimiter">=</span><span> </span><span>local_flow.fbox_g_ode_ivl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>local_flow_temp</span><span> </span><span>_</span><span> </span><span>UNIV_I</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>thermostat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; Tmin"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmax &lt; L"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λs. Tmin ≤ s$1 ∧ s$1 ≤ Tmax ∧ s$4 = 0) ≤
  |LOOP
    ― ‹control›
    ((2 ::= (λs. 0));(3 ::= (λs. s$1));
    (IF (λs. s$4 = 0 ∧ s$3 ≤ Tmin + 1) THEN (4 ::= (λs.1)) ELSE
    (IF (λs. s$4 = 1 ∧ s$3 ≥ Tmax - 1) THEN (4 ::= (λs.0)) ELSE skip));
    ― ‹dynamics›
    (IF (λs. s$4 = 0) THEN (x´=(f a 0) &amp; (λs. s$2 ≤ - (ln (Tmin/s$3))/a) on {0..t} UNIV @ 0)
    ELSE (x´=(f a L) &amp; (λs. s$2 ≤ - (ln ((L-Tmax)/(L-s$3)))/a) on {0..t} UNIV @ 0)) )
  INV (λs. Tmin ≤s$1 ∧ s$1 ≤ Tmax ∧ (s$4 = 0 ∨ s$4 = 1))]
  (λs. Tmin ≤ s$1 ∧ s$1 ≤ Tmax)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>fbox_loopI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fbox_temp_dyn</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>le_fun_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>temp_dyn_up_real_arith</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>Tmin</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>temp_dyn_down_real_arith</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>Tmax</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>temp_vec_field</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>temp_flow</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="HS_VC_PT">
<div class="head"><h1>Theory HS_VC_PT</h1>
<span class="command">theory</span> <span class="name">HS_VC_PT</span><br/>
<span class="keyword">imports</span> <a href="HS_ODEs.html"><span class="name">HS_ODEs</span></a> <a href="Kleisli_Quantale.html"><span class="name">Kleisli_Quantale</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Verification components with predicate transformers
    Author:      Jonathan Julián Huerta y Munive, 2019
    Maintainer:  Jonathan Julián Huerta y Munive &lt;jjhuertaymunive1@sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Verification components with predicate transformers ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ We use the categorical forward box operator @{text fb<span class="hidden">⇩</span><sub>ℱ</sub>} to compute weakest liberal 
preconditions (wlps) of hybrid programs. Then we repeat the three methods for verifying 
correctness specifications of the continuous dynamics of a HS. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HS_VC_PT</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../HS_ODEs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Transformer_Semantics.Kleisli_Quantale"</span></span></span><span>
</span><span>                        
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment">― ‹We start by deleting some notation and introducing some new.›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>bres</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"→"</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dagger</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_<span class="hidden">⇧</span><sup>†</sup>"</span></span></span><span> </span><span class="delimiter">[</span><span>101</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Relation.relcomp"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>75</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eta</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"η"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>kcomp</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∘<span class="hidden">⇩</span><sub>K</sub>"</span></span></span><span> </span><span>75</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>pred</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>eta</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"skip"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>kcomp</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>75</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g_orbital</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _ on _ _ @ _)"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification of regular programs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Properties of the forward box operator. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> F S = {s. F s ⊆ S}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_def</span><span> </span><span>map_dual_def</span><span> </span><span>klift_def</span><span> </span><span>kop_def</span><span> </span><span>dual_set_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Compl_eq_Diff_UNIV</span><span> </span><span>fun_eq_iff</span><span> </span><span>f2r_def</span><span> </span><span>converse_def</span><span> </span><span>r2f_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> F S = {s. ∀s'. s' ∈ F s ⟶ s' ∈ S}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>kop_def</span><span> </span><span>klift_def</span><span> </span><span>map_dual_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dual_set_def</span><span> </span><span>f2r_def</span><span> </span><span>r2f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_iso</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ Q ⟹ fb<span class="hidden">⇩</span><sub>ℱ</sub> F P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> F Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_invariants</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. I s} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> F {s. I s}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. J s} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> F {s. J s}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. I s ∧ J s} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> F {s. I s ∧ J s}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. I s ∨ J s} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> F {s. I s ∨ J s}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The weakest liberal precondition (wlp) of the ``skip'' program is the identity. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_skip</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> skip S = S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>kop_def</span><span> </span><span>klift_def</span><span> </span><span>map_dual_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next, we introduce assignments and their wlps.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vec_upd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a^'n) ⇒ 'n ⇒ 'a ⇒ 'a^'n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_upd s i a = (χ j. ((($) s)(i := a)) j)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>assign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'n ⇒ ('a^'n ⇒ 'a) ⇒ ('a^'n) ⇒ ('a^'n) set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(2_ ::= _)"</span></span></span><span> </span><span class="delimiter">[</span><span>70</span><span class="delimiter">,</span><span> </span><span>65</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ::= e) = (λs. {vec_upd s x (e s)})"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_assign</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (x ::= e) Q = {s. (χ j. ((($) s)(x := (e s))) j) ∈ Q}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vec_upd_def</span><span> </span><span>assign_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>ffb_eq</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The wlp of program composition is just the composition of the wlps.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_kcomp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (G ; F) P = fb<span class="hidden">⇩</span><sub>ℱ</sub> G (fb<span class="hidden">⇩</span><sub>ℱ</sub> F P)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>kop_def</span><span> </span><span>klift_def</span><span> </span><span>map_dual_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dual_set_def</span><span> </span><span>f2r_def</span><span> </span><span>r2f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>kcomp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoare_kcomp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> F R"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> G Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (F ; G) Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ffb_kcomp</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ffb_iso</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We also have an implementation of the conditional operator and its wlp.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ifthenelse</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ ('a ⇒ 'b set) ⇒ ('a ⇒ 'b set) ⇒ ('a ⇒ 'b set)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"IF _ THEN _ ELSE _"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"IF P THEN X ELSE Y = (λ x. if P x then X x else Y x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_if_then_else</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (IF T THEN X ELSE Y) Q = {s. T s ⟶ s ∈ fb<span class="hidden">⇩</span><sub>ℱ</sub> X Q} ∩ {s. ¬ T s ⟶ s ∈ fb<span class="hidden">⇩</span><sub>ℱ</sub> Y Q}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_eq</span><span> </span><span>ifthenelse_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoare_if_then_else</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∩ {s. T s} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> X Q"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∩ {s. ¬ T s} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> Y Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (IF T THEN X ELSE Y) Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ffb_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>ffb_eq</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ifthenelse_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ We also deal with finite iteration. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kpower_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ {s. ∀y. y ∈ F s ⟶ y ∈ I} ⟹ I ≤ {s. ∀y. y ∈ (kpower F n s) ⟶ y ∈ I}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>kcomp_prop</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kstar_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> F I ⟹ I ⊆ fb<span class="hidden">⇩</span><sub>ℱ</sub> (kstar F) I"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kstar_def</span><span> </span><span>ffb_eq</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kpower_inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_kstarI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> F I"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (kstar F) Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ⊆ fb<span class="hidden">⇩</span><sub>ℱ</sub> (kstar F) I"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>kstar_inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (kstar F) I"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (kstar F) I ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (kstar F) Q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ffb_iso</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>loopi</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a set) ⇒ 'a pred ⇒ ('a ⇒ 'a set)"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"LOOP _ INV _ "</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LOOP F INV I ≡ (kstar F)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_loopI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ {s. I s}  ⟹ {s. I s} ≤ Q ⟹ {s. I s} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> F {s. I s} ⟹ P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (LOOP F INV I) Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>loopi_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ffb_kstarI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification of hybrid programs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification by providing evolution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>g_evol</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::ord) ⇒ 'b ⇒ 'b) ⇒ 'b pred ⇒ 'a set ⇒ ('b ⇒ 'b set)"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"EVOL"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"EVOL φ G T = (λs. g_orbit (λt. φ t s) G T)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_g_evol</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>φ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::preorder) ⇒ 'b ⇒ 'b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (EVOL φ G T) Q = {s. (∀t∈T. (∀τ∈down T t. G (φ τ s)) ⟶ (φ t s) ∈ Q)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_evol_def</span><span> </span><span>g_orbit_eq</span><span> </span><span>ffb_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification by providing solutions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_g_orbital</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) Q = 
  {s. ∀X∈Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s. ∀t∈T. (∀τ∈down T t. G (X τ)) ⟶ (X t) ∈ Q}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_eq</span><span> </span><span>g_orbital_eq</span><span> </span><span>subset_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>local_flow</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_g_ode</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ 0) Q = 
  {s. s ∈ S ⟶ (∀t∈T. (∀τ∈down T t. G (φ τ s)) ⟶ (φ t s) ∈ Q)}"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?wlp"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_g_orbital</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>safe</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λt. φ t x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ballE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_ivp_sols</span><span> 
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>init_time</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈down T t. X τ = φ τ x"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_solution</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_time</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_g_ode_ivl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≥ 0 ⟹ t ∈ T ⟹ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´=f &amp; G on {0..t} S @ 0) Q = 
  {s. s ∈ S ⟶ (∀t∈{0..t}. (∀τ∈{0..t}. G (φ τ s)) ⟶ (φ t s) ∈ Q)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_g_orbital</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λt. φ t x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ballE</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_ivp_sols_ivl</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closed_segment_eq_real_ivl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_ivp_sols_ivl</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈{0..t}. (∀τ∈{0..t}. X τ = φ τ x)"</span></span></span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_solution_ivl</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>has_vderiv_on_subset</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closed_segment_eq_real_ivl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closed_segment_eq_real_ivl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>interval_time</span><span> </span><span>init_time</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>is_interval_1</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_time</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_orbit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> γ<span class="hidden">⇧</span><sup>φ</sup> Q = {s. s ∈ S ⟶ (∀ t ∈ T. φ t s ∈ Q)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>orbit_def</span><span> </span><span>ffb_g_ode</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Verification with differential invariants ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>g_ode_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::banach)⇒'a) ⇒ 'a pred ⇒ real set ⇒ 'a set ⇒ 
  real ⇒ 'a pred ⇒ ('a ⇒ 'a set)"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _ on _ _ @ _ DINV _ )"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub> DINV I) = (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_g_orbital_guard</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H = (λs. G s ∧ Q s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) {s. Q s} = fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) {s. H s}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_g_orbital</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_g_orbital_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≤ Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ffb_iso</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_diff_inv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"({s. I s} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) {s. I s}) = diff_invariant I f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>diff_invariant_def</span><span> </span><span>ivp_sols_def</span><span> </span><span>ffb_eq</span><span> </span><span>g_orbital_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bdf_diff_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f T S t<span class="hidden">⇩</span><sub>0</sub> G = (bd<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) {s. I s} ≤ {s. I s})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_fbd_galois_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>diff_invariant_def</span><span> </span><span>ivp_sols_def</span><span> </span><span>ffb_eq</span><span> </span><span>g_orbital_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_inv_guard_ignore</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. I s} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; (λs. True) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) {s. I s}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. I s} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) {s. I s}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_diff_inv</span><span> </span><span>diff_invariant_eq</span><span> </span><span>image_le_pred</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>local_flow</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_diff_inv_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f T S 0 (λs. True) = 
  ({s. s ∈ S ⟶ I s} = fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; (λs. True) on T S @ 0) {s. s ∈ S ⟶ I s})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_diff_inv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ffb_g_orbital</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_time</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subset_eq</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>safe</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ivp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λt. φ t x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_domain</span><span> </span><span>has_vderiv_on_domain</span><span> </span><span>ivp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>init_time</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_inv_eq_inv_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f T S 0 (λs. True) = (∀s. I s ⟶ γ<span class="hidden">⇧</span><sup>φ</sup> s ⊆ {s. I s})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_inv_eq_inv_set</span><span> </span><span>orbit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_g_odei</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ {s. I s} ⟹ {s. I s} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) {s. I s} ⟹ 
  {s. I s ∧ G s} ≤ Q ⟹ P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub> DINV I) Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_ode_inv_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>b</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) {s. I s}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"{s. I s}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ffb_g_orbital_inv</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ffb_g_orbital_guard</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ffb_iso</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Derivation of the rules of dL ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ We derive domain specific rules of differential dynamic logic (dL). First we present a 
generalised version, then we show the rules as instances of the general ones.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_solve_axiom</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::{heine_borel, banach}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open T"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´=(λs. c) &amp; G on T UNIV @ 0) Q = 
  {s. ∀t∈T. (𝒫 (λτ. s + τ *<span class="hidden">⇩</span><sub>R</sub> c) (down T t) ⊆ {s. G s}) ⟶ (s + t *<span class="hidden">⇩</span><sub>R</sub> c) ∈ Q}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>local_flow.ffb_g_ode</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λs. c"</span></span></span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λt s. s + t *<span class="hidden">⇩</span><sub>R</sub> c)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>line_is_local_flow</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>image_le_pred</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_solve_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow f T UNIV φ"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. s ∈ P ⟶ (∀ t∈T. (𝒫 (λt. φ t s) (down T t) ⊆ {s. G s}) ⟶ (φ t s) ∈ Q)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T UNIV @ 0) Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>local_flow.ffb_g_ode</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_weak_axiom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) Q = fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) {s. G s ⟶ s ∈ Q}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_g_orbital</span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_weak_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. G s} ≤ Q ⟹ P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>g_orbitalD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>le_fun_def</span><span> </span><span>g_orbital_eq</span><span> </span><span>ffb_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ffb_g_orbital_eq_univD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) {s. C s} = UNIV"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈(down T t). x τ ∈ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈(down T t). C (x τ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>τ</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ (down T t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x τ ∈ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y. y ∈ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s ⟶ C y"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C (x τ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_cut_axiom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Thyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>0</sub> ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) {s. C s} = UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) Q = fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ x. fb<span class="hidden">⇩</span><sub>ℱ</sub> x Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>HOL.arg_cong</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>subset_antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s'</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>τ</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x_ivp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X τ = s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>guard_x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"𝒫 X (down T τ) ⊆ {s. G s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalD</span><span class="delimiter">[</span><span>of</span><span> </span><span>s'</span><span> </span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span> </span><span>G</span><span> </span><span>T</span><span> </span><span>S</span><span> </span><span>t<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span>s</span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). 𝒫 X (down T t) ⊆ {s. G s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>guard_x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). t ∈ T"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ∈ T›</span></span></span><span> </span><span>Thyp</span><span> </span><span>closed_segment_subset_interval</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). X t ∈ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x_ivp</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). C (X t)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ffb_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ (x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x_ivp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ∈ T›</span></span></span><span class="delimiter">]</span><span> </span><span>guard_x</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹X τ = s'›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>image_le_pred</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s ⊆ (x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s. (x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s ⊆ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_orbital_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_cut_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Thyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>0</sub> ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ffb_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) {s. C s}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ffb_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ffb_eq</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>g_orbital_eq</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ P"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_ivp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"X ∈ Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>guard_x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀τ. s2p T τ ∧ τ ≤ t ⟶ G (X τ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈(down T t). X τ ∈ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x_ivp</span><span class="delimiter">]</span><span> </span><span>guard_x</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>image_le_pred</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈(down T t). C (X τ)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ffb_C</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ P›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>ffb_eq</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t ∈ (x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>guard_x</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>g_orbitalI</span><span> </span><span>x_ivp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(X t) ∈ Q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ P›</span></span></span><span> </span><span>ffb_Q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>ffb_eq</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The rules of dL›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>g_global_orbit</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"(('a::banach)⇒'a) ⇒ 'a pred ⇒ 'a ⇒ 'a set"</span></span></span><span> 
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _)"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´=f &amp; G) ≡ (x´=f &amp; G on UNIV UNIV @ 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>g_global_ode_inv</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"(('a::banach)⇒'a) ⇒ 'a pred ⇒ 'a pred ⇒ 'a ⇒ 'a set"</span></span></span><span> 
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _ DINV _)"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´=f &amp; G DINV I) ≡ (x´=f &amp; G on UNIV UNIV @ 0 DINV I)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>solve</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow f UNIV UNIV φ"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. s ∈ P ⟶ (∀t. (∀τ≤t. G (φ τ s)) ⟶ (φ t s) ∈ Q)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G) Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_solve_rule</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DS</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::{heine_borel, banach}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´=(λs. c) &amp; G) Q = {x. ∀t. (∀τ≤t. G (x + τ *<span class="hidden">⇩</span><sub>R</sub> c)) ⟶ (x + t *<span class="hidden">⇩</span><sub>R</sub> c) ∈ Q}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>diff_solve_axiom</span><span class="delimiter">[</span><span>of</span><span> </span><span>UNIV</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DW</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G) Q = fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G) {s. G s ⟶ s ∈ Q}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_weak_axiom</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dW</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. G s} ≤ Q ⟹ P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G) Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_weak_rule</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G) {s. C s} = UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G) Q = fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; (λs. G s ∧ C s)) Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_cut_axiom</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G) {s. C s}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; (λs. G s ∧ C s)) Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G) Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_cut_rule</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ {s. I s}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f UNIV UNIV 0 G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. I s} ≤ Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G) Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ffb_g_orbital_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="HS_VC_PT_Examples">
<div class="head"><h1>Theory HS_VC_PT_Examples</h1>
<span class="command">theory</span> <span class="name">HS_VC_PT_Examples</span><br/>
<span class="keyword">imports</span> <a href="HS_VC_PT.html"><span class="name">HS_VC_PT</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Examples of hybrid systems verifications
    Author:      Jonathan Julián Huerta y Munive, 2019
    Maintainer:  Jonathan Julián Huerta y Munive &lt;jjhuertaymunive1@sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Examples ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ We prove partial correctness specifications of some hybrid systems with our
recently described verification components.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HS_VC_PT_Examples</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>HS_VC_PT</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Pendulum ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ The ODEs @{text "x' t = y t"} and {text "y' t = - x t"} describe the circular motion of
a mass attached to a string looked from above. We use @{text "s$1"} to represent the x-coordinate
and @{text "s$2"} for the y-coordinate. We prove that this motion remains circular. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>fpend</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f s ≡ (χ i. if i = 1 then s$2 else -s$1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>pend_flow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ t s ≡ (χ i. if i = 1 then s$1 * cos t + s$2 * sin t else - s$1 * sin t + s$2 * cos t)"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Verified by providing the dynamics›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pendulum_dyn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (EVOL φ G T) {s. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="comment">― ‹Verified with differential invariants. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pendulum_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G) {s. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>diff_invariant_rules</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹Verified with the flow. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_flow_pend</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow f UNIV UNIV φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local_lipschitz_def</span><span> </span><span>lipschitz_on_def</span><span> </span><span>vec_eq_iff</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dist_norm</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span> </span><span>power2_commute</span><span> </span><span>UNIV_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>forall_2</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pendulum_flow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub> (x´= f &amp; G) {s. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>local_flow.ffb_g_ode</span><span class="delimiter">[</span><span>OF</span><span> </span><span>local_flow_pend</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>fpend</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pend_flow</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Bouncing Ball ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ A ball is dropped from rest at an initial height @{text "h"}. The motion is described with
the free-fall equations @{text "x' t = v t"} and @{text "v' t = g"} where @{text "g"} is the
constant acceleration due to gravity. The bounce is modelled with a variable assigntment that
flips the velocity, thus it is a completely elastic collision with the ground. We use @{text "s$1"}
to ball's height and @{text "s$2"} for its velocity. We prove that the ball remains above ground
and below its initial resting position. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>fball</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f g s ≡ (χ i. if i = 1 then s$2 else g)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ball_flow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real ⇒ real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ g t s ≡ (χ i. if i = 1 then g * t ^ 2/2 + s$2 * t + s$1 else g * t + s$2)"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Verified with differential invariants. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>bb_real_arith</span><span> </span><span class="string"><span class="delete"><span class="delete">"real arithmetic properties for the bouncing ball."</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_imp_pos_le</span><span class="delimiter">[</span><span>bb_real_arith</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &gt; g"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * x - 2 * g * h = v * v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::real) ≤ h"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v * v = 2 * g * x - 2 * g * h ∧ 0 &gt; g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &gt; g›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"v * v = 2 * g * (x - h) ∧ 0 &gt; g ∧ v * v ≥ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>left_diff_distrib</span><span> </span><span>mult.commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>zero_le_square</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v * v)/(2 * g) = (x - h)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>obs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v * v)/(2 * g) ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>divide_nonneg_neg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h - x ≥ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bouncing_ball_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0 ⟹ h ≥ 0 ⟹
  {s. s$1 = h ∧ s$2 = 0} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub>
  (LOOP (
    (x´=(f g) &amp; (λ s. s$1 ≥ 0) DINV (λs. 2 * g * s$1 - 2 * g * h - s$2 * s$2 = 0)) ;
    (IF (λ s. s$1 = 0) THEN (2 ::= (λs. - s$2)) ELSE skip))
  INV (λs. 0 ≤ s$1 ∧2 * g * s$1 - 2 * g * h - s$2 * s$2 = 0))
  {s. 0 ≤ s$1 ∧ s$1 ≤ h}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ffb_loopI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bb_real_arith</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ffb_g_odei</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>diff_invariant_rules</span><span> </span><span>poly_derivatives</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bb_real_arith</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹Verified by providing the dynamics›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_conserv_at_ground</span><span class="delimiter">[</span><span>bb_real_arith</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * x = 2 * g * h + v * v"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g * τ<span class="hidden">⇧</span><sup>2</sup> / 2 + v * τ + (x::real) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * h + (g * τ * (g * τ + v) + v * (g * τ + v)) = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pos</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g * τ<span class="hidden">⇧</span><sup>2</sup>  + 2 * v * τ + 2 * x = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup>  + 2 * g * v * τ + 2 * g * x = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>mult_zero_right</span><span>
</span><span>        </span><span>monoid_mult_class.power2_eq_square</span><span> </span><span>semiring_class.distrib_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup> + 2 * g * v * τ + v<span class="hidden">⇧</span><sup>2</sup> + 2 * g * h = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invar</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monoid_mult_class.power2_eq_square</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(g * τ + v)<span class="hidden">⇧</span><sup>2</sup> + 2 * g * h = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>power2_sum</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Groups.add_ac</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span> </span><span>3</span><span class="delimiter">)</span><span>
</span><span>        </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span> </span><span>3</span><span class="delimiter">)</span><span> </span><span>monoid_mult_class.power2_eq_square</span><span> </span><span>nat_distrib</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * h + (g * τ * (g * τ + v) + v * (g * τ + v)) = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span> </span><span>distrib_right</span><span> </span><span>power2_eq_square</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_conserv_at_air</span><span class="delimiter">[</span><span>bb_real_arith</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * x = 2 * g * h + v * v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * (g * τ<span class="hidden">⇧</span><sup>2</sup> / 2 + v * τ + (x::real)) =
  2 * g * h + (g * τ + v) * (g * τ + v)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup> + 2 * g * v * τ + 2 * g * x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>29</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup> + 2 * g * v * τ + 2 * g * h + v * v"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ?middle"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>invar</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?middle"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rhs = g * g * (τ * τ) + 2 * g * v * τ + 2 * g * h + v * v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>semiring_class.distrib_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ?middle"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>29</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rhs = ?middle"</span></span></span><span class="keyword1"><span class="command">.</span></span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bouncing_ball_dyn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0 ⟹ h ≥ 0 ⟹
  {s. s$1 = h ∧ s$2 = 0} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub>
  (LOOP (
    (EVOL (φ g) (λ s. s$1 ≥ 0) T) ;
    (IF (λ s. s$1 = 0) THEN (2 ::= (λs. - s$2)) ELSE skip))
  INV (λs. 0 ≤ s$1 ∧ 2 * g * s$1 = 2 * g * h + s$2 * s$2))
  {s. 0 ≤ s$1 ∧ s$1 ≤ h}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ffb_loopI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bb_real_arith</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹Verified with the flow. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_flow_ball</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow (f g) UNIV UNIV (φ g)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local_lipschitz_def</span><span> </span><span>lipschitz_on_def</span><span> </span><span>vec_eq_iff</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"1/2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dist_norm</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span> </span><span>UNIV_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>forall_2</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bouncing_ball_flow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0 ⟹ h ≥ 0 ⟹
  {s. s$1 = h ∧ s$2 = 0} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub>
  (LOOP (
    (x´=(f g) &amp; (λ s. s$1 ≥ 0)) ;
    (IF (λ s. s$1 = 0) THEN (2 ::= (λs. - s$2)) ELSE skip))
  INV (λs. 0 ≤ s$1 ∧ 2 * g * s$1 = 2 * g * h + s$2 * s$2))
  {s. 0 ≤ s$1 ∧ s$1 ≤ h}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ffb_loopI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bb_real_arith</span><span> </span><span>local_flow.ffb_g_ode</span><span class="delimiter">[</span><span>OF</span><span> </span><span>local_flow_ball</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>fball</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ball_flow</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Thermostat ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ A thermostat has a chronometer, a thermometer and a switch to turn on and off a heater.
At most every @{text "t"} minutes, it sets its chronometer to @{term "0::real"}, it registers
the room temperature, and it turns the heater on (or off) based on this reading. The temperature
follows the ODE @{text "T' = - a * (T - U)"} where @{text "U"} is @{text "L ≥ 0"} when the heater
is on, and @{text "0"} when it is off. We use @{term "1::4"} to denote the room's temperature,
@{term "2::4"} is time as measured by the thermostat's chronometer, @{term "3::4"} is the
temperature detected by the thermometer, and @{term "4::4"} states whether the heater is on
(@{text "s$4 = 1"}) or off (@{text "s$4 = 0"}). We prove that the thermostat keeps the room's
temperature between @{text "Tmin"} and @{text "Tmax"}. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>temp_vec_field</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real ⇒ real^4 ⇒ real^4"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f a L s ≡ (χ i. if i = 2 then 1 else (if i = 1 then - a * (s$1 - L) else 0))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>temp_flow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real ⇒ real ⇒ real^4 ⇒ real^4"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ a L t s ≡ (χ i. if i = 1 then - exp(-a * t) * (L - s$1) + L else
  (if i = 2 then t + s$2 else s$i))"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Verified with the flow. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_diff_temp_dyn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; a ⟹ ∥f a L s<span class="hidden">⇩</span><sub>1</sub> - f a L s<span class="hidden">⇩</span><sub>2</sub>∥ = ¦a¦ * ¦s<span class="hidden">⇩</span><sub>1</sub>$1 - s<span class="hidden">⇩</span><sub>2</sub>$1¦"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>UNIV_4</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀r ra. ¦(r::real) + - ra¦ = ¦ra + - r¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>abs_minus_commute</span><span> </span><span>minus_real_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀r ra rb. (r::real) * ra + - (r * rb) = r * (ra + - rb)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>minus_real_def</span><span> </span><span>right_diff_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦a * (s<span class="hidden">⇩</span><sub>1</sub>$1 + - L) + - (a * (s<span class="hidden">⇩</span><sub>2</sub>$1 + - L))¦ = a * ¦s<span class="hidden">⇩</span><sub>1</sub>$1 + - s<span class="hidden">⇩</span><sub>2</sub>$1¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_mult</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦a * (s<span class="hidden">⇩</span><sub>2</sub>$1 - L) - a * (s<span class="hidden">⇩</span><sub>1</sub>$1 - L)¦ = a * ¦s<span class="hidden">⇩</span><sub>1</sub>$1 - s<span class="hidden">⇩</span><sub>2</sub>$1¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>minus_real_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_lipschitz_temp_dyn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; (a::real)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_lipschitz UNIV UNIV (λt::real. f a L)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>local_lipschitz_def</span><span> </span><span>lipschitz_on_def</span><span> </span><span>dist_norm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>a</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_diff_temp_dyn</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>UNIV_4</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>real_sqrt_abs</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>real_le_lsqrt</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_flow_temp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0 ⟹ local_flow (f a L) UNIV UNIV (φ a L)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span> </span><span>local_lipschitz_temp_dyn</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>forall_4</span><span> </span><span>vec_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>temp_dyn_down_real_arith</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; Tmin"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ (t::real)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈{0..t}. τ ≤ - (ln (Tmin / T) / a) "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ exp (-a * t) * T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp (-a * t) * T ≤ Tmax"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t ∧ t ≤ - (ln (Tmin / T) / a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln (Tmin / T) ≤ - a * t ∧ - a * t ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>divide_le_cancel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin / T &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin / T ≤ exp (-a * t)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp (-a * t) ≤ 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exp_ln</span><span> </span><span>exp_le_one_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>exp_less_cancel_iff</span><span> </span><span>not_less</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ exp (-a * t) * T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pos_divide_le_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp (-a * t) * T ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span>mult_left_le_one_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>exp_ge_zero</span><span> </span><span>obs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>      </span><span>less_eq_real_def</span><span> </span><span>order_trans_rules</span><span class="delimiter">(</span><span>23</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>temp_dyn_up_real_arith</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ≤ Tmax"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmax &lt; (L::real)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈{0..t}. τ ≤ - (ln ((L - Tmax) / (L - T)) / a) "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - Tmax ≤ exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - exp (-(a * t)) * (L - T) ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ L - exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t ∧ t ≤ - (ln ((L - Tmax) / (L - T)) / a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln ((L - Tmax) / (L - T)) ≤ - a * t ∧ - a * t ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>divide_le_cancel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) / (L - T) &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) / (L - T) ≤ exp (-a * t) ∧ exp (-a * t) ≤ 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exp_ln</span><span> </span><span>exp_le_one_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>exp_less_cancel_iff</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - T &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) ≤ exp (-a * t) * (L - T) ∧ exp (-a * t) * (L - T) ≤ (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pos_divide_le_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) ≤ exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - exp (-(a * t)) * (L - T) ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ L - exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>obs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>ffb_temp_dyn</span><span> </span><span class="delimiter">=</span><span> </span><span>local_flow.ffb_g_ode_ivl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>local_flow_temp</span><span> </span><span>_</span><span> </span><span>UNIV_I</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>thermostat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; Tmin"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmax &lt; L"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. Tmin ≤ s$1 ∧ s$1 ≤ Tmax ∧ s$4 = 0} ≤ fb<span class="hidden">⇩</span><sub>ℱ</sub>
  (LOOP
    ― ‹control›
    ((2 ::= (λs. 0));(3 ::= (λs. s$1));
    (IF (λs. s$4 = 0 ∧ s$3 ≤ Tmin + 1) THEN (4 ::= (λs.1)) ELSE
    (IF (λs. s$4 = 1 ∧ s$3 ≥ Tmax - 1) THEN (4 ::= (λs.0)) ELSE skip));
    ― ‹dynamics›
    (IF (λs. s$4 = 0) THEN (x´=(f a 0) &amp; (λs. s$2 ≤ - (ln (Tmin/s$3))/a) on {0..t} UNIV @ 0)
    ELSE (x´=(f a L) &amp; (λs. s$2 ≤ - (ln ((L-Tmax)/(L-s$3)))/a) on {0..t} UNIV @ 0)) )
  INV (λs. Tmin ≤s$1 ∧ s$1 ≤ Tmax ∧ (s$4 = 0 ∨ s$4 = 1)))
  {s. Tmin ≤ s$1 ∧ s$1 ≤ Tmax}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ffb_loopI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ffb_temp_dyn</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>le_fun_def</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>temp_dyn_up_real_arith</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>Tmin</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>temp_dyn_down_real_arith</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>Tmax</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>temp_vec_field</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>temp_flow</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="HS_VC_MKA_rel">
<div class="head"><h1>Theory HS_VC_MKA_rel</h1>
<span class="command">theory</span> <span class="name">HS_VC_MKA_rel</span><br/>
<span class="keyword">imports</span> <a href="HS_ODEs.html"><span class="name">HS_ODEs</span></a> <a href="Modal_Kleene_Algebra.html"><span class="name">Modal_Kleene_Algebra</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Verification components with relational MKA 
    Author:      Jonathan Julián Huerta y Munive, 2019
    Maintainer:  Jonathan Julián Huerta y Munive &lt;jjhuertaymunive1@sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Verification components with relational MKA ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ We show that relations form an antidomain Kleene algebra (hence a modal Kleene 
algebra). We use its forward box operator to derive rules in the algebra for weakest 
liberal preconditions (wlps) of hybrid programs. Finally, we derive our three methods 
for verifying correctness specifications for the continuous dynamics of HS in this setting. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HS_VC_MKA_rel</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../HS_ODEs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"KAD.Modal_Kleene_Algebra"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Modal Kleene algebra preparation ›</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>dioid_one_zero</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* by Victor Gomes, Georg Struth *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>power_inductl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + x ⋅ y ≤ y ⟹ (x ^ n) ⋅ z ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>mult.assoc</span><span> </span><span>mult_isol</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>power_inductr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + y ⋅ x ≤ y ⟹ z ⋅ (x ^ n) ≤ y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0.prems"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Suc</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z + y ⋅ x ≤ y ⟹ z ⋅ x ^ n ≤ y"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z + y ⋅ x ≤ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⋅ x ^ n ≤ y"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⋅ x ^ Suc n = z ⋅ x ⋅ x ^ n"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult.assoc</span><span> </span><span>power_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (z ⋅ x ^ n) ⋅ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult.assoc</span><span> </span><span>power_commutes</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ y ⋅ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>calculation</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mult_isor</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ y"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹z + y ⋅ x ≤ y›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⋅ x ^ Suc n ≤ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>antidomain_kleene_algebra</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_frame</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ x ≤ x ⋅ d p ⟹ d q ≤ |x] t ⟹ d p ⋅ d q ≤ |x] (d p ⋅ d t)"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dual.mult_isol_var</span><span> </span><span>fbox_add1</span><span> </span><span>fbox_demodalisation3</span><span> </span><span>fbox_simp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>plus_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ |x] i ⟹ j ≤ |x] j ⟹ (i + j) ≤ |x] (i + j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ads_d_def</span><span> </span><span>dka.dsr5</span><span> </span><span>fbox_simp</span><span> </span><span>fbox_subdist</span><span> </span><span>join.sup_mono</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d i ≤ |x] d i ⟹ d j ≤ |x] d j ⟹ (d i ⋅ d j) ≤ |x] (d i ⋅ d j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fbox_demodalisation3</span><span> </span><span>fbox_frame</span><span> </span><span>fbox_simp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_export1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad p + |x] q = |d p ⋅ x] q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_d_add_closure</span><span> </span><span>addual.ars_r_def</span><span> </span><span>fbox_def</span><span> </span><span>fbox_mult</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_stari</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ d i ⟹ d i ≤ |x] i ⟹ d i ≤ d q ⟹ d p ≤ |x<span class="hidden">⇧</span><sup>⋆</sup>] q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>dual_order.trans</span><span> </span><span>fbox_iso</span><span> </span><span>fbox_star_induct_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>fbox_mult</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cond</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"if _ then _ else _ fi"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"if p then x else y fi = d p ⋅ x + ad p ⋅ y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_cond_var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|if p then x else y fi] q = (ad p + |x] q) ⋅ (d p + |y] q)"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cond_def</span><span> </span><span>a_closure'</span><span> </span><span>ads_d_def</span><span> </span><span>ans_d_def</span><span> </span><span>fbox_add2</span><span> </span><span>fbox_export1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>loopi</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"loop _ inv _ "</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"loop x inv i = x<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_loopi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ d i ⟹ d i ≤ |x] i ⟹ d i ≤ d q ⟹ d p ≤ |loop x inv i] q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>loopi_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fbox_stari</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Relational model ›</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* by Victor Gomes, Georg Struth *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>rel_dioid</span><span class="delimiter">:</span><span> </span><span>dioid_one_zero</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(O)"</span></span></span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>power_is_relpow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_dioid.power X n = X ^^ n"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rel_dioid.power_0</span><span> </span><span>relpow.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Suc</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rel_dioid.power_Suc2</span><span> </span><span>relpow.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_star_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X^* = (⋃n. rel_dioid.power X n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>power_is_relpow</span><span> </span><span>rtrancl_is_UN_relpow</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_star_contl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X O Y^* = (⋃n. X O rel_dioid.power Y n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rel_star_def</span><span> </span><span>relcomp_UNION_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_star_contr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X^* O Y = (⋃n. (rel_dioid.power X n) O Y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rel_star_def</span><span> </span><span>relcomp_UNION_distrib2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>rel_ka</span><span class="delimiter">:</span><span> </span><span>kleene_algebra</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(O)"</span></span></span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span> </span><span>rtrancl</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Id ∪ x O x<span class="hidden">⇧</span><sup>*</sup> ⊆ x<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>order_refl</span><span> </span><span>r_comp_rtrancl_eq</span><span> </span><span>rtrancl_unfold</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∪ x O y ⊆ y"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x<span class="hidden">⇧</span><sup>*</sup> O z ⊆ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>rel_star_contr</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>SUP_le_iff</span><span> </span><span>rel_dioid.power_inductl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∪ y O x ⊆ y"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z O x<span class="hidden">⇧</span><sup>*</sup> ⊆ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>rel_star_contl</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>SUP_le_iff</span><span> </span><span>rel_dioid.power_inductr</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rel_ad</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_ad R = {(x,x) | x. ¬ (∃y. (x,y) ∈ R)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>rel_aka</span><span class="delimiter">:</span><span> </span><span>antidomain_kleene_algebra</span><span> </span><span>rel_ad</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(O)"</span></span></span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span> </span><span>rtrancl</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span>  </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_ad_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Store and weakest preconditions ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>pred</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>Archimedean_Field.ceiling</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⌈_⌉"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Range_Semiring.antirange_semiring_class.ars_r</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"r"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>antidomain_semiringl.ads_d</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"d"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>Id</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"skip"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>relcomp</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>zero_class.zero</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"0"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rel_aka.fbox</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"wp"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>p2r</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1⌈_⌉)"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ = {(s,s) |s. P s}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ ⌈Q⌉ = (∀s. P s ⟶ Q s)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⌈P⌉ = ⌈Q⌉) = (∀s. P s = Q s)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⌈P⌉ ; ⌈Q⌉) = ⌈λ s. P s ∧ Q s⌉"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⌈P⌉ ∪ ⌈Q⌉) = ⌈λ s. P s ∨ Q s⌉"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_ad ⌈P⌉ = ⌈λs. ¬ P s⌉"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_aka.ads_d ⌈P⌉ = ⌈P⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p2r_def</span><span> </span><span>rel_ad_def</span><span> </span><span>rel_aka.ads_d_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp R ⌈P⌉ = ⌈λ x. ∀ y. (x,y) ∈ R ⟶ P y⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_aka.fbox_def</span><span> </span><span>p2r_def</span><span> </span><span>rel_ad_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vec_upd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a^'b) ⇒ 'b ⇒ 'a ⇒ 'a^'b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_upd s i a = (χ j. ((($) s)(i := a)) j)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>assign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b ⇒ ('a^'b ⇒ 'a) ⇒ ('a^'b) rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(2_ ::= _)"</span></span></span><span> </span><span class="delimiter">[</span><span>70</span><span class="delimiter">,</span><span> </span><span>65</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ::= e) = {(s, vec_upd s x (e s))| s. True}"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_assign</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x ::= e) ⌈Q⌉ = ⌈λs. Q (χ j. ((($) s)(x := (e s))) j)⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_rel</span><span> </span><span>vec_upd_def</span><span> </span><span>assign_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_upd_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>cond_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel ⇒ 'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"IF _ THEN _ ELSE _"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"IF P THEN X ELSE Y ≡ rel_aka.cond ⌈P⌉ X Y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>loopi_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a pred ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"LOOP _ INV _ "</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LOOP R INV I ≡ rel_aka.loopi R ⌈I⌉"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_loopI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ ⌈I⌉ ⟹ ⌈I⌉ ≤ ⌈Q⌉ ⟹ ⌈I⌉ ≤ wp R ⌈I⌉ ⟹ ⌈P⌉ ≤ wp (LOOP R INV I) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rel_aka.fbox_loopi</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Verification of hybrid programs ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification by providing evolution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>g_evol</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::ord) ⇒ 'b ⇒ 'b) ⇒ 'b pred ⇒ 'a set ⇒ 'b rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"EVOL"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"EVOL φ G T = {(s,s') |s s'. s' ∈ g_orbit (λt. φ t s) G T}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_g_dyn</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>φ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::preorder) ⇒ 'b ⇒ 'b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (EVOL φ G T) ⌈Q⌉ = ⌈λs. ∀t∈T. (∀τ∈down T t. G (φ τ s)) ⟶ Q (φ t s)⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_rel</span><span> </span><span>g_evol_def</span><span> </span><span>g_orbit_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification by providing solutions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>g_ode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::banach)⇒'a) ⇒ 'a pred ⇒ real set ⇒ 'a set ⇒ real ⇒ 
  'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _ on _ _ @ _)"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) = {(s,s') |s s'. s' ∈ g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_g_orbital</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉ = 
  ⌈λ s. ∀X∈Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s. ∀t∈T. (∀τ∈down T t. G (X τ)) ⟶ Q (X t)⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_orbital_eq</span><span> </span><span>wp_rel</span><span> </span><span>ivp_sols_def</span><span> </span><span>g_ode_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>local_flow</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_g_ode</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ 0) ⌈Q⌉ = 
  ⌈λ s. s ∈ S ⟶ (∀t∈T. (∀τ∈down T t. G (φ τ s)) ⟶ Q (φ t s))⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_g_orbital</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λt. φ t s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ballE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_ivp_sols</span><span> 
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>init_time</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈down T t. X τ = φ τ s"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_solution</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_time</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_g_ode_ivl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≥ 0 ⟹ t ∈ T ⟹ wp (x´=f &amp; G on {0..t} S @ 0) ⌈Q⌉ = 
  ⌈λs. s ∈ S ⟶ (∀t∈{0..t}. (∀τ∈{0..t}. G (φ τ s)) ⟶ Q (φ t s))⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_g_orbital</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λt. φ t s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ballE</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_ivp_sols_ivl</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closed_segment_eq_real_ivl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_ivp_sols_ivl</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈{0..t}. (∀τ∈{0..t}. X τ = φ τ s)"</span></span></span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_solution_ivl</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>has_vderiv_on_subset</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closed_segment_eq_real_ivl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closed_segment_eq_real_ivl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>interval_time</span><span> </span><span>init_time</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>is_interval_1</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_time</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_orbit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp ({(s,s') | s s'. s' ∈ γ<span class="hidden">⇧</span><sup>φ</sup> s}) ⌈Q⌉ = ⌈λ s. s ∈ S ⟶ (∀ t ∈ T. Q (φ t s))⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>orbit_def</span><span> </span><span>wp_g_ode</span><span> </span><span>g_ode_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Verification with differential invariants ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>g_ode_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::banach)⇒'a) ⇒ 'a pred ⇒ real set ⇒ 'a set ⇒ 
  real ⇒ 'a pred ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _ on _ _ @ _ DINV _ )"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub> DINV I) = (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_g_orbital_guard</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H = (λs. G s ∧ Q s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉ = wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈H⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_g_orbital</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_g_orbital_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ ⌈I⌉"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈I⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈I⌉"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈I⌉ ≤ ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_aka.fbox_iso</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_diff_inv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⌈I⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈I⌉) = diff_invariant I f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_invariant_eq</span><span> </span><span>wp_g_orbital</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_inv_guard_ignore</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈I⌉ ≤ wp (x´= f &amp; (λs. True) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈I⌉"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈I⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈I⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_diff_inv</span><span> </span><span>diff_invariant_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>local_flow</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_diff_inv_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f T S 0 (λs. True) = 
  (⌈λs. s ∈ S ⟶ I s⌉ = wp (x´= f &amp; (λs. True) on T S @ 0) ⌈λs. s ∈ S ⟶ I s⌉)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_diff_inv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>wp_g_orbital</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_time</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>safe</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ivp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λt. φ t s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_domain</span><span> </span><span>has_vderiv_on_domain</span><span> </span><span>ivp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>init_time</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_inv_eq_inv_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f T S 0 (λs. True) = (∀s. I s ⟶ γ<span class="hidden">⇧</span><sup>φ</sup> s ⊆ {s. I s})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_inv_eq_inv_set</span><span> </span><span>orbit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_g_odei</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ ⌈I⌉ ⟹ ⌈I⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈I⌉ ⟹ ⌈λs. I s ∧ G s⌉ ≤ ⌈Q⌉ ⟹ 
  ⌈P⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub> DINV I) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_ode_inv_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>b</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈I⌉"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>wp_g_orbital_inv</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>wp_g_orbital_guard</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_aka.fbox_iso</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Derivation of the rules of dL ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ We derive domain specific rules of differential dynamic logic (dL). First we present a 
generalised version, then we show the rules as instances of the general ones.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_solve_axiom</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::{heine_borel, banach}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open T"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´=(λs. c) &amp; G on T UNIV @ 0) ⌈Q⌉ = 
  ⌈λs. ∀t∈T. (𝒫 (λt. s + t *<span class="hidden">⇩</span><sub>R</sub> c) (down T t) ⊆ {s. G s}) ⟶ Q (s + t *<span class="hidden">⇩</span><sub>R</sub> c)⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>local_flow.wp_g_ode</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λs. c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>φ</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"(λ t x. x + t *<span class="hidden">⇩</span><sub>R</sub> c)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>line_is_local_flow</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_solve_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow f T UNIV φ"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. P s ⟶ (∀ t∈T. (𝒫 (λt. φ t s) (down T t) ⊆ {s. G s}) ⟶ Q (φ t s))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G on T UNIV @ 0) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>local_flow.wp_g_ode</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_weak_axiom</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉ = wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈λ s. G s ⟶ Q s⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_g_orbital</span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_weak_rule</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈G⌉ ≤ ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>wp_rel</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_orbital_eq</span><span> </span><span>g_ode_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_g_evol_IdD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈C⌉ = Id"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈(down T t). (s, x τ) ∈ (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈(down T t). C (x τ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>τ</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ (down T t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x τ ∈ g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_ode_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y. y ∈ (g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s) ⟶ C y"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_rel</span><span> </span><span>g_ode_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C (x τ)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_cut_axiom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Thyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>0</sub> ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈C⌉ = Id"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉ = wp (x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ x. wp x ⌈Q⌉"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>HOL.arg_cong</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>subset_antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´=f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⊆ (x´=f &amp; λs. G s ∧ C s on T S @ t<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_ode_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s'</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>τ</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x_ivp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X τ = s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>guard_x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(𝒫 X (down T τ) ⊆ {s. G s})"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalD</span><span class="delimiter">[</span><span>of</span><span> </span><span>s'</span><span> </span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span> </span><span>G</span><span> </span><span>T</span><span> </span><span>S</span><span> </span><span>t<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). 𝒫 X (down T t) ⊆ {s. G s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>guard_x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). t ∈ T"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ∈ T›</span></span></span><span> </span><span>Thyp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). X t ∈ g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x_ivp</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). C (X t)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wp_g_evol_IdD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_ode_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ g_orbital f (λs. G s ∧ C s) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x_ivp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ∈ T›</span></span></span><span class="delimiter">]</span><span> </span><span>guard_x</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹X τ = s'›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´=f &amp; λs. G s ∧ C s on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⊆ (x´=f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_orbital_eq</span><span> </span><span>g_ode_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_cut_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Thyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>0</sub> ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wp_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈C⌉"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wp_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ⊆ wp (x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ⊆ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>wp_rel</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>g_orbital_eq</span><span> </span><span>p2r_def</span><span> </span><span>g_ode_def</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_ivp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"X ∈ Sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>guard_x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀x. x ∈ T ∧ x ≤ t ⟶ G (X x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T t). X t ∈ g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x_ivp</span><span class="delimiter">]</span><span> </span><span>guard_x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T t). C (X t)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wp_C</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P s›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>wp_rel</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_ode_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t ∈ g_orbital f (λs. G s ∧ C s) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>guard_x</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>g_orbitalI</span><span> </span><span>x_ivp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q (X t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P s›</span></span></span><span> </span><span>wp_Q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>wp_rel</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_ode_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The rules of dL›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>g_global_ode</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"(('a::banach)⇒'a) ⇒ 'a pred ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _)"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´= f &amp; G) ≡ (x´= f &amp; G on UNIV UNIV @ 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>g_global_ode_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::banach)⇒'a) ⇒ 'a pred ⇒ 'a pred ⇒ 'a rel"</span></span></span><span> 
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _ DINV _)"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´= f &amp; G DINV I) ≡ (x´= f &amp; G on UNIV UNIV @ 0 DINV I)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DS</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::{heine_borel, banach}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´=(λs. c) &amp; G) ⌈Q⌉ = ⌈λx. ∀t. (∀τ≤t. G (x + τ *<span class="hidden">⇩</span><sub>R</sub> c)) ⟶ Q (x + t *<span class="hidden">⇩</span><sub>R</sub> c)⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>diff_solve_axiom</span><span class="delimiter">[</span><span>of</span><span> </span><span>UNIV</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>solve</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow f UNIV UNIV φ"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. P s ⟶ (∀t. (∀τ≤t. G (φ τ s)) ⟶ Q (φ t s))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_solve_rule</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DW</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G) ⌈Q⌉ = wp (x´= f &amp; G) ⌈λs. G s ⟶ Q s⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_weak_axiom</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dW</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈G⌉ ≤ ⌈Q⌉ ⟹ ⌈P⌉ ≤ wp (x´= f &amp; G) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_weak_rule</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G) ⌈C⌉ = Id"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G) ⌈Q⌉ = wp (x´= f &amp; (λs. G s ∧ C s)) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_cut_axiom</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G) ⌈C⌉"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; (λs. G s ∧ C s)) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_cut_rule</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ ⌈I⌉"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f UNIV UNIV 0 G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈I⌉ ≤ ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wp_g_orbital_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_diff_inv</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="HS_VC_MKA_Examples_rel">
<div class="head"><h1>Theory HS_VC_MKA_Examples_rel</h1>
<span class="command">theory</span> <span class="name">HS_VC_MKA_Examples_rel</span><br/>
<span class="keyword">imports</span> <a href="HS_VC_MKA_rel.html"><span class="name">HS_VC_MKA_rel</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Examples of hybrid systems verifications
    Author:      Jonathan Julián Huerta y Munive, 2019
    Maintainer:  Jonathan Julián Huerta y Munive &lt;jjhuertaymunive1@sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Examples ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ We prove partial correctness specifications of some hybrid systems with our
recently described verification components.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HS_VC_MKA_Examples_rel</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>HS_VC_MKA_rel</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Pendulum›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ The ODEs @{text "x' t = y t"} and {text "y' t = - x t"} describe the circular motion of
a mass attached to a string looked from above. We use @{text "s$1"} to represent the x-coordinate
and @{text "s$2"} for the y-coordinate. We prove that this motion remains circular. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>fpend</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f s ≡ (χ i. if i = 1 then s$2 else -s$1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>pend_flow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ t s ≡ (χ i. if i = 1 then s$1 * cos t + s$2 * sin t
  else - s$1 * sin t + s$2 * cos t)"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Verified by providing dynamics. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pendulum_dyn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⌈λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>⌉ ≤ wp (EVOL φ G T) ⌈λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment">― ‹Verified with differential invariants. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pendulum_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⌈λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>⌉ ≤ wp (x´= f &amp; G) ⌈λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span> </span><span>diff_invariant_rules</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹Verified with the flow. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_flow_pend</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow f UNIV UNIV φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local_lipschitz_def</span><span> </span><span>lipschitz_on_def</span><span> </span><span>vec_eq_iff</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dist_norm</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span> </span><span>power2_commute</span><span> </span><span>UNIV_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>forall_2</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pendulum_flow</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⌈λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>⌉ ≤ wp (x´= f &amp; G) ⌈λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local_flow.wp_g_ode</span><span class="delimiter">[</span><span>OF</span><span> </span><span>local_flow_pend</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>fpend</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pend_flow</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Bouncing Ball ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ A ball is dropped from rest at an initial height @{text "h"}. The motion is described with
the free-fall equations @{text "x' t = v t"} and @{text "v' t = g"} where @{text "g"} is the
constant acceleration due to gravity. The bounce is modelled with a variable assigntment that
flips the velocity, thus it is a completely elastic collision with the ground. We use @{text "s$1"}
to ball's height and @{text "s$2"} for its velocity. We prove that the ball remains above ground
and below its initial resting position. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>fball</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f g s ≡ (χ i. if i = 1 then s$2 else g)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ball_flow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real ⇒ real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ g t s ≡ (χ i. if i = 1 then g * t ^ 2/2 + s$2 * t + s$1 else g * t + s$2)"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Verified with differential invariants. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>bb_real_arith</span><span> </span><span class="string"><span class="delete"><span class="delete">"real arithmetic properties for the bouncing ball."</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_imp_pos_le</span><span class="delimiter">[</span><span>bb_real_arith</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &gt; g"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * x - 2 * g * h = v * v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::real) ≤ h"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v * v = 2 * g * x - 2 * g * h ∧ 0 &gt; g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &gt; g›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"v * v = 2 * g * (x - h) ∧ 0 &gt; g ∧ v * v ≥ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>left_diff_distrib</span><span> </span><span>mult.commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>zero_le_square</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v * v)/(2 * g) = (x - h)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>obs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v * v)/(2 * g) ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>divide_nonneg_neg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h - x ≥ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bouncing_ball_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span class="delimiter">::</span><span>real</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0 ⟹ h ≥ 0 ⟹ ⌈λs. s$1 = h ∧ s$2 = 0⌉ ≤
  wp
    (LOOP
      ((x´= f g &amp; (λ s. s$1 ≥ 0) DINV (λs. 2 * g * s$1 - 2 * g * h - s$2 * s$2 = 0));
       (IF (λ s. s$1 = 0) THEN (2 ::= (λs. - s$2)) ELSE skip))
    INV (λs. 0 ≤ s$1 ∧ 2 * g * s$1 - 2 * g * h - s$2 * s$2 = 0)
  ) ⌈λs. 0 ≤ s$1 ∧ s$1 ≤ h⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wp_loopI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bb_real_arith</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wp_g_odei</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span> </span><span>diff_invariant_rules</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹Verified by providing dynamics. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_conserv_at_ground</span><span class="delimiter">[</span><span>bb_real_arith</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * x = 2 * g * h + v * v"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g * τ<span class="hidden">⇧</span><sup>2</sup> / 2 + v * τ + (x::real) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * h + (g * τ * (g * τ + v) + v * (g * τ + v)) = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pos</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g * τ<span class="hidden">⇧</span><sup>2</sup>  + 2 * v * τ + 2 * x = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup>  + 2 * g * v * τ + 2 * g * x = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>mult_zero_right</span><span>
</span><span>        </span><span>monoid_mult_class.power2_eq_square</span><span> </span><span>semiring_class.distrib_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup> + 2 * g * v * τ + v<span class="hidden">⇧</span><sup>2</sup> + 2 * g * h = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invar</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monoid_mult_class.power2_eq_square</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(g * τ + v)<span class="hidden">⇧</span><sup>2</sup> + 2 * g * h = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>power2_sum</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Groups.add_ac</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span> </span><span>3</span><span class="delimiter">)</span><span>
</span><span>        </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span> </span><span>3</span><span class="delimiter">)</span><span> </span><span>monoid_mult_class.power2_eq_square</span><span> </span><span>nat_distrib</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * h + (g * τ * (g * τ + v) + v * (g * τ + v)) = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monoid_mult_class.power2_eq_square</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_conserv_at_air</span><span class="delimiter">[</span><span>bb_real_arith</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * x = 2 * g * h + v * v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * (g * τ<span class="hidden">⇧</span><sup>2</sup> / 2 + v * τ + (x::real)) =
  2 * g * h + (g * τ * (g * τ + v) + v * (g * τ + v))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup> + 2 * g * v * τ + 2 * g * x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>29</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup> + 2 * g * v * τ + 2 * g * h + v * v"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ?middle"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>invar</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?middle"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rhs = g * g * (τ * τ) + 2 * g * v * τ + 2 * g * h + v * v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>semiring_class.distrib_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ?middle"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>29</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rhs = ?middle"</span></span></span><span class="keyword1"><span class="command">.</span></span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bouncing_ball_dyn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span class="delimiter">::</span><span>real</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ≥ 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0 ⟹ h ≥ 0 ⟹
  ⌈λs. s$1 = h ∧ s$2 = 0⌉ ≤ wp
    (LOOP
      ((EVOL (φ g) (λs. 0 ≤ s$1) T);
      (IF (λ s. s$1 = 0) THEN (2 ::= (λs. - s$2)) ELSE skip))
    INV (λs. 0 ≤ s$1 ∧ 2 * g * s$1 = 2 * g * h + s$2 * s$2))
  ⌈λs. 0 ≤ s$1 ∧ s$1 ≤ h⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wp_loopI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bb_real_arith</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹Verified with the flow. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_flow_ball</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow (f g) UNIV UNIV (φ g)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local_lipschitz_def</span><span> </span><span>lipschitz_on_def</span><span> </span><span>vec_eq_iff</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"1/2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dist_norm</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span> </span><span>UNIV_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>forall_2</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bouncing_ball_flow</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span class="delimiter">::</span><span>real</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ≥ 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0 ⟹ h ≥ 0 ⟹
  ⌈λs. s$1 = h ∧ s$2 = 0⌉ ≤ wp
    (LOOP
      ((x´= f g &amp; (λ s. s$1 ≥ 0));
      (IF (λ s. s$1 = 0) THEN (2 ::= (λs. - s$2)) ELSE skip))
    INV (λs. 0 ≤ s$1 ∧ 2 * g * s$1 = 2 * g * h + s$2 * s$2))
  ⌈λs. 0 ≤ s$1 ∧ s$1 ≤ h⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wp_loopI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local_flow.wp_g_ode</span><span class="delimiter">[</span><span>OF</span><span> </span><span>local_flow_ball</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bb_real_arith</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>fball</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ball_flow</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Thermostat ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ A thermostat has a chronometer, a thermometer and a switch to turn on and off a heater.
At most every @{text "t"} minutes, it sets its chronometer to @{term "0::real"}, it registers
the room temperature, and it turns the heater on (or off) based on this reading. The temperature
follows the ODE @{text "T' = - a * (T - U)"} where @{text "U"} is @{text "L ≥ 0"} when the heater
is on, and @{text "0"} when it is off. We use @{term "1::4"} to denote the room's temperature,
@{term "2::4"} is time as measured by the thermostat's chronometer, @{term "3::4"} is the
temperature detected by the thermometer, and @{term "4::4"} states whether the heater is on
(@{text "s$4 = 1"}) or off (@{text "s$4 = 0"}). We prove that the thermostat keeps the room's
temperature between @{text "Tmin"} and @{text "Tmax"}. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>temp_vec_field</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real ⇒ real^4 ⇒ real^4"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f a L s ≡ (χ i. if i = 2 then 1 else (if i = 1 then - a * (s$1 - L) else 0))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>temp_flow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real ⇒ real ⇒ real^4 ⇒ real^4"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ a L t s ≡ (χ i. if i = 1 then - exp(-a * t) * (L - s$1) + L else
  (if i = 2 then t + s$2 else s$i))"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Verified with the flow. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_diff_temp_dyn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; a ⟹ ∥f a L s<span class="hidden">⇩</span><sub>1</sub> - f a L s<span class="hidden">⇩</span><sub>2</sub>∥ = ¦a¦ * ¦s<span class="hidden">⇩</span><sub>1</sub>$1 - s<span class="hidden">⇩</span><sub>2</sub>$1¦"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>UNIV_4</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀r ra. ¦(r::real) + - ra¦ = ¦ra + - r¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>abs_minus_commute</span><span> </span><span>minus_real_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀r ra rb. (r::real) * ra + - (r * rb) = r * (ra + - rb)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>minus_real_def</span><span> </span><span>right_diff_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦a * (s<span class="hidden">⇩</span><sub>1</sub>$1 + - L) + - (a * (s<span class="hidden">⇩</span><sub>2</sub>$1 + - L))¦ = a * ¦s<span class="hidden">⇩</span><sub>1</sub>$1 + - s<span class="hidden">⇩</span><sub>2</sub>$1¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_mult</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦a * (s<span class="hidden">⇩</span><sub>2</sub>$1 - L) - a * (s<span class="hidden">⇩</span><sub>1</sub>$1 - L)¦ = a * ¦s<span class="hidden">⇩</span><sub>1</sub>$1 - s<span class="hidden">⇩</span><sub>2</sub>$1¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>minus_real_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_lipschitz_temp_dyn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; (a::real)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_lipschitz UNIV UNIV (λt::real. f a L)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>local_lipschitz_def</span><span> </span><span>lipschitz_on_def</span><span> </span><span>dist_norm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>a</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_diff_temp_dyn</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>UNIV_4</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>real_sqrt_abs</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>real_le_lsqrt</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_flow_temp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0 ⟹ local_flow (f a L) UNIV UNIV (φ a L)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span> </span><span>local_lipschitz_temp_dyn</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>forall_4</span><span> </span><span>vec_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>temp_dyn_down_real_arith</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; Tmin"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ (t::real)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈{0..t}. τ ≤ - (ln (Tmin / T) / a) "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ exp (-a * t) * T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp (-a * t) * T ≤ Tmax"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t ∧ t ≤ - (ln (Tmin / T) / a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln (Tmin / T) ≤ - a * t ∧ - a * t ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>divide_le_cancel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin / T &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin / T ≤ exp (-a * t)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp (-a * t) ≤ 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exp_ln</span><span> </span><span>exp_le_one_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>exp_less_cancel_iff</span><span> </span><span>not_less</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ exp (-a * t) * T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pos_divide_le_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp (-a * t) * T ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span>mult_left_le_one_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>exp_ge_zero</span><span> </span><span>obs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>      </span><span>less_eq_real_def</span><span> </span><span>order_trans_rules</span><span class="delimiter">(</span><span>23</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>temp_dyn_up_real_arith</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ≤ Tmax"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmax &lt; (L::real)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈{0..t}. τ ≤ - (ln ((L - Tmax) / (L - T)) / a) "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - Tmax ≤ exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - exp (-(a * t)) * (L - T) ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ L - exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t ∧ t ≤ - (ln ((L - Tmax) / (L - T)) / a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln ((L - Tmax) / (L - T)) ≤ - a * t ∧ - a * t ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>divide_le_cancel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) / (L - T) &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) / (L - T) ≤ exp (-a * t) ∧ exp (-a * t) ≤ 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exp_ln</span><span> </span><span>exp_le_one_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>exp_less_cancel_iff</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - T &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) ≤ exp (-a * t) * (L - T) ∧ exp (-a * t) * (L - T) ≤ (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pos_divide_le_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) ≤ exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - exp (-(a * t)) * (L - T) ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ L - exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>obs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fbox_temp_dyn</span><span> </span><span class="delimiter">=</span><span> </span><span>local_flow.fbox_g_ode_ivl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>local_flow_temp</span><span> </span><span>_</span><span> </span><span>UNIV_I</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>thermostat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; Tmin"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmax &lt; L"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈λs. Tmin ≤ s$1 ∧ s$1 ≤ Tmax ∧ s$4 = 0⌉ ≤ wp
  (LOOP
    ― ‹control›
    ((2 ::= (λs. 0));(3 ::= (λs. s$1));
    (IF (λs. s$4 = 0 ∧ s$3 ≤ Tmin + 1) THEN (4 ::= (λs.1)) ELSE
    (IF (λs. s$4 = 1 ∧ s$3 ≥ Tmax - 1) THEN (4 ::= (λs.0)) ELSE skip));
    ― ‹dynamics›
    (IF (λs. s$4 = 0) THEN (x´=(f a 0) &amp; (λs. s$2 ≤ - (ln (Tmin/s$3))/a) on {0..t} UNIV @ 0)
    ELSE (x´=(f a L) &amp; (λs. s$2 ≤ - (ln ((L-Tmax)/(L-s$3)))/a) on {0..t} UNIV @ 0)) )
  INV (λs. Tmin ≤s$1 ∧ s$1 ≤ Tmax ∧ (s$4 = 0 ∨ s$4 = 1)))
  ⌈λs. Tmin ≤ s$1 ∧ s$1 ≤ Tmax⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wp_loopI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fbox_temp_dyn</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>temp_dyn_up_real_arith</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>Tmin</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>temp_dyn_down_real_arith</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>Tmax</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>temp_vec_field</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>temp_flow</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="HS_VC_MKA_ndfun">
<div class="head"><h1>Theory HS_VC_MKA_ndfun</h1>
<span class="command">theory</span> <span class="name">HS_VC_MKA_ndfun</span><br/>
<span class="keyword">imports</span> <a href="HS_ODEs.html"><span class="name">HS_ODEs</span></a> <a href="Kleisli_Quantale.html"><span class="name">Kleisli_Quantale</span></a> <a href="Modal_Kleene_Algebra.html"><span class="name">Modal_Kleene_Algebra</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Verification components with MKA and non-deterministic functions
    Author:      Jonathan Julián Huerta y Munive, 2019
    Maintainer:  Jonathan Julián Huerta y Munive &lt;jjhuertaymunive1@sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Verification components with MKA and non-deterministic functions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ We show that non-deterministic endofunctions form an antidomain Kleene algebra 
(hence a modal Kleene algebra). We use MKA's forward box operator to derive rules for weakest 
liberal preconditions (wlps) of hybrid programs. Finally, we derive our three methods 
for verifying correctness specifications for the continuous dynamics of HS. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HS_VC_MKA_ndfun</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../HS_ODEs"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Transformer_Semantics.Kleisli_Quantale"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"KAD.Modal_Kleene_Algebra"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Modal Kleene algebra preparation ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>antidomain_kleene_algebra</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_frame</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ x ≤ x ⋅ d p ⟹ d q ≤ |x] t ⟹ d p ⋅ d q ≤ |x] (d p ⋅ d t)"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dual.mult_isol_var</span><span> </span><span>fbox_add1</span><span> </span><span>fbox_demodalisation3</span><span> </span><span>fbox_simp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_export1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad p + |x] q = |d p ⋅ x] q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_d_add_closure</span><span> </span><span>addual.ars_r_def</span><span> </span><span>fbox_def</span><span> </span><span>fbox_mult</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>plus_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ |x] i ⟹ j ≤ |x] j ⟹ (i + j) ≤ |x] (i + j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ads_d_def</span><span> </span><span>dka.dsr5</span><span> </span><span>fbox_simp</span><span> </span><span>fbox_subdist</span><span> </span><span>join.sup_mono</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d i ≤ |x] d i ⟹ d j ≤ |x] d j ⟹ (d i ⋅ d j) ≤ |x] (d i ⋅ d j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fbox_demodalisation3</span><span> </span><span>fbox_frame</span><span> </span><span>fbox_simp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_stari</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ d i ⟹ d i ≤ |x] i ⟹ d i ≤ d q ⟹ d p ≤ |x<span class="hidden">⇧</span><sup>⋆</sup>] q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>dual_order.trans</span><span> </span><span>fbox_iso</span><span> </span><span>fbox_star_induct_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>fbox_mult</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cond</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"if _ then _ else _ fi"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"if p then x else y fi = d p ⋅ x + ad p ⋅ y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_cond_var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|if p then x else y fi] q = (ad p + |x] q) ⋅ (d p + |y] q)"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cond_def</span><span> </span><span>a_closure'</span><span> </span><span>ads_d_def</span><span> </span><span>ans_d_def</span><span> </span><span>fbox_add2</span><span> </span><span>fbox_export1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>loopi</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"loop _ inv _ "</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"loop x inv i = x<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_loopi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ d i ⟹ d i ≤ |x] i ⟹ d i ≤ d q ⟹ d p ≤ |loop x inv i] q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>loopi_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fbox_stari</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Non-deterministic functions ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Our semantics now corresponds to nondeterministic functions @{typ "'a nd_fun"}. Below we prove
some auxiliary lemmas for them and show that they form an antidomain kleene algebra. The proof just 
extends the results on the Transformer\_Semantics.Kleisli\_Quantale theory.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>Abs_nd_fun</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_<span class="hidden">⇧</span><sup>∙</sup>"</span></span></span><span> </span><span class="delimiter">[</span><span>101</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Rep_nd_fun</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_<span class="hidden">⇩</span><sub>∙</sub>"</span></span></span><span> </span><span class="delimiter">[</span><span>101</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fbox</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"wp"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>Abs_nd_fun_inverse</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nd_fun_ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀x. (f<span class="hidden">⇩</span><sub>∙</sub>) x = (g<span class="hidden">⇩</span><sub>∙</sub>) x) ⟹ f = g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_nd_fun f = Rep_nd_fun g"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Rep_nd_fun_inject</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nd_fun_eq_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f = g) = (∀x. (f<span class="hidden">⇩</span><sub>∙</sub>) x = (g<span class="hidden">⇩</span><sub>∙</sub>) x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nd_fun_ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>nd_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>type</span><span class="delimiter">)</span><span> </span><span>antidomain_kleene_algebra</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad f = (λx. if ((f<span class="hidden">⇩</span><sub>∙</sub>) x = {}) then {x} else {})<span class="hidden">⇧</span><sup>∙</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 = ζ<span class="hidden">⇧</span><sup>∙</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"star_nd_fun f = qstar f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a nd_fun"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f + g = ((f<span class="hidden">⇩</span><sub>∙</sub>) ⊔ (g<span class="hidden">⇩</span><sub>∙</sub>))<span class="hidden">⇧</span><sup>∙</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>nd_fun_aka</span><span> </span><span class="string"><span class="delete"><span class="delete">"antidomain kleene algebra properties for nondeterministic functions."</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nd_fun_plus_assoc</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x + y + z = x + (y + z)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nd_fun_plus_comm</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x + y = y + x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nd_fun_plus_idem</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x + x = x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a nd_fun"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plus_nd_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ksup_assoc</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ksup_comm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nd_fun_distr</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x + y) ⋅ z = x ⋅ z + y ⋅ z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nd_fun_distl</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ (y + z) = x ⋅ y + x ⋅ z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a nd_fun"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plus_nd_fun_def</span><span> </span><span>times_nd_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>kcomp_distr</span><span> </span><span>kcomp_distl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nd_fun_plus_zerol</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 + x = x"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nd_fun_mult_zerol</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ⋅ x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nd_fun_mult_zeror</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ 0 = 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a nd_fun"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plus_nd_fun_def</span><span> </span><span>zero_nd_fun_def</span><span> </span><span>times_nd_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nd_fun_leq</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ≤ y) = (x + y = y)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nd_fun_less</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x &lt; y) = (x + y = y ∧ x ≠ y)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nd_fun_leq_add</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⋅ x ≤ z ⋅ (x + y)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a nd_fun"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_eq_nd_fun_def</span><span> </span><span>less_nd_fun_def</span><span> </span><span>plus_nd_fun_def</span><span> </span><span>times_nd_fun_def</span><span> </span><span>sup_fun_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>nd_fun_eq_iff</span><span> </span><span>le_fun_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>kcomp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nd_fun_ad_zero</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ⋅ x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nd_fun_ad</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad (x ⋅ y) + ad (x ⋅ ad (ad y)) = ad (x ⋅ ad (ad y))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nd_fun_ad_one</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad (ad x) + ad x = 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a nd_fun"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>antidomain_op_nd_fun_def</span><span> </span><span>times_nd_fun_def</span><span> </span><span>plus_nd_fun_def</span><span> </span><span>zero_nd_fun_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nd_fun_eq_iff</span><span> </span><span>kcomp_def</span><span> </span><span>one_nd_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nd_star_one</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + x ⋅ x<span class="hidden">⇧</span><sup>⋆</sup> ≤ x<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nd_star_unfoldl</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + x ⋅ y ≤ y ⟹ x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ z ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nd_star_unfoldr</span><span class="delimiter">[</span><span>nd_fun_aka</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + y ⋅ x ≤ y ⟹ z ⋅ x<span class="hidden">⇧</span><sup>⋆</sup> ≤ y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a nd_fun"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plus_nd_fun_def</span><span> </span><span>star_nd_fun_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_star_inductl</span><span> </span><span>sup_nd_fun.rep_eq</span><span> </span><span>fun_star_inductr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>order_refl</span><span> </span><span>sup_nd_fun.rep_eq</span><span> </span><span>uwqlka.conway.dagger_unfoldl_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>intro_classes</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nd_fun_aka</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Store and weakest preconditions ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Now that we know that nondeterministic functions form an Antidomain Kleene Algebra, we give
 a lifting operation from predicates to @{typ "'a nd_fun"} and use it to compute weakest liberal
preconditions.›</span></span></span><span>
</span><span>
</span><span class="comment">― ‹We start by deleting some notation and introducing some new.›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>pred</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>Archimedean_Field.ceiling</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⌈_⌉"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Relation.relcomp</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>75</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Range_Semiring.antirange_semiring_class.ars_r</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"r"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>antidomain_semiringl.ads_d</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"d"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>p2ndf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a nd_fun"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1⌈_⌉)"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈Q⌉ ≡ (λ x::'a. {s::'a. s = x ∧ Q s})<span class="hidden">⇧</span><sup>∙</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2ndf_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ ⌈Q⌉ = (∀s. P s ⟶ Q s)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⌈P⌉ = ⌈Q⌉) = (∀s. P s = Q s)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⌈P⌉ ⋅ ⌈Q⌉) = ⌈λ s. P s ∧ Q s⌉"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⌈P⌉ + ⌈Q⌉) = ⌈λ s. P s ∨ Q s⌉"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ad ⌈P⌉ = ⌈λs. ¬ P s⌉"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"d ⌈P⌉ = ⌈P⌉"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ η<span class="hidden">⇧</span><sup>∙</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_eq_nd_fun_def</span><span> </span><span>times_nd_fun_def</span><span> </span><span>plus_nd_fun_def</span><span> </span><span>ads_d_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nd_fun_eq_iff</span><span> </span><span>kcomp_def</span><span> </span><span>le_fun_def</span><span> </span><span>antidomain_op_nd_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_nd_fun</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp F ⌈P⌉ = ⌈λs. ∀s'. s' ∈ ((F<span class="hidden">⇩</span><sub>∙</sub>) s) ⟶ P s'⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fbox_def</span><span> </span><span>antidomain_op_nd_fun_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>nd_fun_ext</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Rep_comp_hom</span><span> </span><span>kcomp_prop</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vec_upd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a^'b) ⇒ 'b ⇒ 'a ⇒ 'a^'b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_upd s i a = (χ j. ((($) s)(i := a)) j)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>assign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b ⇒ ('a^'b ⇒ 'a) ⇒ ('a^'b) nd_fun"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(2_ ::= _)"</span></span></span><span> </span><span class="delimiter">[</span><span>70</span><span class="delimiter">,</span><span> </span><span>65</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ::= e) = (λs. {vec_upd s x (e s)})<span class="hidden">⇧</span><sup>∙</sup>"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>seq_comp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a nd_fun ⇒ 'a nd_fun ⇒ 'a nd_fun"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>75</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ; g ≡ f ⋅ g"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_assign</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x ::= e) ⌈Q⌉ = ⌈λs. Q (χ j. ((($) s)(x := (e s))) j)⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_nd_fun</span><span> </span><span>nd_fun_eq_iff</span><span> </span><span>vec_upd_def</span><span> </span><span>assign_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>skip</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a nd_fun"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"skip ≡ 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>cond_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a nd_fun ⇒ 'a nd_fun ⇒ 'a nd_fun"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"IF _ THEN _ ELSE _"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"IF P THEN X ELSE Y ≡ cond ⌈P⌉ X Y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>loopi_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a nd_fun ⇒ 'a pred ⇒ 'a nd_fun"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"LOOP _ INV _ "</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LOOP R INV I ≡ loopi R ⌈I⌉"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_loopI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ ⌈I⌉ ⟹ ⌈I⌉ ≤ ⌈Q⌉ ⟹ ⌈I⌉ ≤ wp R ⌈I⌉ ⟹ ⌈P⌉ ≤ wp (LOOP R INV I) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fbox_loopi</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Verification of hybrid programs ›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification by providing evolution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>g_evol</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::ord) ⇒ 'b ⇒ 'b) ⇒ 'b pred ⇒ 'a set ⇒ 'b nd_fun"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"EVOL"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"EVOL φ G T = (λs. g_orbit (λt. φ t s) G T)<span class="hidden">⇧</span><sup>∙</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_g_dyn</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>φ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::preorder) ⇒ 'b ⇒ 'b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (EVOL φ G T) ⌈Q⌉ = ⌈λs. ∀t∈T. (∀τ∈down T t. G (φ τ s)) ⟶ Q (φ t s)⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_nd_fun</span><span> </span><span>g_evol_def</span><span> </span><span>g_orbit_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification by providing solutions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>g_ode</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"(('a::banach)⇒'a) ⇒ 'a pred ⇒ real set ⇒ 'a set ⇒ 
  real ⇒ 'a nd_fun"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´= _ &amp; _ on _ _ @ _)"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ≡ (λ s. g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s)<span class="hidden">⇧</span><sup>∙</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_g_orbital</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉= 
  ⌈λ s. ∀X∈ivp_sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s. ∀t∈T. (∀τ∈down T t. G (X τ)) ⟶ Q (X t)⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_orbital_eq</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>wp_nd_fun</span><span> </span><span>g_ode_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>local_flow</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_g_ode</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ 0) ⌈Q⌉ = 
  ⌈λ s. s ∈ S ⟶ (∀t∈T. (∀τ∈down T t. G (φ τ s)) ⟶ Q (φ t s))⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_g_orbital</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λt. φ t s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ballE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_ivp_sols</span><span> 
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>init_time</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈down T t. X τ = φ τ s"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_solution</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_time</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_g_ode_ivl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≥ 0 ⟹ t ∈ T ⟹ wp (x´=f &amp; G on {0..t} S @ 0) ⌈Q⌉ = 
  ⌈λs. s ∈ S ⟶ (∀t∈{0..t}. (∀τ∈{0..t}. G (φ τ s)) ⟶ Q (φ t s))⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_g_orbital</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λt. φ t s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ballE</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_ivp_sols_ivl</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closed_segment_eq_real_ivl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_ivp_sols_ivl</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈{0..t}. (∀τ∈{0..t}. X τ = φ τ s)"</span></span></span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_solution_ivl</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>has_vderiv_on_subset</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closed_segment_eq_real_ivl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>closed_segment_eq_real_ivl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>interval_time</span><span> </span><span>init_time</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>is_interval_1</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_time</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_orbit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (γ<span class="hidden">⇧</span><sup>φ</sup><span class="hidden">⇧</span><sup>∙</sup>) ⌈Q⌉ = ⌈λ s. s ∈ S ⟶ (∀ t ∈ T. Q (φ t s))⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>orbit_def</span><span> </span><span>wp_g_ode</span><span> </span><span>g_ode_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Verification with differential invariants ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>g_ode_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::banach)⇒'a) ⇒ 'a pred ⇒ real set ⇒ 'a set ⇒ 
  real ⇒ 'a pred ⇒ 'a nd_fun"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _ on _ _ @ _ DINV _ )"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub> DINV I) = (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_g_orbital_guard</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H = (λs. G s ∧ Q s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉ = wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈H⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_g_orbital</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_g_orbital_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ ⌈I⌉"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈I⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈I⌉"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈I⌉ ≤ ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>fbox_iso</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_diff_inv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⌈I⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈I⌉) = diff_invariant I f T S t<span class="hidden">⇩</span><sub>0</sub> G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_invariant_eq</span><span> </span><span>wp_g_orbital</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_inv_guard_ignore</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈I⌉ ≤ wp (x´= f &amp; (λs. True) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈I⌉"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈I⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈I⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_diff_inv</span><span> </span><span>diff_invariant_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>local_flow</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_diff_inv_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f T S 0 (λs. True) = 
  (⌈λs. s ∈ S ⟶ I s⌉ = wp (x´= f &amp; (λs. True) on T S @ 0) ⌈λs. s ∈ S ⟶ I s⌉)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_diff_inv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>wp_g_orbital</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_time</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ivp_sols_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>safe</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ivp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λt. φ t s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_domain</span><span> </span><span>has_vderiv_on_domain</span><span> </span><span>ivp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>init_time</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_inv_eq_inv_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f T S 0 (λs. True) = (∀s. I s ⟶ γ<span class="hidden">⇧</span><sup>φ</sup> s ⊆ {s. I s})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_inv_eq_inv_set</span><span> </span><span>orbit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_g_odei</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ ⌈I⌉ ⟹ ⌈I⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈I⌉ ⟹ ⌈λs. I s ∧ G s⌉ ≤ ⌈Q⌉ ⟹
  ⌈P⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub> DINV I) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_ode_inv_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>b</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈I⌉"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>wp_g_orbital_inv</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>wp_g_orbital_guard</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fbox_iso</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Derivation of the rules of dL ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ We derive domain specific rules of differential dynamic logic (dL). First we present a 
generalised version, then we show the rules as instances of the general ones.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_solve_axiom</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::{heine_borel, banach}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"open T"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´=(λs. c) &amp; G on T UNIV @ 0) ⌈Q⌉ = 
  ⌈λ s. ∀t∈T. (𝒫 (λ t. s + t *<span class="hidden">⇩</span><sub>R</sub> c) (down T t) ⊆ {s. G s}) ⟶ Q (s + t *<span class="hidden">⇩</span><sub>R</sub> c)⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>local_flow.wp_g_ode</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λs. c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>φ</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"(λ t s. s + t *<span class="hidden">⇩</span><sub>R</sub> c)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>line_is_local_flow</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_solve_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow f T UNIV φ"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. P s ⟶ (∀ t∈T. (𝒫 (λt. φ t s) (down T t) ⊆ {s. G s}) ⟶ Q (φ t s))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G on T UNIV @ 0) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>local_flow.wp_g_ode</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_weak_axiom</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉ = wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈λ s. G s ⟶ Q s⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_g_orbital</span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_weak_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈G⌉ ≤ ⌈Q⌉ ⟹ ⌈P⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>wp_g_orbital</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_ode_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_g_orbit_IdD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈C⌉ = η<span class="hidden">⇧</span><sup>∙</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈(down T t). x τ ∈ g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈(down T t). C (x τ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>τ</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ (down T t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x τ ∈ g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y. y ∈ (g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s) ⟶ C y"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_nd_fun</span><span> </span><span>g_ode_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>nd_fun_eq_iff</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C (x τ)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_cut_axiom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Thyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>0</sub> ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈C⌉ = η<span class="hidden">⇧</span><sup>∙</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉ = wp (x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ x. wp x ⌈Q⌉"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>HOL.arg_cong</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>nd_fun_ext</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>subset_antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>)<span class="hidden">⇩</span><sub>∙</sub>) s ⊆ ((x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>)<span class="hidden">⇩</span><sub>∙</sub>) s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_ode_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s'</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>τ</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x_ivp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ ivp_sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X τ = s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>guard_x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(𝒫 X (down T τ) ⊆ {s. G s})"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalD</span><span class="delimiter">[</span><span>of</span><span> </span><span>s'</span><span> </span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span> </span><span>G</span><span> </span><span>T</span><span> </span><span>S</span><span> </span><span>t<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). 𝒫 X (down T t) ⊆ {s. G s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>guard_x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). t ∈ T"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ∈ T›</span></span></span><span> </span><span>Thyp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). X t ∈ g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x_ivp</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T τ). C (X t)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wp_g_orbit_IdD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ g_orbital f (λs. G s ∧ C s) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x_ivp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ ∈ T›</span></span></span><span class="delimiter">]</span><span> </span><span>guard_x</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹X τ = s'›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((x´= f &amp; λs. G s ∧ C s on T S @ t<span class="hidden">⇩</span><sub>0</sub>)<span class="hidden">⇩</span><sub>∙</sub>) s ⊆ ((x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>)<span class="hidden">⇩</span><sub>∙</sub>) s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_orbital_eq</span><span> </span><span>g_ode_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_cut_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Thyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interval T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>0</sub> ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wp_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈C⌉"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wp_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; (λs. G s ∧ C s) on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G on T S @ t<span class="hidden">⇩</span><sub>0</sub>) ⌈Q⌉"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wp_nd_fun</span><span> </span><span>g_orbital_eq</span><span> </span><span>g_ode_def</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_ivp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"X ∈ ivp_sols (λt. f) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>guard_x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀x. x ∈ T ∧ x ≤ t ⟶ G (X x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T t). X t ∈ g_orbital f G T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_orbitalI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x_ivp</span><span class="delimiter">]</span><span> </span><span>guard_x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈(down T t). C (X t)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wp_C</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P s›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>wp_nd_fun</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_ode_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X t ∈ g_orbital f (λs. G s ∧ C s) T S t<span class="hidden">⇩</span><sub>0</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>guard_x</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ T›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>g_orbitalI</span><span> </span><span>x_ivp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q (X t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P s›</span></span></span><span> </span><span>wp_Q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>wp_nd_fun</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_ode_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The rules of dL›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>g_global_ode</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"(('a::banach)⇒'a) ⇒ 'a pred ⇒ 'a nd_fun"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _)"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´= f &amp; G) ≡ (x´= f &amp; G on UNIV UNIV @ 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>g_global_ode_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::banach)⇒'a) ⇒ 'a pred ⇒ 'a pred ⇒ 'a nd_fun"</span></span></span><span> 
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1x´=_ &amp; _ DINV _)"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x´= f &amp; G DINV I) ≡ (x´= f &amp; G on UNIV UNIV @ 0 DINV I)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DS</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::{heine_borel, banach}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´=(λs. c) &amp; G) ⌈Q⌉ = ⌈λx. ∀t. (∀τ≤t. G (x + τ *<span class="hidden">⇩</span><sub>R</sub> c)) ⟶ Q (x + t *<span class="hidden">⇩</span><sub>R</sub> c)⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>diff_solve_axiom</span><span class="delimiter">[</span><span>of</span><span> </span><span>UNIV</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>solve</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow f UNIV UNIV φ"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. P s ⟶ (∀t. (∀τ≤t. G (φ τ s)) ⟶ Q (φ t s))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_solve_rule</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DW</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G) ⌈Q⌉ = wp (x´= f &amp; G) ⌈λs. G s ⟶ Q s⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_weak_axiom</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dW</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈G⌉ ≤ ⌈Q⌉ ⟹ ⌈P⌉ ≤ wp (x´= f &amp; G) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_weak_rule</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G) ⌈C⌉ = η<span class="hidden">⇧</span><sup>∙</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x´= f &amp; G) ⌈Q⌉ = wp (x´= f &amp; (λs. G s ∧ C s)) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_cut_axiom</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G) ⌈C⌉"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; (λs. G s ∧ C s)) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_cut_rule</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ ⌈I⌉"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff_invariant I f UNIV UNIV 0 G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈I⌉ ≤ ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≤ wp (x´= f &amp; G) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wp_g_orbital_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wp_diff_inv</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="HS_VC_MKA_Examples_ndfun">
<div class="head"><h1>Theory HS_VC_MKA_Examples_ndfun</h1>
<span class="command">theory</span> <span class="name">HS_VC_MKA_Examples_ndfun</span><br/>
<span class="keyword">imports</span> <a href="HS_VC_MKA_ndfun.html"><span class="name">HS_VC_MKA_ndfun</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Examples of hybrid systems verifications
    Author:      Jonathan Julián Huerta y Munive, 2019
    Maintainer:  Jonathan Julián Huerta y Munive &lt;jjhuertaymunive1@sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Examples ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ We prove partial correctness specifications of some hybrid systems with our
recently described verification components. Notice that this is an exact copy of
the file @{text HS_VC_MKA_Examples}, meaning our components are truly modular and
we can choose either a relational or predicate transformer semantics.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HS_VC_MKA_Examples_ndfun</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>HS_VC_MKA_ndfun</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Pendulum›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ The ODEs @{text "x' t = y t"} and {text "y' t = - x t"} describe the circular motion of
a mass attached to a string looked from above. We use @{text "s$1"} to represent the x-coordinate
and @{text "s$2"} for the y-coordinate. We prove that this motion remains circular. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>fpend</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f s ≡ (χ i. if i = 1 then s$2 else -s$1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>pend_flow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ t s ≡ (χ i. if i = 1 then s$1 * cos t + s$2 * sin t
  else - s$1 * sin t + s$2 * cos t)"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Verified by providing dynamics. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pendulum_dyn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⌈λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>⌉ ≤ wp (EVOL φ G T) ⌈λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment">― ‹Verified with differential invariants. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pendulum_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⌈λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>⌉ ≤ wp (x´= f &amp; G) ⌈λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span> </span><span>diff_invariant_rules</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹Verified with the flow. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_flow_pend</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow f UNIV UNIV φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local_lipschitz_def</span><span> </span><span>lipschitz_on_def</span><span> </span><span>vec_eq_iff</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dist_norm</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span> </span><span>power2_commute</span><span> </span><span>UNIV_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>forall_2</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pendulum_flow</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⌈λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>⌉ ≤ wp (x´= f &amp; G) ⌈λs. r<span class="hidden">⇧</span><sup>2</sup> = (s$1)<span class="hidden">⇧</span><sup>2</sup> + (s$2)<span class="hidden">⇧</span><sup>2</sup>⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local_flow.wp_g_ode</span><span class="delimiter">[</span><span>OF</span><span> </span><span>local_flow_pend</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>fpend</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pend_flow</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Bouncing Ball ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ A ball is dropped from rest at an initial height @{text "h"}. The motion is described with
the free-fall equations @{text "x' t = v t"} and @{text "v' t = g"} where @{text "g"} is the
constant acceleration due to gravity. The bounce is modelled with a variable assigntment that
flips the velocity, thus it is a completely elastic collision with the ground. We use @{text "s$1"}
to ball's height and @{text "s$2"} for its velocity. We prove that the ball remains above ground
and below its initial resting position. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>fball</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f g s ≡ (χ i. if i = 1 then s$2 else g)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ball_flow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real ⇒ real^2 ⇒ real^2"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ g t s ≡ (χ i. if i = 1 then g * t ^ 2/2 + s$2 * t + s$1 else g * t + s$2)"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Verified with differential invariants. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>bb_real_arith</span><span> </span><span class="string"><span class="delete"><span class="delete">"real arithmetic properties for the bouncing ball."</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_imp_pos_le</span><span class="delimiter">[</span><span>bb_real_arith</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &gt; g"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * x - 2 * g * h = v * v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::real) ≤ h"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v * v = 2 * g * x - 2 * g * h ∧ 0 &gt; g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &gt; g›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"v * v = 2 * g * (x - h) ∧ 0 &gt; g ∧ v * v ≥ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>left_diff_distrib</span><span> </span><span>mult.commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>zero_le_square</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v * v)/(2 * g) = (x - h)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>obs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v * v)/(2 * g) ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>divide_nonneg_neg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h - x ≥ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bouncing_ball_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span class="delimiter">::</span><span>real</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0 ⟹ h ≥ 0 ⟹ ⌈λs. s$1 = h ∧ s$2 = 0⌉ ≤
  wp
    (LOOP
      ((x´= f g &amp; (λ s. s$1 ≥ 0) DINV (λs. 2 * g * s$1 - 2 * g * h - s$2 * s$2 = 0));
       (IF (λ s. s$1 = 0) THEN (2 ::= (λs. - s$2)) ELSE skip))
    INV (λs. 0 ≤ s$1 ∧ 2 * g * s$1 - 2 * g * h - s$2 * s$2 = 0)
  ) ⌈λs. 0 ≤ s$1 ∧ s$1 ≤ h⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wp_loopI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bb_real_arith</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wp_g_odei</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span> </span><span>diff_invariant_rules</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹Verified by providing dynamics. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_conserv_at_ground</span><span class="delimiter">[</span><span>bb_real_arith</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * x = 2 * g * h + v * v"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g * τ<span class="hidden">⇧</span><sup>2</sup> / 2 + v * τ + (x::real) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * h + (g * τ * (g * τ + v) + v * (g * τ + v)) = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pos</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g * τ<span class="hidden">⇧</span><sup>2</sup>  + 2 * v * τ + 2 * x = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup>  + 2 * g * v * τ + 2 * g * x = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>mult_zero_right</span><span>
</span><span>        </span><span>monoid_mult_class.power2_eq_square</span><span> </span><span>semiring_class.distrib_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup> + 2 * g * v * τ + v<span class="hidden">⇧</span><sup>2</sup> + 2 * g * h = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invar</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monoid_mult_class.power2_eq_square</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(g * τ + v)<span class="hidden">⇧</span><sup>2</sup> + 2 * g * h = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>power2_sum</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Groups.add_ac</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span> </span><span>3</span><span class="delimiter">)</span><span>
</span><span>        </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span> </span><span>3</span><span class="delimiter">)</span><span> </span><span>monoid_mult_class.power2_eq_square</span><span> </span><span>nat_distrib</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * h + (g * τ * (g * τ + v) + v * (g * τ + v)) = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monoid_mult_class.power2_eq_square</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_conserv_at_air</span><span class="delimiter">[</span><span>bb_real_arith</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * x = 2 * g * h + v * v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * g * (g * τ<span class="hidden">⇧</span><sup>2</sup> / 2 + v * τ + (x::real)) =
  2 * g * h + (g * τ * (g * τ + v) + v * (g * τ + v))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup> + 2 * g * v * τ + 2 * g * x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>29</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = g<span class="hidden">⇧</span><sup>2</sup> * τ<span class="hidden">⇧</span><sup>2</sup> + 2 * g * v * τ + 2 * g * h + v * v"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ?middle"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>invar</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?middle"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rhs = g * g * (τ * τ) + 2 * g * v * τ + 2 * g * h + v * v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>semiring_class.distrib_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ?middle"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>29</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rhs = ?middle"</span></span></span><span class="keyword1"><span class="command">.</span></span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bouncing_ball_dyn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span class="delimiter">::</span><span>real</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ≥ 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0 ⟹ h ≥ 0 ⟹
  ⌈λs. s$1 = h ∧ s$2 = 0⌉ ≤ wp
    (LOOP
      ((EVOL (φ g) (λs. 0 ≤ s$1) T);
      (IF (λ s. s$1 = 0) THEN (2 ::= (λs. - s$2)) ELSE skip))
    INV (λs. 0 ≤ s$1 ∧ 2 * g * s$1 = 2 * g * h + s$2 * s$2))
  ⌈λs. 0 ≤ s$1 ∧ s$1 ≤ h⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wp_loopI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bb_real_arith</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹Verified with the flow. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_flow_ball</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_flow (f g) UNIV UNIV (φ g)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local_lipschitz_def</span><span> </span><span>lipschitz_on_def</span><span> </span><span>vec_eq_iff</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"1/2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dist_norm</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span> </span><span>UNIV_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>forall_2</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bouncing_ball_flow</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span class="delimiter">::</span><span>real</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ≥ 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g &lt; 0 ⟹ h ≥ 0 ⟹
  ⌈λs. s$1 = h ∧ s$2 = 0⌉ ≤ wp
    (LOOP
      ((x´= f g &amp; (λ s. s$1 ≥ 0));
      (IF (λ s. s$1 = 0) THEN (2 ::= (λs. - s$2)) ELSE skip))
    INV (λs. 0 ≤ s$1 ∧ 2 * g * s$1 = 2 * g * h + s$2 * s$2))
  ⌈λs. 0 ≤ s$1 ∧ s$1 ≤ h⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wp_loopI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local_flow.wp_g_ode</span><span class="delimiter">[</span><span>OF</span><span> </span><span>local_flow_ball</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bb_real_arith</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>fball</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ball_flow</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Thermostat ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ A thermostat has a chronometer, a thermometer and a switch to turn on and off a heater.
At most every @{text "t"} minutes, it sets its chronometer to @{term "0::real"}, it registers
the room temperature, and it turns the heater on (or off) based on this reading. The temperature
follows the ODE @{text "T' = - a * (T - U)"} where @{text "U"} is @{text "L ≥ 0"} when the heater
is on, and @{text "0"} when it is off. We use @{term "1::4"} to denote the room's temperature,
@{term "2::4"} is time as measured by the thermostat's chronometer, @{term "3::4"} is the
temperature detected by the thermometer, and @{term "4::4"} states whether the heater is on
(@{text "s$4 = 1"}) or off (@{text "s$4 = 0"}). We prove that the thermostat keeps the room's
temperature between @{text "Tmin"} and @{text "Tmax"}. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>temp_vec_field</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real ⇒ real^4 ⇒ real^4"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f a L s ≡ (χ i. if i = 2 then 1 else (if i = 1 then - a * (s$1 - L) else 0))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>temp_flow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real ⇒ real ⇒ real^4 ⇒ real^4"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ a L t s ≡ (χ i. if i = 1 then - exp(-a * t) * (L - s$1) + L else
  (if i = 2 then t + s$2 else s$i))"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Verified with the flow. ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_diff_temp_dyn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; a ⟹ ∥f a L s<span class="hidden">⇩</span><sub>1</sub> - f a L s<span class="hidden">⇩</span><sub>2</sub>∥ = ¦a¦ * ¦s<span class="hidden">⇩</span><sub>1</sub>$1 - s<span class="hidden">⇩</span><sub>2</sub>$1¦"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>UNIV_4</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀r ra. ¦(r::real) + - ra¦ = ¦ra + - r¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>abs_minus_commute</span><span> </span><span>minus_real_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀r ra rb. (r::real) * ra + - (r * rb) = r * (ra + - rb)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>minus_real_def</span><span> </span><span>right_diff_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦a * (s<span class="hidden">⇩</span><sub>1</sub>$1 + - L) + - (a * (s<span class="hidden">⇩</span><sub>2</sub>$1 + - L))¦ = a * ¦s<span class="hidden">⇩</span><sub>1</sub>$1 + - s<span class="hidden">⇩</span><sub>2</sub>$1¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_mult</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦a * (s<span class="hidden">⇩</span><sub>2</sub>$1 - L) - a * (s<span class="hidden">⇩</span><sub>1</sub>$1 - L)¦ = a * ¦s<span class="hidden">⇩</span><sub>1</sub>$1 - s<span class="hidden">⇩</span><sub>2</sub>$1¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>minus_real_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_lipschitz_temp_dyn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; (a::real)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_lipschitz UNIV UNIV (λt::real. f a L)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>local_lipschitz_def</span><span> </span><span>lipschitz_on_def</span><span> </span><span>dist_norm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>a</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_diff_temp_dyn</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_vec_def</span><span> </span><span>L2_set_def</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>UNIV_4</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>real_sqrt_abs</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>real_le_lsqrt</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_flow_temp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0 ⟹ local_flow (f a L) UNIV UNIV (φ a L)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_derivatives</span><span> </span><span>local_lipschitz_temp_dyn</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>forall_4</span><span> </span><span>vec_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>temp_dyn_down_real_arith</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; Tmin"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ (t::real)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈{0..t}. τ ≤ - (ln (Tmin / T) / a) "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ exp (-a * t) * T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp (-a * t) * T ≤ Tmax"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t ∧ t ≤ - (ln (Tmin / T) / a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln (Tmin / T) ≤ - a * t ∧ - a * t ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>divide_le_cancel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin / T &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin / T ≤ exp (-a * t)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp (-a * t) ≤ 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exp_ln</span><span> </span><span>exp_le_one_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>exp_less_cancel_iff</span><span> </span><span>not_less</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ exp (-a * t) * T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pos_divide_le_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp (-a * t) * T ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span>mult_left_le_one_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>exp_ge_zero</span><span> </span><span>obs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>      </span><span>less_eq_real_def</span><span> </span><span>order_trans_rules</span><span class="delimiter">(</span><span>23</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>temp_dyn_up_real_arith</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ≤ Tmax"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmax &lt; (L::real)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>thyps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀τ∈{0..t}. τ ≤ - (ln ((L - Tmax) / (L - T)) / a) "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - Tmax ≤ exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - exp (-(a * t)) * (L - T) ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ L - exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t ∧ t ≤ - (ln ((L - Tmax) / (L - T)) / a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln ((L - Tmax) / (L - T)) ≤ - a * t ∧ - a * t ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>divide_le_cancel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) / (L - T) &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) / (L - T) ≤ exp (-a * t) ∧ exp (-a * t) ≤ 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exp_ln</span><span> </span><span>exp_le_one_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>exp_less_cancel_iff</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - T &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) ≤ exp (-a * t) * (L - T) ∧ exp (-a * t) * (L - T) ≤ (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pos_divide_le_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(L - Tmax) ≤ exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L - exp (-(a * t)) * (L - T) ≤ Tmax"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmin ≤ L - exp (-(a * t)) * (L - T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Thyps</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>obs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fbox_temp_dyn</span><span> </span><span class="delimiter">=</span><span> </span><span>local_flow.fbox_g_ode_ivl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>local_flow_temp</span><span> </span><span>_</span><span> </span><span>UNIV_I</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>thermostat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; Tmin"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tmax &lt; L"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈λs. Tmin ≤ s$1 ∧ s$1 ≤ Tmax ∧ s$4 = 0⌉ ≤ wp
  (LOOP
    ― ‹control›
    ((2 ::= (λs. 0));(3 ::= (λs. s$1));
    (IF (λs. s$4 = 0 ∧ s$3 ≤ Tmin + 1) THEN (4 ::= (λs.1)) ELSE
    (IF (λs. s$4 = 1 ∧ s$3 ≥ Tmax - 1) THEN (4 ::= (λs.0)) ELSE skip));
    ― ‹dynamics›
    (IF (λs. s$4 = 0) THEN (x´=(f a 0) &amp; (λs. s$2 ≤ - (ln (Tmin/s$3))/a) on {0..t} UNIV @ 0)
    ELSE (x´=(f a L) &amp; (λs. s$2 ≤ - (ln ((L-Tmax)/(L-s$3)))/a) on {0..t} UNIV @ 0)) )
  INV (λs. Tmin ≤s$1 ∧ s$1 ≤ Tmax ∧ (s$4 = 0 ∨ s$4 = 1)))
  ⌈λs. Tmin ≤ s$1 ∧ s$1 ≤ Tmax⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wp_loopI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fbox_temp_dyn</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>temp_dyn_up_real_arith</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>Tmin</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>temp_dyn_down_real_arith</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>Tmax</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>temp_vec_field</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>temp_flow</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div>