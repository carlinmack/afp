<div id="Cotree">
<div class="head">
<h1>Theory Cotree</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Andreas Lochbihler, ETH Zurich
   Author: Peter Gammie *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹A codatatype of infinite binary trees›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Cotree <span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../../HOL/HOL/Main.html">Main</a>
  <a href="../Applicative_Lifting/Applicative.html">Applicative_Lifting.Applicative</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/BNF_Corec.html">HOL-Library.BNF_Corec</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Adhoc_Overloading.html">HOL-Library.Adhoc_Overloading</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">bnf_internals</span><span class="main">]</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">codatatype</span></span> <span class="tfree">'a</span> tree <span class="main">=</span> Node <span class="main">(</span><span class="free"><span class="entity">root</span></span><span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="entity">left</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="entity">right</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rel_treeD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"rel_tree <span class="free">A</span> <span class="free">x</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> rel_tree_rootD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">(</span>root <span class="free">x</span><span class="main">)</span> <span class="main">(</span>root <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> rel_tree_leftD<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_tree <span class="free">A</span> <span class="main">(</span>left <span class="free">x</span><span class="main">)</span> <span class="main">(</span>left <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> rel_tree_rightD<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_tree <span class="free">A</span> <span class="main">(</span>right <span class="free">x</span><span class="main">)</span> <span class="main">(</span>right <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tree.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> tree.exhaust<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> tree.map_sel tree.map_comp

<span class="keyword1"><span class="command">lemma</span></span> set_tree_induct<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> root left right<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set_tree <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> root<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">t</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>root <span class="bound">t</span><span class="main">)</span> <span class="bound">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> left<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">t</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">x</span> <span class="main">∈</span> set_tree <span class="main">(</span>left <span class="bound">t</span><span class="main">)</span><span class="main">;</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">(</span>left <span class="bound">t</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> right<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">t</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">x</span> <span class="main">∈</span> set_tree <span class="main">(</span>right <span class="bound">t</span><span class="main">)</span><span class="main">;</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">(</span>right <span class="bound">t</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> x
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> tree.set_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">r</span>
  <span class="keyword1"><span class="command">from</span></span> root<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Node <span class="skolem">x</span> <span class="skolem">l</span> <span class="skolem">r</span>"</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">x</span> <span class="main">(</span>Node <span class="skolem">x</span> <span class="skolem">l</span> <span class="skolem">r</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> left right<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> corec_tree_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">stopL</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">STOPL</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">STOPL'</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">~</span> <span class="free">stopL</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">LEFT</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">LEFT'</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">stopR</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">STOPR</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">STOPR'</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="free">stopR</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">RIGHT</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">RIGHT'</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"corec_tree <span class="free">ROOT</span> <span class="free">stopL</span> <span class="free">STOPL</span> <span class="free">LEFT</span> <span class="free">stopR</span> <span class="free">STOPR</span> <span class="free">RIGHT</span> <span class="main">=</span> 
         corec_tree <span class="free">ROOT</span> <span class="free">stopL</span> <span class="free">STOPL'</span> <span class="free">LEFT'</span> <span class="free">stopR</span> <span class="free">STOPR'</span> <span class="free">RIGHT'</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">x</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tree.coinduct_strong<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g22</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">corec</span></span> <span class="entity">unfold_tree</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">unfold_tree</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> Node <span class="main">(</span><span class="free">g1</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">unfold_tree</span> <span class="main">(</span><span class="free">g22</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">unfold_tree</span> <span class="main">(</span><span class="free">g32</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unfold_tree_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root <span class="main">(</span>unfold_tree <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="free">g1</span> <span class="free">a</span>"</span></span>
  <span class="quoted"><span class="quoted">"left <span class="main">(</span>unfold_tree <span class="free">a</span><span class="main">)</span> <span class="main">=</span> unfold_tree <span class="main">(</span><span class="free">g22</span> <span class="free">a</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"right <span class="main">(</span>unfold_tree <span class="free">a</span><span class="main">)</span> <span class="main">=</span> unfold_tree <span class="main">(</span><span class="free">g32</span> <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> unfold_tree.code<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unfold_tree_unique<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> root <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">ROOT</span> <span class="bound">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> left <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="free">LEFT</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> right <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="free">RIGHT</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">s</span> <span class="main">=</span> unfold_tree <span class="free">ROOT</span> <span class="free">LEFT</span> <span class="free">RIGHT</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> unfold_tree.unique<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> fun_cong<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff assms <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> tree.expand<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Applicative functor for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> tree"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">corec</span></span> <span class="entity">pure_tree</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pure_tree</span> <span class="main">=</span> Node <span class="free">x</span> <span class="free">pure_tree</span> <span class="free">pure_tree</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> pure_tree_unfold <span class="main">=</span> pure_tree.code

<span class="keyword1"><span class="command">lemma</span></span> pure_tree_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"root <span class="main">(</span>pure_tree <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"left <span class="main">(</span>pure_tree <span class="free">x</span><span class="main">)</span> <span class="main">=</span> pure_tree <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"right <span class="main">(</span>pure_tree <span class="free">x</span><span class="main">)</span> <span class="main">=</span> pure_tree <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> pure_tree_unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> pure <span class="quoted">pure_tree</span>

<span class="keyword1"><span class="command">lemma</span></span> pure_tree_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_fun <span class="free">A</span> <span class="main">(</span>rel_tree <span class="free">A</span><span class="main">)</span><span class="main">)</span> pure pure"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main">(</span><span class="operator">coinduction</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_pure_tree <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"map_tree <span class="free">f</span> <span class="main">(</span>pure <span class="free">x</span><span class="main">)</span> <span class="main">=</span> pure <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemmas</span></span> pure_tree_unique <span class="main">=</span> pure_tree.unique

<span class="keyword1"><span class="command">primcorec</span></span> <span class="main">(</span>transfer<span class="main">)</span> <span class="entity">ap_tree</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'b</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"root <span class="main">(</span><span class="free">ap_tree</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> root <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>root <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"left <span class="main">(</span><span class="free">ap_tree</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">ap_tree</span> <span class="main">(</span>left <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">(</span>left <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"right <span class="main">(</span><span class="free">ap_tree</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">ap_tree</span> <span class="main">(</span>right <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">(</span>right <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">ap_tree</span>

<span class="keyword1"><span class="command">unbundle</span></span> applicative_syntax

<span class="keyword1"><span class="command">lemma</span></span> ap_tree_pure_Node <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"pure <span class="free">f</span> <span class="main">⋄</span> Node <span class="free">x</span> <span class="free">l</span> <span class="free">r</span> <span class="main">=</span> Node <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>pure <span class="free">f</span> <span class="main">⋄</span> <span class="free">l</span><span class="main">)</span> <span class="main">(</span>pure <span class="free">f</span> <span class="main">⋄</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tree.expand<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_tree_Node_Node <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Node <span class="free">f</span> <span class="free">fl</span> <span class="free">fr</span> <span class="main">⋄</span> Node <span class="free">x</span> <span class="free">l</span> <span class="free">r</span> <span class="main">=</span> Node <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">fl</span> <span class="main">⋄</span> <span class="free">l</span><span class="main">)</span> <span class="main">(</span><span class="free">fr</span> <span class="main">⋄</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tree.expand<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Applicative functor laws›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_tree_ap_tree_pure_tree<span class="main">:</span>
  <span class="quoted"><span class="quoted">"pure <span class="free">f</span> <span class="main">⋄</span> <span class="free">u</span> <span class="main">=</span> map_tree <span class="free">f</span> <span class="free">u</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_tree_identity<span class="main">:</span> <span class="quoted"><span class="quoted">"pure id <span class="main">⋄</span> <span class="free">t</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_tree_ap_tree_pure_tree tree.map_id<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_tree_composition<span class="main">:</span>
  <span class="quoted"><span class="quoted">"pure <span class="main">(∘)</span> <span class="main">⋄</span> <span class="free">r1</span> <span class="main">⋄</span> <span class="free">r2</span> <span class="main">⋄</span> <span class="free">r3</span> <span class="main">=</span> <span class="free">r1</span> <span class="main">⋄</span> <span class="main">(</span><span class="free">r2</span> <span class="main">⋄</span> <span class="free">r3</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">r1</span></span> <span class="quoted"><span class="free">r2</span></span> <span class="quoted"><span class="free">r3</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_tree_homomorphism<span class="main">:</span>
  <span class="quoted"><span class="quoted">"pure <span class="free">f</span> <span class="main">⋄</span> pure <span class="free">x</span> <span class="main">=</span> pure <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_tree_ap_tree_pure_tree<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_tree_interchange<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">⋄</span> pure <span class="free">x</span> <span class="main">=</span> pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_tree_K_tree<span class="main">:</span> <span class="quoted"><span class="quoted">"pure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">u</span> <span class="main">⋄</span> <span class="free">v</span> <span class="main">=</span> <span class="free">u</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_tree_C_tree<span class="main">:</span> <span class="quoted"><span class="quoted">"pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">u</span> <span class="main">⋄</span> <span class="free">v</span> <span class="main">⋄</span> <span class="free">w</span> <span class="main">=</span> <span class="free">u</span> <span class="main">⋄</span> <span class="free">w</span> <span class="main">⋄</span> <span class="free">v</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="free">w</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_tree_W_tree<span class="main">:</span> <span class="quoted"><span class="quoted">"pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">=</span> <span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">⋄</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">applicative</span></span> tree <span class="main">(</span>K<span class="main">,</span> W<span class="main">)</span> <span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted">pure_tree</span>
  ap<span class="main">:</span> <span class="quoted">ap_tree</span>
  rel<span class="main">:</span> <span class="quoted">rel_tree</span>
  set<span class="main">:</span> <span class="quoted">set_tree</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> tree"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_tree <span class="main">(</span>rel_fun <span class="main">(</span>eq_on <span class="main">(</span>set_tree <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">R</span><span class="main">)</span> <span class="skolem">f</span> <span class="skolem">g</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_tree <span class="main">(</span>eq_on <span class="main">(</span>set_tree <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tree.rel_refl_strong<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rel_tree <span class="skolem">R</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">g</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">rule</span> ap_tree_homomorphism ap_tree_composition<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> o_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span> ap_tree_K_tree ap_tree_W_tree ap_tree_interchange pure_tree_parametric<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">declare</span></span> map_tree_ap_tree_pure_tree<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">applicative_unfold</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_tree_strong_extensional<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="main">⋄</span> pure <span class="bound">x</span> <span class="main">=</span> <span class="free">g</span> <span class="main">⋄</span> pure <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">=</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">g</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span> <span class="main">(</span>Eq_tree <span class="skolem">f</span> <span class="skolem">g</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"root <span class="skolem">f</span> <span class="main">=</span> root <span class="skolem">g</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"root <span class="skolem">f</span> <span class="skolem">x</span> <span class="main">=</span> root <span class="skolem">g</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> Eq_tree<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> ap_tree.ctr<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"left <span class="skolem">f</span> <span class="main">⋄</span> pure <span class="skolem">x</span> <span class="main">=</span> left <span class="skolem">g</span> <span class="main">⋄</span> pure <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> Eq_tree<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> ap_tree.ctr<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"right <span class="skolem">f</span> <span class="main">⋄</span> pure <span class="skolem">x</span> <span class="main">=</span> right <span class="skolem">g</span> <span class="main">⋄</span> pure <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> Eq_tree<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> ap_tree.ctr<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ap_tree_extensional<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">g</span> <span class="main">⋄</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">=</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ap_tree_strong_extensional<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Standard tree combinators›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Recurse combinator›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This will be the main combinator to define trees recursively

  Uniqueness for this gives us the unique fixed-point theorem for guarded recursive definitions.
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> map_unfold_tree <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">l</span> <span class="free">r</span> <span class="free">x</span>
 <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">unf</span> <span class="main">≡</span> unfold_tree <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∘</span> <span class="free">l</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∘</span> <span class="free">r</span><span class="main">)</span>"</span></span>
 <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_tree <span class="free">G</span> <span class="main">(</span><span class="free">unf</span> <span class="free">F</span><span class="main">)</span> <span class="main">=</span> <span class="free">unf</span> <span class="main">(</span><span class="free">G</span> <span class="main">∘</span> <span class="free">F</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">F</span></span> <span class="quoted"><span class="free">G</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unf_def o_assoc<span class="main">)</span>

<span class="keyword1"><span class="command">friend_of_corec</span></span> map_tree <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"map_tree <span class="free">f</span> <span class="free">t</span> <span class="main">=</span> Node <span class="main">(</span><span class="free">f</span> <span class="main">(</span>root <span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map_tree <span class="free">f</span> <span class="main">(</span>left <span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map_tree <span class="free">f</span> <span class="main">(</span>right <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tree.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fold</span> <span class="dynamic"><span class="dynamic">relator_eq</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer_prover</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">l</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">corec</span></span> <span class="entity">tree_recurse</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">tree_recurse</span> <span class="main">=</span> Node <span class="free">x</span> <span class="main">(</span>map_tree <span class="free">l</span> <span class="free">tree_recurse</span><span class="main">)</span> <span class="main">(</span>map_tree <span class="free">r</span> <span class="free">tree_recurse</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> tree_recurse_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root <span class="main">(</span>tree_recurse <span class="free">l</span> <span class="free">r</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"left <span class="main">(</span>tree_recurse <span class="free">l</span> <span class="free">r</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> map_tree <span class="free">l</span> <span class="main">(</span>tree_recurse <span class="free">l</span> <span class="free">r</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"right <span class="main">(</span>tree_recurse <span class="free">l</span> <span class="free">r</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> map_tree <span class="free">r</span> <span class="main">(</span>tree_recurse <span class="free">l</span> <span class="free">r</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> tree_recurse.code<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> tree_recurse_unfold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tree_recurse <span class="free">l</span> <span class="free">r</span> <span class="free">x</span> <span class="main">=</span> Node <span class="free">x</span> <span class="main">(</span>map_tree <span class="free">l</span> <span class="main">(</span>tree_recurse <span class="free">l</span> <span class="free">r</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map_tree <span class="free">r</span> <span class="main">(</span>tree_recurse <span class="free">l</span> <span class="free">r</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> tree_recurse.code<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> tree_recurse_fusion<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∘</span> <span class="free">l</span> <span class="main">=</span> <span class="free">l'</span> <span class="main">∘</span> <span class="free">h</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∘</span> <span class="free">r</span> <span class="main">=</span> <span class="free">r'</span> <span class="main">∘</span> <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_tree <span class="free">h</span> <span class="main">(</span>tree_recurse <span class="free">l</span> <span class="free">r</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> tree_recurse <span class="free">l'</span> <span class="free">r'</span> <span class="main">(</span><span class="free">h</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tree_recurse.unique<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tree.expand assms<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Tree iteration›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">l</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">tree_iterate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">" <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">tree_iterate</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> Node <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span><span class="free">tree_iterate</span> <span class="main">(</span><span class="free">l</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">tree_iterate</span> <span class="main">(</span><span class="free">r</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unfold_tree_tree_iterate<span class="main">:</span>
  <span class="quoted"><span class="quoted">"unfold_tree <span class="free">out</span> <span class="free">l</span> <span class="free">r</span> <span class="main">=</span> map_tree <span class="free">out</span> <span class="main">∘</span> tree_iterate <span class="free">l</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> unfold_tree_unique<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> tree_iterate_fusion<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∘</span> <span class="free">l</span> <span class="main">=</span> <span class="free">l'</span> <span class="main">∘</span> <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∘</span> <span class="free">r</span> <span class="main">=</span> <span class="free">r'</span> <span class="main">∘</span> <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_tree <span class="free">h</span> <span class="main">(</span>tree_iterate <span class="free">l</span> <span class="free">r</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> tree_iterate <span class="free">l'</span> <span class="free">r'</span> <span class="main">(</span><span class="free">h</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Tree traversal›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> dir <span class="main">=</span> L <span class="main">|</span> R
<span class="keyword1"><span class="command">type_synonym</span></span> path <span class="main">=</span> <span class="quoted"><span class="quoted">"dir list"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">traverse_tree</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"path <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">traverse_tree</span> <span class="free"><span class="bound"><span class="entity">path</span></span></span> <span class="main">≡</span> foldr <span class="main">(</span><span class="main">λ</span><span class="bound">d</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∘</span> case_dir left right <span class="bound">d</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">path</span></span></span> id"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> traverse_tree_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"traverse_tree <span class="main">[]</span> <span class="main">=</span> id"</span></span>
  <span class="quoted"><span class="quoted">"traverse_tree <span class="main">(</span><span class="free">d</span> <span class="main">#</span> <span class="free">path</span><span class="main">)</span> <span class="main">=</span> traverse_tree <span class="free">path</span> <span class="main">∘</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">d</span> <span class="keyword1">of</span> L <span class="main">⇒</span> left <span class="main">|</span> R <span class="main">⇒</span> right<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> traverse_tree_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> traverse_tree_map_tree <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"traverse_tree <span class="free">path</span> <span class="main">(</span>map_tree <span class="free">f</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> map_tree <span class="free">f</span> <span class="main">(</span>traverse_tree <span class="free">path</span> <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">path</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> traverse_tree_append <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"traverse_tree <span class="main">(</span><span class="free">path</span> <span class="main">@</span> <span class="free">ext</span><span class="main">)</span> <span class="free">t</span> <span class="main">=</span> traverse_tree <span class="free">ext</span> <span class="main">(</span>traverse_tree <span class="free">path</span> <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">path</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "traverse_tree"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is an applicative-functor homomorphism.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> traverse_tree_pure_tree <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"traverse_tree <span class="free">path</span> <span class="main">(</span>pure <span class="free">x</span><span class="main">)</span> <span class="main">=</span> pure <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">path</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> traverse_tree_ap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"traverse_tree <span class="free">path</span> <span class="main">(</span><span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> traverse_tree <span class="free">path</span> <span class="free">f</span> <span class="main">⋄</span> traverse_tree <span class="free">path</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">path</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">l</span> <span class="free">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">traverse_dir</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"dir <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">traverse_dir</span> L <span class="main">=</span> <span class="free">l</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">traverse_dir</span> R <span class="main">=</span> <span class="free">r</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">traverse_path</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"path <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">traverse_path</span> <span class="main">≡</span> fold traverse_dir"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> traverse_tree_tree_iterate<span class="main">:</span>
  <span class="quoted"><span class="quoted">"traverse_tree <span class="free">path</span> <span class="main">(</span>tree_iterate <span class="free">l</span> <span class="free">r</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span>
   tree_iterate <span class="free">l</span> <span class="free">r</span> <span class="main">(</span>traverse_path <span class="free">l</span> <span class="free">r</span> <span class="free">path</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">path</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\citeauthor{DBLP:journals/jfp/Hinze09} shows that if the tree
construction function is suitably monoidal then recursion and
iteration define the same tree.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> tree_recurse_iterate<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> monoid<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">z</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">(</span><span class="free">f</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="free">ε</span> <span class="main">=</span> <span class="bound">x</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="free">ε</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tree_recurse <span class="main">(</span><span class="free">f</span> <span class="free">l</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="free">r</span><span class="main">)</span> <span class="free">ε</span> <span class="main">=</span> tree_iterate <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="free">l</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="free">r</span><span class="main">)</span> <span class="free">ε</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> tree_recurse.unique<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> tree.expand<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tree_iterate_fusion<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> r'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="free">r</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> l'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="free">l</span>"</span></span><span class="main"><span class="main">]</span></span> fun_eq_iff monoid<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Mirroring›</span></span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">mirror</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"root <span class="main">(</span><span class="free">mirror</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">=</span> root <span class="free"><span class="bound"><span class="entity">t</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"left <span class="main">(</span><span class="free">mirror</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">mirror</span> <span class="main">(</span>right <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"right <span class="main">(</span><span class="free">mirror</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">mirror</span> <span class="main">(</span>left <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mirror_unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"mirror <span class="main">(</span>Node <span class="free">x</span> <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> Node <span class="free">x</span> <span class="main">(</span>mirror <span class="free">r</span><span class="main">)</span> <span class="main">(</span>mirror <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tree.expand<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> mirror_pure<span class="main">:</span> <span class="quoted"><span class="quoted">"mirror <span class="main">(</span>pure <span class="free">x</span><span class="main">)</span> <span class="main">=</span> pure <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tree.coinduct<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> mirror_ap_tree<span class="main">:</span> <span class="quoted"><span class="quoted">"mirror <span class="main">(</span><span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> mirror <span class="free">f</span> <span class="main">⋄</span> mirror <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Cotree_Algebra">
<div class="head">
<h1>Theory Cotree_Algebra</h1>
</div>
<pre class="source"><span class="comment1">(*  Author: Andreas Lochbihler, ETH Zurich
    Author: Joshua Schneider, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Pointwise arithmetic on infinite binary trees›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Cotree_Algebra
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Cotree.html">Cotree</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Constants and operators›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">zero</span><span class="main">)</span> <span class="quoted">zero</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">=</span> pure_tree <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">one</span><span class="main">)</span> <span class="quoted">one</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">=</span> pure_tree <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">plus</span><span class="main">)</span> <span class="quoted">plus</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"plus <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> pure <span class="main">(+)</span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⋄</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> tree<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> plus_tree_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root <span class="main">(</span><span class="free">t</span> <span class="main">+</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> root <span class="free">t</span> <span class="main">+</span> root <span class="free">t'</span>"</span></span>
  <span class="quoted"><span class="quoted">"left <span class="main">(</span><span class="free">t</span> <span class="main">+</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> left <span class="free">t</span> <span class="main">+</span> left <span class="free">t'</span>"</span></span>
  <span class="quoted"><span class="quoted">"right <span class="main">(</span><span class="free">t</span> <span class="main">+</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> right <span class="free">t</span> <span class="main">+</span> right <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> plus_tree_def<span class="main">)</span>

<span class="keyword1"><span class="command">friend_of_corec</span></span> plus <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">+</span> <span class="free">t'</span> <span class="main">=</span> Node <span class="main">(</span>root <span class="free">t</span> <span class="main">+</span> root <span class="free">t'</span><span class="main">)</span> <span class="main">(</span>left <span class="free">t</span> <span class="main">+</span> left <span class="free">t'</span><span class="main">)</span> <span class="main">(</span>right <span class="free">t</span> <span class="main">+</span> right <span class="free">t'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tree.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">instantiation</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">minus</span><span class="main">)</span> <span class="quoted">minus</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"minus <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> pure <span class="main">(-)</span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⋄</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> tree<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> minus_tree_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root <span class="main">(</span><span class="free">t</span> <span class="main">-</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> root <span class="free">t</span> <span class="main">-</span> root <span class="free">t'</span>"</span></span>
  <span class="quoted"><span class="quoted">"left <span class="main">(</span><span class="free">t</span> <span class="main">-</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> left <span class="free">t</span> <span class="main">-</span> left <span class="free">t'</span>"</span></span>
  <span class="quoted"><span class="quoted">"right <span class="main">(</span><span class="free">t</span> <span class="main">-</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> right <span class="free">t</span> <span class="main">-</span> right <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> minus_tree_def<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">uminus</span><span class="main">)</span> <span class="quoted">uminus</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span> tree<span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"uminus <span class="main">=</span> <span class="main">(</span><span class="main">(⋄)</span> <span class="main">(</span>pure uminus<span class="main">)</span> <span class="main">::</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">times</span><span class="main">)</span> <span class="quoted">times</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"times <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> pure <span class="main">(*)</span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⋄</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> tree<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> times_tree_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root <span class="main">(</span><span class="free">t</span> <span class="main">*</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> root <span class="free">t</span> <span class="main">*</span> root <span class="free">t'</span>"</span></span>
  <span class="quoted"><span class="quoted">"left <span class="main">(</span><span class="free">t</span> <span class="main">*</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> left <span class="free">t</span> <span class="main">*</span> left <span class="free">t'</span>"</span></span>
  <span class="quoted"><span class="quoted">"right <span class="main">(</span><span class="free">t</span> <span class="main">*</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> right <span class="free">t</span> <span class="main">*</span> right <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> times_tree_def<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">Rings.dvd</span><span class="main">)</span> <span class="quoted">Rings.dvd</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">modulo</span><span class="main">)</span> <span class="quoted">modulo</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">div</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> pure_tree <span class="keyword1">(div)</span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⋄</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> tree<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">mod</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> pure_tree <span class="keyword1">(mod)</span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⋄</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> tree<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mod_tree_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root <span class="main">(</span><span class="free">t</span> <span class="keyword1">mod</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> root <span class="free">t</span> <span class="keyword1">mod</span> root <span class="free">t'</span>"</span></span>
  <span class="quoted"><span class="quoted">"left <span class="main">(</span><span class="free">t</span> <span class="keyword1">mod</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> left <span class="free">t</span> <span class="keyword1">mod</span> left <span class="free">t'</span>"</span></span>
  <span class="quoted"><span class="quoted">"right <span class="main">(</span><span class="free">t</span> <span class="keyword1">mod</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> right <span class="free">t</span> <span class="keyword1">mod</span> right <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> modulo_tree_def<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Algebraic instances›</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">semigroup_add</span><span class="main">)</span> <span class="quoted">semigroup_add</span>
<span class="keyword1"><span class="command">using</span></span> add.assoc <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="operator">applicative_lifting</span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">ab_semigroup_add</span><span class="main">)</span> <span class="quoted">ab_semigroup_add</span>
<span class="keyword1"><span class="command">using</span></span> add.commute <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="operator">applicative_lifting</span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">semigroup_mult</span><span class="main">)</span> <span class="quoted">semigroup_mult</span>
<span class="keyword1"><span class="command">using</span></span> mult.assoc <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="operator">applicative_lifting</span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">ab_semigroup_mult</span><span class="main">)</span> <span class="quoted">ab_semigroup_mult</span>
<span class="keyword1"><span class="command">using</span></span> mult.commute <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="operator">applicative_lifting</span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">monoid_add</span><span class="main">)</span> <span class="quoted">monoid_add</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_monoid_add</span><span class="main">)</span> <span class="quoted">comm_monoid_add</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_monoid_diff</span><span class="main">)</span> <span class="quoted">comm_monoid_diff</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> diff_diff_add<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">monoid_mult</span><span class="main">)</span> <span class="quoted">monoid_mult</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_monoid_mult</span><span class="main">)</span> <span class="quoted">comm_monoid_mult</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">cancel_semigroup_add</span><span class="main">)</span> <span class="quoted">cancel_semigroup_add</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">+</span> <span class="skolem">b</span> <span class="main">=</span> <span class="skolem">a</span> <span class="main">+</span> <span class="skolem">c</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> <span class="skolem">c</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="skolem">b</span></span> <span class="quoted"><span class="skolem">c</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_tree <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"root <span class="main">(</span><span class="skolem">a</span> <span class="main">+</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">=</span> root <span class="main">(</span><span class="skolem">a</span> <span class="main">+</span> <span class="skolem">c</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"left <span class="main">(</span><span class="skolem">a</span> <span class="main">+</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">=</span> left <span class="main">(</span><span class="skolem">a</span> <span class="main">+</span> <span class="skolem">c</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"right <span class="main">(</span><span class="skolem">a</span> <span class="main">+</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">=</span> right <span class="main">(</span><span class="skolem">a</span> <span class="main">+</span> <span class="skolem">c</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">+</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">c</span> <span class="main">+</span> <span class="skolem">a</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> <span class="skolem">c</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="skolem">b</span></span> <span class="quoted"><span class="skolem">c</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_tree <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"root <span class="main">(</span><span class="skolem">b</span> <span class="main">+</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> root <span class="main">(</span><span class="skolem">c</span> <span class="main">+</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"left <span class="main">(</span><span class="skolem">b</span> <span class="main">+</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> left <span class="main">(</span><span class="skolem">c</span> <span class="main">+</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"right <span class="main">(</span><span class="skolem">b</span> <span class="main">+</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> right <span class="main">(</span><span class="skolem">c</span> <span class="main">+</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">cancel_ab_semigroup_add</span><span class="main">)</span> <span class="quoted">cancel_ab_semigroup_add</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> diff_diff_eq<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">cancel_comm_monoid_add</span><span class="main">)</span> <span class="quoted">cancel_comm_monoid_add</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">group_add</span><span class="main">)</span> <span class="quoted">group_add</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">ab_group_add</span><span class="main">)</span> <span class="quoted">ab_group_add</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">semiring</span><span class="main">)</span> <span class="quoted">semiring</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ring_distribs<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">mult_zero</span><span class="main">)</span> <span class="quoted">mult_zero</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">semiring_0</span><span class="main">)</span> <span class="quoted">semiring_0</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">semiring_0_cancel</span><span class="main">)</span> <span class="quoted">semiring_0_cancel</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_semiring</span><span class="main">)</span> <span class="quoted">comm_semiring</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span><span class="main">(</span><span class="operator">rule</span> distrib_right<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_semiring_0</span><span class="main">)</span> <span class="quoted">comm_semiring_0</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_semiring_0_cancel</span><span class="main">)</span> <span class="quoted">comm_semiring_0_cancel</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> pure_tree_inject<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"pure_tree <span class="free">x</span> <span class="main">=</span> pure_tree <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"pure_tree <span class="free">x</span> <span class="main">=</span> pure_tree <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"root <span class="main">(</span>pure_tree <span class="free">x</span><span class="main">)</span> <span class="main">=</span> root <span class="main">(</span>pure_tree <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">zero_neq_one</span><span class="main">)</span> <span class="quoted">zero_neq_one</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_unfold</span> tree<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">semiring_1</span><span class="main">)</span> <span class="quoted">semiring_1</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_semiring_1</span><span class="main">)</span> <span class="quoted">comm_semiring_1</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">semiring_1_cancel</span><span class="main">)</span> <span class="quoted">semiring_1_cancel</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_semiring_1_cancel</span><span class="main">)</span> <span class="quoted">comm_semiring_1_cancel</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> right_diff_distrib'<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">ring</span><span class="main">)</span> <span class="quoted">ring</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_ring</span><span class="main">)</span> <span class="quoted">comm_ring</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">ring_1</span><span class="main">)</span> <span class="quoted">ring_1</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_ring_1</span><span class="main">)</span> <span class="quoted">comm_ring_1</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">numeral</span><span class="main">)</span> <span class="quoted">numeral</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">neg_numeral</span><span class="main">)</span> <span class="quoted">neg_numeral</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">semiring_numeral</span><span class="main">)</span> <span class="quoted">semiring_numeral</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> of_nat_tree<span class="main">:</span> <span class="quoted"><span class="quoted">"of_nat <span class="free">n</span> <span class="main">=</span> pure_tree <span class="main">(</span>of_nat <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_tree_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">+</span> pure <span class="main">(</span>of_nat <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> pure <span class="main">(</span><span class="main">1</span> <span class="main">+</span> of_nat <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">with</span></span> Suc.IH <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">semiring_char_0</span><span class="main">)</span> <span class="quoted">semiring_char_0</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def of_nat_tree<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> numeral_tree_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"left <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"right <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> numeral.simps plus_tree_def one_tree_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> numeral_tree_conv_pure <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"numeral <span class="free">n</span> <span class="main">=</span> pure <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> pure_tree_unique<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> tree.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> tree <span class="main">::</span> <span class="main">(</span><span class="quoted">ring_char_0</span><span class="main">)</span> <span class="quoted">ring_char_0</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Stern_Brocot_Tree">
<div class="head">
<h1>Theory Stern_Brocot_Tree</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Peter Gammie
   Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹The Stern-Brocot Tree›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Stern_Brocot_Tree
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOL/Rat.html">HOL.Rat</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Sublist.html">HOL-Library.Sublist</a>"</span>
  <a href="Cotree_Algebra.html">Cotree_Algebra</a>
  <a href="../Applicative_Lifting/Stream_Algebra.html">Applicative_Lifting.Stream_Algebra</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
  The Stern-Brocot tree is discussed at length by \citet[\S4.5]{GrahamKnuthPatashnik1994CM}.
  In essence the tree enumerates the rational numbers in their lowest terms by constructing the
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mediant›</span></span></span></span> of two bounding fractions.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> fraction <span class="main">=</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mediant</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"fraction <span class="main">×</span> fraction <span class="main">⇒</span> fraction"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">mediant</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span> <span class="main">+</span> <span class="bound">b</span><span class="main">,</span> <span class="bound">c</span> <span class="main">+</span> <span class="bound">d</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stern_brocot</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"fraction tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">stern_brocot</span> <span class="main">=</span> unfold_tree
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">lb</span><span class="main">,</span> <span class="bound">ub</span><span class="main">)</span><span class="main">.</span> mediant <span class="main">(</span><span class="bound">lb</span><span class="main">,</span> <span class="bound">ub</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">lb</span><span class="main">,</span> <span class="bound">ub</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">lb</span><span class="main">,</span> mediant <span class="main">(</span><span class="bound">lb</span><span class="main">,</span> <span class="bound">ub</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">lb</span><span class="main">,</span> <span class="bound">ub</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>mediant <span class="main">(</span><span class="bound">lb</span><span class="main">,</span> <span class="bound">ub</span><span class="main">)</span><span class="main">,</span> <span class="bound">ub</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
  This process is visualised in Figure~\ref{fig:stern-brocot-iterate}.
  Intuitively each node is labelled with the mediant of it's rightmost and leftmost ancestors.

  \begin{figure}
    \centering
    \begin{tikzpicture}[auto,thick,node distance=3cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
      \node[main node] (0) at (0, 0) {$\frac{1}{1}$};
      \node[main node] (1) at (-4, 1) {$\frac{0}{1}$};
      \node[main node] (2) at (4, 1) {$\frac{1}{0}$};
      \node[main node] (3) at (-2, -1) {$\frac{1}{2}$};
      \node[main node] (4) at (2, -1) {$\frac{2}{1}$};
      \node[main node] (5) at (-3, -2) {$\frac{1}{3}$};
      \node[main node] (6) at (3, -2) {$\frac{3}{1}$};
      \node[main node] (7) at (-1, -2) {$\frac{2}{3}$};
      \node[main node] (8) at (1, -2) {$\frac{3}{2}$};
      \node (9) at (-3.5, -3) {};
      \node (10) at (-2.5, -3) {};
      \node (11) at (-1.5, -3) {};
      \node (12) at (-0.5, -3) {};
      \node (13) at (0.5, -3) {};
      \node (14) at (1.5, -3) {};
      \node (15) at (2.5, -3) {};
      \node (16) at (3.5, -3) {};
      \path
        (1) edge[dashed] (0)
        (2) edge[dashed] (0)
        (0) edge (3)
        (0) edge (4)
        (3) edge (5)
        (3) edge (7)
        (4) edge (6)
        (4) edge (8)
        (5) edge[dotted] (9)
        (5) edge[dotted] (10)
        (6) edge[dotted] (15)
        (6) edge[dotted] (16)
        (7) edge[dotted] (11)
        (7) edge[dotted] (12)
        (8) edge[dotted] (13)
        (8) edge[dotted] (14);
    \end{tikzpicture}
    \label{fig:stern-brocot-iterate}
    \caption{Constructing the Stern-Brocot tree iteratively.}
  \end{figure}
  
  Our ultimate goal is to show that the Stern-Brocot tree contains all rationals (in lowest terms),
  and that each occurs exactly once in the tree. A proof is sketched in \citet[\S4.5]{GrahamKnuthPatashnik1994CM}.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Specification via a recursion equation›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \cite{Hinze2009JFP} derives the following recurrence relation for the Stern-Brocot tree. 
  We will show in \S\ref{section:eq:rec:iterative} that his derivation is sound with respect to the
  standard iterative definition of the tree shown above.
›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">succ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"fraction <span class="main">⇒</span> fraction"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">succ</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">m</span> <span class="main">+</span> <span class="bound">n</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">recip</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"fraction <span class="main">⇒</span> fraction"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">recip</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">corec</span></span> <span class="entity">stern_brocot_recurse</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"fraction tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">stern_brocot_recurse</span> <span class="main">=</span>
   Node <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span>
     <span class="main">(</span>map_tree recip <span class="main">(</span>map_tree succ <span class="main">(</span>map_tree recip <span class="free">stern_brocot_recurse</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
     <span class="main">(</span>map_tree succ <span class="free">stern_brocot_recurse</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Actually, we would like to write the specification below, but <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(⋄)›</span></span></span></span> cannot be registered as friendly due to varying type parameters›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> stern_brocot_unfold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"stern_brocot_recurse <span class="main">=</span>
   Node <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span>
        <span class="main">(</span>pure recip <span class="main">⋄</span> <span class="main">(</span>pure succ <span class="main">⋄</span> <span class="main">(</span>pure recip <span class="main">⋄</span> stern_brocot_recurse<span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="main">(</span>pure succ <span class="main">⋄</span> stern_brocot_recurse<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> stern_brocot_recurse.code<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> map_tree_ap_tree_pure_tree<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stern_brocot_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root stern_brocot_recurse <span class="main">=</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"left stern_brocot_recurse <span class="main">=</span> pure recip <span class="main">⋄</span> <span class="main">(</span>pure succ <span class="main">⋄</span> <span class="main">(</span>pure recip <span class="main">⋄</span> stern_brocot_recurse<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"right stern_brocot_recurse <span class="main">=</span> pure succ <span class="main">⋄</span> stern_brocot_recurse"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> stern_brocot_unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stern_brocot_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"stern_brocot_recurse <span class="main">=</span> tree_recurse <span class="main">(</span>recip <span class="main">∘</span> succ <span class="main">∘</span> recip<span class="main">)</span> succ <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> tree_recurse.unique<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> stern_brocot_unfold<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_assoc<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> conjI<span class="main"><span class="keyword3">;</span></span> <span class="operator">applicative_nf</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic properties›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The recursive definition is useful for showing some basic properties of the tree, 
  such as that the pairs of numbers at each node are coprime, and have non-zero denominators.
  Both are simple inductions on the path.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stern_brocot_denominator_non_zero<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> root <span class="main">(</span>traverse_tree <span class="free">path</span> stern_brocot_recurse<span class="main">)</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">m</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">∧</span> <span class="bound">n</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">path</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stern_brocot_coprime<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> root <span class="main">(</span>traverse_tree <span class="free">path</span> stern_brocot_recurse<span class="main">)</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span> <span class="main">⇒</span> coprime <span class="bound">m</span> <span class="bound">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">path</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coprime_iff_gcd_eq_1<span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> gcd.commute gcd_add1<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹All the rationals›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
  For every pair of positive naturals, we can construct a path into the Stern-Brocot tree such that the naturals at the end of the path define the same rational as the pair we started with.
  Intuitively, the choices made by Euclid's algorithm define this path.
›</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">mk_path</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> path"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">⟹</span> <span class="free">mk_path</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">⟹</span> <span class="free">mk_path</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> L <span class="main">#</span> <span class="free">mk_path</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">&gt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">⟹</span> <span class="free">mk_path</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> R <span class="main">#</span> <span class="free">mk_path</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">mk_path</span> <span class="main">0</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> undefined"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">mk_path</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">0</span> <span class="main">=</span> undefined"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">atomize_elim</span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">arith</span><span class="main">)</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="quoted">mk_path</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword1"><span class="command">lemmas</span></span> mk_path_induct<span class="main">[</span><span class="operator">case_names</span> equal less greater<span class="main">]</span> <span class="main">=</span> mk_path.induct

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">rat_of</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"fraction <span class="main">⇒</span> rat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rat_of</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> Fract <span class="main">(</span>int <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>int <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> stern_brocot_rationals<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">m</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">;</span> <span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟧</span> <span class="main">⟹</span>
  root <span class="main">(</span>traverse_tree <span class="main">(</span>mk_path <span class="free">m</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>pure rat_of <span class="main">⋄</span> stern_brocot_recurse<span class="main">)</span><span class="main">)</span> <span class="main">=</span> Fract <span class="main">(</span>int <span class="free">m</span><span class="main">)</span> <span class="main">(</span>int <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> mk_path_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>less <span class="skolem">m</span> <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> stern_brocot_denominator_non_zero<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"mk_path <span class="main">(</span>Suc <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span><span class="skolem">n</span> <span class="main">-</span> <span class="skolem">m</span><span class="main">)</span>"</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_rat <span class="dynamic"><span class="dynamic">field_simps</span></span> of_nat_diff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>greater <span class="skolem">m</span> <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> stern_brocot_denominator_non_zero<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"mk_path <span class="main">(</span><span class="skolem">m</span> <span class="main">-</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>"</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_rat <span class="dynamic"><span class="dynamic">field_simps</span></span> of_nat_diff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_rat<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹No repetitions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We establish that the Stern-Brocot tree does not contain repetitions, i.e.,
  that each rational number appears at most once in it.
  Note that this property is stronger than merely requiring that pairs of naturals not be repeated,
  though it is implied by that property and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] "stern_brocot_coprime"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  
  Intuitively, the tree enjoys the \emph{binary search tree} ordering property when we map our
  pairs of naturals into rationals. This suffices to show that each rational appears at most once
  in the tree. To establish this seems to require more structure than is present in the recursion
  equations, and so we follow \citet{BackhouseFerreira2008MPC} and \citet{Hinze2009JFP} by
  introducing another definition of the tree, which summarises the path to each node using a matrix.

  We then derive an iterative version and use invariant reasoning on that.
  We begin by defining some matrix machinery.
  This is all elementary and primitive (we do not need much algebra).
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> matrix <span class="main">=</span> <span class="quoted"><span class="quoted">"fraction <span class="main">×</span> fraction"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> vector <span class="main">=</span> <span class="quoted">fraction</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">times_matrix</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"matrix <span class="main">⇒</span> matrix <span class="main">⇒</span> matrix"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⊗</span>"</span> 70<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">times_matrix</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="bound">a'</span><span class="main">,</span> <span class="bound">c'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="bound">d'</span><span class="main">)</span><span class="main">)</span><span class="main">.</span>
       <span class="main">(</span><span class="main">(</span><span class="bound">a</span> <span class="main">*</span> <span class="bound">a'</span> <span class="main">+</span> <span class="bound">b</span> <span class="main">*</span> <span class="bound">c'</span><span class="main">,</span> <span class="bound">c</span> <span class="main">*</span> <span class="bound">a'</span> <span class="main">+</span> <span class="bound">d</span> <span class="main">*</span> <span class="bound">c'</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="bound">a</span> <span class="main">*</span> <span class="bound">b'</span> <span class="main">+</span> <span class="bound">b</span> <span class="main">*</span> <span class="bound">d'</span><span class="main">,</span> <span class="bound">c</span> <span class="main">*</span> <span class="bound">b'</span> <span class="main">+</span> <span class="bound">d</span> <span class="main">*</span> <span class="bound">d'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">times_vector</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"matrix <span class="main">⇒</span> vector <span class="main">⇒</span> vector"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">⊙</span>"</span> 70<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">times_vector</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="bound">a'</span><span class="main">,</span> <span class="bound">c'</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span> <span class="main">*</span> <span class="bound">a'</span> <span class="main">+</span> <span class="bound">b</span> <span class="main">*</span> <span class="bound">c'</span><span class="main">,</span> <span class="bound">c</span> <span class="main">*</span> <span class="bound">a'</span> <span class="main">+</span> <span class="bound">d</span> <span class="main">*</span> <span class="bound">c'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">F</span> <span class="main">::</span> <span class="quoted">matrix</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">I</span> <span class="main">::</span> <span class="quoted">matrix</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">LL</span> <span class="main">::</span> <span class="quoted">matrix</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">LL</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">UR</span> <span class="main">::</span> <span class="quoted">matrix</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">UR</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Det</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"matrix <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Det</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">*</span> <span class="bound">d</span> <span class="main">-</span> <span class="bound">b</span> <span class="main">*</span> <span class="bound">c</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Dets <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Det I <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="quoted"><span class="quoted">"Det LL <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="quoted"><span class="quoted">"Det UR <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Det_def I_def LL_def UR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> LL_UR_Det<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Det <span class="free">m</span> <span class="main">=</span> <span class="main">1</span> <span class="main">⟹</span> Det <span class="main">(</span><span class="free">m</span> <span class="main">⊗</span> LL<span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="quoted"><span class="quoted">"Det <span class="free">m</span> <span class="main">=</span> <span class="main">1</span> <span class="main">⟹</span> Det <span class="main">(</span>LL <span class="main">⊗</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="quoted"><span class="quoted">"Det <span class="free">m</span> <span class="main">=</span> <span class="main">1</span> <span class="main">⟹</span> Det <span class="main">(</span><span class="free">m</span> <span class="main">⊗</span> UR<span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="quoted"><span class="quoted">"Det <span class="free">m</span> <span class="main">=</span> <span class="main">1</span> <span class="main">⟹</span> Det <span class="main">(</span>UR <span class="main">⊗</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Det_def LL_def UR_def times_matrix_def split_def <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mediant_I_F <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mediant F <span class="main">=</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"mediant I <span class="main">=</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_def I_def mediant_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> times_matrix_I <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"I <span class="main">⊗</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊗</span> I <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> times_matrix_def I_def split_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> times_matrix_assoc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">⊗</span> <span class="free">y</span><span class="main">)</span> <span class="main">⊗</span> <span class="free">z</span> <span class="main">=</span> <span class="free">x</span> <span class="main">⊗</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊗</span> <span class="free">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> times_matrix_def <span class="dynamic"><span class="dynamic">field_simps</span></span> split_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> LL_UR_pos<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> snd <span class="main">(</span>mediant <span class="free">m</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">&lt;</span> snd <span class="main">(</span>mediant <span class="main">(</span><span class="free">m</span> <span class="main">⊗</span> LL<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> snd <span class="main">(</span>mediant <span class="free">m</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">&lt;</span> snd <span class="main">(</span>mediant <span class="main">(</span><span class="free">m</span> <span class="main">⊗</span> UR<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LL_def UR_def times_matrix_def split_def <span class="dynamic"><span class="dynamic">field_simps</span></span> mediant_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> recip_succ_recip<span class="main">:</span> <span class="quoted"><span class="quoted">"recip <span class="main">∘</span> succ <span class="main">∘</span> recip <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">x</span> <span class="main">+</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \citeauthor{BackhouseFerreira2008MPC} work with the identity matrix <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "I"<span class="antiquote"><span class="antiquote">}</span></span></span></span> at the root.
  This has the advantage that all relevant matrices have determinants of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">1</span></span> <span class="main"><span class="main">::</span></span> nat"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stern_brocot_iterate_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"matrix <span class="main">⇒</span> matrix tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">stern_brocot_iterate_aux</span> <span class="main">≡</span> tree_iterate <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">⊗</span> LL<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">⊗</span> UR<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stern_brocot_iterate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"fraction tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">stern_brocot_iterate</span> <span class="main">≡</span> map_tree mediant <span class="main">(</span>stern_brocot_iterate_aux I<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stern_brocot_recurse_iterate<span class="main">:</span> <span class="quoted"><span class="quoted">"stern_brocot_recurse <span class="main">=</span> stern_brocot_iterate"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">=</span> map_tree mediant <span class="main">(</span>tree_recurse <span class="main">(</span><span class="main">(⊗)</span> LL<span class="main">)</span> <span class="main">(</span><span class="main">(⊗)</span> UR<span class="main">)</span> I<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tree_recurse_iterate<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(⊗)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> l<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"LL"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> r<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"UR"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> ε<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"I"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stern_brocot_iterate_def stern_brocot_iterate_aux_def<span class="main">)</span>
 <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> tree_recurse <span class="main">(</span><span class="main">(⊙)</span> LL<span class="main">)</span> <span class="main">(</span><span class="main">(⊙)</span> UR<span class="main">)</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command">unfolding</span></span> mediant_I_F<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tree_recurse_fusion<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff mediant_def times_matrix_def times_vector_def LL_def UR_def<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
 <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?lhs</span>"</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stern_brocot_conv recip_succ_recip times_vector_def LL_def UR_def<span class="main">)</span>
 <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
  The following are the key ordering properties derived by \citet{BackhouseFerreira2008MPC}.
  They hinge on the matrices containing only natural numbers.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> tree_ordering_left<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> DX<span class="main">:</span> <span class="quoted"><span class="quoted">"Det <span class="free">X</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> DY<span class="main">:</span> <span class="quoted"><span class="quoted">"Det <span class="free">Y</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> MX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> snd <span class="main">(</span>mediant <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rat_of <span class="main">(</span>mediant <span class="main">(</span><span class="free">X</span> <span class="main">⊗</span> LL <span class="main">⊗</span> <span class="free">Y</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> rat_of <span class="main">(</span>mediant <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> DX DY <span class="keyword1"><span class="command">have</span></span> F<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> snd <span class="main">(</span>mediant <span class="main">(</span><span class="free">X</span> <span class="main">⊗</span> LL <span class="main">⊗</span> <span class="free">Y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Det_def times_matrix_def LL_def split_def mediant_def<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x11</span></span> <span class="skolem"><span class="skolem">x12</span></span> <span class="skolem"><span class="skolem">x21</span></span> <span class="skolem"><span class="skolem">x22</span></span> <span class="keyword2"><span class="keyword">where</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="skolem">x11</span><span class="main">,</span> <span class="skolem">x12</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="skolem">x21</span><span class="main">,</span> <span class="skolem">x22</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">X</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y11</span></span> <span class="skolem"><span class="skolem">y12</span></span> <span class="skolem"><span class="skolem">y21</span></span> <span class="skolem"><span class="skolem">y22</span></span> <span class="keyword2"><span class="keyword">where</span></span> Y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="skolem">y11</span><span class="main">,</span> <span class="skolem">y12</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="skolem">y21</span><span class="main">,</span> <span class="skolem">y22</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Y</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> DX DY <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x12</span> <span class="main">*</span> <span class="skolem">x21</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">y12</span> <span class="main">+</span> <span class="skolem">y22</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">(</span><span class="skolem">x11</span> <span class="main">*</span> <span class="skolem">x22</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">y12</span> <span class="main">+</span> <span class="skolem">y22</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> X Y Det_def<span class="main">)</span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y12</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> DX DY MX F <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def X Y of_nat_mult <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> of_nat_mult<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Det_def times_matrix_def LL_def UR_def mediant_def split_def<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> tree_ordering_right<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> DX<span class="main">:</span> <span class="quoted"><span class="quoted">"Det <span class="free">X</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> DY<span class="main">:</span> <span class="quoted"><span class="quoted">"Det <span class="free">Y</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> MX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> snd <span class="main">(</span>mediant <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rat_of <span class="main">(</span>mediant <span class="free">X</span><span class="main">)</span> <span class="main">&lt;</span> rat_of <span class="main">(</span>mediant <span class="main">(</span><span class="free">X</span> <span class="main">⊗</span> UR <span class="main">⊗</span> <span class="free">Y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> DX DY <span class="keyword1"><span class="command">have</span></span> F<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> snd <span class="main">(</span>mediant <span class="main">(</span><span class="free">X</span> <span class="main">⊗</span> UR <span class="main">⊗</span> <span class="free">Y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Det_def times_matrix_def UR_def split_def mediant_def<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x11</span></span> <span class="skolem"><span class="skolem">x12</span></span> <span class="skolem"><span class="skolem">x21</span></span> <span class="skolem"><span class="skolem">x22</span></span> <span class="keyword2"><span class="keyword">where</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="skolem">x11</span><span class="main">,</span> <span class="skolem">x12</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="skolem">x21</span><span class="main">,</span> <span class="skolem">x22</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">X</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y11</span></span> <span class="skolem"><span class="skolem">y12</span></span> <span class="skolem"><span class="skolem">y21</span></span> <span class="skolem"><span class="skolem">y22</span></span> <span class="keyword2"><span class="keyword">where</span></span> Y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="skolem">y11</span><span class="main">,</span> <span class="skolem">y12</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="skolem">y21</span><span class="main">,</span> <span class="skolem">y22</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Y</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> DX DY MX F
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> X Y split_def of_nat_mult <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> of_nat_mult<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Det_def times_matrix_def LL_def UR_def mediant_def split_def <span class="dynamic"><span class="dynamic">algebra_simps</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add_mult_distrib2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> mult.assoc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y21</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stern_brocot_iterate_aux_Det<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Det <span class="free">m</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> snd <span class="main">(</span>mediant <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Det <span class="main">(</span>root <span class="main">(</span>traverse_tree <span class="free">path</span> <span class="main">(</span>stern_brocot_iterate_aux <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> snd <span class="main">(</span>mediant <span class="main">(</span>root <span class="main">(</span>traverse_tree <span class="free">path</span> <span class="main">(</span>stern_brocot_iterate_aux <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">path</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span>
   <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stern_brocot_iterate_aux_def LL_UR_Det LL_UR_pos <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stern_brocot_iterate_aux_decompose<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">m''</span><span class="main">.</span> <span class="free">m</span> <span class="main">⊗</span> <span class="bound">m''</span> <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="free">path</span> <span class="main">(</span>stern_brocot_iterate_aux <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> Det <span class="bound">m''</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">path</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stern_brocot_iterate_aux_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">I</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> split_paired_Ex<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">d</span> <span class="skolem">ds</span> <span class="skolem">m</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Cons.IH<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">⊗</span> UR"</span></span><span class="main">]</span> Cons.IH<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">⊗</span> LL"</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stern_brocot_iterate_aux_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> split_paired_Ex<span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> LL_UR_Det<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stern_brocot_fractions_not_repeated_strict_prefix<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"root <span class="main">(</span>traverse_tree <span class="free">path</span> stern_brocot_iterate<span class="main">)</span> <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="free">path'</span> stern_brocot_iterate<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> pp'<span class="main">:</span> <span class="quoted"><span class="quoted">"strict_prefix <span class="free">path</span> <span class="free">path'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted">False</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> pp' <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">d</span></span> <span class="skolem"><span class="skolem">ds</span></span> <span class="keyword2"><span class="keyword">where</span></span> pp'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">path'</span> <span class="main">=</span> <span class="free">path</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">d</span><span class="main">]</span> <span class="main">@</span> <span class="skolem">ds</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> strict_prefixE'<span class="main">)</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="free">path</span> <span class="main">(</span>stern_brocot_iterate_aux I<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> Dm<span class="main">:</span> <span class="quoted"><span class="quoted">"Det <span class="skolem">m</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> Pm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> snd <span class="main">(</span>mediant <span class="skolem">m</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stern_brocot_iterate_aux_Det<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">path</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"I"</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">m'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m'</span> <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="free">path'</span> <span class="main">(</span>stern_brocot_iterate_aux I<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> Dm'<span class="main">:</span> <span class="quoted"><span class="quoted">"Det <span class="skolem">m'</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stern_brocot_iterate_aux_Det<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">path'</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"I"</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?M</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="skolem">d</span> <span class="keyword1">of</span> L <span class="main">⇒</span> <span class="skolem">m</span> <span class="main">⊗</span> LL <span class="main">|</span> R <span class="main">⇒</span> <span class="skolem">m</span> <span class="main">⊗</span> UR"</span></span>
  <span class="keyword1"><span class="command">from</span></span> pp' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"root <span class="main">(</span>traverse_tree <span class="skolem">ds</span> <span class="main">(</span>stern_brocot_iterate_aux <span class="var">?M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> m_def m'_def stern_brocot_iterate_aux_def traverse_tree_tree_iterate <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m''</span></span> <span class="keyword2"><span class="keyword">where</span></span> mm'm''<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?M</span> <span class="main">⊗</span> <span class="skolem">m''</span><span class="main">=</span> <span class="skolem">m'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> Dm''<span class="main">:</span> <span class="quoted"><span class="quoted">"Det <span class="skolem">m''</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stern_brocot_iterate_aux_decompose<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">ds</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="var">?M</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="skolem">d</span> <span class="keyword1">of</span> L <span class="main">⇒</span> rat_of <span class="main">(</span>mediant <span class="skolem">m'</span><span class="main">)</span> <span class="main">&lt;</span> rat_of <span class="main">(</span>mediant <span class="skolem">m</span><span class="main">)</span> <span class="main">|</span> R <span class="main">⇒</span> rat_of <span class="main">(</span>mediant <span class="skolem">m</span><span class="main">)</span> <span class="main">&lt;</span> rat_of <span class="main">(</span>mediant <span class="skolem">m'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tree_ordering_left<span class="main">[</span><span class="operator">OF</span> Dm Dm'' Pm<span class="main">]</span> tree_ordering_right<span class="main">[</span><span class="operator">OF</span> Dm Dm'' Pm<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stern_brocot_iterate_def m_def m'_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stern_brocot_fractions_not_repeated_parallel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"root <span class="main">(</span>traverse_tree <span class="free">path</span> stern_brocot_iterate<span class="main">)</span> <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="free">path'</span> stern_brocot_iterate<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">path</span> <span class="main">=</span> <span class="free">pref</span> <span class="main">@</span> <span class="free">d</span> <span class="main">#</span> <span class="free">ds</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> p'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">path'</span> <span class="main">=</span> <span class="free">pref</span> <span class="main">@</span> <span class="free">d'</span> <span class="main">#</span> <span class="free">ds'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> dd'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">≠</span> <span class="free">d'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted">False</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="free">pref</span> <span class="main">(</span>stern_brocot_iterate_aux I<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> Dm<span class="main">:</span> <span class="quoted"><span class="quoted">"Det <span class="skolem">m</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> Pm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> snd <span class="main">(</span>mediant <span class="skolem">m</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stern_brocot_iterate_aux_Det<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">pref</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"I"</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">pm</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">pm</span> <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="free">path</span> <span class="main">(</span>stern_brocot_iterate_aux I<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> Dpm<span class="main">:</span> <span class="quoted"><span class="quoted">"Det <span class="skolem">pm</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stern_brocot_iterate_aux_Det<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">path</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"I"</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?M</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="free">d</span> <span class="keyword1">of</span> L <span class="main">⇒</span> <span class="skolem">m</span> <span class="main">⊗</span> LL <span class="main">|</span> R <span class="main">⇒</span> <span class="skolem">m</span> <span class="main">⊗</span> UR"</span></span>
  <span class="keyword1"><span class="command">from</span></span> p
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"root <span class="main">(</span>traverse_tree <span class="free">ds</span> <span class="main">(</span>stern_brocot_iterate_aux <span class="var">?M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">pm</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stern_brocot_iterate_aux_def m_def pm_def traverse_tree_tree_iterate <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pm'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> pm'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?M</span> <span class="main">⊗</span> <span class="skolem">pm'</span><span class="main">=</span> <span class="skolem">pm</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> Dpm'<span class="main">:</span> <span class="quoted"><span class="quoted">"Det <span class="skolem">pm'</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stern_brocot_iterate_aux_decompose<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">ds</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="var">?M</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="free">d</span> <span class="keyword1">of</span> L <span class="main">⇒</span> rat_of <span class="main">(</span>mediant <span class="skolem">pm</span><span class="main">)</span> <span class="main">&lt;</span> rat_of <span class="main">(</span>mediant <span class="skolem">m</span><span class="main">)</span> <span class="main">|</span> R <span class="main">⇒</span> rat_of <span class="main">(</span>mediant <span class="skolem">m</span><span class="main">)</span> <span class="main">&lt;</span> rat_of <span class="main">(</span>mediant <span class="skolem">pm</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tree_ordering_left<span class="main">[</span><span class="operator">OF</span> Dm Dpm' Pm<span class="main">,</span> <span class="operator">unfolded</span> pm'<span class="main">]</span>
          tree_ordering_right<span class="main">[</span><span class="operator">OF</span> Dm Dpm' Pm<span class="main">,</span> <span class="operator">unfolded</span> pm'<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">p'm</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p'm</span> <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="free">path'</span> <span class="main">(</span>stern_brocot_iterate_aux I<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> Dp'm<span class="main">:</span> <span class="quoted"><span class="quoted">"Det <span class="skolem">p'm</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stern_brocot_iterate_aux_Det<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">path'</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"I"</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?M'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="free">d'</span> <span class="keyword1">of</span> L <span class="main">⇒</span> <span class="skolem">m</span> <span class="main">⊗</span> LL <span class="main">|</span> R <span class="main">⇒</span> <span class="skolem">m</span> <span class="main">⊗</span> UR"</span></span>
  <span class="keyword1"><span class="command">from</span></span> p'
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"root <span class="main">(</span>traverse_tree <span class="free">ds'</span> <span class="main">(</span>stern_brocot_iterate_aux <span class="var">?M'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">p'm</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stern_brocot_iterate_aux_def m_def p'm_def traverse_tree_tree_iterate <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p'm'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> p'm'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?M'</span> <span class="main">⊗</span> <span class="skolem">p'm'</span> <span class="main">=</span> <span class="skolem">p'm</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> Dp'm'<span class="main">:</span> <span class="quoted"><span class="quoted">"Det <span class="skolem">p'm'</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stern_brocot_iterate_aux_decompose<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">ds'</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="var">?M'</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="free">d'</span> <span class="keyword1">of</span> L <span class="main">⇒</span> rat_of <span class="main">(</span>mediant <span class="skolem">p'm</span><span class="main">)</span> <span class="main">&lt;</span> rat_of <span class="main">(</span>mediant <span class="skolem">m</span><span class="main">)</span> <span class="main">|</span> R <span class="main">⇒</span> rat_of <span class="main">(</span>mediant <span class="skolem">m</span><span class="main">)</span> <span class="main">&lt;</span> rat_of <span class="main">(</span>mediant <span class="skolem">p'm</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tree_ordering_left<span class="main">[</span><span class="operator">OF</span> Dm Dp'm' Pm<span class="main">,</span> <span class="operator">unfolded</span> pm'<span class="main">]</span>
          tree_ordering_right<span class="main">[</span><span class="operator">OF</span> Dm Dp'm' Pm<span class="main">,</span> <span class="operator">unfolded</span> pm'<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> pm' p'm' assms
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> m_def pm_def p'm_def stern_brocot_iterate_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lists_not_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span>
    <span class="main">(</span>c1<span class="main">)</span> <span class="quoted"><span class="quoted">"strict_prefix <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>c2<span class="main">)</span> <span class="quoted"><span class="quoted">"strict_prefix <span class="free">ys</span> <span class="free">xs</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>c3<span class="main">)</span> <span class="free">ps</span> <span class="free">x</span> <span class="free">y</span> <span class="free">xs'</span> <span class="free">ys'</span>
          <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ps</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">xs'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="free">ps</span> <span class="main">@</span> <span class="free">y</span> <span class="main">#</span> <span class="free">ys'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> prefix_cases<span class="main">)</span>
   <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> parallel_decomp prefix_order.neq_le_trans<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stern_brocot_fractions_not_repeated<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"root <span class="main">(</span>traverse_tree <span class="free">path</span> stern_brocot_iterate<span class="main">)</span> <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="free">path'</span> stern_brocot_iterate<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">path</span> <span class="main">=</span> <span class="free">path'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">path</span> <span class="main">≠</span> <span class="free">path'</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">path</span></span> <span class="quoted"><span class="free">path'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lists_not_eq<span class="main">)</span>
       <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> stern_brocot_fractions_not_repeated_strict_prefix sym
                     stern_brocot_fractions_not_repeated_parallel<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ The function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Fract<span class="antiquote"><span class="antiquote">}</span></span></span></span> is injective under certain conditions. ›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rat_inv_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Fract <span class="free">a</span> <span class="free">b</span> <span class="main">=</span> Fract <span class="free">c</span> <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"coprime <span class="free">a</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"coprime <span class="free">c</span> <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">c</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">=</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">b</span> <span class="main">&gt;</span> <span class="main">0</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">d</span> <span class="main">&gt;</span> <span class="main">0</span>›</span></span> <span class="quoted"><span class="quoted">‹Fract <span class="free">a</span> <span class="free">b</span> <span class="main">=</span> Fract <span class="free">c</span> <span class="free">d</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">*</span> <span class="free">d</span> <span class="main">=</span> <span class="free">c</span> <span class="main">*</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_rat<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> arg_cong<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted">sgn</span><span class="main">,</span> <span class="operator">OF</span> this<span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">b</span> <span class="main">&gt;</span> <span class="main">0</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">d</span> <span class="main">&gt;</span> <span class="main">0</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sgn <span class="free">a</span> <span class="main">=</span> sgn <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sgn_mult<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">b</span> <span class="main">&gt;</span> <span class="main">0</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">d</span> <span class="main">&gt;</span> <span class="main">0</span>›</span></span> coprime_crossproduct_int<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹coprime <span class="free">a</span> <span class="free">b</span>›</span></span> <span class="quoted"><span class="quoted">‹coprime <span class="free">c</span> <span class="free">d</span>›</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_sgn<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> stern_brocot_rationals_not_repeated<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"root <span class="main">(</span>traverse_tree <span class="free">path</span> <span class="main">(</span>pure rat_of <span class="main">⋄</span> stern_brocot_recurse<span class="main">)</span><span class="main">)</span>
         <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="free">path'</span> <span class="main">(</span>pure rat_of <span class="main">⋄</span> stern_brocot_recurse<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">path</span> <span class="main">=</span> <span class="free">path'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">using</span></span> stern_brocot_coprime<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">path</span></span><span class="main">]</span>
      stern_brocot_coprime<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">path'</span></span><span class="main">]</span>
      stern_brocot_denominator_non_zero<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">path</span></span><span class="main">]</span>
      stern_brocot_denominator_non_zero<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">path'</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gcd_int_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rat_inv_eq <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> stern_brocot_fractions_not_repeated <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stern_brocot_recurse_iterate<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Equivalence of recursive and iterative version \label{section:eq:rec:iterative}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \citeauthor{Hinze2009JFP} shows that it does not matter whether we use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> I<span class="antiquote"><span class="antiquote">}</span></span></span></span> or
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "F"<span class="antiquote"><span class="antiquote">}</span></span></span></span> at the root provided we swap the left and right matrices too.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stern_brocot_Hinze_iterate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"fraction tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">stern_brocot_Hinze_iterate</span> <span class="main">=</span> map_tree mediant <span class="main">(</span>tree_iterate <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">⊗</span> UR<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">⊗</span> LL<span class="main">)</span> F<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mediant_times_F<span class="main">:</span> <span class="quoted"><span class="quoted">"mediant <span class="main">∘</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">⊗</span> F<span class="main">)</span> <span class="main">=</span> mediant"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> times_matrix_def F_def mediant_def split_def o_def add.commute<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stern_brocot_iterate<span class="main">:</span> <span class="quoted"><span class="quoted">"stern_brocot <span class="main">=</span> stern_brocot_iterate"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"stern_brocot <span class="main">=</span> stern_brocot_Hinze_iterate"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> stern_brocot_def stern_brocot_Hinze_iterate_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> unfold_tree_tree_iterate<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_def times_matrix_def mediant_def UR_def LL_def split_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map_tree mediant <span class="main">(</span>map_tree <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">⊗</span> F<span class="main">)</span> <span class="main">(</span>tree_iterate <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">⊗</span> LL<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">⊗</span> UR<span class="main">)</span> I<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> stern_brocot_Hinze_iterate_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> tree_iterate_fusion<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> l'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">s</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="bound"><span class="bound"><span class="bound">s</span></span></span> <span class="main"><span class="main"><span class="main">⊗</span></span></span> UR"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> r'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">s</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="bound"><span class="bound"><span class="bound">s</span></span></span> <span class="main"><span class="main"><span class="main">⊗</span></span></span> LL"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff times_matrix_def UR_def LL_def F_def I_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> stern_brocot_iterate"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> tree.map_comp mediant_times_F stern_brocot_iterate_def stern_brocot_iterate_aux_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> stern_brocot_mediant_recurse<span class="main">:</span> <span class="quoted"><span class="quoted">"stern_brocot <span class="main">=</span> stern_brocot_recurse"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stern_brocot_recurse_iterate stern_brocot_iterate<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> times_matrix <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⊗</span>"</span> 70<span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> times_vector <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⊙</span>"</span> 70<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Linearising the Stern-Brocot Tree›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Turning a tree into a stream›</span></span>

<span class="keyword1"><span class="command">corec</span></span> <span class="entity">tree_chop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">tree_chop</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> Node <span class="main">(</span>root <span class="main">(</span>left <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>right <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">tree_chop</span> <span class="main">(</span>left <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> tree_chop_sel <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root <span class="main">(</span>tree_chop <span class="free">t</span><span class="main">)</span> <span class="main">=</span> root <span class="main">(</span>left <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"left <span class="main">(</span>tree_chop <span class="free">t</span><span class="main">)</span> <span class="main">=</span> right <span class="free">t</span>"</span></span>
  <span class="quoted"><span class="quoted">"right <span class="main">(</span>tree_chop <span class="free">t</span><span class="main">)</span> <span class="main">=</span> tree_chop <span class="main">(</span>left <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> tree_chop.code<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> tree_chop<span class="antiquote"><span class="antiquote">}</span></span></span></span> is a idiom homomorphism›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> tree_chop_pure_tree <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tree_chop <span class="main">(</span>pure <span class="free">x</span><span class="main">)</span> <span class="main">=</span> pure <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tree.coinduct_strong<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> tree_chop_ap_tree <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tree_chop <span class="main">(</span><span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> tree_chop <span class="free">f</span> <span class="main">⋄</span> tree_chop <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tree.coinduct_strong<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> tree_chop_plus<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_chop <span class="main">(</span><span class="free">t</span> <span class="main">+</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> tree_chop <span class="free">t</span> <span class="main">+</span> tree_chop <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> plus_tree_def<span class="main">)</span>

<span class="keyword1"><span class="command">corec</span></span> <span class="entity">stream</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> stream"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">stream</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> root <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">##</span> <span class="free">stream</span> <span class="main">(</span>tree_chop <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stream_sel <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"shd <span class="main">(</span>stream <span class="free">t</span><span class="main">)</span> <span class="main">=</span> root <span class="free">t</span>"</span></span>
  <span class="quoted"><span class="quoted">"stl <span class="main">(</span>stream <span class="free">t</span><span class="main">)</span> <span class="main">=</span> stream <span class="main">(</span>tree_chop <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> stream.code<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "stream"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is an idiom homomorphism.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stream_pure <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stream <span class="main">(</span>pure <span class="free">x</span><span class="main">)</span> <span class="main">=</span> pure <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">coinduction</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> stream_ap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stream <span class="main">(</span><span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> stream <span class="free">f</span> <span class="main">⋄</span> stream <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> stream_plus <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stream <span class="main">(</span><span class="free">t</span> <span class="main">+</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> stream <span class="free">t</span> <span class="main">+</span> stream <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> plus_stream_def plus_tree_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stream_minus <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stream <span class="main">(</span><span class="free">t</span> <span class="main">-</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> stream <span class="free">t</span> <span class="main">-</span> stream <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> minus_stream_def minus_tree_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stream_times <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stream <span class="main">(</span><span class="free">t</span> <span class="main">*</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> stream <span class="free">t</span> <span class="main">*</span> stream <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> times_stream_def times_tree_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stream_mod <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stream <span class="main">(</span><span class="free">t</span> <span class="keyword1">mod</span> <span class="free">t'</span><span class="main">)</span> <span class="main">=</span> stream <span class="free">t</span> <span class="keyword1">mod</span> stream <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> modulo_stream_def modulo_tree_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stream_1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stream <span class="main">1</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_tree_def one_stream_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stream_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stream <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> numeral.simps stream_plus stream_1<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Split the Stern-Brocot tree into numerators and denumerators›</span></span>

<span class="keyword1"><span class="command">corec</span></span> <span class="entity">num_den</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> nat tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">num_den</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span>
   Node <span class="main">1</span>
     <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="free">num_den</span> True <span class="keyword1">else</span> <span class="free">num_den</span> True <span class="main">+</span> <span class="free">num_den</span> False<span class="main">)</span>
     <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="free">num_den</span> True <span class="main">+</span> <span class="free">num_den</span> False <span class="keyword1">else</span> <span class="free">num_den</span> False<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">num</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">num</span> <span class="main">≡</span> num_den True"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">den</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">den</span> <span class="main">≡</span> num_den False"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> num_unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"num <span class="main">=</span> Node <span class="main">1</span> num <span class="main">(</span>num <span class="main">+</span> den<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> num_den.code<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> den_unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"den <span class="main">=</span> Node <span class="main">1</span> <span class="main">(</span>num <span class="main">+</span> den<span class="main">)</span> den"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> num_den.code<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> num_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root num <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="quoted"><span class="quoted">"left num <span class="main">=</span> num"</span></span>
  <span class="quoted"><span class="quoted">"right num <span class="main">=</span> num <span class="main">+</span> den"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> num_unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> den_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root den <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="quoted"><span class="quoted">"left den <span class="main">=</span> num <span class="main">+</span> den"</span></span>
  <span class="quoted"><span class="quoted">"right den <span class="main">=</span> den"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> den_unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stern_brocot_num_den<span class="main">:</span>
  <span class="quoted"><span class="quoted">"pure_tree Pair <span class="main">⋄</span> num <span class="main">⋄</span> den <span class="main">=</span> stern_brocot_recurse"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> stern_brocot_recurse.unique<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> den_unfold<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> num_unfold<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> conjI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> den_eq_chop_num<span class="main">:</span> <span class="quoted"><span class="quoted">"den <span class="main">=</span> tree_chop num"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tree.coinduct_strong<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> num_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"num <span class="main">=</span> pure fst <span class="main">⋄</span> stern_brocot_recurse"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> stern_brocot_num_den<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_tree_ap_tree_pure_tree stern_brocot_num_den<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> den_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"den <span class="main">=</span> pure snd <span class="main">⋄</span> stern_brocot_recurse"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> stern_brocot_num_den<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_tree_ap_tree_pure_tree stern_brocot_num_den<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">corec</span></span> <span class="entity">num_mod_den</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">num_mod_den</span> <span class="main">=</span> Node <span class="main">0</span> num <span class="free">num_mod_den</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> num_mod_den_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root num_mod_den <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"left num_mod_den <span class="main">=</span> num"</span></span>
  <span class="quoted"><span class="quoted">"right num_mod_den <span class="main">=</span> num_mod_den"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> num_mod_den.code<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
  The arithmetic transformations need the precondition that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> den<span class="antiquote"><span class="antiquote">}</span></span></span></span> contains only
  positive numbers, no <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">0</span></span> <span class="main"><span class="main">::</span></span> nat"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. \citet[p502]{Hinze2009JFP} gets a bit sloppy here; it is
  not straightforward to adapt his lifting framework \cite{Hinze2010Lifting} to conditional equations.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mod_tree_lemma1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat tree"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>set_tree <span class="free">y</span><span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="bound">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">mod</span> <span class="main">(</span><span class="free">x</span> <span class="main">+</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rel_tree <span class="main">(=)</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">mod</span> <span class="main">(</span><span class="free">x</span> <span class="main">+</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold</span> tree.rel_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mod_tree_lemma2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="free">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> unique_euclidean_semiring tree"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">+</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> set_tree_pathD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set_tree <span class="free">t</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="bound">p</span> <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> set_tree_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main"><span class="main">]</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"L <span class="main">#</span> <span class="skolem">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">p</span><span class="main"><span class="main">]</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"R <span class="main">#</span> <span class="skolem">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">p</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> den_gt_0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set_tree den"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> that <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="skolem">p</span> den<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_tree_pathD<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> stern_brocot_denominator_non_zero<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">p</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> den_conv split_beta<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> num_mod_den<span class="main">:</span> <span class="quoted"><span class="quoted">"num <span class="keyword1">mod</span> den <span class="main">=</span> num_mod_den"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> num_mod_den.unique<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> tree.expand<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mod_tree_lemma2 mod_tree_lemma1 den_gt_0<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> tree_chop_den<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_chop den <span class="main">=</span> num <span class="main">+</span> den <span class="main">-</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>num <span class="keyword1">mod</span> den<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> le<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="skolem">y</span> <span class="main">⟹</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">x</span> <span class="keyword1">mod</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">x</span> <span class="main">+</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mult_2 add_mono<span class="main">)</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We switch to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">int</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> such that all cancellation laws are available.›</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">den'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">den'</span> <span class="main">=</span> pure int <span class="main">⋄</span> den"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">num'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">num'</span> <span class="main">=</span> pure int <span class="main">⋄</span> num"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">num_mod_den'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">num_mod_den'</span> <span class="main">=</span> pure int <span class="main">⋄</span> num_mod_den"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"root <span class="skolem">num'</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="quoted"><span class="quoted">"left <span class="skolem">num'</span> <span class="main">=</span> <span class="skolem">num'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> den'_def num'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"right <span class="skolem">num'</span> <span class="main">=</span> <span class="skolem">num'</span> <span class="main">+</span> <span class="skolem">den'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> den'_def num'_def ap_tree.sel pure_tree_simps num_simps
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">have</span></span> num_mod_den'_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"root <span class="skolem">num_mod_den'</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"left <span class="skolem">num_mod_den'</span> <span class="main">=</span> <span class="skolem">num'</span>"</span></span> <span class="quoted"><span class="quoted">"right <span class="skolem">num_mod_den'</span> <span class="main">=</span> <span class="skolem">num_mod_den'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> num_mod_den'_def num'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> den'_eq_chop_num'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">den'</span> <span class="main">=</span> tree_chop <span class="skolem">num'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> den'_def num'_def den_eq_chop_num<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> num_mod_den'2_unique<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> Node <span class="main">0</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="skolem">num'</span><span class="main">)</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="skolem">num_mod_den'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">corec_unique</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> tree.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> num'_plus_den'_minus_chop_den'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">num'</span> <span class="main">+</span> <span class="skolem">den'</span> <span class="main">-</span> tree_chop <span class="skolem">den'</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="skolem">num_mod_den'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> num_mod_den'2_unique<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> tree.expand<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tree_chop_plus den'_eq_chop_num'<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tree_chop den <span class="main">=</span> pure nat <span class="main">⋄</span> <span class="main">(</span>tree_chop <span class="skolem">den'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> den_conv tree_chop_ap_tree tree_chop_pure_tree den'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tree_chop <span class="skolem">den'</span> <span class="main">=</span> <span class="skolem">num'</span> <span class="main">+</span> <span class="skolem">den'</span> <span class="main">-</span> tree_chop <span class="skolem">den'</span> <span class="main">+</span> tree_chop <span class="skolem">den'</span> <span class="main">-</span> <span class="numeral">2</span> <span class="main">*</span> <span class="skolem">num_mod_den'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> num'_plus_den'_minus_chop_den'<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="skolem">num'</span> <span class="main">+</span> <span class="skolem">den'</span> <span class="main">-</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">num'</span> <span class="keyword1">mod</span> <span class="skolem">den'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> num_mod_den'_def num'_def den'_def num_mod_den<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zmod_int<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">unfolded</span> tree.rel_eq<span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_tree <span class="main">(=)</span> <span class="main">…</span> <span class="main">(</span>pure int <span class="main">⋄</span> <span class="main">(</span>num <span class="main">+</span> den <span class="main">-</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>num <span class="keyword1">mod</span> den<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> num'_def den'_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">applicative_lifting</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> of_nat_diff zmod_int le den_gt_0<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pure nat <span class="main">⋄</span> <span class="main">(</span>pure int <span class="main">⋄</span> <span class="main">(</span>num <span class="main">+</span> den <span class="main">-</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>num <span class="keyword1">mod</span> den<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> num <span class="main">+</span> den <span class="main">-</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>num <span class="keyword1">mod</span> den<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">applicative_nf</span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Loopless linearisation of the Stern-Brocot tree.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This is a loopless linearisation of the Stern-Brocot tree that gives Stern's diatomic sequence,
  which is also known as Dijkstra's fusc function \cite{Dijkstra1982EWD570,Dijkstra1982EWD578}.
  Loopless \`a la \cite{Bird2006MPC} means that the first element of the stream can be computed in linear
  time and every further element in constant time.
›</span></span>

<span class="keyword1"><span class="command">friend_of_corec</span></span> smap <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> stream <span class="main">⇒</span> <span class="tfree">'a</span> stream"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"smap <span class="free">f</span> <span class="free">xs</span> <span class="main">=</span> SCons <span class="main">(</span><span class="free">f</span> <span class="main">(</span>shd <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>smap <span class="free">f</span> <span class="main">(</span>stl <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stream.expand<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fold</span> <span class="dynamic"><span class="dynamic">relator_eq</span></span><span class="main">)</span><span class="main">(</span><span class="operator">transfer_prover</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">step</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat <span class="main">⇒</span> nat <span class="main">×</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">step</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">d</span><span class="main">,</span> <span class="bound">n</span> <span class="main">+</span> <span class="bound">d</span> <span class="main">-</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="bound">n</span> <span class="keyword1">mod</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">corec</span></span> <span class="entity">stern_brocot_loopless</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"fraction stream"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">stern_brocot_loopless</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span> <span class="main">##</span> smap step <span class="free">stern_brocot_loopless</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> stern_brocot_loopless_rec <span class="main">=</span> stern_brocot_loopless.code

<span class="keyword1"><span class="command">friend_of_corec</span></span> plus <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">+</span> <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>shd <span class="free">s</span> <span class="main">+</span> shd <span class="free">s'</span><span class="main">)</span> <span class="main">##</span> <span class="main">(</span>stl <span class="free">s</span> <span class="main">+</span> stl <span class="free">s'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> stream.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> plus_stream_shd plus_stream_stl<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">friend_of_corec</span></span> minus <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">-</span> <span class="free">t'</span> <span class="main">=</span> <span class="main">(</span>shd <span class="free">t</span> <span class="main">-</span> shd <span class="free">t'</span><span class="main">)</span> <span class="main">##</span> <span class="main">(</span>stl <span class="free">t</span> <span class="main">-</span> stl <span class="free">t'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> stream.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> minus_stream_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">friend_of_corec</span></span> times <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">*</span> <span class="free">t'</span> <span class="main">=</span> <span class="main">(</span>shd <span class="free">t</span> <span class="main">*</span> shd <span class="free">t'</span><span class="main">)</span> <span class="main">##</span> <span class="main">(</span>stl <span class="free">t</span> <span class="main">*</span> stl <span class="free">t'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> stream.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> times_stream_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">friend_of_corec</span></span> modulo <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="keyword1">mod</span> <span class="free">t'</span> <span class="main">=</span> <span class="main">(</span>shd <span class="free">t</span> <span class="keyword1">mod</span> shd <span class="free">t'</span><span class="main">)</span> <span class="main">##</span> <span class="main">(</span>stl <span class="free">t</span> <span class="keyword1">mod</span> stl <span class="free">t'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> stream.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> modulo_stream_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">corec</span></span> <span class="entity">fusc'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat stream"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fusc'</span> <span class="main">=</span> <span class="main">1</span> <span class="main">##</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">1</span> <span class="main">##</span> <span class="free">fusc'</span><span class="main">)</span> <span class="main">+</span> <span class="free">fusc'</span><span class="main">)</span> <span class="main">-</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span><span class="main">1</span> <span class="main">##</span> <span class="free">fusc'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">fusc'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fusc</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fusc</span> <span class="main">=</span> <span class="main">1</span> <span class="main">##</span> fusc'"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fusc_unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"fusc <span class="main">=</span> <span class="main">1</span> <span class="main">##</span> fusc'"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> fusc_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fusc'_unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"fusc' <span class="main">=</span> <span class="main">1</span> <span class="main">##</span> <span class="main">(</span>fusc <span class="main">+</span> fusc' <span class="main">-</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>fusc <span class="keyword1">mod</span> fusc'<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> fusc'.code<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fusc_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fusc_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"shd fusc <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="quoted"><span class="quoted">"stl fusc <span class="main">=</span> fusc'"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fusc_unfold<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fusc'_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"shd fusc' <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="quoted"><span class="quoted">"stl fusc' <span class="main">=</span> fusc <span class="main">+</span> fusc' <span class="main">-</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>fusc <span class="keyword1">mod</span> fusc'<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> fusc'_unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Equivalence with Dijkstra's fusc function›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stern_brocot_loopless_siterate<span class="main">:</span> <span class="quoted"><span class="quoted">"stern_brocot_loopless <span class="main">=</span> siterate step <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stern_brocot_loopless.unique<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> stream.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smap_siterate<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fusc_fusc'_iterate<span class="main">:</span> <span class="quoted"><span class="quoted">"pure Pair <span class="main">⋄</span> fusc <span class="main">⋄</span> fusc' <span class="main">=</span> stern_brocot_loopless"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> stern_brocot_loopless.unique<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> stream.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">theorem</span></span> stern_brocot_loopless<span class="main">:</span>
  <span class="quoted"><span class="quoted">"stream stern_brocot_recurse <span class="main">=</span> stern_brocot_loopless"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> stern_brocot_loopless.unique<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> stream <span class="main">(</span>pure_tree Pair <span class="main">⋄</span> num <span class="main">⋄</span> den<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> stern_brocot_num_den<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> num<span class="main">:</span> <span class="quoted"><span class="quoted">"stream num <span class="main">=</span> <span class="main">1</span> <span class="main">##</span> stream den"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> stream.expand<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> den_eq_chop_num<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> den<span class="main">:</span> <span class="quoted"><span class="quoted">"stream den <span class="main">=</span> <span class="main">1</span> <span class="main">##</span> <span class="main">(</span>stream num <span class="main">+</span> stream den <span class="main">-</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>stream num <span class="keyword1">mod</span> stream den<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> stream.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tree_chop_den<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span> <span class="main">##</span> smap step <span class="var">?lhs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stream.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> den_eq_chop_num<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> tree_chop_den<span class="main"><span class="keyword3">;</span></span> <span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Bird_Tree">
<div class="head">
<h1>Theory Bird_Tree</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Andreas Lochbihler, ETH Zurich
   Author: Peter Gammie *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹ The Bird tree ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define the Bird tree following \cite{Hinze2009JFP} and prove that it is a
  permutation of the Stern-Brocot tree. As a corollary, we derive that the Bird tree also
  contains all rational numbers in lowest terms exactly once.
›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Bird_Tree <span class="keyword2"><span class="keyword">imports</span></span> <a href="Stern_Brocot_Tree.html">Stern_Brocot_Tree</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">corec</span></span> <span class="entity">bird</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"fraction tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bird</span> <span class="main">=</span> Node <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span>map_tree recip <span class="main">(</span>map_tree succ <span class="free">bird</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map_tree succ <span class="main">(</span>map_tree recip <span class="free">bird</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bird_unfold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bird <span class="main">=</span> Node <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span>pure recip <span class="main">⋄</span> <span class="main">(</span>pure succ <span class="main">⋄</span> bird<span class="main">)</span><span class="main">)</span> <span class="main">(</span>pure succ <span class="main">⋄</span> <span class="main">(</span>pure recip <span class="main">⋄</span> bird<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> bird.code <span class="keyword1"><span class="command">unfolding</span></span> map_tree_ap_tree_pure_tree<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bird_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root bird <span class="main">=</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"left bird <span class="main">=</span> pure recip <span class="main">⋄</span> <span class="main">(</span>pure succ <span class="main">⋄</span> bird<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"right bird <span class="main">=</span> pure succ <span class="main">⋄</span> <span class="main">(</span>pure recip <span class="main">⋄</span> bird<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> bird_unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mirror_bird<span class="main">:</span> <span class="quoted"><span class="quoted">"mirror bird <span class="main">=</span> pure recip <span class="main">⋄</span> bird"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> sym<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?F</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">t</span><span class="main">.</span> Node <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span>map_tree succ <span class="main">(</span>map_tree recip <span class="bound">t</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map_tree recip <span class="main">(</span>map_tree succ <span class="bound">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"mirror bird <span class="main">=</span> <span class="var">?F</span> <span class="main">(</span>mirror bird<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tree.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mirror_ap_tree mirror_pure map_tree_ap_tree_pure_tree<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span> <span class="main">=</span> mirror bird"</span></span> <span class="keyword2"><span class="keyword">when</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span> <span class="main">=</span> <span class="var">?F</span> <span class="skolem">t</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">t</span> <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">corec_unique</span> <span class="main">(</span><span class="operator">fact</span> *<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure recip <span class="main">⋄</span> bird <span class="main">=</span> <span class="var">?F</span> <span class="main">(</span>pure recip <span class="main">⋄</span> bird<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tree.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_tree_ap_tree_pure_tree<span class="main"><span class="keyword3">;</span></span> <span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">even_odd_mirror</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">even</span><span class="main">.</span> root <span class="main">(</span><span class="free">even_odd_mirror</span> <span class="bound">even</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">=</span> root <span class="free"><span class="bound"><span class="entity">t</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">even</span><span class="main">.</span> left <span class="main">(</span><span class="free">even_odd_mirror</span> <span class="bound">even</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">even_odd_mirror</span> <span class="main">(</span><span class="main">¬</span> <span class="bound">even</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">even</span> <span class="keyword1">then</span> right <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">else</span> left <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">even</span><span class="main">.</span> right <span class="main">(</span><span class="free">even_odd_mirror</span> <span class="bound">even</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">even_odd_mirror</span> <span class="main">(</span><span class="main">¬</span> <span class="bound">even</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">even</span> <span class="keyword1">then</span> left <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">else</span> right <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">even_mirror</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">even_mirror</span> <span class="main">=</span> even_odd_mirror True"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">odd_mirror</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">odd_mirror</span> <span class="main">=</span> even_odd_mirror False"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> even_mirror_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root <span class="main">(</span>even_mirror <span class="free">t</span><span class="main">)</span> <span class="main">=</span> root <span class="free">t</span>"</span></span>
  <span class="quoted"><span class="quoted">"left <span class="main">(</span>even_mirror <span class="free">t</span><span class="main">)</span> <span class="main">=</span> odd_mirror <span class="main">(</span>right <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"right <span class="main">(</span>even_mirror <span class="free">t</span><span class="main">)</span> <span class="main">=</span> odd_mirror <span class="main">(</span>left <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> odd_mirror_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root <span class="main">(</span>odd_mirror <span class="free">t</span><span class="main">)</span> <span class="main">=</span> root <span class="free">t</span>"</span></span>
  <span class="quoted"><span class="quoted">"left <span class="main">(</span>odd_mirror <span class="free">t</span><span class="main">)</span> <span class="main">=</span> even_mirror <span class="main">(</span>left <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"right <span class="main">(</span>odd_mirror <span class="free">t</span><span class="main">)</span> <span class="main">=</span> even_mirror <span class="main">(</span>right <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> even_mirror_def odd_mirror_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> even_odd_mirror_pure <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">even</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"even_odd_mirror <span class="free">even</span> <span class="main">(</span>pure_tree <span class="free">x</span><span class="main">)</span> <span class="main">=</span> pure_tree <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">even</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> even_odd_mirror_ap_tree <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">even</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"even_odd_mirror <span class="free">even</span> <span class="main">(</span><span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> even_odd_mirror <span class="free">even</span> <span class="free">f</span> <span class="main">⋄</span> even_odd_mirror <span class="free">even</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">even</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> even_mirror_pure<span class="main">:</span> <span class="quoted"><span class="quoted">"even_mirror <span class="main">(</span>pure_tree <span class="free">x</span><span class="main">)</span> <span class="main">=</span> pure_tree <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> odd_mirror_pure<span class="main">:</span> <span class="quoted"><span class="quoted">"odd_mirror <span class="main">(</span>pure_tree <span class="free">x</span><span class="main">)</span> <span class="main">=</span> pure_tree <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> even_mirror_def odd_mirror_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> even_mirror_ap_tree<span class="main">:</span> <span class="quoted"><span class="quoted">"even_mirror <span class="main">(</span><span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> even_mirror <span class="free">f</span> <span class="main">⋄</span> even_mirror <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> odd_mirror_ap_tree<span class="main">:</span> <span class="quoted"><span class="quoted">"odd_mirror <span class="main">(</span><span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> odd_mirror <span class="free">f</span> <span class="main">⋄</span> odd_mirror <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> even_mirror_def odd_mirror_def<span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">even_mirror_path</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"path <span class="main">⇒</span> path"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">odd_mirror_path</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"path <span class="main">⇒</span> path"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">even_mirror_path</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">even_mirror_path</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="keyword1">of</span> L <span class="main">⇒</span> R <span class="main">|</span> R <span class="main">⇒</span> L<span class="main">)</span> <span class="main">#</span> <span class="free">odd_mirror_path</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">odd_mirror_path</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">odd_mirror_path</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">#</span> <span class="free">even_mirror_path</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> even_mirror_traverse_tree <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"root <span class="main">(</span>traverse_tree <span class="free">path</span> <span class="main">(</span>even_mirror <span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="main">(</span>even_mirror_path <span class="free">path</span><span class="main">)</span> <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> odd_mirror_traverse_tree <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"root <span class="main">(</span>traverse_tree <span class="free">path</span> <span class="main">(</span>odd_mirror <span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="main">(</span>odd_mirror_path <span class="free">path</span><span class="main">)</span> <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">path</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> even_odd_mirror_path_involution <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"even_mirror_path <span class="main">(</span>even_mirror_path <span class="free">path</span><span class="main">)</span> <span class="main">=</span> <span class="free">path</span>"</span></span>
  <span class="quoted"><span class="quoted">"odd_mirror_path <span class="main">(</span>odd_mirror_path <span class="free">path</span><span class="main">)</span> <span class="main">=</span> <span class="free">path</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">path</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> even_odd_mirror_path_injective <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"even_mirror_path <span class="free">path</span> <span class="main">=</span> even_mirror_path <span class="free">path'</span> <span class="main">⟷</span> <span class="free">path</span> <span class="main">=</span> <span class="free">path'</span>"</span></span>
  <span class="quoted"><span class="quoted">"odd_mirror_path <span class="free">path</span> <span class="main">=</span> odd_mirror_path <span class="free">path'</span> <span class="main">⟷</span> <span class="free">path</span> <span class="main">=</span> <span class="free">path'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">path</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">path'</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">path'</span></span></span></span></span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dir.splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> odd_mirror_bird_stern_brocot<span class="main">:</span>
  <span class="quoted"><span class="quoted">"odd_mirror bird <span class="main">=</span> stern_brocot_recurse"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rsrs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_tree <span class="main">(</span>recip <span class="main">∘</span> succ <span class="main">∘</span> recip <span class="main">∘</span> succ<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rssr</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_tree <span class="main">(</span>recip <span class="main">∘</span> succ <span class="main">∘</span> succ <span class="main">∘</span> recip<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?srrs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_tree <span class="main">(</span>succ <span class="main">∘</span> recip <span class="main">∘</span> recip <span class="main">∘</span> succ<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?srsr</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_tree <span class="main">(</span>succ <span class="main">∘</span> recip <span class="main">∘</span> succ <span class="main">∘</span> recip<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">t</span><span class="main">.</span> Node <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span>Node <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">(</span><span class="var">?rssr</span> <span class="bound">t</span><span class="main">)</span> <span class="main">(</span><span class="var">?rsrs</span> <span class="bound">t</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Node <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="var">?srsr</span> <span class="bound">t</span><span class="main">)</span> <span class="main">(</span><span class="var">?srrs</span> <span class="bound">t</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"stern_brocot_recurse <span class="main">=</span> <span class="var">?R</span> stern_brocot_recurse"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tree.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> conjI<span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> tree.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> conjI<span class="main">)</span> <span class="comment1">― ‹Expand the tree twice›</span>
      <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">=</span> stern_brocot_recurse"</span></span> <span class="keyword2"><span class="keyword">when</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">=</span> <span class="var">?R</span> <span class="skolem">f</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="keyword1"><span class="command">using</span></span> that * <span class="keyword1"><span class="command">by</span></span> <span class="operator">corec_unique</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"odd_mirror bird <span class="main">=</span> <span class="var">?R</span> <span class="main">(</span>odd_mirror bird<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tree.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> conjI<span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> tree.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> conjI<span class="main">)</span> <span class="comment1">― ‹Expand the tree twice›</span>
      <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> bird_rationals<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"root <span class="main">(</span>traverse_tree <span class="main">(</span>odd_mirror_path <span class="main">(</span>mk_path <span class="free">m</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>pure rat_of <span class="main">⋄</span> bird<span class="main">)</span><span class="main">)</span> <span class="main">=</span> Fract <span class="main">(</span>int <span class="free">m</span><span class="main">)</span> <span class="main">(</span>int <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> stern_brocot_rationals<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> odd_mirror_bird_stern_brocot<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> bird_rationals_not_repeated<span class="main">:</span>
  <span class="quoted"><span class="quoted">"root <span class="main">(</span>traverse_tree <span class="free">path</span> <span class="main">(</span>pure rat_of <span class="main">⋄</span> bird<span class="main">)</span><span class="main">)</span> <span class="main">=</span> root <span class="main">(</span>traverse_tree <span class="free">path'</span> <span class="main">(</span>pure rat_of <span class="main">⋄</span> bird<span class="main">)</span><span class="main">)</span>
  <span class="main">⟹</span> <span class="free">path</span> <span class="main">=</span> <span class="free">path'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> stern_brocot_rationals_not_repeated<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> path<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"odd_mirror_path <span class="free">path</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> path'<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"odd_mirror_path <span class="free">path'</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> odd_mirror_bird_stern_brocot<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>