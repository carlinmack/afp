<div id="Method">
<div class="head">
<h1>Theory Method</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       A General Method for the Proof of Theorems on Tail-recursive Functions
    Author:      Pasquale Noce
                 Security Certification Specialist at Arjo Systems - Gep S.p.A.
                 pasquale dot noce dot lavoro at gmail dot com
                 pasquale dot noce at arjowiggins-it dot com
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Method rationale"</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Method
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> 
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Tail-recursive function definitions are sometimes more intuitive and
straightforward than alternatives, and this alone would be enough to make them
preferable in such cases for the mere purposes of functional programming. However,
proving theorems about them with a formal proof assistant like Isabelle may be
roundabout because of the peculiar form of the resulting recursion induction
rules.

Let:

\begin{itemize}

\item
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive›</span></span></span></span> be a tail-recursive function of type
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a<span class="hidden">⇩</span><sub>1</sub> ⇒ ... ⇒ 'a<span class="hidden">⇩</span><sub>n</sub> ⇒ 'b›</span></span></span></span>.

\item
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a›</span></span></span></span> be an <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span>-tuple of values of types <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>, ...,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a<span class="hidden">⇩</span><sub>n</sub>›</span></span></span></span> such that the computation of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive a›</span></span></span></span>, say outputting
value <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>b›</span></span></span></span>, involves at least one recursive call -- which is what happens in
general for significant inputs (e.g. those complying with initial conditions for
accumulator arguments), as otherwise a non-recursive function definition would be
sufficient.

\item
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>, ..., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a<span class="hidden">⇩</span><sub>m</sub>›</span></span></span></span> be the sequence of the intermediate
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span>-tuples of values of types <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>, ..., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a<span class="hidden">⇩</span><sub>n</sub>›</span></span></span></span> arising from
the computation of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive a›</span></span></span></span>.

\item
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive X<span class="hidden">⇩</span><sub>1</sub> = f_naive X'<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>, ..., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive X<span class="hidden">⇩</span><sub>m</sub> = f_naive X'<span class="hidden">⇩</span><sub>m</sub>›</span></span></span></span>,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive X = Y›</span></span></span></span> be the sequence (possibly with repetitions) of the
equations involved in the computation of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive a›</span></span></span></span> -- which implies
that, putting <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a<span class="hidden">⇩</span><sub>0</sub> = a›</span></span></span></span>, they are satisfied for
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(X<span class="hidden">⇩</span><sub>1</sub>, X'<span class="hidden">⇩</span><sub>1</sub>) = (a<span class="hidden">⇩</span><sub>0</sub>, a<span class="hidden">⇩</span><sub>1</sub>)›</span></span></span></span>, ..., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(X<span class="hidden">⇩</span><sub>m</sub>, X'<span class="hidden">⇩</span><sub>m</sub>) = (a<span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>-</sub><span class="hidden">⇩</span><sub>1</sub>, a<span class="hidden">⇩</span><sub>m</sub>)›</span></span></span></span>,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(X, Y) = (a<span class="hidden">⇩</span><sub>m</sub>, b)›</span></span></span></span>, respectively.

\end{itemize}

That being stated, suppose that theorem <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_naive a)›</span></span></span></span> has to be proven.
If recursion induction is applied to such goal, for each <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>i ∈ {1..m}›</span></span></span></span>,
the recursive equation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive X<span class="hidden">⇩</span><sub>i</sub> = f_naive X'<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> gives rise to subgoal
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_naive X'<span class="hidden">⇩</span><sub>i</sub>) ⟹ P (f_naive X<span class="hidden">⇩</span><sub>i</sub>)›</span></span></span></span>, trivially discharged by
simplification. On the contrary, the non-recursive equation
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive X = Y›</span></span></span></span> brings about the generation of subgoal
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_naive X)›</span></span></span></span>, which is intractable unless it trivially follows from
either the equation or the form of pattern <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X›</span></span></span></span>.

Indeed, in non-trivial cases such as the case studies examined in this paper, this
formula even fails to be a theorem, thus being hopeless as a goal, since it is
false for some values of its variables. The reason for this is that non-trivial
properties of the output of tail-recursive functions depend on the input as well
as on the whole recursive call pipeline leading from the input to the output, and
all of this information corresponds to missing necessary assumptions in subgoal
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_naive X)›</span></span></span></span>.

Therefore, for a non-trivial theorem <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_naive a)›</span></span></span></span>, recursion induction
is rather applicable to some true conditional statement
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv x ⟶ P (f_naive x)›</span></span></span></span> complying with both of the following
requirements:

\begin{itemize}

\item
subgoal <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv X ⟶ P (f_naive X)›</span></span></span></span> arising from equation
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive X = Y›</span></span></span></span> be tractable, and

\item
formula <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv a›</span></span></span></span> can be shown to be true, so that theorem
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_naive a)›</span></span></span></span> can be inferred from conditional
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv a ⟶ P (f_naive a)›</span></span></span></span> by \emph{modus ponens}.

\end{itemize}

Observe that the antecedent of the conditional may not have the form
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv (f_naive x)›</span></span></span></span>. Otherwise, the latter requirement would ask for
proving formula <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv (f_naive a)›</span></span></span></span>, which would be at least as hard to
prove as formula <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_naive a)›</span></span></span></span> being the former a sufficient condition
for the latter. Hence, the same problem as that originating from the proof of
formula <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_naive a)›</span></span></span></span> would have to be solved again, which would give
rise to a \emph{regressio ad infinitum}.

The latter requirement entails that formula <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv a<span class="hidden">⇩</span><sub>0</sub>›</span></span></span></span> holds. Moreover,
for each <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>i ∈ {1..m}›</span></span></span></span>, in the proof of conditional
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv x ⟶ P (f_naive x)›</span></span></span></span> by recursion induction, the recursive equation
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive X<span class="hidden">⇩</span><sub>i</sub> = f_naive X'<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> brings about the generation of subgoal
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv X'<span class="hidden">⇩</span><sub>i</sub> ⟶ P (f_naive X'<span class="hidden">⇩</span><sub>i</sub>) ⟹ f_inv X<span class="hidden">⇩</span><sub>i</sub> ⟶ P (f_naive X<span class="hidden">⇩</span><sub>i</sub>)›</span></span></span></span>. Assuming
that formula <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv a<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>-</sub><span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span> holds, it turns out that the conclusion
antecedent <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv X<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> may not be shown to be false, as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span>-tuple
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>-</sub><span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span> matches pattern <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span>; thus, the conclusion consequent
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_naive X<span class="hidden">⇩</span><sub>i</sub>)›</span></span></span></span> has to be proven.

In non-trivial cases, this requires that the assumption antecedent
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv X'<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> be derived from the conclusion antecedent <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv X<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span>
used as a further assumption, so that the assumption consequent
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_naive X'<span class="hidden">⇩</span><sub>i</sub>)›</span></span></span></span> -- matching <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_naive X<span class="hidden">⇩</span><sub>i</sub>)›</span></span></span></span> by virtue of
equation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive X<span class="hidden">⇩</span><sub>i</sub> = f_naive X'<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> -- can be proven by
\emph{modus ponens}. This in turn requires that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv X<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> imply
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv X'<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span>, i.e. that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv x<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> imply <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv x'<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> for any
pair of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span>-tuples <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x'<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> matching patterns <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span>,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X'<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> with respect to the same value assignment. But such are
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span>-tuples <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>-</sub><span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> as they solve equation
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive X<span class="hidden">⇩</span><sub>i</sub> = f_naive X'<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span>, so that the supposed truth of
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv a<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>-</sub><span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span> entails that of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv a<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span>.

Hence, by induction, all of formulae <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv a›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv a<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>, ...,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv a<span class="hidden">⇩</span><sub>m</sub>›</span></span></span></span> turn out to be true. On the other hand, the former requirement
is verified if either the antecedent <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv X›</span></span></span></span> can be shown to be false,
which would entail its falsity for any <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span>-tuple matching pattern <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X›</span></span></span></span>,
or else the consequent <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_naive X)›</span></span></span></span> can be shown to be true using the
antecedent as an assumption. Since formula <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv a<span class="hidden">⇩</span><sub>m</sub>›</span></span></span></span> is true and
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span>-tuple <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a<span class="hidden">⇩</span><sub>m</sub>›</span></span></span></span> matches pattern <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X›</span></span></span></span>, the case that actually
occurs is the second one.

Thus, the former requirement is equivalent to asking for an introduction rule to
be proven -- in fact, a conditional with a contradiction as antecedent may not be
used as an introduction rule -- having the form
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv X ⟹ P (f_naive X)›</span></span></span></span>, or rather
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟦f_inv x; f_form x⟧ ⟹ P (f_naive x)›</span></span></span></span> for a suitable predicate
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_form›</span></span></span></span> satisfied by any <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span>-tuple matching pattern <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X›</span></span></span></span>. In
the degenerate case in which the rule can be shown to be true for
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_form = (λx. True)›</span></span></span></span>, it admits to be put into the simpler equivalent
form <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv x ⟹ P (f_naive x)›</span></span></span></span>.

An even more important consequence of the previous argument is that in non-trivial
cases, the task of proving conditional <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv x ⟶ P (f_naive x)›</span></span></span></span> by
recursion induction requires that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv X'<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> be derived from
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv X<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> for each recursive equation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive X<span class="hidden">⇩</span><sub>i</sub> = f_naive X'<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span>,
where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>i ∈ {1..m}›</span></span></span></span>.

Let:

\begin{itemize}

\item
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a›</span></span></span></span> be the Cartesian product of types <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>, ..., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a<span class="hidden">⇩</span><sub>n</sub>›</span></span></span></span>.

\item
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_set›</span></span></span></span> be the inductive set of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a ⇒ 'a set›</span></span></span></span> defined by
introduction rules <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x ∈ f_set x›</span></span></span></span>,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X<span class="hidden">⇩</span><sub>1</sub> ∈ f_set x ⟹ X'<span class="hidden">⇩</span><sub>1</sub> ∈ f_set x›</span></span></span></span>, ...,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X<span class="hidden">⇩</span><sub>m</sub> ∈ f_set x ⟹ X'<span class="hidden">⇩</span><sub>m</sub> ∈ f_set x›</span></span></span></span> -- where patterns <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X'<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>, ..., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X<span class="hidden">⇩</span><sub>m</sub>›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X'<span class="hidden">⇩</span><sub>m</sub>›</span></span></span></span> are now viewed as values of type
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a›</span></span></span></span>.

\end{itemize}

Then, the problem of discharging the above proof obligation on predicate
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv›</span></span></span></span> is at least as hard as that of proving by rule induction
introduction rule <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟦y ∈ f_set x; f_inv x⟧ ⟹ f_inv y›</span></span></span></span> -- which states that
for any <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> such that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv x›</span></span></span></span> is true, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv›</span></span></span></span> is an
invariant over inductive set <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_set x›</span></span></span></span>, i.e. <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv y›</span></span></span></span> is true for
each <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>y ∈ f_set x›</span></span></span></span>.

In fact, the application of rule induction to this goal generates subgoals
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv x ⟹ f_inv x›</span></span></span></span>,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟦X<span class="hidden">⇩</span><sub>1</sub> ∈ f_set x; f_inv X<span class="hidden">⇩</span><sub>1</sub>; f_inv x⟧ ⟹ f_inv X'<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>, ...,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟦X<span class="hidden">⇩</span><sub>m</sub> ∈ f_set x; f_inv X<span class="hidden">⇩</span><sub>m</sub>; f_inv x⟧ ⟹ f_inv X'<span class="hidden">⇩</span><sub>m</sub>›</span></span></span></span>; the first is trivial,
and such would also be the other ones if rules <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv X<span class="hidden">⇩</span><sub>1</sub> ⟹ f_inv X'<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>,
..., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv X<span class="hidden">⇩</span><sub>m</sub> ⟹ f_inv X'<span class="hidden">⇩</span><sub>m</sub>›</span></span></span></span> were available.

Furthermore, suppose that the above invariance property of predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv›</span></span></span></span>
have been proven; then, the proof of conditional
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv x ⟶ P (f_naive x)›</span></span></span></span> by recursion induction can be made unnecessary
by slightly refining the definition of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive›</span></span></span></span>, as shown in the
continuation.

Let <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span> be the tail-recursive function of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a ⇒ 'a›</span></span></span></span> whose
definition is obtained from that of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive›</span></span></span></span> by treating as fixed points
the patterns to which non-recursive equations apply as well as those to which no
equation applies, if any -- i.e. by replacing recursive equation
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive X<span class="hidden">⇩</span><sub>i</sub> = f_naive X'<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux X<span class="hidden">⇩</span><sub>i</sub> = f_aux X'<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> for each
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>i ∈ {1..m}›</span></span></span></span> and non-recursive equation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive X = Y›</span></span></span></span> with
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux X = X›</span></span></span></span>.

Then, define function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f›</span></span></span></span> by means of a non-recursive equation
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f x = f_out (f_aux (f_in x))›</span></span></span></span>, where:

\begin{itemize}

\item
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_in›</span></span></span></span> is a function of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a' ⇒ 'a›</span></span></span></span>, for a suitable type
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a'›</span></span></span></span>, whose range contains all the significant inputs of function
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive›</span></span></span></span>.

\item
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_out›</span></span></span></span> is a function of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a ⇒ 'b›</span></span></span></span> mapping the outputs of
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span> to those of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive›</span></span></span></span>, i.e. the values of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a›</span></span></span></span>
matching pattern <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X›</span></span></span></span> to those of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'b›</span></span></span></span> matching pattern
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Y›</span></span></span></span> with respect to the same value assignment.

\end{itemize}

The definitions of functions <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_out›</span></span></span></span> entail that equation
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive x = f_out (f_aux x)›</span></span></span></span> holds for any <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span>. Particularly,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive a = f_out (f_aux a)›</span></span></span></span>; thus, being <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a'›</span></span></span></span> an inverse image of
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a›</span></span></span></span> under <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_in›</span></span></span></span>, viz. <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a = f_in a'›</span></span></span></span>, it follows that
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive a = f a'›</span></span></span></span>. As a result, theorem <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_naive a)›</span></span></span></span> may be
rewritten as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f a')›</span></span></span></span>.

For any <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_set x›</span></span></span></span> is precisely the set of the values
recursively input to function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span> in the computation of
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux x›</span></span></span></span>, including <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> itself, and it can easily be ascertained
that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux x›</span></span></span></span> is such a value. In fact, the equation invoked last in the
computation of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux x›</span></span></span></span> must be a non-recursive one, so that it has the
form <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux X = X›</span></span></span></span>, since all non-recursive equations in the definition
of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span> apply to fixed points. Thus, being <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux x›</span></span></span></span> the output
of the computation, the right-hand side of the equation, i.e. the pattern
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X›</span></span></span></span> also input to function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span> in the left-hand side, is
instantiated to value <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux x›</span></span></span></span>.

Therefore, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux x ∈ f_set x›</span></span></span></span> for any <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span>. Observe that the
argument rests on the assumption that whatever <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> is given, a sequence of
equations leading from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux x›</span></span></span></span> be actually available -- and
what is more, nothing significant could be proven on <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux x›</span></span></span></span> for any
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> for which its value were undefined, and then arbitrary. The trick of
making the definition of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span> total by adding equations for the patterns
not covered in the definition of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive›</span></span></span></span>, if any, guarantees that this
assumption be satisfied.

An additional consequence of the previous argument is that
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux (f_aux x) = f_aux x›</span></span></span></span> for any <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span>, i.e. function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span>
is idempotent. If introduction rule <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟦f_inv x; f_form x⟧ ⟹ P (f_naive x)›</span></span></span></span>
is rewritten by applying equation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive x = f_out (f_aux x)›</span></span></span></span>,
instantiating free variable <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux x›</span></span></span></span>, and then applying the
idempotence of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span>, the result is formula
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟦f_inv (f_aux x); f_form (f_aux x)⟧ ⟹ P (f_out (f_aux x))›</span></span></span></span>, which is
nothing but an instantiation of introduction rule
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟦f_inv x; f_form x⟧ ⟹ P (f_out x)›</span></span></span></span>.

Observe that this rule is just a refinement of a rule whose proof is required for
proving conditional <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv x ⟶ P (f_naive x)›</span></span></span></span> by recursion induction, so
that it does not give rise to any additional proof obligation. Moreover, it
contains neither function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive›</span></span></span></span> nor <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span>, thus its proof does
not require recursion induction with respect to the corresponding induction rules.

The instantiation of such refined introduction rule with value <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux a›</span></span></span></span>
is <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟦f_inv (f_aux a); f_form (f_aux a)⟧ ⟹ P (f_out (f_aux a))›</span></span></span></span>, which by
virtue of equality <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a = f_in a'›</span></span></span></span> and the definition of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f›</span></span></span></span>
is equivalent to formula
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟦f_inv (f_aux a); f_form (f_aux a)⟧ ⟹ P (f a')›</span></span></span></span>. Therefore, the rule is
sufficient to prove theorem <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f a')›</span></span></span></span> -- hence making unnecessary the
proof of conditional <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv x ⟶ P (f_naive x)›</span></span></span></span> by recursion induction,
as mentioned previously -- provided the instantiated assumptions
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv (f_aux a)›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_form (f_aux a)›</span></span></span></span> can be shown to be true.

This actually is the case: the former assumption can be derived from formulae
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux a ∈ f_set a›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv a›</span></span></span></span> and the invariance of predicate
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv›</span></span></span></span> over <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_set a›</span></span></span></span>, while the latter can be proven by recursion
induction, as by construction goal <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_form X›</span></span></span></span> is trivial for any pattern
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X›</span></span></span></span> to which some non-recursive equation in the definition of function
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive›</span></span></span></span> applies. If further non-recursive equations whose patterns do not
satisfy predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_form›</span></span></span></span> have been added to the definition of
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span> to render it total, rule inversion can be applied to exclude that
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux a›</span></span></span></span> may match any of such patterns, again using formula
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux a ∈ f_set a›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Method summary"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The general method developed so far can be schematized as follows.

Let <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive›</span></span></span></span> be a tail-recursive function of type
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a<span class="hidden">⇩</span><sub>1</sub> ⇒ ... ⇒ 'a<span class="hidden">⇩</span><sub>n</sub> ⇒ 'b›</span></span></span></span>, and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_naive a<span class="hidden">⇩</span><sub>1</sub> ... a<span class="hidden">⇩</span><sub>n</sub>)›</span></span></span></span> be a
non-trivial theorem having to be proven on this function.

In order to accomplish such task, the following procedure shall be observed.

\begin{itemize}

\item
\emph{Step 1} --- Refine the definition of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive›</span></span></span></span> into that of an
auxiliary tail-recursive function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span> of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a ⇒ 'a›</span></span></span></span>, where
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a›</span></span></span></span> is a product or record type with types <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>, ..., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a<span class="hidden">⇩</span><sub>n</sub>›</span></span></span></span>
as components, by treating as fixed points the patterns to which non-recursive
equations apply as well as those to which no equation applies, if any.

\item
\emph{Step 2} --- Define a function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f›</span></span></span></span> of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a' ⇒ 'b›</span></span></span></span> by means
of a non-recursive equation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f x = f_out (f_aux (f_in x))›</span></span></span></span>, where
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_in›</span></span></span></span> is a function of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a' ⇒ 'a›</span></span></span></span> (possibly matching the
identity function) whose range contains all the significant inputs of function
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive›</span></span></span></span>, and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_out›</span></span></span></span> is a function of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a ⇒ 'b›</span></span></span></span>
mapping the outputs of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span> to those of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive›</span></span></span></span>.
\\Then, denoting with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a›</span></span></span></span> the value of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a›</span></span></span></span> with components
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>, ..., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a<span class="hidden">⇩</span><sub>n</sub>›</span></span></span></span>, and with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a'›</span></span></span></span> an inverse image of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a›</span></span></span></span>
under function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_in›</span></span></span></span>, the theorem to be proven takes the equivalent form
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f a')›</span></span></span></span>.

\item
\emph{Step 3} --- Let <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux X<span class="hidden">⇩</span><sub>1</sub> = f_aux X'<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>, ...,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux X<span class="hidden">⇩</span><sub>m</sub> = f_aux X'<span class="hidden">⇩</span><sub>m</sub>›</span></span></span></span> be the recursive equations in the definition of
function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span>.
\\Then, define an inductive set <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_set›</span></span></span></span> of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a ⇒ 'a set›</span></span></span></span> with
introduction rules <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x ∈ f_set x›</span></span></span></span>,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X<span class="hidden">⇩</span><sub>1</sub> ∈ f_set x ⟹ X'<span class="hidden">⇩</span><sub>1</sub> ∈ f_set x›</span></span></span></span>, ...,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X<span class="hidden">⇩</span><sub>m</sub> ∈ f_set x ⟹ X'<span class="hidden">⇩</span><sub>m</sub> ∈ f_set x›</span></span></span></span>.
\\If the right-hand side of some recursive equation contains conditionals in the
form of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>if›</span></span></span></span> or <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>case›</span></span></span></span> constructs, the corresponding introduction
rule can be split into as many rules as the possible mutually exclusive cases;
each of such rules shall then provide for the related case as an additional
assumption.

\item
\emph{Step 4} --- Prove lemma <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux x ∈ f_set x›</span></span></span></span>; a general inference
scheme, independent of the specific function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span>, applies to this proof.
\\First, prove lemma <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>y ∈ f_set x ⟹ f_set y ⊆ f_set x›</span></span></span></span>, which can easily
be done by rule induction.
\\Next, applying recursion induction to goal <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux x ∈ f_set x›</span></span></span></span> and then
simplifying, a subgoal <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X<span class="hidden">⇩</span><sub>i</sub> ∈ f_set X<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> arises for each non-recursive
equation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux X<span class="hidden">⇩</span><sub>i</sub> = X<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span>, while a subgoal
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux X'<span class="hidden">⇩</span><sub>j</sub> ∈ f_set X'<span class="hidden">⇩</span><sub>j</sub> ⟹ f_aux X'<span class="hidden">⇩</span><sub>j</sub> ∈ f_set X<span class="hidden">⇩</span><sub>j</sub>›</span></span></span></span> arises for each recursive
equation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux X<span class="hidden">⇩</span><sub>j</sub> = f_aux X'<span class="hidden">⇩</span><sub>j</sub>›</span></span></span></span>.
\\The former subgoals can be proven by introduction rule <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x ∈ f_set x›</span></span></span></span>, the
latter ones as follows: rule instantiations <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X<span class="hidden">⇩</span><sub>j</sub> ∈ f_set X<span class="hidden">⇩</span><sub>j</sub>›</span></span></span></span> and
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X<span class="hidden">⇩</span><sub>j</sub> ∈ f_set X<span class="hidden">⇩</span><sub>j</sub> ⟹ X'<span class="hidden">⇩</span><sub>j</sub> ∈ f_set X<span class="hidden">⇩</span><sub>j</sub>›</span></span></span></span> imply formula <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X'<span class="hidden">⇩</span><sub>j</sub> ∈ f_set X<span class="hidden">⇩</span><sub>j</sub>›</span></span></span></span>;
thus <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_set X'<span class="hidden">⇩</span><sub>j</sub> ⊆ f_set X<span class="hidden">⇩</span><sub>j</sub>›</span></span></span></span> by the aforesaid lemma; from this and subgoal
assumption <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux X'<span class="hidden">⇩</span><sub>j</sub> ∈ f_set X'<span class="hidden">⇩</span><sub>j</sub>›</span></span></span></span>, subgoal conclusion
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux X'<span class="hidden">⇩</span><sub>j</sub> ∈ f_set X<span class="hidden">⇩</span><sub>j</sub>›</span></span></span></span> ensues.
\\As regards recursive equations containing conditionals, the above steps have to
be preceded by a case distinction, so as to obtain further assumptions sufficient
for splitting such conditionals.

\item
\emph{Step 5} --- Define a predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv›</span></span></span></span> of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a ⇒ bool›</span></span></span></span> in
such a way as to meet the proof obligations prescribed by the following steps.

\item
\emph{Step 6} --- Prove lemma <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv a›</span></span></span></span>.
\\In case of failure, return to step 5 so as to suitably change the definition of
predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv›</span></span></span></span>.

\item
\emph{Step 7} --- Prove introduction rule <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv x ⟹ P (f_out x)›</span></span></span></span>, or
rather <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟦f_inv x; f_form x⟧ ⟹ P (f_out x)›</span></span></span></span>, where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_form›</span></span></span></span> is a
suitable predicate of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a ⇒ bool›</span></span></span></span> satisfied by any pattern to which
some non-recursive equation in the definition of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_naive›</span></span></span></span> applies.
\\In case of failure, return to step 5 so as to suitably change the definition of
predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv›</span></span></span></span>.

\item
\emph{Step 8} --- In case an introduction rule of the second form has been proven
in step 7, prove lemma <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_form (f_aux a)›</span></span></span></span> by recursion induction.
\\If the definition of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux›</span></span></span></span> resulting from step 1 contains
additional non-recursive equations whose patterns do not satisfy predicate
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_form›</span></span></span></span>, rule inversion can be applied to exclude that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux a›</span></span></span></span>
may match any of such patterns, using instantiation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux a ∈ f_set a›</span></span></span></span> of
the lemma proven in step 4.

\item
\emph{Step 9} --- Prove by rule induction introduction rule
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟦y ∈ f_set x; f_inv x⟧ ⟹ f_inv y›</span></span></span></span>, which states the invariance of
predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv›</span></span></span></span> over inductive set <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_set x›</span></span></span></span> for any <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span>
satisfying <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv›</span></span></span></span>.
\\In case of failure, return to step 5 so as to suitably change the definition of
predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv›</span></span></span></span>.
\\Observe that the order in which the proof obligations related to predicate
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv›</span></span></span></span> are distributed among steps 6 to 9 is ascending in the effort
typically required to discharge them. The reason why this strategy is advisable is
that in case one step fails, which forces to revise the definition of predicate
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv›</span></span></span></span> and then also the proofs already worked out, such proofs will be the
least demanding ones so as to minimize the effort required for their revision.

\item
\emph{Step 10} --- Prove theorem <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f a')›</span></span></span></span> by means of the following
inference scheme.
\\First, derive formula <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv (f_aux a)›</span></span></span></span> from introduction rule
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟦y ∈ f_set x; f_inv x⟧ ⟹ f_inv y›</span></span></span></span> and formulae
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_aux a ∈ f_set a›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv a›</span></span></span></span>.
\\Then, derive formula <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_out (f_aux a))›</span></span></span></span> from either introduction rule
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv x ⟹ P (f_out x)›</span></span></span></span> or <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⟦f_inv x; f_form x⟧ ⟹ P (f_out x)›</span></span></span></span>
and formulae <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_inv (f_aux a)›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_form (f_aux a)›</span></span></span></span> (in the latter
case).
\\Finally, derive theorem <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f a')›</span></span></span></span> from formulae
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P (f_out (f_aux a))›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a = f_in a'›</span></span></span></span> and the definition of
function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f›</span></span></span></span>.

\end{itemize}

In the continuation, the application of this method is illustrated by analyzing
two case studies drawn from an exercise comprised in Isabelle online course
material; see \cite{R5}. The salient points of definitions and proofs are
commented; for additional information see Isabelle documentation, particularly
\cite{R1}, \cite{R2}, \cite{R3}, and \cite{R4}.
›</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="CaseStudy1">
<div class="head">
<h1>Theory CaseStudy1</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       A General Method for the Proof of Theorems on Tail-recursive Functions
    Author:      Pasquale Noce
                 Security Certification Specialist at Arjo Systems - Gep S.p.A.
                 pasquale dot noce dot lavoro at gmail dot com
                 pasquale dot noce at arjowiggins-it dot com
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Case study 1"</span></span>

<span class="keyword1"><span class="command">theory</span></span> CaseStudy1
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

In the first case study, the problem will be examined of defining a function
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l_sort›</span></span></span></span> performing insertion sort on lists of elements of a linear order,
and then proving the correctness of this definition, i.e. that the lists output by
the function actually be sorted and contain as many occurrences of any value as
the input lists.

Such function constitutes a paradigmatic example of a function admitting a
straightforward tail-recursive definition. Here below is a naive one:

\null
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">l_sort_naive</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">l_sort_naive</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="free">l_sort_naive</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">[]</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">l_sort_naive</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span>
  <span class="keyword1">then</span> <span class="free">l_sort_naive</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">[]</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span>
  <span class="keyword1">else</span> <span class="free">l_sort_naive</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">]</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">l_sort_naive</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

The first argument is deputed to contain the values still having to be inserted
into the sorted list, accumulated in the third argument. For each of such values,
the items of the sorted list are orderly moved into a temporary one (second
argument) to search the insertion position. Once found, the sorted list is
restored, the processed value is moved from the unsorted list to the sorted one,
and another iteration of the loop is performed up to the exhaustion of the former
list.

A further couple of functions are needed to express the aforesaid correctness
properties of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l_sort_naive›</span></span></span></span>:

\null
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">l_sorted</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">l_sorted</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">x'</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x'</span></span></span> <span class="main">∧</span> <span class="free">l_sorted</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x'</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">l_sorted</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> True"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">l_count</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">l_count</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≡</span> length <span class="main">[</span><span class="bound">x'</span><span class="main">←</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">.</span> <span class="bound">x'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

Then, the target correctness theorems can be enunciated as follows:

\null

<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l_sorted (l_sort_naive xs [] [])›</span></span></span></span>

\null

<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l_count x (l_sort_naive xs [] []) = l_count x xs›</span></span></span></span>

\null

Unfortunately, attempts to apply recursion induction to such goals turn out to be
doomed, as can easily be ascertained by considering the former theorem:

\null
›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="quoted"><span class="quoted">"l_sorted <span class="main">(</span>l_sort_naive <span class="free">xs</span> <span class="main">[]</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_naive.induct <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">xs</span></span> <span class="bound"><span class="bound">ys</span></span> <span class="bound"><span class="bound">zs</span></span><span class="main"><span class="main">.</span></span> l_sorted <span class="main"><span class="main">(</span></span>l_sort_naive <span class="bound"><span class="bound">xs</span></span> <span class="bound"><span class="bound">ys</span></span> <span class="bound"><span class="bound">zs</span></span><span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span>
 <span class="operator">simp_all</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> l_sort_naive.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹
\null

Simplification deletes all the subgoals generated by recursive equations.
However, the following subgoal arises from the non-recursive one:

\null

<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display]<span class="antiquote"><span class="antiquote">}</span></span></span></span>

\null

which is hopeless as the formula is false for any unsorted list <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>zs›</span></span></span></span>.

\null
›</span></span>

<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 1"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> l_type <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">×</span> <span class="tfree">'a</span> list <span class="main">×</span> <span class="tfree">'a</span> list"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">l_sort_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder l_type <span class="main">⇒</span> <span class="tfree">'a</span> l_type"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">l_sort_aux</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="main">=</span> <span class="free">l_sort_aux</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">l_sort_aux</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span>
  <span class="keyword1">then</span> <span class="free">l_sort_aux</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span>
  <span class="keyword1">else</span> <span class="free">l_sort_aux</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">l_sort_aux</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

Observe that the Cartesian product of the input types has been implemented as a
product type.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 2"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">l_sort_in</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> l_type"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">l_sort_in</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">l_sort_out</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> l_type <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">l_sort_out</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">l_sort</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">l_sort</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≡</span> l_sort_out <span class="main">(</span>l_sort_aux <span class="main">(</span>l_sort_in <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

Since the significant inputs of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l_sort_naive›</span></span></span></span> match pattern
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>_›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>[]›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>[]›</span></span></span></span>, those of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l_sort_aux›</span></span></span></span>
match pattern <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(_, [], [])›</span></span></span></span>, thus being in a one-to-one correspondence
with the type of the first component.

The target correctness theorems can then be put into the following equivalent
form:

\null

<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l_sorted (l_sort xs)›</span></span></span></span>

\null

<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l_count x (l_sort xs) = l_count x xs›</span></span></span></span>
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 3"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The conditional recursive equation in the definition of function
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l_sort_aux›</span></span></span></span> will equivalently be associated to two distinct introduction
rules in the definition of the inductive set <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l_sort_set›</span></span></span></span>, one for either
truth value of the Boolean condition, handled as an additional assumption. The
advantage is twofold: simpler introduction rules are obtained, and case
distinctions are saved as rule induction is applied.

\null
›</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">l_sort_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder l_type <span class="main">⇒</span> <span class="tfree">'a</span> l_type set"</span></span>
<span class="keyword2"><span class="keyword">for</span></span> <span class="entity">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> l_type"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
R0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> <span class="free">l_sort_set</span> <span class="free">X</span>"</span></span> <span class="main">|</span>
R1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="main">∈</span> <span class="free">l_sort_set</span> <span class="free">X</span> <span class="main">⟹</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span><span class="main">)</span> <span class="main">∈</span> <span class="free">l_sort_set</span> <span class="free">X</span>"</span></span> <span class="main">|</span>
R2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">l_sort_set</span> <span class="free">X</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">⟧</span> <span class="main">⟹</span>
     <span class="main">(</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">l_sort_set</span> <span class="free">X</span>"</span></span> <span class="main">|</span>
R3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">l_sort_set</span> <span class="free">X</span><span class="main">;</span> <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">⟧</span> <span class="main">⟹</span>
     <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">l_sort_set</span> <span class="free">X</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 4"</span></span>

<span class="keyword1" id="CaseStudy1-l_sort_subset"><span class="command">lemma</span></span> l_sort_subset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> XY<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">∈</span> l_sort_set <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"l_sort_set <span class="free">Y</span> <span class="main">⊆</span> l_sort_set <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> l_sort_set.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">∈</span> l_sort_set <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> XY <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">ys</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="free">X</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R1<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">z</span> <span class="skolem">zs</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R2<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">z</span> <span class="skolem">zs</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">z</span><span class="main">]</span><span class="main">,</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R3<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="CaseStudy1-l_sort_aux_set"><span class="command">lemma</span></span> l_sort_aux_set<span class="main">:</span> <span class="quoted"><span class="quoted">"l_sort_aux <span class="free">X</span> <span class="main">∈</span> l_sort_set <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> l_sort_aux.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> l_sort_aux.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">zs</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R0<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R0<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R1<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"l_sort_set <span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span> <span class="main">⊆</span> l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"l_sort_aux <span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"l_sort_aux <span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> subsetD<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">z</span> <span class="skolem">zs</span>
  <span class="keyword3"><span class="command">assume</span></span>
   case1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">z</span> <span class="main">⟹</span>
    l_sort_aux <span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>
   case2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">z</span> <span class="main">⟹</span>
    l_sort_aux <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">z</span><span class="main">]</span><span class="main">,</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">z</span><span class="main">]</span><span class="main">,</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> 0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R0<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"l_sort_aux <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> 0 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R2<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"l_sort_set <span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">⊆</span> l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_subset<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l_sort_aux <span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span>
     l_sort_set <span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> case1 <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">z</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"l_sort_aux <span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span>
     l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> subsetD<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> 0 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">z</span><span class="main">]</span><span class="main">,</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span> l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R3<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">z</span><span class="main">]</span><span class="main">,</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">⊆</span> l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_subset<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l_sort_aux <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">z</span><span class="main">]</span><span class="main">,</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span>
     l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">z</span><span class="main">]</span><span class="main">,</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> case2 <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">z</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"l_sort_aux <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">z</span><span class="main">]</span><span class="main">,</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∈</span>
     l_sort_set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> subsetD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

The reader will have observed that the simplification rule arising from the
second equation in the definition of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l_sort_aux›</span></span></span></span>, i.e. the one
whose right-hand side contains a conditional, has been ignored in the initial
backward steps of the previous proof. The reason is that it would actually make
more complex the conclusion of the corresponding subgoal, as can easily be
verified by trying to leave it enabled.

\null
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"l_sort_aux <span class="free">X</span> <span class="main">∈</span> l_sort_set <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> l_sort_aux.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 2
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹
\null

As a result of the application of the rule, the related subgoal takes the
following form:

\null

<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display, goals_limit = 1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>

\null

Now the conclusion is comprised of a conjunction of two implications. This is
pointless, since case distinction is faster than the application of conjunction
and implication introduction rules in providing sufficient assumptions for the
simplification of both the induction hypotheses and the conclusion.

\null
›</span></span>

<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

These considerations clearly do not depend on the particular function under
scrutiny, so that postponing the application of conditional simplification rules
to case distinction turns out to be a generally advisable strategy for the
accomplishment of step 4.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 5"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Two invariants are defined here below, one for each of the target correctness
theorems:

\null
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">l_sort_inv_1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder l_type <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">l_sort_inv_1</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span>l_sorted <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">∧</span> l_sorted <span class="main">(</span><span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span> <span class="main">∧</span>
  last <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∧</span> last <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">l_sort_inv_1</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span>l_sorted <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">∧</span> last <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">l_sort_inv_1</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span> <span class="main">=</span>
  l_sorted <span class="free"><span class="bound"><span class="entity">zs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">l_sort_inv_2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> l_type <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">l_sort_inv_2</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟶</span> fst <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">[]</span><span class="main">)</span> <span class="main">∧</span>
  l_count <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span> <span class="main">+</span> l_count <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>fst <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> l_count <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
  l_count <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

More precisely, the second invariant, whose type has to match
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a l_type ⇒ bool›</span></span></span></span> according to the method specification, shall be
comprised of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l_sort_inv_2 x xs›</span></span></span></span>, where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>xs›</span></span></span></span>
are the free variables appearing in the latter target theorem.

Both of the above definitions are non-recursive; command <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fun›</span></span></span></span> is used in
the former for the sole purpose of taking advantage of pattern matching.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 6"</span></span>

<span class="keyword1" id="CaseStudy1-l_sort_input_1"><span class="command">lemma</span></span> l_sort_input_1<span class="main">:</span> <span class="quoted"><span class="quoted">"l_sort_inv_1 <span class="main">(</span><span class="free">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="CaseStudy1-l_sort_input_2"><span class="command">lemma</span></span> l_sort_input_2<span class="main">:</span> <span class="quoted"><span class="quoted">"l_sort_inv_2 <span class="free">x</span> <span class="free">xs</span> <span class="main">(</span><span class="free">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sort_inv_2_def l_count_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 7"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">l_sort_form</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> l_type <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">l_sort_form</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> fst <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">[]</span>"</span></span>

<span class="keyword1" id="CaseStudy1-l_sort_intro_1"><span class="command">lemma</span></span> l_sort_intro_1<span class="main">:</span>
 <span class="quoted"><span class="quoted">"l_sort_inv_1 <span class="free">X</span> <span class="main">⟹</span> l_sorted <span class="main">(</span>l_sort_out <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_inv_1.cases <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">X</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sort_out_def<span class="main">)</span>

<span class="keyword1" id="CaseStudy1-l_sort_intro_2"><span class="command">lemma</span></span> l_sort_intro_2<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span>l_sort_inv_2 <span class="free">x</span> <span class="free">xs</span> <span class="free">X</span><span class="main">;</span> l_sort_form <span class="free">X</span><span class="main">⟧</span> <span class="main">⟹</span>
  l_count <span class="free">x</span> <span class="main">(</span>l_sort_out <span class="free">X</span><span class="main">)</span> <span class="main">=</span> l_count <span class="free">x</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sort_inv_2_def<span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">erule</span> conjE<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">,</span></span>
 <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sort_form_def l_sort_out_def l_count_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 8"</span></span>

<span class="keyword1" id="CaseStudy1-l_sort_form_aux_all"><span class="command">lemma</span></span> l_sort_form_aux_all<span class="main">:</span> <span class="quoted"><span class="quoted">"l_sort_form <span class="main">(</span>l_sort_aux <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_aux.induct <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">X</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> l_sort_form <span class="main"><span class="main"><span class="main">(</span></span></span>l_sort_aux <span class="bound"><span class="bound"><span class="bound">X</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span>
 <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sort_form_def<span class="main">)</span>

<span class="keyword1" id="CaseStudy1-l_sort_form_aux"><span class="command">lemma</span></span> l_sort_form_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"l_sort_form <span class="main">(</span>l_sort_aux <span class="main">(</span><span class="free">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_form_aux_all<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 9"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The proof of the first invariance property requires the following lemma, stating
that in case two lists are sorted, their concatenation still is such as long as
the last item of the former is not greater than the first one of the latter.

\null
›</span></span>

<span class="keyword1" id="CaseStudy1-l_sorted_app"><span class="command">lemma</span></span> l_sorted_app <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
 <span class="quoted"><span class="quoted">"l_sorted <span class="free">xs</span> <span class="main">⟶</span> l_sorted <span class="free">ys</span> <span class="main">⟶</span> last <span class="free">xs</span> <span class="main">≤</span> hd <span class="free">ys</span> <span class="main">⟶</span> l_sorted <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> l_sorted.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">rule</span> impI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"l_sorted <span class="free">ys</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> hd <span class="free">ys</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"l_sorted <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">ys</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="CaseStudy1-l_sort_invariance_1"><span class="command">lemma</span></span> l_sort_invariance_1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> XY<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">∈</span> l_sort_set <span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"l_sort_inv_1 <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_1 <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> XY
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_set.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_1 <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> X <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span>
  <span class="keyword3"><span class="command">assume</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"l_sort_inv_1 <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"l_sorted <span class="main">(</span><span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">as</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">as</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"l_sorted <span class="skolem">ys</span> <span class="main">∧</span> last <span class="skolem">ys</span> <span class="main">≤</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l_sorted <span class="main">[</span><span class="skolem">x</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sorted_app<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">z</span> <span class="skolem">zs</span>
  <span class="keyword3"><span class="command">assume</span></span> XZ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"l_sort_inv_1 <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"l_sorted <span class="main">(</span><span class="skolem">ys</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">as</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">as</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"l_sorted <span class="skolem">ys</span> <span class="main">∧</span> l_sorted <span class="main">(</span><span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∧</span> last <span class="skolem">ys</span> <span class="main">≤</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> XZ <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l_sorted <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sorted_app<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">z</span> <span class="skolem">zs</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> XZ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≤</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_1 <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_1 <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">z</span><span class="main">]</span><span class="main">,</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"l_sorted <span class="main">(</span><span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_1 <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="main">[</span><span class="skolem">z</span><span class="main">]</span><span class="main">,</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">zs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≤</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> XZ <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">as</span>
      <span class="keyword3"><span class="command">assume</span></span> zs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">zs</span> <span class="main">=</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">as</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≤</span> <span class="skolem">a</span> <span class="main">∧</span> l_sorted <span class="skolem">zs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l_sorted <span class="main">[</span><span class="skolem">z</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> zs * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> XZ <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">as</span>
    <span class="keyword3"><span class="command">assume</span></span> YS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">as</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_1 <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"l_sorted <span class="skolem">ys</span> <span class="main">∧</span> l_sorted <span class="main">(</span><span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">∧</span> last <span class="skolem">ys</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l_sorted <span class="main">[</span><span class="skolem">z</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> I'<span class="main">:</span> <span class="quoted"><span class="quoted">"l_sorted <span class="main">(</span><span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">z</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sorted_app<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">zs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_1 <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">z</span><span class="main">]</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I' <span class="keyword2"><span class="keyword">and</span></span> XZ <span class="keyword2"><span class="keyword">and</span></span> YS <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">b</span> <span class="skolem">bs</span>
      <span class="keyword3"><span class="command">assume</span></span> zs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">zs</span> <span class="main">=</span> <span class="skolem">b</span> <span class="main">#</span> <span class="skolem">bs</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≤</span> <span class="skolem">b</span> <span class="main">∧</span> l_sorted <span class="skolem">zs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> zs <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> I <span class="keyword2"><span class="keyword">and</span></span> I' <span class="keyword2"><span class="keyword">and</span></span> XZ <span class="keyword2"><span class="keyword">and</span></span> YS <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

Likewise, the proof of the second invariance property calls for the following
lemmas, stating that the number of occurrences of a value in a list is
additive with respect to both item prepending and list concatenation.

\null
›</span></span>

<span class="keyword1" id="CaseStudy1-l_count_cons"><span class="command">lemma</span></span> l_count_cons<span class="main">:</span> <span class="quoted"><span class="quoted">"l_count <span class="free">x</span> <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> l_count <span class="free">x</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span> <span class="main">+</span> l_count <span class="free">x</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_count_def<span class="main">)</span>

<span class="keyword1" id="CaseStudy1-l_count_app"><span class="command">lemma</span></span> l_count_app<span class="main">:</span> <span class="quoted"><span class="quoted">"l_count <span class="free">x</span> <span class="main">(</span><span class="free">ys</span> <span class="main">@</span> <span class="free">zs</span><span class="main">)</span> <span class="main">=</span> l_count <span class="free">x</span> <span class="free">ys</span> <span class="main">+</span> l_count <span class="free">x</span> <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_count_def<span class="main">)</span>

<span class="keyword1" id="CaseStudy1-l_sort_invariance_2"><span class="command">lemma</span></span> l_sort_invariance_2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> XY<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">∈</span> l_sort_set <span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"l_sort_inv_2 <span class="free">w</span> <span class="free">ws</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_2 <span class="free">w</span> <span class="free">ws</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> XY
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_set.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_2 <span class="free">w</span> <span class="free">ws</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> X <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">ys</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_2 <span class="free">w</span> <span class="free">ws</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_2 <span class="free">w</span> <span class="free">ws</span> <span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sort_inv_2_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> l_count_cons<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> l_count_app<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_count_def <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">z</span> <span class="skolem">zs</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_2 <span class="free">w</span> <span class="free">ws</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_2 <span class="free">w</span> <span class="free">ws</span> <span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sort_inv_2_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> l_count_cons<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> l_count_app<span class="main"><span class="keyword3">,</span></span>
   <span class="operator">subst</span> l_count_cons<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_count_def <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">z</span> <span class="skolem">zs</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_2 <span class="free">w</span> <span class="free">ws</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">,</span> <span class="skolem">z</span> <span class="main">#</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_2 <span class="free">w</span> <span class="free">ws</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">z</span><span class="main">]</span><span class="main">,</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sort_inv_2_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> l_count_cons<span class="main"><span class="keyword3">,</span></span>
   <span class="operator">subst</span> l_count_app<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_count_def <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 10"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="quoted"><span class="quoted">"l_sorted <span class="main">(</span>l_sort <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l_sort_aux <span class="var">?X</span> <span class="main">∈</span> l_sort_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_aux_set<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_1 <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_input_1<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_1 <span class="main">(</span>l_sort_aux <span class="var">?X</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_invariance_1<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"l_sorted <span class="main">(</span>l_sort_out <span class="main">(</span>l_sort_aux <span class="var">?X</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_intro_1<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?X</span> <span class="main">=</span> l_sort_in <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sort_in_def<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sort_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="quoted"><span class="quoted">"l_count <span class="free">x</span> <span class="main">(</span>l_sort <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> l_count <span class="free">x</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l_sort_aux <span class="var">?X</span> <span class="main">∈</span> l_sort_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_aux_set<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_2 <span class="free">x</span> <span class="free">xs</span> <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_input_2<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l_sort_inv_2 <span class="free">x</span> <span class="free">xs</span> <span class="main">(</span>l_sort_aux <span class="var">?X</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_invariance_2<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l_sort_form <span class="main">(</span>l_sort_aux <span class="var">?X</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_form_aux<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l_count <span class="free">x</span> <span class="main">(</span>l_sort_out <span class="main">(</span>l_sort_aux <span class="var">?X</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> l_count <span class="free">x</span> <span class="free">xs</span>"</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_sort_intro_2<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?X</span> <span class="main">=</span> l_sort_in <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sort_in_def<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_sort_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="CaseStudy2">
<div class="head">
<h1>Theory CaseStudy2</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       A General Method for the Proof of Theorems on Tail-recursive Functions
    Author:      Pasquale Noce
                 Security Certification Specialist at Arjo Systems - Gep S.p.A.
                 pasquale dot noce dot lavoro at gmail dot com
                 pasquale dot noce at arjowiggins-it dot com
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Case study 2"</span></span>

<span class="keyword1"><span class="command">theory</span></span> CaseStudy2
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <span class="quoted">"<a href="../../HOL/HOL-Library/Multiset.html">HOL-Library.Multiset</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

In the second case study, the problem will be examined of defining a function
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins›</span></span></span></span> performing item insertion into binary search trees (admitting value
repetitions) of elements of a linear order, and then proving the correctness of
this definition, i.e. that the trees output by the function still be sorted if
the input ones are and contain one more occurrence of the inserted value, the
number of occurrences of any other value being left unaltered.

Here below is a naive tail-recursive definition of such function:

\null
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> bintree <span class="main">=</span> Leaf <span class="main">|</span> Branch <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bintree"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bintree"</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>sequential<span class="main">)</span> <span class="entity">t_ins_naive</span> <span class="main">::</span>
 <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>linorder <span class="main">⇒</span> <span class="tfree">'a</span> bintree list <span class="main">⇒</span> <span class="tfree">'a</span> bintree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_naive</span> False <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>
  <span class="keyword1">then</span> <span class="free">t_ins_naive</span> False <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="main">#</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span>
  <span class="keyword1">else</span> <span class="free">t_ins_naive</span> False <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_naive</span> False <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Leaf <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="free">t_ins_naive</span> True <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Branch <span class="free"><span class="bound"><span class="entity">x</span></span></span> Leaf Leaf <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_naive</span> True <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="main">#</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>
  <span class="keyword1">then</span> <span class="free">t_ins_naive</span> True <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span>
  <span class="keyword1">else</span> <span class="free">t_ins_naive</span> True <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_naive</span> True <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">xt</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

The list appearing as the third argument, deputed to initially contain the sole
tree into which the second argument has to be inserted, is used to unfold all the
involved subtrees until a leaf is reached; then, such leaf is replaced with a branch
whose root value matches the second argument, and the subtree list is folded again.
The information on whether unfolding or folding is taking place is conveyed by the
first argument, whose value will respectively be <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>False›</span></span></span></span> or <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>True›</span></span></span></span>.

According to this plan, the computation is meant to terminate in correspondence
with pattern <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>True›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>_›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>[_]›</span></span></span></span>. Hence, the above naive
definition comprises a non-recursive equation for this pattern only, so that the
residual ones <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>True›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>_›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>_ # Leaf # _›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>_›</span></span></span></span>,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>_›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>[]›</span></span></span></span> are not covered by any equation.

That which decreases in recursive calls is the size of the head of the subtree
list during unfolding, and the length of the list during folding. Furthermore,
unfolding precedes folding in the recursive call pipeline, viz. there is a
recursive equation switching from unfolding to folding, but no one carrying out
the opposite transition. These considerations suggest that a measure function
suitable to prove the termination of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins_naive›</span></span></span></span> should roughly
match the sum of the length of the list and the size of the list head during
unfolding, and the length of the list alone during folding.

This idea can be refined by observing that the length of the list increases by one
at each recursive call during unfolding, and does not change in the recursive call
leading from unfolding to folding, at which the size of the input list head (a
leaf) equals zero. Therefore, in order that the measure function value be strictly
decreasing in each recursive call, the size of the list head has to be counted more
than once during unfolding -- e.g. twice --, and the length of the list has to be
decremented by one during folding -- no more than that, as otherwise the function
value would not change in the passage from a two-item to a one-item list.

As a result, a suitable measure function and the corresponding termination proof
are as follows:

\null
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">t_ins_naive_measure</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">×</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span> bintree list <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_naive_measure</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>
  <span class="keyword1">then</span> length <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">-</span> <span class="main">1</span>
  <span class="keyword1">else</span> length <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> size <span class="main">(</span>hd <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">termination</span></span> <span class="quoted">t_ins_naive</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure t_ins_naive_measure"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

Some further functions are needed to express the aforesaid correctness
properties of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins_naive›</span></span></span></span>:

\null
›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">t_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bintree <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_set</span> Leaf <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_set</span> <span class="main">(</span>Branch <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xl</span></span></span> <span class="free"><span class="bound"><span class="entity">xr</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">}</span> <span class="main">∪</span> <span class="free">t_set</span> <span class="free"><span class="bound"><span class="entity">xl</span></span></span> <span class="main">∪</span> <span class="free">t_set</span> <span class="free"><span class="bound"><span class="entity">xr</span></span></span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">t_multiset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bintree <span class="main">⇒</span> <span class="tfree">'a</span> multiset"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_multiset</span> Leaf <span class="main">=</span> <span class="main">{#}</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_multiset</span> <span class="main">(</span>Branch <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xl</span></span></span> <span class="free"><span class="bound"><span class="entity">xr</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{#</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#}</span> <span class="main">+</span> <span class="free">t_multiset</span> <span class="free"><span class="bound"><span class="entity">xl</span></span></span> <span class="main">+</span> <span class="free">t_multiset</span> <span class="free"><span class="bound"><span class="entity">xr</span></span></span>"</span></span>

<span class="keyword1" id="CaseStudy2-t_set_multiset"><span class="command">lemma</span></span> t_set_multiset<span class="main">:</span> <span class="quoted"><span class="quoted">"t_set <span class="free">xt</span> <span class="main">=</span> set_mset <span class="main">(</span>t_multiset <span class="free">xt</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">t_sorted</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder bintree <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_sorted</span> Leaf <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_sorted</span> <span class="main">(</span>Branch <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xl</span></span></span> <span class="free"><span class="bound"><span class="entity">xr</span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> t_set <span class="free"><span class="bound"><span class="entity">xl</span></span></span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> t_set <span class="free"><span class="bound"><span class="entity">xr</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> <span class="free">t_sorted</span> <span class="free"><span class="bound"><span class="entity">xl</span></span></span> <span class="main">∧</span> <span class="free">t_sorted</span> <span class="free"><span class="bound"><span class="entity">xr</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">t_count</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> bintree <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_count</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="main">≡</span> count <span class="main">(</span>t_multiset <span class="free"><span class="bound"><span class="entity">xt</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

Functions <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_set›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_multiset›</span></span></span></span> return the set and the multiset,
respectively, of the items of the input tree; the connection between them
expressed by lemma <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_set_multiset›</span></span></span></span> will be used in step 9.

The target correctness theorems can then be enunciated as follows:

\null

<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_sorted xt ⟶ t_sorted (t_ins_naive False x [xt])›</span></span></span></span>

\null

<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_count y (t_ins_naive False x [xt]) =›</span></span></span></span>

<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(if y = x then Suc else id) (t_count y xt)›</span></span></span></span>
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 1"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This time, the Cartesian product of the input types will be implemented as a
record type. The second command instructs the system to regard such type as a
datatype, thus enabling record patterns:

\null
›</span></span>

<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'a</span> t_type <span class="main">=</span>
 folding <span class="main">::</span> <span class="quoted">bool</span>
 item <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
 subtrees <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bintree list"</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>sequential<span class="main">)</span> <span class="entity">t_ins_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder t_type <span class="main">⇒</span> <span class="tfree">'a</span> t_type"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_aux</span> <span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>
  <span class="keyword1">then</span> <span class="free">t_ins_aux</span> <span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span>
    subtrees <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="main">#</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span>
  <span class="keyword1">else</span> <span class="free">t_ins_aux</span> <span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span>
    subtrees <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_aux</span> <span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> Leaf <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span> <span class="main">=</span>
  <span class="free">t_ins_aux</span> <span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="free"><span class="bound"><span class="entity">x</span></span></span> Leaf Leaf <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_aux</span> <span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="main">#</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>
  <span class="keyword1">then</span> <span class="free">t_ins_aux</span> <span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span>
  <span class="keyword1">else</span> <span class="free">t_ins_aux</span> <span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_aux</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

Observe that the pattern appearing in the non-recursive equation matches any
one of the residual patterns
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⦇folding = True, item = _, subtrees = [_]⦈›</span></span></span></span>,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⦇folding = True, item = _, subtrees = _ # Leaf # _⦈›</span></span></span></span>,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⦇folding = _, item = _, subtrees = []⦈›</span></span></span></span>, thus complying with the
requirement that the definition of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins_aux›</span></span></span></span> be total.

Since the arguments of recursive calls in the definition of function
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins_aux›</span></span></span></span> are the same as those of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins_naive›</span></span></span></span>,
the termination proof developed for the latter can be applied to the former
as well by just turning the input product type of the previous measure
function into the input record type of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins_aux›</span></span></span></span>.

\null
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">t_ins_aux_measure</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> t_type <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_aux_measure</span> <span class="main">⦇</span>folding <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>
  <span class="keyword1">then</span> length <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">-</span> <span class="main">1</span>
  <span class="keyword1">else</span> length <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> size <span class="main">(</span>hd <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">termination</span></span> <span class="quoted">t_ins_aux</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure t_ins_aux_measure"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 2"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">t_ins_in</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> bintree <span class="main">⇒</span> <span class="tfree">'a</span> t_type"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_in</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="main">≡</span> <span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">xt</span></span></span><span class="main">]</span><span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">t_ins_out</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> t_type <span class="main">⇒</span> <span class="tfree">'a</span> bintree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_out</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> hd <span class="main">(</span>subtrees <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">t_ins</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder <span class="main">⇒</span> <span class="tfree">'a</span> bintree <span class="main">⇒</span> <span class="tfree">'a</span> bintree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="main">≡</span> t_ins_out <span class="main">(</span>t_ins_aux <span class="main">(</span>t_ins_in <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

Since the significant inputs of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins_naive›</span></span></span></span> match pattern
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>False›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>_›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>[_]›</span></span></span></span>, those of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins_aux›</span></span></span></span>
match pattern <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⦇folding = False, item = _, subtrees = [_]⦈›</span></span></span></span>, thus
being in a one-to-one correspondence with the Cartesian product of the types
of the second and the third component.

Then, the target correctness theorems can be put into the following equivalent
form:

\null

<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_sorted xt ⟶ t_sorted (t_ins x xt)›</span></span></span></span>

\null

<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_count y (t_ins x xt) =›</span></span></span></span>
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(if y = x then Suc else id) (t_count y xt)›</span></span></span></span>
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 3"</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">t_ins_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder t_type <span class="main">⇒</span> <span class="tfree">'a</span> t_type set"</span></span>
<span class="keyword2"><span class="keyword">for</span></span> <span class="entity">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> t_type"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
R0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> <span class="free">t_ins_set</span> <span class="free">X</span>"</span></span> <span class="main">|</span>
R1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span> <span class="main">∈</span> <span class="free">t_ins_set</span> <span class="free">X</span><span class="main">;</span>
     <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">⟧</span> <span class="main">⟹</span>
     <span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="main">#</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span>
       <span class="main">∈</span> <span class="free">t_ins_set</span> <span class="free">X</span>"</span></span> <span class="main">|</span>
R2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span> <span class="main">∈</span> <span class="free">t_ins_set</span> <span class="free">X</span><span class="main">;</span>
     <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">⟧</span> <span class="main">⟹</span>
     <span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span>
       <span class="main">∈</span> <span class="free">t_ins_set</span> <span class="free">X</span>"</span></span> <span class="main">|</span>
R3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> Leaf <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span> <span class="main">∈</span> <span class="free">t_ins_set</span> <span class="free">X</span> <span class="main">⟹</span>
     <span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="free"><span class="bound"><span class="entity">x</span></span></span> Leaf Leaf <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span>
       <span class="main">∈</span> <span class="free">t_ins_set</span> <span class="free">X</span>"</span></span> <span class="main">|</span>
R4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="main">#</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span>
       <span class="main">∈</span> <span class="free">t_ins_set</span> <span class="free">X</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">⟧</span> <span class="main">⟹</span>
     <span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span> <span class="main">∈</span> <span class="free">t_ins_set</span> <span class="free">X</span>"</span></span> <span class="main">|</span>
R5<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="main">#</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">yr</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span>
       <span class="main">∈</span> <span class="free">t_ins_set</span> <span class="free">X</span><span class="main">;</span> <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">⟧</span> <span class="main">⟹</span>
     <span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">yl</span></span></span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span> <span class="main">∈</span> <span class="free">t_ins_set</span> <span class="free">X</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 4"</span></span>

<span class="keyword1" id="CaseStudy2-t_ins_subset"><span class="command">lemma</span></span> t_ins_subset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> XY<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">∈</span> t_ins_set <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"t_ins_set <span class="free">Y</span> <span class="main">⊆</span> t_ins_set <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> t_ins_set.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">∈</span> t_ins_set <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> XY <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="skolem">ts</span>
  <span class="keyword3"><span class="command">assume</span></span>
   <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span> <span class="main">∈</span> t_ins_set <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> <span class="skolem">yl</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span>
   <span class="main">∈</span> t_ins_set <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R1<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="skolem">ts</span>
  <span class="keyword3"><span class="command">assume</span></span>
   <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span> <span class="main">∈</span> t_ins_set <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> <span class="skolem">yr</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span>
   <span class="main">∈</span> t_ins_set <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R2<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">ts</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> Leaf <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span> <span class="main">∈</span> t_ins_set <span class="free">X</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="skolem">x</span> Leaf Leaf <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span>
   <span class="main">∈</span> t_ins_set <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R3<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">xt</span> <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="skolem">ts</span>
  <span class="keyword3"><span class="command">assume</span></span>
   <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> <span class="skolem">xt</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span> <span class="main">∈</span> t_ins_set <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="skolem">y</span> <span class="skolem">xt</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span> <span class="main">∈</span> t_ins_set <span class="free">X</span>"</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R4<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">xt</span> <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="skolem">ts</span>
  <span class="keyword3"><span class="command">assume</span></span>
   <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> <span class="skolem">xt</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span> <span class="main">∈</span> t_ins_set <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">xt</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span> <span class="main">∈</span> t_ins_set <span class="free">X</span>"</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R5<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="CaseStudy2-t_ins_aux_set"><span class="command">lemma</span></span> t_ins_aux_set<span class="main">:</span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="free">X</span> <span class="main">∈</span> t_ins_set <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> t_ins_aux.induct<span class="main"><span class="keyword3">,</span></span>
 <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> R0 <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> t_ins_aux.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span> 3<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="skolem">ts</span>
  <span class="keyword1"><span class="command">let</span></span>
   <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
   <span class="var"><span class="quoted"><span class="var">?X'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> <span class="skolem">yl</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
   <span class="var"><span class="quoted"><span class="var">?X''</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> <span class="skolem">yr</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span>
   case1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span> <span class="main">⟹</span> t_ins_aux <span class="var">?X'</span> <span class="main">∈</span> t_ins_set <span class="var">?X'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
   case2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span> <span class="main">⟹</span> t_ins_aux <span class="var">?X''</span> <span class="main">∈</span> t_ins_set <span class="var">?X''</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> 0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?X</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R0<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="var">?X</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> 0 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?X'</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R1<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"t_ins_set <span class="var">?X'</span> <span class="main">⊆</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_subset<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="var">?X'</span> <span class="main">∈</span> t_ins_set <span class="var">?X'</span>"</span></span>
     <span class="keyword1"><span class="command">using</span></span> case1 <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="var">?X'</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> subsetD<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> 0 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?X''</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R2<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"t_ins_set <span class="var">?X''</span> <span class="main">⊆</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_subset<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="var">?X''</span> <span class="main">∈</span> t_ins_set <span class="var">?X''</span>"</span></span>
     <span class="keyword1"><span class="command">using</span></span> case2 <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="var">?X''</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> subsetD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">ts</span>
  <span class="keyword1"><span class="command">let</span></span>
   <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> Leaf <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
   <span class="var"><span class="quoted"><span class="var">?X'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="skolem">x</span> Leaf Leaf <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?X</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R0<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?X'</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R3<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"t_ins_set <span class="var">?X'</span> <span class="main">⊆</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="var">?X'</span> <span class="main">∈</span> t_ins_set <span class="var">?X'</span>"</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="var">?X'</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> subsetD<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xt</span> <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="skolem">ts</span>
  <span class="keyword1"><span class="command">let</span></span>
   <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> <span class="skolem">xt</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
   <span class="var"><span class="quoted"><span class="var">?X'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="skolem">y</span> <span class="skolem">xt</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
   <span class="var"><span class="quoted"><span class="var">?X''</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="skolem">x</span><span class="main">,</span> subtrees <span class="main">=</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">xt</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">⦈</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span>
   case1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span> <span class="main">⟹</span> t_ins_aux <span class="var">?X'</span> <span class="main">∈</span> t_ins_set <span class="var">?X'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
   case2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span> <span class="main">⟹</span> t_ins_aux <span class="var">?X''</span> <span class="main">∈</span> t_ins_set <span class="var">?X''</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> 0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?X</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R0<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="var">?X</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> 0 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?X'</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R4<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"t_ins_set <span class="var">?X'</span> <span class="main">⊆</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_subset<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="var">?X'</span> <span class="main">∈</span> t_ins_set <span class="var">?X'</span>"</span></span>
     <span class="keyword1"><span class="command">using</span></span> case1 <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="var">?X'</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> subsetD<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> 0 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?X''</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> R5<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"t_ins_set <span class="var">?X''</span> <span class="main">⊆</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_subset<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="var">?X''</span> <span class="main">∈</span> t_ins_set <span class="var">?X''</span>"</span></span>
     <span class="keyword1"><span class="command">using</span></span> case2 <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="var">?X''</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> subsetD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 5"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">t_val</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bintree <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_val</span> <span class="main">(</span>Branch <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xl</span></span></span> <span class="free"><span class="bound"><span class="entity">xr</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">t_left</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bintree <span class="main">⇒</span> <span class="tfree">'a</span> bintree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_left</span> <span class="main">(</span>Branch <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xl</span></span></span> <span class="free"><span class="bound"><span class="entity">xr</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">xl</span></span></span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">t_right</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bintree <span class="main">⇒</span> <span class="tfree">'a</span> bintree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_right</span> <span class="main">(</span>Branch <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xl</span></span></span> <span class="free"><span class="bound"><span class="entity">xr</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">xr</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

The partiality of the definition of the previous functions, which merely return
the root value and either subtree of the input branch, does not matter as they
will be applied to branches only.

These functions are used to define the following invariant -- this time, a single
invariant for both of the target correctness theorems:

\null
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">t_ins_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder <span class="main">⇒</span> <span class="tfree">'a</span> bintree <span class="main">⇒</span> <span class="tfree">'a</span> t_type <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_inv</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="main">⦇</span>folding <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">,</span> item <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">⦈</span> <span class="main">=</span>
  <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>length <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">}</span><span class="main">.</span>
    <span class="main">(</span>t_sorted <span class="free"><span class="bound"><span class="entity">xt</span></span></span> <span class="main">⟶</span> t_sorted <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">0</span> <span class="main">&lt;</span> <span class="bound">n</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span> <span class="bound">yl</span> <span class="bound">yr</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">!</span> <span class="bound">n</span> <span class="main">=</span> Branch <span class="bound">y</span> <span class="bound">yl</span> <span class="bound">yr</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span><span class="keyword1">let</span> <span class="bound">ts'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xt</span></span></span> Leaf<span class="main">]</span> <span class="keyword1">in</span> t_multiset <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">∧</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">{#</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#}</span> <span class="keyword1">else</span> <span class="main">{#}</span><span class="main">)</span> <span class="main">+</span>
      <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> t_val <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span>
        <span class="keyword1">then</span> t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1">else</span> t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

More precisely, the invariant, whose type has to match <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a t_type ⇒ bool›</span></span></span></span>
according to the method specification, shall be comprised of function
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins_inv x xt›</span></span></span></span>, where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>xt›</span></span></span></span> are the free variables
appearing in the target theorems as the arguments of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 6"</span></span>

<span class="keyword1" id="CaseStudy2-t_ins_input"><span class="command">lemma</span></span> t_ins_input<span class="main">:</span> <span class="quoted"><span class="quoted">"t_ins_inv <span class="free">x</span> <span class="free">xt</span> <span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="free">x</span><span class="main">,</span> subtrees <span class="main">=</span> <span class="main">[</span><span class="free">xt</span><span class="main">]</span><span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 7"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">t_ins_form</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> t_type <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_form</span> <span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> <span class="main">[</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">]</span><span class="main">⦈</span> <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_form</span> <span class="main">⦇</span>folding <span class="main">=</span> True<span class="main">,</span> item <span class="main">=</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span> subtrees <span class="main">=</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">#</span> Leaf <span class="main">#</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">⦈</span> <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_form</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> False"</span></span>

<span class="keyword1" id="CaseStudy2-t_ins_intro_1"><span class="command">lemma</span></span> t_ins_intro_1<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span>t_ins_inv <span class="free">x</span> <span class="free">xt</span> <span class="free">X</span><span class="main">;</span> t_ins_form <span class="free">X</span><span class="main">⟧</span> <span class="main">⟹</span>
  t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span>t_ins_out <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_form.cases <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">X</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> t_ins_out_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="CaseStudy2-t_ins_intro_2"><span class="command">lemma</span></span> t_ins_intro_2<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span>t_ins_inv <span class="free">x</span> <span class="free">xt</span> <span class="free">X</span><span class="main">;</span> t_ins_form <span class="free">X</span><span class="main">⟧</span> <span class="main">⟹</span>
  t_count <span class="free">y</span> <span class="main">(</span>t_ins_out <span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">then</span> Suc <span class="keyword1">else</span> id<span class="main">)</span> <span class="main">(</span>t_count <span class="free">y</span> <span class="free">xt</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_form.cases <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">X</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> t_ins_out_def t_count_def<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\null

Defining predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins_form›</span></span></span></span> by means of pattern matching rather than
quantifiers permits a faster proof of the introduction rules through a case
distinction followed by simplification. These steps leave the subgoal
corresponding to pattern
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⦇folding = True, item = _, subtrees = _ # Leaf # _⦈›</span></span></span></span> to be proven, which
can be done \emph{ad absurdum} as this pattern is incompatible with the invariant,
stating that all the subtrees in the list except for its head are branches.

The reason why this pattern, unlike
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⦇folding = _, item = _, subtrees = []⦈›</span></span></span></span>, is not filtered by predicate
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins_form›</span></span></span></span>, is that the lack of its occurrences in recursive calls in
correspondence with significant inputs cannot be proven by rule inversion,
being it compatible with the patterns introduced by rules <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>R3›</span></span></span></span>,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>R4›</span></span></span></span>, and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>R5›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 8"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This step will be accomplished by first proving by recursion induction that
the outputs of function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins_aux›</span></span></span></span> match either of the patterns
satisfying predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t_ins_form›</span></span></span></span> or else the residual one
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⦇folding = _, item = _, subtrees = []⦈›</span></span></span></span>, and then proving by rule
inversion that the last pattern may not occur in recursive calls in
correspondence with significant inputs.

\null
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">t_ins_form_all</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> t_type <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_ins_form_all</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> t_ins_form <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∨</span> subtrees <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">[]</span>"</span></span>

<span class="keyword1" id="CaseStudy2-t_ins_form_aux_all"><span class="command">lemma</span></span> t_ins_form_aux_all<span class="main">:</span> <span class="quoted"><span class="quoted">"t_ins_form_all <span class="main">(</span>t_ins_aux <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_aux.induct <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">X</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> t_ins_form_all <span class="main"><span class="main"><span class="main">(</span></span></span>t_ins_aux <span class="bound"><span class="bound"><span class="bound">X</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span>
 <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> t_ins_form_all_def<span class="main">)</span>

<span class="keyword1" id="CaseStudy2-t_ins_form_aux"><span class="command">lemma</span></span> t_ins_form_aux<span class="main">:</span>
 <span class="quoted"><span class="quoted">"t_ins_form <span class="main">(</span>t_ins_aux <span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="free">x</span><span class="main">,</span> subtrees <span class="main">=</span> <span class="main">[</span><span class="free">xt</span><span class="main">]</span><span class="main">⦈</span><span class="main">)</span>"</span></span>
 <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">(</span>t_ins_aux <span class="var">?X</span><span class="main">)</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">using</span></span> t_ins_aux_set <span class="main">[</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span><span class="main">]</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_set.cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> t_ins_form_aux_all <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var"><span class="quoted"><span class="var">?X</span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> t_ins_form_all_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 9"</span></span>

<span class="keyword1" id="CaseStudy2-t_ins_invariance"><span class="command">lemma</span></span> t_ins_invariance<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> XY<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">∈</span> t_ins_set <span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"t_ins_inv <span class="free">x</span> <span class="free">xt</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"t_ins_inv <span class="free">x</span> <span class="free">xt</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> XY <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> defined_all<span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_set.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"t_ins_inv <span class="free">x</span> <span class="free">xt</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> X <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="skolem">ts</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> <span class="free">x</span> <span class="main">∧</span>
   <span class="main">(</span><span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span>
     <span class="main">(</span>t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span><span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="main">0</span> <span class="main">&lt;</span> <span class="bound">n</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">.</span> <span class="skolem">ts</span> <span class="main">!</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span> Branch <span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="keyword1">let</span> <span class="bound">ts'</span> <span class="main">=</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span>
       <span class="keyword1">in</span> t_multiset <span class="main">(</span><span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span>
           <span class="keyword1">then</span> t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span>
           <span class="keyword1">else</span> t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">n</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">n</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword3"><span class="command">assume</span></span> xy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span>
   <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">.</span>
     <span class="main">(</span>t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span><span class="main">(</span><span class="skolem">yl</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="main">0</span> <span class="main">&lt;</span> <span class="bound">n</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">.</span> <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span>
       Branch <span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="keyword1">let</span> <span class="bound">ts'</span> <span class="main">=</span> <span class="skolem">yl</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span>
       <span class="keyword1">in</span> t_multiset <span class="main">(</span><span class="main">(</span><span class="skolem">yl</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span>
           <span class="keyword1">then</span> t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span>
           <span class="keyword1">else</span> t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?Q</span> <span class="bound">n</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
    <span class="keyword3"><span class="command">assume</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Q</span> <span class="skolem">n</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def xy 0<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">m</span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Suc<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">m</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="skolem">ts</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> <span class="free">x</span> <span class="main">∧</span>
   <span class="main">(</span><span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span>
     <span class="main">(</span>t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span><span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="main">0</span> <span class="main">&lt;</span> <span class="bound">n</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">.</span> <span class="skolem">ts</span> <span class="main">!</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span> Branch <span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="keyword1">let</span> <span class="bound">ts'</span> <span class="main">=</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span>
       <span class="keyword1">in</span> t_multiset <span class="main">(</span><span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span>
           <span class="keyword1">then</span> t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span>
           <span class="keyword1">else</span> t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">n</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">n</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword3"><span class="command">assume</span></span> xy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span>
   <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">.</span>
     <span class="main">(</span>t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span><span class="main">(</span><span class="skolem">yr</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="main">0</span> <span class="main">&lt;</span> <span class="bound">n</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">.</span> <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span>
       Branch <span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="keyword1">let</span> <span class="bound">ts'</span> <span class="main">=</span> <span class="skolem">yr</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span>
       <span class="keyword1">in</span> t_multiset <span class="main">(</span><span class="main">(</span><span class="skolem">yr</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span>
           <span class="keyword1">then</span> t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span>
           <span class="keyword1">else</span> t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?Q</span> <span class="bound">n</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
    <span class="keyword3"><span class="command">assume</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Q</span> <span class="skolem">n</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def xy 0<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">m</span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Suc<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">m</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">ts</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> <span class="free">x</span> <span class="main">∧</span>
   <span class="main">(</span><span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span>
     <span class="main">(</span>t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span><span class="main">(</span>Leaf <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="main">0</span> <span class="main">&lt;</span> <span class="bound">n</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span> <span class="bound">yl</span> <span class="bound">yr</span><span class="main">.</span> <span class="skolem">ts</span> <span class="main">!</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span> Branch <span class="bound">y</span> <span class="bound">yl</span> <span class="bound">yr</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="keyword1">let</span> <span class="bound">ts'</span> <span class="main">=</span> Leaf <span class="main">#</span> <span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span>
       <span class="keyword1">in</span> t_multiset <span class="main">(</span><span class="main">(</span>Leaf <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span>
           <span class="keyword1">then</span> t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span>
           <span class="keyword1">else</span> t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">n</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">n</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword3"><span class="command">show</span></span>
   <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span>
     <span class="main">(</span>t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span><span class="main">(</span>Branch <span class="free">x</span> Leaf Leaf <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="keyword1">let</span> <span class="bound">ts'</span> <span class="main">=</span> Branch <span class="free">x</span> Leaf Leaf <span class="main">#</span> <span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span>
       <span class="keyword1">in</span> t_multiset <span class="main">(</span><span class="main">(</span>Branch <span class="free">x</span> Leaf Leaf <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">{#</span><span class="free">x</span><span class="main">#}</span> <span class="keyword1">else</span> <span class="main">{#}</span><span class="main">)</span> <span class="main">+</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span>
           <span class="keyword1">then</span> t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span>
           <span class="keyword1">else</span> t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?Q</span> <span class="bound">n</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
    <span class="keyword3"><span class="command">assume</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Q</span> <span class="skolem">n</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def 0 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">m</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I <span class="keyword2"><span class="keyword">and</span></span> n <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Suc<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">zt</span> <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="skolem">ts</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> <span class="free">x</span> <span class="main">∧</span>
   <span class="main">(</span><span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">.</span>
     <span class="main">(</span>t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span><span class="main">(</span><span class="skolem">zt</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="main">0</span> <span class="main">&lt;</span> <span class="bound">n</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">.</span> <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span>
       Branch <span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="keyword1">let</span> <span class="bound">ts'</span> <span class="main">=</span> <span class="skolem">zt</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span>
       <span class="keyword1">in</span> t_multiset <span class="main">(</span><span class="main">(</span><span class="skolem">zt</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">{#</span><span class="free">x</span><span class="main">#}</span> <span class="keyword1">else</span> <span class="main">{#}</span><span class="main">)</span> <span class="main">+</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span>
           <span class="keyword1">then</span> t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span>
           <span class="keyword1">else</span> t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">n</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">n</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword3"><span class="command">assume</span></span> xy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span>
   <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span>
     <span class="main">(</span>t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span><span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">zt</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="main">0</span> <span class="main">&lt;</span> <span class="bound">n</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">.</span> <span class="skolem">ts</span> <span class="main">!</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span> Branch <span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="keyword1">let</span> <span class="bound">ts'</span> <span class="main">=</span> Branch <span class="skolem">y</span> <span class="skolem">zt</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span>
       <span class="keyword1">in</span> t_multiset <span class="main">(</span><span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">zt</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">{#</span><span class="free">x</span><span class="main">#}</span> <span class="keyword1">else</span> <span class="main">{#}</span><span class="main">)</span> <span class="main">+</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span>
           <span class="keyword1">then</span> t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span>
           <span class="keyword1">else</span> t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?Q</span> <span class="bound">n</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
    <span class="keyword3"><span class="command">assume</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Q</span> <span class="skolem">n</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">hence</span></span> I0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="skolem">zt</span><span class="main">)</span> <span class="main">∧</span>
       t_multiset <span class="skolem">zt</span> <span class="main">=</span> <span class="main">{#</span><span class="free">x</span><span class="main">#}</span> <span class="main">+</span> t_multiset <span class="skolem">yl</span>"</span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def xy<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Suc <span class="main">0</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">hence</span></span> I1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
       t_multiset <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span><span class="main">)</span> <span class="main">=</span>
       <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span>
        <span class="keyword1">then</span> t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1">else</span> t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def 0 <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> t_sorted.simps <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split<span class="main"><span class="keyword3">,</span></span>
       <span class="operator">rule</span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def 0 <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> t_sorted.simps<span class="main"><span class="keyword3">,</span></span>
       <span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span>2<span class="main"><span class="improper">]</span></span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> impI<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"t_sorted <span class="free">xt</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"t_sorted <span class="skolem">zt</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_sorted <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I1 <span class="keyword2"><span class="keyword">and</span></span> s <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_set <span class="skolem">zt</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">∪</span> t_set <span class="skolem">yl</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I0
         <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> t_set_multiset<span class="main">)</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"t_sorted <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">zt</span> <span class="skolem">yr</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xy <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
         t_multiset <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"add_mset <span class="skolem">y</span> <span class="main">(</span>t_multiset <span class="skolem">zt</span> <span class="main">+</span> t_multiset <span class="skolem">yr</span><span class="main">)</span> <span class="main">=</span>
         add_mset <span class="free">x</span> <span class="main">(</span>t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I0
         <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
         t_multiset <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"add_mset <span class="skolem">y</span> <span class="main">(</span>t_multiset <span class="skolem">zt</span> <span class="main">+</span> t_multiset <span class="skolem">yr</span><span class="main">)</span> <span class="main">=</span>
         add_mset <span class="free">x</span> <span class="main">(</span>t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I0
         <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">m</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Suc<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">zt</span> <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="skolem">ts</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> <span class="free">x</span> <span class="main">∧</span>
   <span class="main">(</span><span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">.</span>
     <span class="main">(</span>t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span><span class="main">(</span><span class="skolem">zt</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="main">0</span> <span class="main">&lt;</span> <span class="bound">n</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">.</span> <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span>
       Branch <span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="keyword1">let</span> <span class="bound">ts'</span> <span class="main">=</span> <span class="skolem">zt</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span>
       <span class="keyword1">in</span> t_multiset <span class="main">(</span><span class="main">(</span><span class="skolem">zt</span> <span class="main">#</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">{#</span><span class="free">x</span><span class="main">#}</span> <span class="keyword1">else</span> <span class="main">{#}</span><span class="main">)</span> <span class="main">+</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span> <span class="main">#</span> <span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span>
           <span class="keyword1">then</span> t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span>
           <span class="keyword1">else</span> t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">n</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">n</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword3"><span class="command">assume</span></span> xy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span>
   <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span>
     <span class="main">(</span>t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span><span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">zt</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="main">0</span> <span class="main">&lt;</span> <span class="bound">n</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">.</span> <span class="skolem">ts</span> <span class="main">!</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span> Branch <span class="bound">y'</span> <span class="bound">yl'</span> <span class="bound">yr'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
     <span class="main">(</span><span class="keyword1">let</span> <span class="bound">ts'</span> <span class="main">=</span> Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">zt</span> <span class="main">#</span> <span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span>
       <span class="keyword1">in</span> t_multiset <span class="main">(</span><span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">zt</span> <span class="main">#</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">{#</span><span class="free">x</span><span class="main">#}</span> <span class="keyword1">else</span> <span class="main">{#}</span><span class="main">)</span> <span class="main">+</span>
         <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span>
           <span class="keyword1">then</span> t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span>
           <span class="keyword1">else</span> t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="bound">ts'</span> <span class="main">!</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> <span class="var">?Q</span> <span class="bound">n</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
    <span class="keyword3"><span class="command">assume</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Q</span> <span class="skolem">n</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">hence</span></span> I0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="skolem">zt</span><span class="main">)</span> <span class="main">∧</span>
       t_multiset <span class="skolem">zt</span> <span class="main">=</span> <span class="main">{#</span><span class="free">x</span><span class="main">#}</span> <span class="main">+</span> t_multiset <span class="skolem">yr</span>"</span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def xy<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Suc <span class="main">0</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">hence</span></span> I1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
       t_multiset <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span><span class="main">)</span> <span class="main">=</span>
       <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span>
        <span class="keyword1">then</span> t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1">else</span> t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def 0 <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> t_sorted.simps <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split<span class="main"><span class="keyword3">,</span></span>
       <span class="operator">rule</span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def 0 <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> t_sorted.simps<span class="main"><span class="keyword3">,</span></span>
       <span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span>2<span class="main"><span class="improper">]</span></span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> impI<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"t_sorted <span class="free">xt</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"t_sorted <span class="skolem">zt</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_sorted <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I1 <span class="keyword2"><span class="keyword">and</span></span> s <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_set <span class="skolem">zt</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">∪</span> t_set <span class="skolem">yr</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I0
         <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> t_set_multiset<span class="main">)</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"t_sorted <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">zt</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xy <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
         t_multiset <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"add_mset <span class="skolem">y</span> <span class="main">(</span>t_multiset <span class="skolem">yl</span> <span class="main">+</span> t_multiset <span class="skolem">zt</span><span class="main">)</span> <span class="main">=</span>
         add_mset <span class="free">x</span> <span class="main">(</span>t_multiset <span class="main">(</span>t_left <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I0
         <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">x</span> <span class="main">≤</span> t_val <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
         t_multiset <span class="main">(</span>Branch <span class="skolem">y</span> <span class="skolem">yl</span> <span class="skolem">yr</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"add_mset <span class="skolem">y</span> <span class="main">(</span>t_multiset <span class="skolem">yl</span> <span class="main">+</span> t_multiset <span class="skolem">zt</span><span class="main">)</span> <span class="main">=</span>
         add_mset <span class="free">x</span> <span class="main">(</span>t_multiset <span class="main">(</span>t_right <span class="main">(</span><span class="main">(</span><span class="skolem">ts</span> <span class="main">@</span> <span class="main">[</span>Branch <span class="free">x</span> <span class="free">xt</span> Leaf<span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I0
         <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">m</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">n</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Suc<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Step 10"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="quoted"><span class="quoted">"t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span>t_ins <span class="free">x</span> <span class="free">xt</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="free">x</span><span class="main">,</span> subtrees <span class="main">=</span> <span class="main">[</span><span class="free">xt</span><span class="main">]</span><span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="var">?X</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_aux_set<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_ins_inv <span class="free">x</span> <span class="free">xt</span> <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_input<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_ins_inv <span class="free">x</span> <span class="free">xt</span> <span class="main">(</span>t_ins_aux <span class="var">?X</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_invariance<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_ins_form <span class="main">(</span>t_ins_aux <span class="var">?X</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_form_aux<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_sorted <span class="free">xt</span> <span class="main">⟶</span> t_sorted <span class="main">(</span>t_ins_out <span class="main">(</span>t_ins_aux <span class="var">?X</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_intro_1<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?X</span> <span class="main">=</span> t_ins_in <span class="free">x</span> <span class="free">xt</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> t_ins_in_def<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> t_ins_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="quoted"><span class="quoted">"t_count <span class="free">y</span> <span class="main">(</span>t_ins <span class="free">x</span> <span class="free">xt</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">then</span> Suc <span class="keyword1">else</span> id<span class="main">)</span> <span class="main">(</span>t_count <span class="free">y</span> <span class="free">xt</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>folding <span class="main">=</span> False<span class="main">,</span> item <span class="main">=</span> <span class="free">x</span><span class="main">,</span> subtrees <span class="main">=</span> <span class="main">[</span><span class="free">xt</span><span class="main">]</span><span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_ins_aux <span class="var">?X</span> <span class="main">∈</span> t_ins_set <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_aux_set<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_ins_inv <span class="free">x</span> <span class="free">xt</span> <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_input<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_ins_inv <span class="free">x</span> <span class="free">xt</span> <span class="main">(</span>t_ins_aux <span class="var">?X</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_invariance<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_ins_form <span class="main">(</span>t_ins_aux <span class="var">?X</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_form_aux<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"t_count <span class="free">y</span> <span class="main">(</span>t_ins_out <span class="main">(</span>t_ins_aux <span class="var">?X</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">then</span> Suc <span class="keyword1">else</span> id<span class="main">)</span> <span class="main">(</span>t_count <span class="free">y</span> <span class="free">xt</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_ins_intro_2<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?X</span> <span class="main">=</span> t_ins_in <span class="free">x</span> <span class="free">xt</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> t_ins_in_def<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> t_ins_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>