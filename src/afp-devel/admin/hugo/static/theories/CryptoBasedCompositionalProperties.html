<div id="ListExtras">
<div class="head"><h1>Theory ListExtras</h1>
<span class="command">theory</span> <span class="name">ListExtras</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
   Title:  Theory ListExtras.thy
   Author: Maria Spichkova &lt;maria.spichkova at rmit.edu.au&gt;, 2014
*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Auxiliary Theory ListExtras.thy›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>ListExtras</span><span> 
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>disjoint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"disjoint x y ≡  (set x) ∩ (set y) = {}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span>
</span><span>  </span><span>mem</span><span> </span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a list ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mem"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x mem [] = False"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x mem (y # l) = ((x = y) ∨ (x mem l))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>memS</span><span> </span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"memS x l  ≡  x ∈ (set l)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem_memS_eq</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x mem l ≡ memS x l"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>memS_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>la</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>la</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>memS_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem_set_1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a mem l"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set l"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>memS_def</span><span> </span><span>mem_memS_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem_set_2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set l"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a mem l"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>memS_def</span><span> </span><span>mem_memS_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_inter_mem</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x mem l1"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x mem l2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set l1 ∩ set l2 ≠ {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>IntI</span><span> </span><span>empty_iff</span><span> </span><span>mem_set_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem_notdisjoint</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x mem l1"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x mem l2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ disjoint l1 l2"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>disjoint_def</span><span> </span><span>set_inter_mem</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem_notdisjoint2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"disjoint (schedule A) (schedule B)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x mem schedule A"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ x mem schedule B"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" x mem schedule B"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>h2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>this</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬  disjoint (schedule A) (schedule B)"</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mem_notdisjoint</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>h1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>this</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ x mem schedule B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Add_Less</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; b"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"(Suc a - b &lt; Suc a) = True"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_length_hint1</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≠ []"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"0 &lt; length l"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_length_hint1a</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≠ []"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"0 &lt; length l"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_length_hint2</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length x  = Suc 0"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"[hd x] = x"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Zero_neq_Suc</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>length_Suc_conv</span><span> </span><span>neq_Nil_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_length_hint2a</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length l = Suc 0"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"tl l = []"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list_length_hint2</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_length_hint3</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length l = Suc 0"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"l ≠ []"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Zero_neq_Suc</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_length_hint4</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length x ≤ Suc 0"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ []"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length x = Suc 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_0_eq</span><span> </span><span>le_Suc_eq</span><span> </span><span>length_greater_0_conv</span><span> </span><span>less_numeral_extra</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_nonempty</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ []"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"Suc 0 ≤ length x"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_greater_0_conv</span><span> </span><span>less_eq_Suc_le</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_nth_length</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ []"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"x ! ((length x) - Suc 0) = last x"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>last_conv_nth</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_nth_append0</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"x ! i = (x @ z) ! i"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_nth_append1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"(b # x) ! i = (b # x @ y) ! i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length (b # x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(b # x) ! i = ((b # x) @ y) ! i"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>list_nth_append0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_nth_append2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; Suc (length x)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"(b # x) ! i = (b # x @ a # y) ! i"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_eq_appendI</span><span> </span><span>length_Suc_conv</span><span> </span><span>list_nth_append0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_nth_append3</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ i &lt; Suc (length x)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i - Suc (length x) &lt; Suc (length y)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a # y) ! (i - Suc (length x)) = (b # x @ a # y) ! i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i=0"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>h1</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ii</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = Suc ii"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>h1</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_nth_append4</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; Suc (length x + length y)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ i - Suc (length x) &lt; Suc (length y)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_nth_append5</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i - length x &lt; Suc (length y)"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ i - Suc (length x) &lt; Suc (length y)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬  i &lt; Suc (length x + length y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_nth_append6</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ i - length x &lt; Suc (length y)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ i - Suc (length x) &lt; Suc (length y)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ i &lt; Suc (length x + length y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_nth_append6a</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; Suc (length x + length y)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ i - length x &lt; Suc (length y)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_nth_append7</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i - length x &lt; Suc (length y)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i - Suc (length x) &lt; Suc (length y)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"i &lt; Suc (Suc (length x + length y))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_nth_append8</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ i &lt; Suc (length x + length y)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; Suc (Suc (length x + length y))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"i = Suc (length x + length y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_nth_append9</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i - Suc (length x) &lt; Suc (length y)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"i &lt; Suc (Suc (length x + length y))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_nth_append10</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ i &lt; Suc (length x)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ i - Suc (length x) &lt; Suc (length y)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ i &lt; Suc (Suc (length x + length y))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Secrecy_types">
<div class="head"><h1>Theory Secrecy_types</h1>
<span class="command">theory</span> <span class="name">Secrecy_types</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
   Title: Theory  Secrecy_types.thy
   Author:    Maria Spichkova &lt;maria.spichkova at rmit.edu.au&gt;, 2014
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Auxiliary data types›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Secrecy_types</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment">― ‹We assume disjoint sets: Data of data values,›</span><span>
</span><span class="comment">― ‹Secrets of unguessable values, Keys - set of cryptographic  keys.›</span><span>  
</span><span class="comment">― ‹Based on these sets, we specify the sets EncType of encryptors that may be›</span><span>
</span><span class="comment">― ‹used for encryption or decryption, and Expression of expression items.›</span><span>
</span><span class="comment">― ‹The specification (component) identifiers should be listed in the set specID,›</span><span>
</span><span class="comment">― ‹the channel indentifiers should be listed in the set chanID.›</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>Keys</span><span> </span><span class="delimiter">=</span><span> </span><span>CKey</span><span> </span><span class="delimiter">|</span><span> </span><span>CKeyP</span><span> </span><span class="delimiter">|</span><span> </span><span>SKey</span><span> </span><span class="delimiter">|</span><span> </span><span>SKeyP</span><span> </span><span class="delimiter">|</span><span> </span><span>genKey</span><span> 
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>Secrets</span><span> </span><span class="delimiter">=</span><span> </span><span>secretD</span><span> </span><span class="delimiter">|</span><span> </span><span>N</span><span> </span><span class="delimiter">|</span><span> </span><span>NA</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>Var</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>Data</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>KS</span><span>          </span><span class="delimiter">=</span><span> </span><span>kKS</span><span> </span><span>Keys</span><span> </span><span class="delimiter">|</span><span> </span><span>sKS</span><span> </span><span>Secrets</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>EncType</span><span>  </span><span class="delimiter">=</span><span> </span><span>kEnc</span><span> </span><span>Keys</span><span> </span><span class="delimiter">|</span><span> </span><span>vEnc</span><span> </span><span>Var</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>specID</span><span> </span><span class="delimiter">=</span><span> </span><span>sComp1</span><span> </span><span class="delimiter">|</span><span> </span><span>sComp2</span><span> </span><span class="delimiter">|</span><span> </span><span>sComp3</span><span> </span><span class="delimiter">|</span><span> </span><span>sComp4</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>Expression</span><span> </span><span class="delimiter">=</span><span> </span><span>kE</span><span> </span><span>Keys</span><span> </span><span class="delimiter">|</span><span> </span><span>sE</span><span> </span><span>Secrets</span><span> </span><span class="delimiter">|</span><span> </span><span>dE</span><span> </span><span>Data</span><span> </span><span class="delimiter">|</span><span> </span><span>idE</span><span> </span><span>specID</span><span> 
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>chanID</span><span> </span><span class="delimiter">=</span><span> </span><span>ch1</span><span> </span><span class="delimiter">|</span><span> </span><span>ch2</span><span>   </span><span class="delimiter">|</span><span> </span><span>ch3</span><span>  </span><span class="delimiter">|</span><span> </span><span>ch4</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>Expression2KSL</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"Expression list ⇒ KS list"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"Expression2KSL [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"Expression2KSL (x#xs) = 
     ((case x of (kE m) ⇒ [kKS m] 
                  | (sE m) ⇒ [sKS m] 
                  | (dE m) ⇒ [] 
                  | (idE m) ⇒ []) @ Expression2KSL xs) "</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>KS2Expression</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"KS ⇒ Expression"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"KS2Expression (kKS m) = (kE m)"</span></span></span><span>  </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"KS2Expression (sKS m) = (sE m)"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="inout">
<div class="head"><h1>Theory inout</h1>
<span class="command">theory</span> <span class="name">inout</span><br/>
<span class="keyword">imports</span> <a href="Secrecy_types.html"><span class="name">Secrecy_types</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
   Title: Theory  inout.thy
   Author:    Maria Spichkova &lt;maria.spichkova at rmit.edu.au&gt;, 2014
*)</span></span></span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of the relations between sets of Input/Output channels›</span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">theory</span></span><span>  </span><span>inout</span><span> 
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Secrecy_types</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> 
</span><span>  </span><span>subcomponents</span><span> </span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ specID set"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Mappings, defining sets of input, local, and output channels›</span><span>
</span><span class="comment">― ‹of a component›</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span>
</span><span>  </span><span>ins</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ chanID set"</span></span></span><span>
</span><span>  </span><span>loc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ chanID set"</span></span></span><span>
</span><span>  </span><span>out</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ chanID set"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Predicate insuring the correct mapping from the component identifier›</span><span>
</span><span class="comment">― ‹to the set of input channels of a component›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>inStream</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ chanID set ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inStream x y  ≡ (ins x = y)"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Predicate insuring the correct mapping from the component identifier›</span><span>
</span><span class="comment">― ‹to the set of local channels of a component›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>locStream</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ chanID set ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"locStream x y ≡ (loc x = y)"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Predicate insuring the correct mapping from the component identifier›</span><span>
</span><span class="comment">― ‹to the set of output channels of a component›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>outStream</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ chanID set ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"outStream x y ≡ (out x = y)"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Predicate insuring the correct relations between›</span><span>
</span><span class="comment">― ‹to the set of input, output and local channels of a component›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>correctInOutLoc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"correctInOutLoc x ≡ 
   (ins x) ∩ (out x) = {} 
    ∧ (ins x) ∩ (loc x) = {} 
    ∧ (loc x) ∩ (out x) = {} "</span></span></span><span> 
</span><span>
</span><span class="comment">― ‹Predicate insuring the correct relations between›</span><span>
</span><span class="comment">― ‹sets of input channels within a composed component›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>correctCompositionIn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn x ≡ 
  (ins x) = (⋃ (ins ` (subcomponents x)) - (loc x))
  ∧ (ins x) ∩ (⋃ (out ` (subcomponents x))) = {}"</span></span></span><span> 
</span><span>
</span><span class="comment">― ‹Predicate insuring the correct relations between›</span><span>
</span><span class="comment">― ‹sets of output channels within a composed component›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>correctCompositionOut</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut x ≡ 
  (out x) = (⋃ (out ` (subcomponents x))- (loc x))
  ∧ (out x) ∩ (⋃ (ins ` (subcomponents x))) = {} "</span></span></span><span> 
</span><span>
</span><span class="comment">― ‹Predicate insuring the correct relations between›</span><span>
</span><span class="comment">― ‹sets of local channels within a composed component›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>correctCompositionLoc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc x ≡ 
   (loc x) = ⋃ (ins ` (subcomponents x))
           ∩ ⋃ (out ` (subcomponents x))"</span></span></span><span> 
</span><span>
</span><span class="comment">― ‹If a component is an elementary one (has no subcomponents)›</span><span>
</span><span class="comment">― ‹its set of local channels should be empty›</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subcomponents_loc</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc x"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents x = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"loc x = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionLoc_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Secrecy">
<div class="head"><h1>Theory Secrecy</h1>
<span class="command">theory</span> <span class="name">Secrecy</span><br/>
<span class="keyword">imports</span> <a href="inout.html"><span class="name">inout</span></a> <a href="ListExtras.html"><span class="name">ListExtras</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
   Title: Theory  Secrecy.thy
   Author:    Maria Spichkova &lt;maria.spichkova at rmit.edu.au&gt;, 2014
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Secrecy: Definitions and properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Secrecy</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Secrecy_types</span><span> </span><span>inout</span><span> </span><span>ListExtras</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment">― ‹Encryption, decryption, signature creation and signature verification functions›</span><span>
</span><span class="comment">― ‹For these functions we define only their signatures and general axioms,›</span><span>
</span><span class="comment">― ‹because in order to reason effectively, we view them as abstract functions and›</span><span>
</span><span class="comment">― ‹abstract from their implementation details›</span><span> 
</span><span class="keyword1"><span class="command">consts</span></span><span> 
</span><span>  </span><span>Enc</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"Keys ⇒ Expression list ⇒ Expression list"</span></span></span><span>
</span><span>  </span><span>Decr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"Keys ⇒ Expression list ⇒ Expression list"</span></span></span><span>
</span><span>  </span><span>Sign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"Keys ⇒ Expression list ⇒ Expression list"</span></span></span><span>
</span><span>  </span><span>Ext</span><span>   </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"Keys ⇒ Expression list ⇒ Expression list"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Axioms on relations between encription and decription keys›</span><span>
</span><span class="keyword1"><span class="command">axiomatization</span></span><span>
</span><span>   </span><span>EncrDecrKeys</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"Keys  ⇒ Keys ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>ExtSign</span><span class="delimiter">:</span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">"EncrDecrKeys K1 K2 ⟶ (Ext K1 (Sign K2 E)) = E"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>DecrEnc</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"EncrDecrKeys K1 K2 ⟶ (Decr K2 (Enc K1 E)) = E"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Set of private keys of a component›</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span>
</span><span> </span><span>specKeys</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ Keys set"</span></span></span><span>
</span><span class="comment">― ‹Set of unguessable values used by a component›</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> 
</span><span> </span><span>specSecrets</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ Secrets set"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Join set of private keys and unguessable values used by a component›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>specKeysSecrets</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ KS set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"specKeysSecrets C ≡
  {y .  ∃ x. y = (kKS x)  ∧ (x ∈ (specKeys C))} ∪
  {z .  ∃ s. z = (sKS s)  ∧ (s ∈ (specSecrets C))}"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Predicate defining that a list of expression items does not contain›</span><span>
</span><span class="comment">― ‹any private key  or unguessable value used by a component›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>notSpecKeysSecretsExpr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒  Expression list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"notSpecKeysSecretsExpr P e ≡
     (∀ x. (kE x) mem e ⟶ (kKS x) ∉ specKeysSecrets P) ∧
     (∀ y. (sE y) mem e ⟶ (sKS y) ∉ specKeysSecrets P)"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹If a component is a composite one, the set of its private keys›</span><span> 
</span><span class="comment">― ‹is a union of the subcomponents' sets of the private keys›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>correctCompositionKeys</span><span> </span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKeys x ≡
    subcomponents x ≠ {} ⟶ 
    specKeys x =  ⋃ (specKeys ` (subcomponents x))"</span></span></span><span> 
</span><span>
</span><span class="comment">― ‹If a component is a composite one, the set of its unguessable values›</span><span> 
</span><span class="comment">― ‹is a union of the subcomponents' sets of the unguessable values›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>correctCompositionSecrets</span><span> </span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"correctCompositionSecrets x ≡
    subcomponents x ≠ {} ⟶ 
    specSecrets x =  ⋃ (specSecrets ` (subcomponents x))"</span></span></span><span> 
</span><span>
</span><span class="comment">― ‹If a component is a composite one, the set of its private keys and›</span><span> 
</span><span class="comment">― ‹unguessable values is a union of the corresponding sets of its subcomponents›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>correctCompositionKS</span><span> </span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS x ≡
    subcomponents x ≠ {} ⟶ 
    specKeysSecrets x =  ⋃ (specKeysSecrets ` (subcomponents x))"</span></span></span><span> 
</span><span>
</span><span class="comment">― ‹Predicate defining set of correctness properties of the component's›</span><span>
</span><span class="comment">― ‹interface  and relations on its private keys and unguessable values›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>correctComponentSecrecy</span><span>  </span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"correctComponentSecrecy x ≡ 
    correctCompositionKS x ∧ 
    correctCompositionSecrets x ∧ 
    correctCompositionKeys x ∧ 
    correctCompositionLoc x ∧
    correctCompositionIn x ∧
    correctCompositionOut x ∧ 
    correctInOutLoc x"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Predicate exprChannel I E defines whether the expression item E can be sent via the channel I›</span><span>    
</span><span class="keyword1"><span class="command">consts</span></span><span>
</span><span> </span><span>exprChannel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"chanID ⇒ Expression ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Predicate eoutM sP M E defines whether the component sP may eventually›</span><span>
</span><span class="comment">― ‹output an expression E if there exists a time interval t of›</span><span> 
</span><span class="comment">― ‹an output channel which contains this expression E›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>eout</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID  ⇒ Expression ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"eout sP E ≡ 
  ∃ (ch :: chanID). ((ch ∈ (out sP)) ∧ (exprChannel ch E))"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Predicate eout sP E defines whether the component sP may eventually›</span><span>
</span><span class="comment">― ‹output an expression E via subset of channels M,›</span><span>
</span><span class="comment">― ‹which is a subset of output channels of sP,›</span><span>
</span><span class="comment">― ‹and if there exists a time interval t of›</span><span> 
</span><span class="comment">― ‹an output channel which contains this expression E›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>eoutM</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID  ⇒ chanID set ⇒ Expression ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutM sP M E ≡ 
  ∃ (ch :: chanID). ((ch ∈ (out sP)) ∧ (ch ∈ M) ∧ (exprChannel ch E))"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Predicate ineM sP M E defines whether a component sP may eventually›</span><span>
</span><span class="comment">― ‹get an expression E  if there exists a time interval t of›</span><span> 
</span><span class="comment">― ‹an input stream  which contains this expression E›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>ine</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID  ⇒ Expression ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"ine sP E ≡ 
  ∃ (ch :: chanID). ((ch ∈ (ins sP)) ∧ (exprChannel ch E))"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Predicate ine sP E defines whether a component sP may eventually›</span><span>
</span><span class="comment">― ‹get an expression E via subset of channels M,›</span><span>
</span><span class="comment">― ‹which is a subset of input channels of sP,›</span><span>
</span><span class="comment">― ‹and if there exists a time interval t of›</span><span> 
</span><span class="comment">― ‹an input stream  which contains this expression E›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>ineM</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID  ⇒ chanID set ⇒ Expression ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"ineM sP M E ≡ 
  ∃ (ch :: chanID). ((ch ∈ (ins sP)) ∧ (ch ∈ M) ∧ (exprChannel ch E))"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹This predicate defines whether an input channel ch of a component sP›</span><span>
</span><span class="comment">― ‹is the only one input channel of this component›</span><span>
</span><span class="comment">― ‹via which it may eventually output an expression E›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>out_exprChannelSingle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID  ⇒ chanID ⇒ Expression ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"out_exprChannelSingle sP ch E ≡ 
  (ch ∈ (out sP)) ∧  
  (exprChannel ch E)  ∧
  (∀ (x :: chanID) (t :: nat). ((x ∈ (out sP)) ∧ (x ≠ ch) ⟶ ¬ exprChannel x E))"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹This predicate  yields true if only the channels from the set chSet,›</span><span>
</span><span class="comment">― ‹which is a subset of input channels of the  component sP,›</span><span>
</span><span class="comment">― ‹may eventually output an expression E›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>out_exprChannelSet</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID  ⇒ chanID set ⇒ Expression ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"out_exprChannelSet sP chSet E ≡ 
   ((∀ (x ::chanID). ((x ∈ chSet) ⟶ ((x ∈ (out sP)) ∧ (exprChannel x E))))
   ∧
   (∀ (x :: chanID). ((x ∉ chSet) ∧ (x ∈ (out sP)) ⟶ ¬ exprChannel x E)))"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹This redicate defines whether›</span><span>
</span><span class="comment">― ‹an input channel ch of a component sP is the only one input channel›</span><span>
</span><span class="comment">― ‹of this component via which it may eventually get an expression E›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>ine_exprChannelSingle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID  ⇒ chanID ⇒ Expression ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"ine_exprChannelSingle sP ch E ≡ 
  (ch ∈ (ins sP)) ∧
  (exprChannel ch E)  ∧
  (∀ (x :: chanID) (t :: nat). (( x ∈ (ins sP)) ∧ (x ≠ ch) ⟶ ¬ exprChannel x E))"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹This predicate yields true if the component sP may eventually›</span><span>
</span><span class="comment">― ‹get an expression E only via the channels from the set chSet,›</span><span>
</span><span class="comment">― ‹which is a subset of input channels of sP›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>ine_exprChannelSet</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID  ⇒ chanID set ⇒ Expression ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"ine_exprChannelSet sP chSet E ≡ 
   ((∀ (x ::chanID). ((x ∈ chSet) ⟶ ((x ∈ (ins sP)) ∧ (exprChannel x E))))
   ∧
   (∀ (x :: chanID). ((x ∉ chSet) ∧ ( x ∈ (ins sP)) ⟶ ¬ exprChannel x E)))"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹If a list of expression items does not contain any private key›</span><span>
</span><span class="comment">― ‹or unguessable value of a component P, then the first element›</span><span> 
</span><span class="comment">― ‹of the list is neither a private key nor unguessable value of P›</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>notSpecKeysSecretsExpr_L1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"notSpecKeysSecretsExpr P (a # l)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"notSpecKeysSecretsExpr P [a]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>notSpecKeysSecretsExpr_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹If a list of expression items does not contain any private key›</span><span>
</span><span class="comment">― ‹or unguessable value of a component P, then this list without its first›</span><span> 
</span><span class="comment">― ‹element does not contain them too›</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>notSpecKeysSecretsExpr_L2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"notSpecKeysSecretsExpr P (a # l)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"notSpecKeysSecretsExpr P l"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>notSpecKeysSecretsExpr_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹If a channel belongs to the set of input channels of a component P›</span><span>
</span><span class="comment">― ‹and does not belong to the set of local channels of the compositon of P and Q›</span><span> 
</span><span class="comment">― ‹then it belongs to the set of input channels of this composition›</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionIn_L1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∉ loc PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins P"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins PQ"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionIn_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">― ‹If a channel belongs to the set of input channels of the compositon of P and Q›</span><span>
</span><span class="comment">― ‹then it belongs to the set of input channels either of P or of Q›</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionIn_L2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins PQ"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"(ch ∈ ins P) ∨ (ch ∈ ins Q)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionIn_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ineM_L1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ M"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exprChannel ch E"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ineM P M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ineM_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ineM_ine</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ineM P M E"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ine P E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ineM_def</span><span> </span><span>ine_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_ine_ineM</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine P E"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ ineM P M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ineM_def</span><span> </span><span>ine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eoutM_eout</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutM P M E"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"eout P E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eoutM_def</span><span> </span><span>eout_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_eout_eoutM</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ eout P E"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ eoutM P M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eoutM_def</span><span> </span><span>eout_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKeys_subcomp1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKeys C"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ subcomponents C"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xb ∈ specKeys C"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ x ∈ subcomponents C. (xb ∈ specKeys x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKeys_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionSecrets_subcomp1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionSecrets C"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ subcomponents C"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ specSecrets C"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ x ∈ subcomponents C. (s ∈ specSecrets x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionSecrets_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKeys_subcomp2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKeys C"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xb ∈ subcomponents C"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xc ∈ specKeys xb"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xc ∈ specKeys C"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKeys_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionSecrets_subcomp2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionSecrets C"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xb ∈ subcomponents C"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xc ∈ specSecrets xb"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"xc ∈ specSecrets C"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionSecrets_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompKS_Keys</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS C"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKeys C"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKeys_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_def</span><span> 
</span><span>                </span><span>correctCompositionKeys_def</span><span>
</span><span>                </span><span>specKeysSecrets_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompKS_Secrets</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS C"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"correctCompositionSecrets C"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionSecrets_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_def</span><span> 
</span><span>                </span><span>correctCompositionSecrets_def</span><span>
</span><span>                </span><span>specKeysSecrets_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompKS_KeysSecrets</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKeys C"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionSecrets C"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS C"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_def</span><span> 
</span><span>                </span><span>correctCompositionKeys_def</span><span> 
</span><span>                </span><span>correctCompositionSecrets_def</span><span>
</span><span>                </span><span>specKeysSecrets_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_subcomp1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS C"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ∈ subcomponents C"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xa ∈ specKeys C"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃ y ∈ subcomponents C. (xa ∈ specKeys y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_def</span><span> </span><span>specKeysSecrets_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_subcomp2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS C"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ∈ subcomponents C"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xa ∈ specSecrets C"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃ y ∈ subcomponents C. xa ∈ specSecrets y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents C ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_def</span><span> </span><span>specKeysSecrets_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_subcomp3</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS C"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ subcomponents C"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xa ∈ specKeys x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"xa ∈ specKeys C"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_def</span><span> </span><span>specKeysSecrets_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_subcomp4</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS C"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ subcomponents C"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xa ∈ specSecrets x"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"xa ∈ specSecrets C"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_def</span><span> </span><span>specKeysSecrets_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_PQ</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ks ∈ specKeysSecrets PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ks ∈ specKeysSecrets P ∨ ks ∈ specKeysSecrets Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_neg1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ks ∉ specKeysSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ks ∉ specKeysSecrets Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ks ∉ specKeysSecrets PQ"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_negP</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ks ∉ specKeysSecrets PQ"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"ks ∉ specKeysSecrets P"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_negQ</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ks ∉ specKeysSecrets PQ"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"ks ∉ specKeysSecrets Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>out_exprChannelSingle_Set</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"out_exprChannelSingle P ch E"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"out_exprChannelSet P {ch} E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>out_exprChannelSingle_def</span><span> </span><span>out_exprChannelSet_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>out_exprChannelSet_Single</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"out_exprChannelSet P {ch} E"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"out_exprChannelSingle P ch E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>out_exprChannelSingle_def</span><span> </span><span>out_exprChannelSet_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ine_exprChannelSingle_Set</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine_exprChannelSingle P ch E"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine_exprChannelSet P {ch} E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_exprChannelSingle_def</span><span> </span><span>ine_exprChannelSet_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ine_exprChannelSet_Single</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine_exprChannelSet P {ch} E"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ine_exprChannelSingle P ch E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_exprChannelSingle_def</span><span> </span><span>ine_exprChannelSet_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ine_ins_neg1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine P m"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exprChannel x m"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"x ∉ ins P"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem1a</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine PQ E"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine P E  ∨ ine Q E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_def</span><span> </span><span>correctCompositionIn_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem1b</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ineM PQ M E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ineM P M E ∨ ineM Q M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ineM_def</span><span> </span><span>correctCompositionIn_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem2a</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eout PQ E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"eout P E ∨ eout Q E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eout_def</span><span> </span><span>correctCompositionOut_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem2b</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutM PQ M E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"eoutM P M E ∨ eoutM Q M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eoutM_def</span><span> </span><span>correctCompositionOut_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionIn_prop1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (ins PQ)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(x ∈ (ins P)) ∨ (x ∈ (ins Q))"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionIn_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionOut_prop1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (out PQ)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"(x ∈ (out P)) ∨ (x ∈ (out Q))"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionOut_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem3a</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (ine P E)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (ine Q E)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ (ine PQ E)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_def</span><span> </span><span>correctCompositionIn_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBlemma3b</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ (ineM P M E)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ (ineM Q M E)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>chM</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ch ∈ M"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>chPQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eCh</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"exprChannel ch E"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins P"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>chM</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eCh</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ineM P M E"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ineM_L1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ch ∉ ins P"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>chPQ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ch ∈ ins P) ∨ (ch ∈ ins Q)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionIn_L2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins Q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>chM</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eCh</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ineM Q M E"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ineM_L1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem3b</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (ineM P M E)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (ineM Q M E)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ (ineM PQ M E)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>TBtheorem1b</span><span class="delimiter">)</span><span>    
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem4a_empty</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ine P E) ∨ (ine Q E)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"loc PQ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ine PQ E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_def</span><span> </span><span>correctCompositionIn_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem4a_P</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine P E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ ch. (ch ∈ (ins P) ∧ exprChannel ch E ∧ ch ∉ (loc PQ))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ine PQ E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_def</span><span> </span><span>correctCompositionIn_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem4b_P</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ineM P M E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ ch. ((ch ∈ (ins Q)) ∧ (exprChannel ch E) ∧ 
                        (ch ∉ (loc PQ)) ∧ (ch ∈ M))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ineM PQ M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ineM_def</span><span> </span><span>correctCompositionIn_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem4a_PQ</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ine P E) ∨ (ine Q E)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ ch. (((ch ∈ (ins P)) ∨ (ch ∈ (ins Q) )) ∧ 
                         (exprChannel ch E) ∧  (ch ∉ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ine PQ E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_def</span><span> </span><span>correctCompositionIn_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem4b_PQ</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ineM P M E) ∨ (ineM Q M E)"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ ch. (((ch ∈ (ins P)) ∨ (ch ∈ (ins Q) )) ∧ 
                         (ch ∈ M) ∧ (exprChannel ch E) ∧  (ch ∉ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"ineM PQ M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ineM_def</span><span> </span><span>correctCompositionIn_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem4a_notP1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine P E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine Q E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ ch. ((ine_exprChannelSingle P ch E) ∧ (ch ∈ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ ine PQ E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_def</span><span> </span><span>correctCompositionIn_def</span><span> 
</span><span>                     </span><span>ine_exprChannelSingle_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem4b_notP1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ineM P M E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ineM Q M E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>  
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ ch. ((ine_exprChannelSingle P ch E) ∧ (ch ∈ M) 
                     ∧ (ch ∈ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ ineM PQ M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ineM_def</span><span> </span><span>correctCompositionIn_def</span><span> 
</span><span>                     </span><span>ine_exprChannelSingle_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem4a_notP2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine Q E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine_exprChannelSet P ChSet E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (x ::chanID). ((x ∈ ChSet) ⟶ (x ∈ (loc PQ)))"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ ine PQ E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_def</span><span> </span><span>correctCompositionIn_def</span><span> 
</span><span>                     </span><span>ine_exprChannelSet_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem4b_notP2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ineM Q M E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine_exprChannelSet P ChSet E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (x ::chanID). ((x ∈ ChSet) ⟶ (x ∈ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ ineM PQ M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ineM_def</span><span> </span><span>correctCompositionIn_def</span><span> 
</span><span>                     </span><span>ine_exprChannelSet_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem4a_notPQ</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine_exprChannelSet P ChSetP E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine_exprChannelSet Q ChSetQ E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (x ::chanID). ((x ∈ ChSetP) ⟶ (x ∈ (loc PQ)))"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (x ::chanID). ((x ∈ ChSetQ) ⟶ (x ∈ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ ine PQ E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_def</span><span> </span><span>correctCompositionIn_def</span><span> 
</span><span>                     </span><span>ine_exprChannelSet_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ineM_Un1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ineM P A E"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ineM P (A Un B) E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ineM_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem4b_notPQ</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine_exprChannelSet P ChSetP E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine_exprChannelSet Q ChSetQ E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (x ::chanID). ((x ∈ ChSetP) ⟶ (x ∈ (loc PQ)))"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (x ::chanID). ((x ∈ ChSetQ) ⟶ (x ∈ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">" ¬ ineM PQ M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ineM_def</span><span> </span><span>correctCompositionIn_def</span><span> 
</span><span>                     </span><span>ine_exprChannelSet_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ine_nonempty_exprChannelSet</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine_exprChannelSet P ChSet E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ChSet ≠ {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ine P E "</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_def</span><span> </span><span>ine_exprChannelSet_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ine_empty_exprChannelSet</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine_exprChannelSet P ChSet E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ChSet = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ ine P E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_def</span><span> </span><span>ine_exprChannelSet_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem5a_empty</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(eout P E) ∨ (eout Q E)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"loc PQ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"eout PQ E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eout_def</span><span> </span><span>correctCompositionOut_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem45a_P</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eout P E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ ch. ((ch ∈ (out P)) ∧ (exprChannel ch E) ∧ 
                        (ch ∉ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"eout PQ E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eout_def</span><span> </span><span>correctCompositionOut_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheore54b_P</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutM P M E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ ch. ((ch ∈ (out Q)) ∧ (exprChannel ch E) ∧ 
                        (ch ∉ (loc PQ)) ∧ (ch ∈ M) )"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"eoutM PQ M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eoutM_def</span><span> </span><span>correctCompositionOut_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem5a_PQ</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(eout P E) ∨ (eout Q E)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ ch. (((ch ∈ (out P)) ∨ (ch ∈ (out Q) )) ∧ 
                        (exprChannel ch E) ∧  (ch ∉ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"eout PQ E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eout_def</span><span> </span><span>correctCompositionOut_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem5b_PQ</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(eoutM P M E) ∨ (eoutM Q M E)"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ ch. (((ch ∈ (out P)) ∨ (ch ∈ (out Q) )) ∧ (ch ∈ M) 
                      ∧ (exprChannel ch E) ∧  (ch ∉ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"eoutM PQ M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eoutM_def</span><span> </span><span>correctCompositionOut_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem5a_notP1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eout P E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ eout Q E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ ch. ((out_exprChannelSingle P ch E) ∧ (ch ∈ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ eout PQ E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eout_def</span><span> </span><span>correctCompositionOut_def</span><span> 
</span><span>                      </span><span>out_exprChannelSingle_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem5b_notP1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutM P M E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ eoutM Q M E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ ch. ((out_exprChannelSingle P ch E) ∧ (ch ∈ M) 
                   ∧ (ch ∈ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ eoutM PQ M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eoutM_def</span><span> </span><span>correctCompositionOut_def</span><span> 
</span><span>                     </span><span>out_exprChannelSingle_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem5a_notP2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ eout Q E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"out_exprChannelSet P ChSet E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (x ::chanID). ((x ∈ ChSet) ⟶ (x ∈ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ eout PQ E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eout_def</span><span> </span><span>correctCompositionOut_def</span><span> 
</span><span>                     </span><span>out_exprChannelSet_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem5b_notP2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ eoutM Q M E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"out_exprChannelSet P ChSet E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (x ::chanID). ((x ∈ ChSet) ⟶ (x ∈ (loc PQ)))"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ eoutM PQ M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eoutM_def</span><span> </span><span>correctCompositionOut_def</span><span> 
</span><span>                     </span><span>out_exprChannelSet_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem5a_notPQ</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"out_exprChannelSet P ChSetP E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"out_exprChannelSet Q ChSetQ E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (x ::chanID). ((x ∈ ChSetP) ⟶ (x ∈ (loc PQ)))"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (x ::chanID). ((x ∈ ChSetQ) ⟶ (x ∈ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ eout PQ E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eout_def</span><span> </span><span>correctCompositionOut_def</span><span> 
</span><span>                     </span><span>out_exprChannelSet_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TBtheorem5b_notPQ</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionOut PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"out_exprChannelSet P ChSetP E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"out_exprChannelSet Q ChSetQ E"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = ChSetP ∪ ChSetQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (x ::chanID). ((x ∈ ChSetP) ⟶ (x ∈ (loc PQ)))"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (x ::chanID). ((x ∈ ChSetQ) ⟶ (x ∈ (loc PQ)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ eoutM PQ M E"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eoutM_def</span><span> </span><span>correctCompositionOut_def</span><span> 
</span><span>                     </span><span>out_exprChannelSet_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> 
</span></pre>
</div>
</div><div id="CompLocalSecrets">
<div class="head"><h1>Theory CompLocalSecrets</h1>
<span class="command">theory</span> <span class="name">CompLocalSecrets</span><br/>
<span class="keyword">imports</span> <a href="Secrecy.html"><span class="name">Secrecy</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
   Title:  Theory  CompLocalSecrets.thy
   Author: Maria Spichkova &lt;maria.spichkova at rmit.edu.au&gt;, 2014
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Local Secrets of a component›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CompLocalSecrets</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Secrecy</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment">― ‹Set of local secrets: the set of secrets which does not belong to›</span><span>
</span><span class="comment">― ‹the set of private keys and unguessable values, but are transmitted›</span><span>
</span><span class="comment">― ‹via local channels or belongs to the local secrets of its subcomponents›</span><span>
</span><span class="keyword1"><span class="command">axiomatization</span></span><span>
</span><span>  </span><span>LocalSecrets</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID  ⇒ KS set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>LocalSecretsDef</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"LocalSecrets A =
  {(m :: KS). m ∉ specKeysSecrets A  ∧ 
              ((∃ x y. ((x ∈ loc A) ∧ m = (kKS y) ∧ (exprChannel x (kE y)))) 
              |(∃ x z. ((x ∈ loc A) ∧ m = (sKS z) ∧ (exprChannel x (sE z)) )) )} 
   ∪  (⋃ (LocalSecrets ` (subcomponents A) ))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecretsComposition1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ls ∈ LocalSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ls ∈ LocalSecrets PQ"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm</span><span class="delimiter">)</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>LocalSecretsDef</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>LocalSecretsComposition_exprChannel_k</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exprChannel x (kE Keys)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine P (kE Keys)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine Q (kE Keys)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (x ∉ ins P ∧ x ∉ ins Q)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>LocalSecretsComposition_exprChannel_s</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exprChannel x (sE Secrets)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine P (sE Secrets)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine Q (sE Secrets)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (x ∉ ins P ∧ x ∉ ins Q)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ine_ins_neg1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecretsComposition_neg1_k</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine P (kE Keys)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine Q (kE Keys)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS Keys ∉ LocalSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS Keys ∉ LocalSecrets Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"kKS Keys ∉ LocalSecrets PQ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm</span><span class="delimiter">)</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>LocalSecretsDef</span><span class="delimiter">,</span><span> 
</span><span>           </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionLoc_def</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LocalSecretsComposition_exprChannel_k</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecretsComposition_neg_k</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(kKS m) ∉ specKeysSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(kKS m) ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine P (kE m)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine Q (kE m)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(kKS m) ∉ ((LocalSecrets P) ∪ (LocalSecrets Q))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"(kKS m) ∉ (LocalSecrets PQ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm</span><span class="delimiter">)</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>LocalSecretsDef</span><span class="delimiter">,</span><span> 
</span><span>           </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionLoc_def</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LocalSecretsComposition_exprChannel_k</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecretsComposition_neg_s</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>subPQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompLoc</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompKS</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>notKSP</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(sKS m) ∉ specKeysSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>notKSQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(sKS m) ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine P (sE m)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine Q (sE m)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>notLocSeqPQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(sKS m) ∉ ((LocalSecrets P) ∪ (LocalSecrets Q))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(sKS m) ∉ (LocalSecrets PQ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompKS</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>notKSP</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>notKSQ</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"sKS m ∉ specKeysSecrets PQ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_neg1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompLoc</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>notLocSeqPQ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg2</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"sKS m ∉  ⋃ (LocalSecrets ` subcomponents PQ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm</span><span class="delimiter">)</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>LocalSecretsDef</span><span class="delimiter">,</span><span> 
</span><span>           </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionLoc_def</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LocalSecretsComposition_exprChannel_s</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecretsComposition_neg</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ks ∉ specKeysSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ks ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀ m. ks = kKS m ⟶ (¬ ine P (kE m) ∧ ¬ ine Q (kE m))"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀ m. ks = sKS m ⟶ (¬ ine P (sE m) ∧ ¬ ine Q (sE m))"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ks ∉ ((LocalSecrets P) ∪ (LocalSecrets Q))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"ks ∉ (LocalSecrets PQ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ks"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ks = kKS m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine P (kE m) ∧ ¬ ine Q (kE m)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LocalSecretsComposition_neg_k</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ks = sKS m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine P (sE m) ∧ ¬ ine Q (sE m)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LocalSecretsComposition_neg_s</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecretsComposition_neg1_s</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine P (sE s)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine Q (sE s)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS s ∉ LocalSecrets P"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS s ∉ LocalSecrets Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"sKS s ∉ LocalSecrets PQ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"sKS s ∉  ⋃ (LocalSecrets ` subcomponents PQ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span>  </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm</span><span class="delimiter">)</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>LocalSecretsDef</span><span class="delimiter">,</span><span> 
</span><span>              </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionLoc_def</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LocalSecretsComposition_exprChannel_s</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecretsComposition_neg1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀ m. ks = kKS m ⟶ (¬ ine P (kE m) ∧ ¬ ine Q (kE m))"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀ m. ks = sKS m ⟶ (¬ ine P (sE m) ∧ ¬ ine Q (sE m))"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ks ∉ LocalSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ks ∉ LocalSecrets Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ks ∉ LocalSecrets PQ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ks"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ks = kKS m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine P (kE m) ∧ ¬ ine Q (kE m)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LocalSecretsComposition_neg1_k</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ks = sKS m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine P (sE m) ∧ ¬ ine Q (sE m)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LocalSecretsComposition_neg1_s</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecretsComposition_ine1_k</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS k ∈ LocalSecrets PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine Q (kE k)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS k ∉ LocalSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS k ∉ LocalSecrets Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ine P (kE k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LocalSecretsComposition_neg1_k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecretsComposition_ine1_s</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS s ∈ LocalSecrets PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine Q (sE s)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS s ∉ LocalSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS s ∉ LocalSecrets Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ine P (sE s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LocalSecretsComposition_neg1_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecretsComposition_ine2_k</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS k ∈ LocalSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine P (kE k)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS k ∉ LocalSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS k ∉ LocalSecrets Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"ine Q (kE k)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LocalSecretsComposition_ine1_k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecretsComposition_ine2_s</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS s ∈ LocalSecrets PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ine P (sE s)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS s ∉ LocalSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS s ∉ LocalSecrets Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ine Q (sE s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LocalSecretsComposition_ine1_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecretsComposition_neg_loc_k</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ LocalSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exprChannel ch (kE key)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ specKeysSecrets P"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ch ∉ loc P"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>LocalSecretsDef</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecretsComposition_neg_loc_s</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ LocalSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exprChannel ch (sE secret)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ specKeysSecrets P"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ch ∉ loc P"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>LocalSecretsDef</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_exprChannel_k_P</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ LocalSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exprChannel ch (kE key)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ specKeysSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins PQ ∧ exprChannel ch (kE key)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LocalSecretsComposition_neg_loc_k</span><span> </span><span>correctCompositionIn_L1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_exprChannel_k_Pex</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ LocalSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exprChannel ch (kE key)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ specKeysSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃ch. ch ∈ ins PQ ∧ exprChannel ch (kE key)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>correctCompositionKS_exprChannel_k_P</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_exprChannel_k_Q</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ LocalSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"exprChannel ch (kE key)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ specKeysSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins PQ ∧ exprChannel ch (kE key)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∉ loc PQ"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LocalSecretsComposition_neg_loc_k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins PQ"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionIn_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_exprChannel_k_Qex</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ LocalSecrets PQ"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins Q"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exprChannel ch (kE key)"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ specKeysSecrets PQ"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃ch. ch ∈ ins PQ ∧ exprChannel ch (kE key)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>correctCompositionKS_exprChannel_k_Q</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_exprChannel_s_P</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ LocalSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exprChannel ch (sE secret)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ specKeysSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins PQ ∧ exprChannel ch (sE secret)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LocalSecretsComposition_neg_loc_s</span><span> </span><span>correctCompositionIn_L1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_exprChannel_s_Pex</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ LocalSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exprChannel ch (sE secret)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ specKeysSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃ch. ch ∈ ins PQ ∧ exprChannel ch (sE secret)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>correctCompositionKS_exprChannel_s_P</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_exprChannel_s_Q</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ LocalSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"exprChannel ch (sE secret)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ specKeysSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins PQ ∧ exprChannel ch (sE secret)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∉ loc PQ"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LocalSecretsComposition_neg_loc_s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins PQ"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionIn_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionKS_exprChannel_s_Qex</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ LocalSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch ∈ ins Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exprChannel ch (sE secret)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ specKeysSecrets PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃ch. ch ∈ ins PQ ∧ exprChannel ch (sE secret)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>correctCompositionKS_exprChannel_s_Q</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="KnowledgeKeysSecrets">
<div class="head"><h1>Theory KnowledgeKeysSecrets</h1>
<span class="command">theory</span> <span class="name">KnowledgeKeysSecrets</span><br/>
<span class="keyword">imports</span> <a href="CompLocalSecrets.html"><span class="name">CompLocalSecrets</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
   Title:  Theory AdvKnowledge.thy
   Author: Maria Spichkova &lt;maria.spichkova at rmit.edu.au&gt;, 2014
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Knowledge of Keys and Secrets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>KnowledgeKeysSecrets</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>CompLocalSecrets</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
~\\
An component $A$ knows a secret $m$ (or some secret expression $m$)  that does not belong to its local sectrets , if
\begin{itemize}
  \item %
  $A$  may eventually get the secret $m$,
  \item 
  $m$ belongs to the set $LS_A$ of its local secrets, 
  \item %
  $A$ knows some list of expressions $m_2$ which is an concatenations of $m$ and some list of expressions $m_1$,
  \item %
  $m$ is a concatenation of some lists of secrets $m_1$ and $m_2$, and $A$ knows both these secrets,
  \item %
  $A$ knows some secret key $k^{-1}$ and the result of the encryption of the $m$ with the corresponding public key,
  \item %
  $A$ knows some public key $k$ and the result of the signature creation of the $m$ with the corresponding private key,%
  \item %
  $m$ is an encryption of some secret $m_1$ with a public key $k$, and $A$ knows both $m_1$ and $k$,
  \item %
  $m$ is the result of the signature creation of the $m_1$ with the key $k$, and $A$ knows both $m_1$ and $k$.
  %($m = Sign(k, m_1)  \wedge \knows{A}{m_1} \wedge \knows{A}{k}$).
\end{itemize}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span>
</span><span>  </span><span>know</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ KS ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">"know A (kKS m) = 
  ((ine A (kE m)) ∨ ((kKS m) ∈ (LocalSecrets A)))"</span></span></span><span> </span><span class="delimiter">|</span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">"know A (sKS m) = 
  ((ine A (sE m)) ∨ ((sKS m) ∈ (LocalSecrets A)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">axiomatization</span></span><span>
</span><span>  </span><span>knows</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ Expression list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>knows_emptyexpression</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"knows C [] = True"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>know1k</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"knows C [KS2Expression (kKS m1)] = know C (kKS m1)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>know1s</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"knows C [KS2Expression (sKS m2)] = know C (sKS m2)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>knows2a</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"knows A (e1 @ e) ⟶ knows A e"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>knows2b</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"knows A (e @ e1) ⟶ knows A e"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>knows3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(knows A e1) ∧ (knows A e2) ⟶ knows A (e1 @ e2)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>knows4</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(IncrDecrKeys k1 k2) ∧ (know A (kKS k2)) ∧ (knows A (Enc k1 e))
   ⟶ knows A e"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>knows5</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(IncrDecrKeys k1 k2) ∧ (know A (kKS k1)) ∧ (knows A (Sign k2 e))
   ⟶ knows A e"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>knows6</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(know A (kKS k)) ∧ (knows A e1) ⟶ knows A (Enc k e1)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>knows7</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(know A (kKS k)) ∧ (knows A e1) ⟶ knows A (Sign k e1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span>  </span><span>eoutKnowCorrect</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ KS ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>eout_know_k</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eoutKnowCorrect C (kKS m) = 
  ((eout  C (kE m)) ⟷ (m ∈ (specKeys C) ∨ (know C (kKS m))) )"</span></span></span><span>  </span><span class="delimiter">|</span><span>
</span><span>eout_know_s</span><span class="delimiter">:</span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"eoutKnowCorrect C (sKS m) = 
  ((eout  C (sE m)) ⟷  (m ∈ (specSecrets C) ∨ (know C (sKS m))) )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eoutKnowsECorrect</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"specID ⇒ Expression ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eoutKnowsECorrect C e ≡
   ((eout  C e) ⟷
   ((∃ k. e = (kE k) ∧ (k ∈ specKeys C)) ∨ 
    (∃ s. e = (sE s) ∧ (s ∈ specSecrets C)) ∨
    (knows C [e])))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eoutKnowCorrect_L1k</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutKnowCorrect C (kKS m)"</span></span></span><span>  
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eout  C (kE m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"m ∈ (specKeys C) ∨ (know C (kKS m))"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eout_know_k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eoutKnowCorrect_L1s</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutKnowCorrect C (sKS m)"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eout  C (sE m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"m ∈ (specSecrets C) ∨ (know C (sKS m))"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eout_know_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eoutKnowsECorrect_L1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutKnowsECorrect C e"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eout  C e"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ k. e = (kE k) ∧ (k ∈ specKeys C)) ∨ 
            (∃ s. e = (sE s) ∧ (s ∈ specSecrets C)) ∨
            (knows C [e])"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eoutKnowsECorrect_def</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>know2knows_k</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"know A (kKS m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"knows A [kE m]"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>KS2Expression.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>know1k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows2know_k</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A [kE m]"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"know A (kKS m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>KS2Expression.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>know1k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>know2knowsPQ_k</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"know P (kKS m) ∨ know Q (kKS m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"knows P [kE m] ∨ knows Q [kE m]"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>know2knows_k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows2knowPQ_k</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P [kE m] ∨ knows Q [kE m]"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"know P (kKS m) ∨ know Q (kKS m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>knows2know_k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows1k</span><span class="delimiter">:</span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">"know A (kKS m) = knows A [kE m]"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>know2knows_k</span><span> </span><span>knows2know_k</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>know2knows_neg_k</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ know A (kKS m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"¬ knows A [kE m]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>knows1k</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows2know_neg_k</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows A [kE m]"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ know A (kKS m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>know2knowsPQ_k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>know2knows_s</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"know A (sKS m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"knows A [sE m]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>KS2Expression.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>know1s</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows2know_s</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A [sE m]"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"know A (sKS m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>KS2Expression.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>know1s</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>know2knowsPQ_s</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"know P (sKS m) ∨ know Q (sKS m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"knows P [sE m] ∨ knows Q [sE m]"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>know2knows_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows2knowPQ_s</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P [sE m] ∨ knows Q [sE m]"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"know P (sKS m) ∨ know Q (sKS m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>knows2know_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows1s</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"know A (sKS m) = knows A [sE m]"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>know2knows_s</span><span> </span><span>knows2know_s</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>know2knows_neg_s</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ know A (sKS m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ knows A [sE m]"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>knows2know_s</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows2know_neg_s</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows A [sE m]"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ know A (sKS m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span>know2knows_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows2</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e2 = e1 @ e ∨ e2 = e @ e1"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A e2"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"knows A e"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>knows2a</span><span> </span><span>knows2b</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctCompositionInLoc_exprChannel</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ch : ins P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exprChannel ch m"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x. x ∈ ins PQ ⟶ ¬ exprChannel x m"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"ch : loc PQ"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionIn_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eout_know_nonKS_k</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∉ specKeys A"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eout A (kE m)"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutKnowCorrect A (kKS m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"know A (kKS m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eoutKnowCorrect_L1k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>eout_know_nonKS_s</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∉ specSecrets A"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eout A (sE m)"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutKnowCorrect A (sKS m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"know A (sKS m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eoutKnowCorrect_L1s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_know_k_not_ine</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ know A (kKS m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ ine A (kE m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_know_s_not_ine</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ know A (sKS m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ ine A (sE m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_know_k_not_eout</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∉ specKeys A"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ know A (kKS m)"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutKnowCorrect A (kKS m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"¬ eout A (kE m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eout_know_k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_know_s_not_eout</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∉ specSecrets A"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ know A (sKS m)"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutKnowCorrect A (sKS m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"¬ eout A (sE m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eout_know_nonKS_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adv_not_know1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"out P ⊆ ins A"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ know A (kKS m)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ eout P (kE m)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>eout_def</span><span> </span><span>ine_ins_neg1</span><span> </span><span>not_know_k_not_ine</span><span> </span><span>rev_subsetD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>adv_not_know2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"out P ⊆ ins A"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ know A (sKS m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ eout P (sE m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>eout_def</span><span> </span><span>ine_ins_neg1</span><span> </span><span>not_know_s_not_ine</span><span> </span><span>rev_subsetD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecrets_L1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(kKS) key ∈ LocalSecrets P"</span></span></span><span>  
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(kKS key) ∉ ⋃(LocalSecrets ` subcomponents P)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ specKeysSecrets P"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>LocalSecretsDef</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LocalSecrets_L2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∈ LocalSecrets P"</span></span></span><span>  
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∈ specKeysSecrets P"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"kKS key ∈ ⋃(LocalSecrets ` subcomponents P)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>LocalSecretsDef</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>know_composition1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>notKSP</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"m ∉ specKeysSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>notKSQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"m ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"know P m"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompKS</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"know PQ m"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>key</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"m = kKS key"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ine P (kE key)"</span></span></span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a11</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ine P (kE key)"</span></span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a11ext</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ine P (kE key) | ine Q (kE key)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompKS</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>notKSP</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>notKSQ</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∉ specKeysSecrets PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>correctCompositionKS_neg1</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ specKeysSecrets PQ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a11ext</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompKS</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"loc PQ = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a11locE</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"loc PQ = {}"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a11ext</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a11locE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine PQ (kE key)"</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>TBtheorem4a_empty</span><span class="delimiter">)</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a11locNE</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"loc PQ ≠ {}"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a11</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_exprChannel_k_Pex</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a12</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ ine P (kE key)"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>LocalSecretsComposition1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>secret</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"m = sKS secret"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ine P (sE secret)"</span></span></span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a21</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ine P (sE secret)"</span></span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a21ext</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ine P (sE secret) | ine Q (sE secret)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompKS</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>notKSP</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>notKSQ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∉ specKeysSecrets PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>correctCompositionKS_neg1</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ specKeysSecrets PQ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a21ext</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompKS</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"loc PQ = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a21locE</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"loc PQ = {}"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a21ext</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a21locE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine PQ (sE secret)"</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>TBtheorem4a_empty</span><span class="delimiter">)</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a21locNE</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"loc PQ ≠ {}"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a21</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ine_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correctCompositionKS_exprChannel_s_Pex</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a12</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ ine P (sE secret)"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LocalSecretsComposition1</span><span> </span><span>know.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>know_composition2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∉ specKeysSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"know Q m"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"know PQ m"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insert_commute</span><span> </span><span>know_composition1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>know_composition</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∉ specKeysSecrets P"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"know P m ∨ know Q m"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"know PQ m"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>know_composition1</span><span> </span><span>know_composition2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>know_composition_neg_ine_k</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ know P (kKS key)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ know Q (kKS key)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ (ine PQ (kE key))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>TBtheorem3a</span><span> </span><span>not_know_k_not_ine</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>know_composition_neg_ine_s</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ know P (sKS secret)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ know Q (sKS secret)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ (ine PQ (sE secret))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>TBtheorem3a</span><span> </span><span>not_know_s_not_ine</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>know_composition_neg1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>notknowP</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ know P m"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>notknowQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ know Q m"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompLoc</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ know PQ m"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>key</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"m = kKS key"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>notknowP</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ know P (kKS key)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg1a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ ine P (kE key)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg1b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ LocalSecrets P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>notknowQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ know Q (kKS key)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg2a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ ine Q (kE key)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg2b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ LocalSecrets Q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ ine PQ (kE key)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>know_composition_neg_ine_k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompLoc</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg1a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg1b</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg4</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ LocalSecrets PQ"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LocalSecretsComposition_neg1_k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg3</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg4</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>secret</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"m = sKS secret"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>notknowP</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ know P (sKS secret)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg1a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ ine P (sE secret)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg1b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ LocalSecrets P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>notknowQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ know Q (sKS secret)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg2a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ ine Q (sE secret)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg2b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ LocalSecrets Q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ ine PQ (sE secret)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>know_composition_neg_ine_s</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompLoc</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg1a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg1b</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg4</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ LocalSecrets PQ"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LocalSecretsComposition_neg1_s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg3</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg4</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>know_decomposition</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>knowPQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"know PQ m"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompLoc</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"know P m ∨ know Q m"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>key</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"m = kKS key"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ine PQ (kE key)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a11</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ine PQ (kE key)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"ine P (kE key)  ∨ ine Q (kE key)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>TBtheorem1a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a12</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ ine PQ (kE key)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>knowPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"kKS key ∈ LocalSecrets PQ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"know Q m"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"know Q m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>not_knowQm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ know Q m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>not_knowQm</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg3a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ ine Q (kE key)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>not_knowQm</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg3b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ LocalSecrets Q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∈ LocalSecrets P"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∈ LocalSecrets P"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS key ∉ LocalSecrets P"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompLoc</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg3a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg3b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ine P (kE key)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LocalSecretsComposition_ine1_k</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>secret</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"m = sKS secret"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ine PQ (sE secret)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a21</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ine PQ (sE secret)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"ine P (sE secret)  ∨ ine Q (sE secret)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>TBtheorem1a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a22</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ ine PQ (sE secret)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>knowPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg5</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∈ LocalSecrets PQ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"know Q m"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"know Q m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>not_knowQm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ know Q m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>not_knowQm</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg6a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ ine Q (sE secret)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>not_knowQm</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg6b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ LocalSecrets Q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∈ LocalSecrets P"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∈ LocalSecrets P"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS secret ∉ LocalSecrets P"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg5</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompLoc</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg6a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg6b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>         </span><span class="string"><span class="delete"><span class="delete">"ine P (sE secret)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LocalSecretsComposition_ine1_s</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eout_knows_nonKS_k</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∉ (specKeys A)"</span></span></span><span>
</span><span>         </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eout A (kE m)"</span></span></span><span>
</span><span>         </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutKnowsECorrect A (kE m)"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A [kE m]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Expression.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Expression.inject</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>eoutKnowsECorrect_L1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eout_knows_nonKS_s</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"m ∉ specSecrets A"</span></span></span><span>
</span><span>         </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"eout A (sE m)"</span></span></span><span>
</span><span>         </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"eoutKnowsECorrect A (sE m)"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A [sE m]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Expression.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Expression.inject</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>eoutKnowsECorrect_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_knows_k_not_ine</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows A [kE m]"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ ine A (kE m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>knows2know_neg_k</span><span> </span><span>not_know_k_not_ine</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_knows_s_not_ine</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows A [sE m]"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ ine A (sE m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>knows2know_neg_s</span><span> </span><span>not_know_s_not_ine</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_knows_k_not_eout</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∉ specKeys A"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows A [kE m]"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutKnowsECorrect A (kE m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ eout A (kE m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eout_knows_nonKS_k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_knows_s_not_eout</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∉ specSecrets A"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows A [sE m]"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eoutKnowsECorrect A (sE m)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ eout A (sE m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eout_knows_nonKS_s</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>adv_not_knows1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"out P ⊆ ins A"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows A [kE m]"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ eout P (kE m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>adv_not_know1</span><span> </span><span>knows2know_neg_k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adv_not_knows2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"out P  ⊆ ins A"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows A [sE m]"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ eout P (sE m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>adv_not_know2</span><span> </span><span>knows2know_neg_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_decomposition_1_k</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS a ∉ specKeysSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS a ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows PQ [kE a]"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P [kE a] ∨ knows Q [kE a]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>know_decomposition</span><span> </span><span>knows1k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_decomposition_1_s</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS a ∉ specKeysSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS a ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows PQ [sE a]"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P [sE a] ∨ knows Q [sE a]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>know_decomposition</span><span> </span><span>knows1s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_decomposition_1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P, Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows PQ [a]"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ z. a = kE z) ∨ (∃ z. a = sE z)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ z. a = kE z ⟶ 
         kKS z ∉ specKeysSecrets P ∧ kKS z ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h7</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀ z. a = sE z ⟶ 
         sKS z ∉ specKeysSecrets P ∧ sKS z ∉ specKeysSecrets Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P [a] ∨ knows Q [a]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>knows_decomposition_1_k</span><span> </span><span>knows_decomposition_1_s</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_composition1_k</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(kKS m) ∉ specKeysSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(kKS m) ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P [kE m]"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows PQ [kE m]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>know_composition</span><span> </span><span>knows1k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_composition1_s</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(sKS m) ∉ specKeysSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(sKS m) ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P [sE m]"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows PQ [sE m]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>know_composition</span><span> </span><span>knows1s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_composition2_k</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(kKS m) ∉ specKeysSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(kKS m) ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows Q [kE m]"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows PQ [kE m]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>know2knowsPQ_k</span><span> </span><span>know_composition</span><span> </span><span>knows2know_k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_composition2_s</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(sKS m) ∉ specKeysSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(sKS m) ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows Q [sE m]"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows PQ [sE m]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>know2knowsPQ_s</span><span> </span><span>know_composition</span><span> </span><span>knows2know_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_composition_neg1_k</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS m ∉ specKeysSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kKS m ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows P [kE m]"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows Q [kE m]"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows PQ [kE m]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>know_decomposition</span><span> </span><span>knows1k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_composition_neg1_s</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS m ∉ specKeysSecrets P"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sKS m ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows P [sE m]"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows Q [sE m]"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionLoc PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows PQ [sE m]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>knows_decomposition_1_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_concat_1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P (a # e)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"knows P [a]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>knows2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_concat_2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P (a # e)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"knows P e"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>knows2a</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_concat_3</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P [a]"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P e"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P (a # e)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>knows3</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_knows_conc_knows_elem_not_knows_tail</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows P (a # e)"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P [a]"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows P e"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>knows_concat_3</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_knows_conc_not_knows_elem_tail</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows P (a#e)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ knows P [a] ∨ ¬ knows P e"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>knows3</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_knows_elem_not_knows_conc</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows P [a]"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ knows P (a # e)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>knows_concat_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_knows_tail_not_knows_conc</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ knows P e"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ knows P (a # e)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>knows_concat_2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_composition3</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>e</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"Expression list"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P e"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompKS</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (m::Expression). ((m mem e) ⟶ 
            ((∃ z1. m = (kE z1)) ∨ (∃ z2. m = (sE z2))))"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"notSpecKeysSecretsExpr P e"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"notSpecKeysSecretsExpr Q e"</span></span></span><span> 
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows PQ e"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>knows_emptyexpression</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>l</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"knows P [a]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>knows_concat_1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"knows P l"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>knows_concat_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"a mem (a # l)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg2a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"knows PQ l"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>notSpecKeysSecretsExpr_L2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ z1. a = kE z1"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ z1. a = (kE z1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"a = (kE z)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(kKS z) ∉ specKeysSecrets P"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>notSpecKeysSecretsExpr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg5</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(kKS z) ∉ specKeysSecrets Q"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>notSpecKeysSecretsExpr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg6</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"knows P [kE z]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg4</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg5</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg6</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompKS</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows PQ [kE z]"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>knows_composition1_k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>knows_concat_3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (∃z1. a = kE z1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cons</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ z2. a = (sE z2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"a = (sE z)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg8</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(sKS z) ∉ specKeysSecrets P"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>notSpecKeysSecretsExpr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg9</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(sKS z) ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>notSpecKeysSecretsExpr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg10</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"knows P [sE z]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg8</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg9</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg10</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompKS</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows PQ [sE z]"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>knows_composition1_s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>knows_concat_3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_composition4</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows Q e"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompKS</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ m. m mem e ⟶ ((∃ z. m = kE z) ∨ (∃ z. m = sE z))"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"notSpecKeysSecretsExpr P e"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"notSpecKeysSecretsExpr Q e"</span></span></span><span> 
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows PQ e"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>knows_emptyexpression</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>l</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"knows Q [a]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>knows_concat_1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"knows Q l"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>knows_concat_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"a mem (a # l)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg2a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"knows PQ l"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>notSpecKeysSecretsExpr_L2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ z1. a = kE z1"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ z1. a = (kE z1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"a = (kE z)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(kKS z) ∉ specKeysSecrets P"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>notSpecKeysSecretsExpr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg5</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(kKS z) ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>notSpecKeysSecretsExpr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg6</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"knows Q [kE z]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg4</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg5</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg6</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompKS</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows PQ [kE z]"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>knows_composition2_k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>knows_concat_3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (∃z1. a = kE z1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cons</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ z2. a = (sE z2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"a = (sE z)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg8</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(sKS z) ∉ specKeysSecrets P"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>notSpecKeysSecretsExpr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg9</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(sKS z) ∉ specKeysSecrets Q"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>notSpecKeysSecretsExpr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sg10</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"knows Q [sE z]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sg8</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg9</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg10</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subPQ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompI</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cCompKS</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows PQ [sE z]"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>knows_composition2_s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sg2a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>knows_concat_3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_composition5</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows P e ∨ knows Q e"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subcomponents PQ = {P,Q}"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionIn PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"correctCompositionKS PQ"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ m. m mem e ⟶ ((∃ z. m = kE z) ∨ (∃ z. m = sE z))"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"notSpecKeysSecretsExpr P e"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"notSpecKeysSecretsExpr Q e"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows PQ e"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>knows_composition3</span><span> </span><span>knows_composition4</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> 
</span></pre>
</div>
</div>