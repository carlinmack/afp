<div id="KMP">
<div class="head"><h1>Theory KMP</h1>
<span class="command">theory</span> <span class="name">KMP</span><br/>
<span class="keyword">imports</span> <a href="../Sepref_IICF/IICF.html"><span class="name">IICF</span></a> <a href="Sublist.html"><span class="name">Sublist</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>KMP</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Refine_Imperative_HOL.IICF</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Sublist"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>len_greater_imp_nonempty</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span>min_absorb2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>Ref.update</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ := _"</span></span></span><span> </span><span>62</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSpecification‚Ä∫</span></span></span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\label{sec:spec}‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSublist-predicate with a position check‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπDefinition‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπOne could define‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at' xs ys i ‚â° take (length xs) (drop i ys) = xs"</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπHowever, this doesn't handle out-of-bound indexes uniformly:‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span class="delimiter">[</span><span>nbe</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at' [] [a] 5"</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span class="delimiter">[</span><span>nbe</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at' [a] [a] 5"</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span class="delimiter">[</span><span>nbe</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at' [] [] 5"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInstead, we use a recursive definition:‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>sublist_at</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ‚áí 'a list ‚áí nat ‚áí bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sublist_at (x#xs) (y#ys) 0 ‚ü∑ x=y ‚àß sublist_at xs ys 0"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sublist_at xs (y#ys) (Suc i) ‚ü∑ sublist_at xs ys i"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sublist_at [] ys 0 ‚ü∑ True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sublist_at _ [] _ ‚ü∑ False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIn the relevant cases, both definitions agree:‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ‚â§ length ys ‚üπ sublist_at xs ys i ‚ü∑ sublist_at' xs ys i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sublist_at'_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sublist_at.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπHowever, the new definition has some reasonable properties:‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπProperties‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_lengths</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at xs ys i ‚üπ i + length xs ‚â§ length ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sublist_at.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nil_is_sublist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at ([] :: 'x list) ys i ‚ü∑ i ‚â§ length ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"[] :: 'x list"</span></span></span><span> </span><span>ys</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sublist_at.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFurthermore, we need:‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_step</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"‚ü¶i + length xs &lt; length ys; sublist_at xs ys i; ys!(i + length xs) = x‚üß ‚üπ sublist_at (xs@[x]) ys i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sublist_at.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sublist_at.elims</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_positions_sublist</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"‚ü¶i + length xs ‚â§ length ys; ‚àÄjj&lt;length xs. ys!(i+jj) = xs!jj‚üß ‚üπ sublist_at xs ys i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Nil_is_sublist</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπi + length (xs @ [x]) ‚â§ length ys‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + length xs ‚â§ length ys"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄjj&lt;length xs. ys!(i + jj) = xs!jj"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span> </span><span>snoc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at xs ys i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snoc.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snoc.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_all_positions</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at xs ys i ‚üπ ‚àÄjj&lt;length xs. ys!(i+jj) = xs!jj"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sublist_at.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_Cons'</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIt also connects well to theory @{theory "HOL-Library.Sublist"} (compare @{thm[source] sublist_def}):‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_at_altdef</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sublist_at xs ys i ‚ü∑ (‚àÉps ss. ys = ps@xs@ss ‚àß i = length ps)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sublist_at.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>ss</span><span> </span><span>t</span><span> </span><span>ts</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at ss (t#ts) (Suc i) ‚ü∑ (‚àÉxs ys. t#ts = xs@ss@ys ‚àß Suc i = length xs)"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs ‚ü∑ ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at ss ts i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2.IH"</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉys. ts = xs@ss@ys ‚àß i = length xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉys. t#ts = (t#xs)@ss@ys ‚àß Suc i = length (t#xs)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉys. t#ts = xs@ss@ys ‚àß Suc i = length xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉys. ts = (tl xs)@ss@ys ‚àß i = length (tl xs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hd_Cons_tl</span><span> </span><span>length_0_conv</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>nat.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>size_Cons_lem_eq</span><span> </span><span>tl_append2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉxs ys. ts = xs@ss@ys ‚àß i = length xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2.IH"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?lhs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>sublist_iff_sublist_at</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Sublist.sublist xs ys ‚ü∑ (‚àÉi. sublist_at xs ys i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sublist_at_altdef</span><span> </span><span>Sublist.sublist_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSublist-check algorithms‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  We use the Isabelle Refinement Framework (Theory @{theory Refine_Monadic.Refine_Monadic}) to
  phrase the specification and the algorithm. 
‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ@{term s} for "searchword" / "searchlist", @{term t} for "text"‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp_SPEC s t = SPEC (Œª
  None ‚áí ‚àÑi. sublist_at s t i |
  Some i ‚áí sublist_at s t i ‚àß (‚àÄii&lt;i. ¬¨sublist_at s t ii))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_arg_min_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_arg_min id P i ‚ü∑ P i ‚àß (‚àÄii&lt;i. ¬¨P ii)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_arg_min_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp_result</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp_SPEC s t =
  RETURN (if sublist s t then Some (LEAST i. sublist_at s t i) else None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kmp_SPEC_def</span><span> </span><span>sublist_iff_sublist_at</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>LeastI</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>not_less_Least</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>LeastI</span><span> </span><span>nat_neq_iff</span><span> </span><span>not_less_Least</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>weak_kmp_SPEC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp_SPEC s t ‚â§ SPEC (Œªpos. pos‚â†None ‚ü∑ Sublist.sublist s t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>kmp_result</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>kmp_SPEC_altdefs</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>kmp_SPEC_def</span><span class="delimiter">[</span><span>folded</span><span> </span><span>is_arg_min_id</span><span class="delimiter">]</span><span>
</span><span>  </span><span>kmp_SPEC_def</span><span class="delimiter">[</span><span>folded</span><span> </span><span>sublist_iff_sublist_at</span><span class="delimiter">]</span><span>
</span><span>  </span><span>kmp_result</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπNaive algorithm‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSince KMP is a direct advancement of the naive "test-all-starting-positions" approach, we provide it here for comparison:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInvariants‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_out_na s t ‚â° Œª(i,j,pos).
  (‚àÄii&lt;i. ¬¨sublist_at s t ii) ‚àß
  (case pos of None ‚áí j = 0
    | Some p ‚áí p=i ‚àß sublist_at s t i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_in_na s t i ‚â° Œª(j,pos).
  case pos of None ‚áí j &lt; length s ‚àß (‚àÄjj&lt;j. t!(i+jj) = s!(jj))
    | Some p ‚áí sublist_at s t i"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAlgorithm‚Ä∫</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Algorithm is common knowledge ‚ü∂ remove citation here, move explanations to KMP below?*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe following definition is taken from Helmut Seidl's lecture on algorithms and data structures@{cite GAD} except that we
‚ñ™ output the identified position @{term ‚Äπpos :: nat option‚Ä∫} instead of just @{const True}
‚ñ™ use @{term ‚Äπpos :: nat option‚Ä∫} as break-flag to support the abort within the loops
‚ñ™ rewrite @{prop ‚Äπi ‚â§ length t - length s‚Ä∫} in the first while-condition to @{prop ‚Äπi + length s ‚â§ length t‚Ä∫} to avoid having to use @{typ int} for list indexes (or the additional precondition @{prop ‚Äπlength s ‚â§ length t‚Ä∫})
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"naive_algorithm s t ‚â° do {
  let i=0;
  let j=0;
  let pos=None;
  (_,_,pos) ‚Üê WHILEIT (I_out_na s t) (Œª(i,_,pos). i + length s ‚â§ length t ‚àß pos=None) (Œª(i,j,pos). do {
    (_,pos) ‚Üê WHILEIT (I_in_na s t i) (Œª(j,pos). t!(i+j) = s!j ‚àß pos=None) (Œª(j,_). do {
      let j=j+1;
      if j=length s then RETURN (j,Some i) else RETURN (j,None)
    }) (j,pos);
    if pos=None then do {
      let i = i + 1;
      let j = 0;
      RETURN (i,j,None)
    } else RETURN (i,j,Some i)
  }) (i,j,pos);

  RETURN pos
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCorrectness‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe basic lemmas on @{const sublist_at} from the previous chapter together with @{theory Refine_Monadic.Refine_Monadic}'s verification condition generator / solver suffice:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚â† [] ‚üπ naive_algorithm s t ‚â§ kmp_SPEC s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>naive_algorithm_def</span><span> </span><span>kmp_SPEC_def</span><span> </span><span>I_out_na_def</span><span> </span><span>I_in_na_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span>
</span><span>    </span><span>WHILEIT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"measure (Œª(i,_,pos). length t - i + (if pos = None then 1 else 0))"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>WHILEIT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"measure (Œª(j,_::nat option). length s - j)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>                 </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>solve</span><span class="delimiter">:</span><span> </span><span>asm_rl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_Suc_right</span><span> </span><span>all_positions_sublist</span><span> </span><span>less_antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_Suc_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_SucE</span><span> </span><span>sublist_all_positions</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sublist_lengths</span><span> </span><span>add_less_cancel_right</span><span> </span><span>leI</span><span> </span><span>le_less_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπNote that the precondition cannot be removed without an extra branch: If @{prop ‚Äπs = []‚Ä∫}, the inner while-condition accesses out-of-bound memory. This will apply to KMP, too.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπKnuth--Morris--Pratt algorithm‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπJust like our templates@{cite KMP77}@{cite GAD}, we first verify the main routine and discuss the computation of the auxiliary values @{term ‚Äπùî£ s‚Ä∫} only in a later section.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπPreliminaries: Borders of lists‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"border xs ys ‚ü∑ prefix xs ys ‚àß suffix xs ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border xs ys ‚ü∑ border xs ys ‚àß length xs &lt; length ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intrinsic_border ls ‚â° ARG_MAX length b. strict_border b ls"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπProperties‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>border_order</span><span class="delimiter">:</span><span> </span><span>order</span><span> </span><span>border</span><span> </span><span>strict_border</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>border_def</span><span> </span><span>suffix_def</span><span> </span><span>strict_border_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>border_bot</span><span class="delimiter">:</span><span> </span><span>order_bot</span><span> </span><span>Nil</span><span> </span><span>border</span><span> </span><span>strict_border</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>border_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>borderE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"border xs ys"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix xs ys"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suffix xs ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>border_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_borderE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border xs ys"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"border xs ys"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs &lt; length ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>strict_border_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_border_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_border xs [] ‚ü∑ False"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_border [] (x # xs) ‚ü∑ True"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>strict_border_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_border_prefix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border xs ys ‚üπ strict_prefix xs ys"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>strict_border_suffix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border xs ys ‚üπ strict_suffix xs ys"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>strict_border_imp_nonempty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border xs ys ‚üπ ys ‚â† []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>strict_border_prefix_suffix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border xs ys ‚ü∑ strict_prefix xs ys ‚àß strict_suffix xs ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>border_order.order.strict_iff_order</span><span> </span><span>border_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_length_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"border xs ys ‚üπ length xs ‚â§ length ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>border_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prefix_length_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_length_r_less</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*rm*)</span></span></span></span></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄxs. strict_border xs ys ‚ü∂ length xs &lt; length ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>strict_borderE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_positions</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"border xs ys ‚üπ ‚àÄi&lt;length xs. ys!i = ys!(length ys - length xs + i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>border_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_add_inverse</span><span> </span><span>diff_add_inverse2</span><span> </span><span>length_append</span><span> </span><span>not_add_less1</span><span> </span><span>nth_append</span><span> </span><span>prefixE</span><span> </span><span>suffixE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_positions_drop_length_take</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ü¶i ‚â§ length w; i ‚â§ length x;
  ‚àÄj&lt;i. x ! j = w ! (length w + j - i)‚üß
    ‚üπ drop (length w - i) w = take i x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i = length x"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>nth_equalityI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_positions_suffix_take</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ü¶i ‚â§ length w; i ‚â§ length x;
  ‚àÄj&lt;i. x ! j = w ! (length w + j - i)‚üß
    ‚üπ suffix (take i x) w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>all_positions_drop_length_take</span><span> </span><span>suffix_drop</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suffix_butlast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"suffix xs ys ‚üπ suffix (butlast xs) (butlast ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suffix_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Nil2</span><span> </span><span>butlast.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>butlast_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>positions_border</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄj&lt;l. w!j = w!(length w - l + j) ‚üπ border (take l w) w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"l &lt; length w"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>border_def</span><span> </span><span>all_positions_suffix_take</span><span> </span><span>take_is_prefix</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>positions_strict_border</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l &lt; length w ‚üπ ‚àÄj&lt;l. w!j = w!(length w - l + j) ‚üπ strict_border (take l w) w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>positions_border</span><span> </span><span>strict_border_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>intrinsic_borderI</span><span> </span><span class="delimiter">=</span><span> </span><span>arg_max_natI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>border_length_r_less</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>intrinsic_border_def</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>intrinsic_borderI'</span><span> </span><span class="delimiter">=</span><span> </span><span>border_bot.bot.not_eq_extremum</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>intrinsic_borderI</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>intrinsic_border_max</span><span> </span><span class="delimiter">=</span><span> </span><span>arg_max_nat_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>border_length_r_less</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>intrinsic_border_def</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonempty_is_arg_max_ib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ys ‚â† [] ‚üπ is_arg_max length (Œªxs. strict_border xs ys) (intrinsic_border ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>intrinsic_borderI'</span><span> </span><span>intrinsic_border_max</span><span> </span><span>is_arg_max_linorder</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intrinsic_border_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w ‚â† [] ‚üπ length (intrinsic_border w) &lt; length w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>intrinsic_borderI</span><span class="delimiter">[</span><span>of</span><span> </span><span>w</span><span class="delimiter">]</span><span> </span><span>border_length_r_less</span><span> </span><span>intrinsic_borderI'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intrinsic_border_take_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j &gt; 0 ‚üπ w ‚â† [] ‚üπ length (intrinsic_border (take j w)) &lt; length w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>intrinsic_border_less</span><span> </span><span>length_take</span><span> </span><span>less_not_refl2</span><span> </span><span>min_less_iff_conj</span><span> </span><span>take_eq_Nil</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπExamples‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_example</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{b. border b ''aabaabaa''} = {'''', ''a'', ''aa'', ''aabaa'', ''aabaabaa''}"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{b. border b ?l} = {?take0, ?take1, ?take2, ?take5, ?l}"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{?take0, ?take1, ?take2, ?take5, ?l} ‚äÜ {b. border b ?l}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>eval</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨border ''aab'' ?l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨border ''aaba'' ?l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨border ''aabaab'' ?l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨border ''aabaaba'' ?l"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{b. border b ?l} ‚äÜ set (prefixes ?l)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>border_def</span><span> </span><span>in_set_prefixes</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{b. border b ?l} ‚äÜ {?take0, ?take1, ?take2, ?take5, ?l}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>strict_border_example</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{b. strict_border b ''aabaabaa''} = {'''', ''a'', ''aa'', ''aabaa''}"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l = ?r"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l ‚äÜ {b. border b ''aabaabaa''}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = {'''', ''a'', ''aa'', ''aabaa'', ''aabaabaa''}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>border_example</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l ‚äÜ ?r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?r ‚äÜ ?l"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>eval</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intrinsic_border ''aabaabaa'' = ''aabaa''"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment">‚Äï ‚ÄπWe later obtain a fast algorithm for that.‚Ä∫</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>exhaust</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border b ''aabaabaa'' ‚ü∑ b ‚àà {'''', ''a'', ''aa'', ''aabaa''}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>strict_border_example</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬¨is_arg_max length (Œªb. strict_border b ''aabaabaa'') ''''"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬¨is_arg_max length (Œªb. strict_border b ''aabaabaa'') ''a''"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬¨is_arg_max length (Œªb. strict_border b ''aabaabaa'') ''aa''"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_arg_max length (Œªb. strict_border b ''aabaabaa'') ''aabaa''"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_arg_max_linorder</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (intrinsic_border ''aabaabaa'') ''aabaabaa''"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>intrinsic_borderI'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>exhaust</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.discI</span><span> </span><span>nonempty_is_arg_max_ib</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπMain routine‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe following is Seidl's "border"-table@{cite GAD} (values shifted by 1 so we don't need @{typ int}),
or equivalently, "f" from Knuth's, Morris' and Pratt's paper@{cite KMP77} (with indexes starting at 0).‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ùî£</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ‚áí nat ‚áí nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ùî£ s 0 = 0"</span></span></span><span> </span><span class="comment">‚Äï ‚ÄπThis increments the compare position while @{prop ‚Äπj=(0::nat)‚Ä∫}‚Ä∫</span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j = length (intrinsic_border (take j s)) + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπNote that we use their "next" only implicitly.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInvariants‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_outer s t ‚â° Œª(i,j,pos).
  (‚àÄii&lt;i. ¬¨sublist_at s t ii) ‚àß
  (case pos of None ‚áí (‚àÄjj&lt;j. t!(i+jj) = s!(jj)) ‚àß j &lt; length s
    | Some p ‚áí p=i ‚àß sublist_at s t i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFor the inner loop, we can reuse @{const I_in_na}.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAlgorithm‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFirst, we use the non-evaluable function @{const ùî£} directly:‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp s t ‚â° do {
  ASSERT (s ‚â† []);
  let i=0;
  let j=0;
  let pos=None;
  (_,_,pos) ‚Üê WHILEIT (I_outer s t) (Œª(i,j,pos). i + length s ‚â§ length t ‚àß pos=None) (Œª(i,j,pos). do {
    ASSERT (i + length s ‚â§ length t);
    (j,pos) ‚Üê WHILEIT (I_in_na s t i) (Œª(j,pos). t!(i+j) = s!j ‚àß pos=None) (Œª(j,pos). do {
      let j=j+1;
      if j=length s then RETURN (j,Some i) else RETURN (j,None)
    }) (j,pos);
    if pos=None then do {
      ASSERT (j &lt; length s);
      let i = i + (j - ùî£ s j + 1);
      let j = max 0 (ùî£ s j - 1); ‚Äï ‚Äπ‚Äπmax‚Ä∫ not necessary‚Ä∫
      RETURN (i,j,None)
    } else RETURN (i,j,Some i)
  }) (i,j,pos);

  RETURN pos
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCorrectness‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ùî£_eq_0_iff_j_eq_0</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j = 0 ‚ü∑ j = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>j</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>j_le_ùî£_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j ‚â§ length s ‚üπ ùî£ s j ‚â§ j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_leI</span><span> </span><span>intrinsic_border_less</span><span> </span><span>length_take</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>min.absorb2</span><span> </span><span>nat.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>j_le_ùî£_le'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; j ‚üπ j ‚â§ length s ‚üπ ùî£ s j - 1 &lt; j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_less</span><span> </span><span>j_le_ùî£_le</span><span> </span><span>le_eq_less_or_eq</span><span> </span><span>less_imp_diff_less</span><span> </span><span>less_one</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ùî£_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚â† [] ‚üπ ùî£ s j - 1 &lt; length s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>j</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>intrinsic_border_take_less</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  Only needed for run-time analysis
lemma "p576 et seq":
  assumes
    "j ‚â§ length s" and
    assignments:
    "i' = i + (j + 1 - ùî£ s j)"
    "j' = max 0 (ùî£ s j - 1)"
  shows
    sum_no_decrease: "i' + j' ‚â• i + j" and
    i_increase: "i' &gt; i"
  using assignments by (simp_all add: j_le_ùî£_le[OF assms(1), THEN le_imp_less_Suc])
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reuse_matches</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>j_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j ‚â§ length s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>old_matches</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄjj&lt;j. t ! (i + jj) = s ! jj"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄjj&lt;ùî£ s j - 1. t ! (i + (j - ùî£ s j + 1) + jj) = s ! jj"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄjj&lt;?j'. t ! (?i' + jj) = s ! jj"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"j&gt;0"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j&gt;0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ùî£_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j ‚â§ j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>j_le</span><span> </span><span>j_le_ùî£_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>old_matches</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄjj&lt;?j'. t ! (?i' + jj) = s ! (j - ùî£ s j + 1 + jj)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ab_semigroup_add_class.add.commute</span><span> </span><span>add.assoc</span><span> </span><span>diff_diff_cancel</span><span> </span><span>less_diff_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (take j s) = j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (intrinsic_border (take j s)) = ?j'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>j_le</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ0 &lt; j‚Ä∫</span></span></span><span> </span><span>diff_add_inverse2</span><span> </span><span>ùî£.elims</span><span> </span><span>nat_neq_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄjj&lt;?j'. take j s ! jj = take j s ! (j - (ùî£ s j - 1) + jj)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>intrinsic_borderI'</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ0 &lt; j‚Ä∫</span></span></span><span> </span><span>border_positions</span><span> </span><span>length_greater_0_conv</span><span> </span><span>strict_border_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄjj&lt;?j'. take j s ! jj = take j s ! (j - ùî£ s j + 1 + jj)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ùî£_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄjj&lt;?j'. s ! (j - ùî£ s j + 1 + jj) = s ! jj"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ùî£_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>shift_safe</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"‚àÄii&lt;i. ¬¨sublist_at s t ii"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t!(i+j) ‚â† s!j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>matches</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄjj&lt;j. t!(i+jj) = s!jj"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span>
</span><span>    </span><span>assignment</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i' ‚â° i + (j - ùî£ s j + 1)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"‚àÄii&lt;i'. ¬¨sublist_at s t ii"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>standard</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ii</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ii &lt; i'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="comment">‚Äï ‚ÄπThe position falls into one of three categories:‚Ä∫</span><span>
</span><span>    </span><span class="delimiter">(</span><span>old</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"ii &lt; i"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="delimiter">(</span><span>current</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"ii = i"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="delimiter">(</span><span>skipped</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"ii &gt; i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨sublist_at s t ii"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>old</span><span> </span><span class="comment">‚Äï ‚ÄπOld position, use invariant.‚Ä∫</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ‚àÄii&lt;i. ¬¨sublist_at s t ii‚Ä∫</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>current</span><span> </span><span class="comment">‚Äï ‚ÄπThe mismatch occurred while testing this alignment.‚Ä∫</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπt!(i+j) ‚â† s!j‚Ä∫</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sublist_all_positions</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>skipped</span><span> </span><span class="comment">‚Äï ‚ÄπThe skipped positions.‚Ä∫</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0&lt;j"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπii &lt; i'‚Ä∫</span></span></span><span> </span><span>assignment</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>less_j</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j + i - ii &lt; j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>le_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j + i - ii ‚â§ length s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπii &lt; i'‚Ä∫</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>skipped</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ùî£_le</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>j_le_ùî£_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>less_imp_le</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; ùî£ s j"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ0 &lt; j‚Ä∫</span></span></span><span> </span><span>ùî£_eq_0_iff_j_eq_0</span><span> </span><span>neq0_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j + i - ii &gt; ùî£ s j - 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπii &lt; i'‚Ä∫</span></span></span><span> </span><span>assignment</span><span> </span><span>ùî£_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>contradiction_goal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j + i - ii &gt; length (intrinsic_border (take j s))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ùî£.elims</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ0 &lt; j‚Ä∫</span></span></span><span> </span><span>add_diff_cancel_right'</span><span> </span><span>not_gr_zero</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at s t ii"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>sublist_all_positions</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>le_s</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄjj &lt; j+i-ii. t!(ii+jj) = s!jj"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ff1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ ii &lt; i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>not_less_iff_gr_or_eq</span><span> </span><span>skipped</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + (ii - i + jj) = ii + jj"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>jj</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.assoc</span><span> </span><span>add_diff_inverse_nat</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ jj &lt; j + i - ii ‚à® t ! (ii + jj) = s ! (ii - i + jj)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ii - i + jj &lt; j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>jj</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>ff1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>matches</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ jj &lt; j + i - ii ‚à® t ! (ii + jj) = s ! (ii - i + jj)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>jj</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ff1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>matches</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄjj &lt; j+i-ii. t!(ii+jj) = s!(ii-i+jj)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄjj &lt; j+i-ii. s!jj = s!(ii-i+jj)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄjj &lt; j+i-ii. (take j s)!jj = (take j s)!(ii-i+jj)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπi&lt;ii‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>positions_strict_border</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"j+i-ii"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take j s"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (take (j+i-ii) s) (take j s)"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>intrinsic_border_max</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>contradiction_goal</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j+i-ii ‚â§ length s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>le_s</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚â† []
  ‚üπ kmp s t ‚â§ kmp_SPEC s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kmp_def</span><span> </span><span>kmp_SPEC_def</span><span> </span><span>I_outer_def</span><span> </span><span>I_in_na_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span>
</span><span>    </span><span>WHILEIT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"measure (Œª(i,_,pos). length t - i + (if pos = None then 1 else 0))"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>WHILEIT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"measure (Œª(j,_::nat option). length s - j)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>                   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>solve</span><span class="delimiter">:</span><span> </span><span>asm_rl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_Suc_right</span><span> </span><span>all_positions_sublist</span><span> </span><span>less_antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span>jout</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>shift_safe</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>j</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span>jout</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reuse_matches</span><span class="delimiter">[</span><span>of</span><span> </span><span>j</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>ùî£_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sublist_lengths</span><span> </span><span>add_less_cancel_right</span><span> </span><span>leI</span><span> </span><span>le_less_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπStoring the @{const ùî£}-values‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπWe refine the algorithm to compute the @{const ùî£}-values only once at the start:‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>compute_ùî£s_SPEC</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ‚áí nat list nres"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"compute_ùî£s_SPEC s ‚â° SPEC (Œªùî£s. length ùî£s = length s + 1 ‚àß (‚àÄj‚â§length s. ùî£s!j = ùî£ s j))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp1 s t ‚â° do {
  ASSERT (s ‚â† []);
  let i=0;
  let j=0;
  let pos=None;
  ùî£s ‚Üê compute_ùî£s_SPEC (butlast s); ‚Äï ‚ÄπAt the last char, we abort instead.‚Ä∫
  (_,_,pos) ‚Üê WHILEIT (I_outer s t) (Œª(i,j,pos). i + length s ‚â§ length t ‚àß pos=None) (Œª(i,j,pos). do {
    ASSERT (i + length s ‚â§ length t);
    (j,pos) ‚Üê WHILEIT (I_in_na s t i) (Œª(j,pos). t!(i+j) = s!j ‚àß pos=None) (Œª(j,pos). do {
      let j=j+1;
      if j=length s then RETURN (j,Some i) else RETURN (j,None)
    }) (j,pos);
    if pos=None then do {
      ASSERT (j &lt; length ùî£s);
      let i = i + (j - ùî£s!j + 1);
      let j = max 0 (ùî£s!j - 1); ‚Äï ‚Äπ‚Äπmax‚Ä∫ not necessary‚Ä∫
      RETURN (i,j,None)
    } else RETURN (i,j,Some i)
  }) (i,j,pos);

  RETURN pos
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ùî£_butlast</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length s ‚üπ ùî£ (butlast s) j = ùî£ s j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>j</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>take_butlast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp1_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp1 s t ‚â§ kmp s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refine_IdD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kmp1_def</span><span> </span><span>kmp_def</span><span> </span><span>Let_def</span><span> </span><span>compute_ùî£s_SPEC_def</span><span> </span><span>nres_monad_laws</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ASSERT_refine_right</span><span> </span><span>ASSERT_refine_left</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Refine_Basic.intro_spec_refine</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vc_solve</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπNext, an algorithm that satisfies @{const compute_ùî£s_SPEC}:‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπComputing @{const ùî£}‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInvariants‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_out_cb s ‚â° Œª(ùî£s,i,j).
  length s + 1 = length ùî£s ‚àß
  (‚àÄjj&lt;j. ùî£s!jj = ùî£ s jj) ‚àß
  ùî£s!(j-1) = i ‚àß
  0 &lt; j"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_in_cb s j ‚â° Œªi.
  if j=1 then i=0 ‚Äï ‚Äπfirst iteration‚Ä∫
  else
    strict_border (take (i-1) s) (take (j-1) s) ‚àß
    ùî£ s j ‚â§ i + 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAlgorithm‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAgain, we follow Seidl@{cite GAD}, p.582. Apart from the +1-shift, we make another modification:
Instead of directly setting @{term ‚Äπùî£s!1‚Ä∫}, we let the first loop-iteration (if there is one) do that for us.
This allows us to remove the precondition @{prop ‚Äπs ‚â† []‚Ä∫}, as the index bounds are respected even in that corner case.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>compute_ùî£s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ‚áí nat list nres"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"compute_ùî£s s = do {
  let ùî£s=replicate (length s + 1) 0; ‚Äï ‚Äπonly the first 0 is needed‚Ä∫
  let i=0;
  let j=1;
  (ùî£s,_,_) ‚Üê WHILEIT (I_out_cb s) (Œª(ùî£s,_,j). j &lt; length ùî£s) (Œª(ùî£s,i,j). do {
    i ‚Üê WHILEIT (I_in_cb s j) (Œªi. i&gt;0 ‚àß s!(i-1) ‚â† s!(j-1)) (Œªi. do {
      ASSERT (i-1 &lt; length ùî£s);
      let i=ùî£s!(i-1);
      RETURN i
    }) i;
    let i=i+1;
    ASSERT (j &lt; length ùî£s);
    let ùî£s=ùî£s[j:=i];
    let j=j+1;
    RETURN (ùî£s,i,j)
  }) (ùî£s,i,j);
  
  RETURN ùî£s
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCorrectness‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>take_length_ib</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ‚â§ length s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take (length (intrinsic_border (take j s))) s = intrinsic_border (take j s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix (intrinsic_border (take j s)) (take j s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>intrinsic_borderI'</span><span> </span><span>border_def</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>neq0_conv</span><span> </span><span>not_less</span><span> </span><span>strict_border_def</span><span> </span><span>take_eq_Nil</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix (take j s) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπj ‚â§ length s‚Ä∫</span></span></span><span> </span><span>take_is_prefix</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_eq_conv_conj</span><span> </span><span>prefixE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ib_singleton</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"intrinsic_border [z] = []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>intrinsic_border_less</span><span> </span><span>length_Cons</span><span> </span><span>length_greater_0_conv</span><span> </span><span>less_Suc0</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_butlast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"border xs ys ‚üπ border (butlast xs) (butlast ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>border_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>butlast_append</span><span> </span><span>prefixE</span><span> </span><span>prefix_order.eq_refl</span><span> </span><span>prefix_prefix</span><span> </span><span>prefixeq_butlast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Sublist.suffix_def</span><span> </span><span>append.right_neutral</span><span> </span><span>butlast.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>butlast_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>strict_border_butlast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs ‚â† [] ‚üπ strict_border xs ys ‚üπ strict_border (butlast xs) (butlast ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>strict_border_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>border_butlast</span><span> </span><span>less_diff_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_take_lengths</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ‚â§ length s ‚üπ border (take i s) (take j s) ‚üπ i ‚â§ j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>border_length_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"border xs ys ‚ü∑ border (xs@[ys!length xs]) (ys@[ys!length xs])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>border_def</span><span> </span><span>suffix_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>append_one_prefix</span><span> </span><span>prefixE</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>append_prefixD</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>strict_border_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border xs ys ‚ü∑ strict_border (xs@[ys!length xs]) (ys@[ys!length xs])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>strict_border_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>border_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ib_butlast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length w ‚â• 2 ‚üπ length (intrinsic_border w) ‚â§ length (intrinsic_border (butlast w)) + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length w ‚â• 2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w ‚â† []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (intrinsic_border w) w"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>intrinsic_borderI'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ2 ‚â§ length w‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (butlast (intrinsic_border w)) (butlast w)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>border_bot.bot.not_eq_extremum</span><span> </span><span>butlast.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>len_greater_imp_nonempty</span><span> </span><span>length_butlast</span><span> </span><span>lessI</span><span> </span><span>less_le_trans</span><span> </span><span>numerals</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>strict_border_butlast</span><span> </span><span>zero_less_diff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (butlast (intrinsic_border w)) ‚â§ length (intrinsic_border (butlast w))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>intrinsic_border_max</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>ùî£_Suc</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*rm*)</span></span></span></span></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc i ‚â§ length w ‚üπ ùî£ w (Suc i) ‚â§ ùî£ w i + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>take_Suc0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>Suc_to_right</span><span> </span><span>butlast_take</span><span> </span><span>diff_is_0_eq</span><span> </span><span>ib_butlast</span><span> </span><span>length_take</span><span> </span><span>min.absorb2</span><span> </span><span>nat.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>not_less_eq_eq</span><span> </span><span>numerals</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ùî£_step_bound</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*rm*)</span></span></span></span></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ‚â§ length w"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ w j ‚â§ ùî£ w (j-1) + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>j_le_ùî£_le</span><span class="delimiter">]</span><span> </span><span>ùî£_Suc</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_pred</span><span> </span><span>le_SucI</span><span> </span><span>not_gr_zero</span><span> </span><span>trans_le_add2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_take_ùî£</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"border (take (ùî£ s i - 1) s ) (take i s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>intrinsic_borderI'</span><span> </span><span>border_order.eq_iff</span><span> </span><span>border_order.less_imp_le</span><span> </span><span>border_positions</span><span> </span><span>nat.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>nat_le_linear</span><span> </span><span>positions_border</span><span> </span><span>take_all</span><span> </span><span>take_eq_Nil</span><span> </span><span>take_length_ib</span><span> </span><span>zero_less_Suc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>ùî£_strict_borderI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y = ùî£ s (i-1) ‚üπ strict_border (take (i-1) s) (take (j-1) s) ‚üπ strict_border (take (y-1) s) (take (j-1) s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>border_order.less_le_not_le</span><span> </span><span>border_order.order.trans</span><span> </span><span>border_take_ùî£</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>strict_border_take_ùî£</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; i ‚üπ i ‚â§ length s ‚üπ strict_border (take (ùî£ s i - 1) s ) (take i s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>border_order.less_le_not_le</span><span> </span><span>border_take_ùî£</span><span> </span><span>border_take_lengths</span><span> </span><span>j_le_ùî£_le'</span><span> </span><span>leD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ùî£_is_max</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j ‚â§ length s ‚üπ strict_border b (take j s) ‚üπ ùî£ s j ‚â• length b + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ùî£.elims</span><span> </span><span>add_le_cancel_right</span><span> </span><span>add_less_same_cancel2</span><span> </span><span>border_length_r_less</span><span> </span><span>intrinsic_border_max</span><span> </span><span>length_take</span><span> </span><span>min_absorb2</span><span> </span><span>not_add_less2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>skipping_ok</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>j_bounds</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 &lt; j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ‚â§ length s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mismatch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s!(i-1) ‚â† s!(j-1)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>greater_checked</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j ‚â§ i + 1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (take (i-1) s) (take (j-1) s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j ‚â§ ùî£ s (i-1) + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ùî£ s j ‚â§ ùî£ s (i-1) + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i_bounds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ‚â§ length s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>greater_checked</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>take_Nil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i_less_j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>border_length_r_less</span><span> </span><span>nz_le_conv_less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ¬¨ùî£ s j ‚â§ ùî£ s (i-1) + 1‚Ä∫</span></span></span><span> </span><span>greater_checked</span><span> </span><span class="keyword1"><span class="command">consider</span></span><span>
</span><span>    </span><span class="delimiter">(</span><span>tested</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j = i + 1"</span></span></span><span> </span><span class="comment">‚Äï ‚ÄπThis contradicts @{thm mismatch}‚Ä∫</span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="delimiter">(</span><span>skipped</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s (i-1) + 1 &lt; ùî£ s j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j ‚â§ i"</span></span></span><span>
</span><span>      </span><span class="comment">‚Äï ‚ÄπThis contradicts @{thm ùî£_is_max[of "i-1" s]}‚Ä∫</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>tested</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j - 1 = i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>border_positions</span><span class="delimiter">[</span><span>OF</span><span> </span><span>border_take_ùî£</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>j</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>this</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take j s ! (i-1) = s!(j-1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_bounds</span><span> </span><span>i_less_j</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπi &lt; j‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s!(i-1) = s!(j-1)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_imp_diff_less</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mismatch</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>skipped</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?border</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"take (i-1) s"</span></span></span><span>
</span><span>      </span><span class="comment">‚Äï ‚ÄπThis border of @{term ‚Äπtake (j-1) s‚Ä∫} could not be extended to a border of @{term ‚Äπtake j s‚Ä∫} due to the mismatch.‚Ä∫</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?impossible</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"take (ùî£ s j - 2) s"</span></span></span><span>
</span><span>      </span><span class="comment">‚Äï ‚ÄπA strict border longer than @{term ‚Äπintrinsic_border ?border‚Ä∫}, a contradiction.‚Ä∫</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (take j s) = j"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j - 2 &lt; i - 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>skipped</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>less_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j - 2 &lt; length s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i - 1 &lt; length s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπi &lt; j‚Ä∫</span></span></span><span> </span><span>j_bounds</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>strict</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ?impossible &lt; length ?border"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπùî£ s j - 2 &lt; i - 1‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix ?impossible (take j s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prefix_length_prefix</span><span> </span><span>take_is_prefix</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπlength (take j s) = j‚Ä∫</span></span></span><span> </span><span>j_bounds</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>diff_le_self</span><span> </span><span>j_le_ùî£_le</span><span> </span><span>length_take</span><span> </span><span>less_s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>min_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix ?border (take j s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπlength (take j s) = j‚Ä∫</span></span></span><span> </span><span>diff_le_self</span><span> </span><span>i_less_j</span><span> </span><span>le_trans</span><span> </span><span>length_take</span><span> </span><span>less_or_eq_imp_le</span><span> </span><span>less_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>min_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>prefix_length_prefix</span><span> </span><span>take_is_prefix</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix ?impossible ?border"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>strict</span><span> </span><span>less_imp_le_nat</span><span> </span><span>prefix_length_prefix</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suffix (take (ùî£ s j - 1) s) (take j s)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>border_take_ùî£</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>border_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>suffix_butlast</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suffix ?impossible (take (j-1) s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>j_bounds</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>butlast_take</span><span> </span><span>diff_diff_left</span><span> </span><span>ùî£_le</span><span> </span><span>len_greater_imp_nonempty</span><span> </span><span>less_or_eq_imp_le</span><span> </span><span>less_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>one_add_one</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suffix ?impossible (take (j-1) s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suffix ?border (take (j-1) s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>suffix_length_suffix</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>strict</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>less_imp_le</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suffix ?impossible ?border"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border ?impossible ?border"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>strict_border_def</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>border_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ùî£_is_max</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"i-1"</span></span></span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (take (ùî£ s j - 2) s) + 1 ‚â§ ùî£ s (i-1)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_imp_le_nat</span><span> </span><span>less_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j - 1 ‚â§ ùî£ s (i-1)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j ‚â§ ùî£ s (i-1) + 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_diff_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>skipped</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extend_border</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ‚â§ length s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s!(i-1) = s!(j-1)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (take (i-1) s) (take (j-1) s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j ‚â§ i + 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j = i + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>pos_in_range</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i - 1 &lt; length s "</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (take (i-1) s) = i - 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>border_length_r_less</span><span> </span><span>min_less_iff_conj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>strict_border_step</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (take (i-1) s @ [s!(i-1)]) (take (j-1) s @ [s!(i-1)])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>border_length_r_less</span><span> </span><span>length_take</span><span> </span><span>min_less_iff_conj</span><span> </span><span>nth_take</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pos_in_range</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (take i s) (take (j-1) s @ [s!(i-1)])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>Suc_pred</span><span> </span><span>add.left_neutral</span><span> </span><span>border_bot.bot.not_eq_extremum</span><span> </span><span>border_order.less_asym</span><span> </span><span>neq0_conv</span><span> </span><span>take_0</span><span> </span><span>take_Suc_conv_app_nth</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (take i s) (take (j-1) s @ [s!(j-1)])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπs!(i-1) = s!(j-1)‚Ä∫</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (take i s) (take j s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_pred</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>diff_le_self</span><span> </span><span>less_le_trans</span><span> </span><span>neq0_conv</span><span> </span><span>nz_le_conv_less</span><span> </span><span>strict_border_imp_nonempty</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span>take_eq_Nil</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ùî£_is_max</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùî£ s j ‚â• i + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_leI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπùî£ s j ‚â§ i + 1‚Ä∫</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compute_ùî£s_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"compute_ùî£s s ‚â§ compute_ùî£s_SPEC s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compute_ùî£s_SPEC_def</span><span> </span><span>compute_ùî£s_def</span><span> </span><span>I_out_cb_def</span><span> </span><span>I_in_cb_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>refine_vcg</span><span>
</span><span>    </span><span>WHILEIT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"measure (Œª(ùî£s,i,j). length s + 1 - j)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>WHILEIT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"measure id"</span></span></span><span class="delimiter">]</span><span> </span><span class="comment">‚Äï ‚Äπ@{term ‚Äπi::nat‚Ä∫} decreases with every iteration.‚Ä∫</span><span>
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>                      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span class="delimiter">,</span><span> </span><span>fold</span><span> </span><span>One_nat_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>strict_border_take_ùî£</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>ùî£_step_bound</span><span> </span><span>less_Suc_eq_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_lessD</span><span> </span><span>Suc_pred</span><span> </span><span>border_length_r_less</span><span> </span><span>ùî£_strict_borderI</span><span> </span><span>length_take</span><span> </span><span>less_Suc_eq</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>min.absorb2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>j</span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_diff_1</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>Suc_leI</span><span> </span><span>border_take_lengths</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>less_antisym</span><span> </span><span>skipping_ok</span><span> </span><span>strict_border_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_diff_1</span><span> </span><span>border_take_lengths</span><span> </span><span>j_le_ùî£_le</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>strict_border_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>j</span><span> </span><span>i</span><span> </span><span>jj</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>Suc_eq_plus1_left</span><span> </span><span>add.right_neutral</span><span> </span><span>extend_border</span><span> </span><span>ùî£_eq_0_iff_j_eq_0</span><span> </span><span>j_le_ùî£_le</span><span> </span><span>le_zero_eq</span><span> </span><span>less_Suc_eq</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>nth_list_update_eq</span><span> </span><span>nth_list_update_neq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIndex shift‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπTo avoid inefficiencies, we refine @{const compute_ùî£s} to take @{term s}
instead of @{term ‚Äπbutlast s‚Ä∫} (it still only uses @{term ‚Äπbutlast s‚Ä∫}).‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>compute_butlast_ùî£s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ‚áí nat list nres"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"compute_butlast_ùî£s s = do {
  let ùî£s=replicate (length s) 0;
  let i=0;
  let j=1;
  (ùî£s,_,_) ‚Üê WHILEIT (I_out_cb (butlast s)) (Œª(b,i,j). j &lt; length b) (Œª(ùî£s,i,j). do {
    ASSERT (j &lt; length ùî£s);
    i ‚Üê WHILEIT (I_in_cb (butlast s) j) (Œªi. i&gt;0 ‚àß s!(i-1) ‚â† s!(j-1)) (Œªi. do {
      ASSERT (i-1 &lt; length ùî£s);
      let i=ùî£s!(i-1);
      RETURN i
    }) i;
    let i=i+1;
    ASSERT (j &lt; length ùî£s);
    let ùî£s=ùî£s[j:=i];
    let j=j+1;
    RETURN (ùî£s,i,j)
  }) (ùî£s,i,j);
  
  RETURN ùî£s
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compute_ùî£s_inner_bounds</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_out_cb s (ùî£s,ix,j)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length ùî£s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_in_cb s j i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i-1 &lt; length s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j-1 &lt; length s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>I_out_cb_def</span><span> </span><span>I_in_cb_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compute_butlast_ùî£s_refine</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,s') ‚àà br butlast ((‚â†) [])"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compute_butlast_ùî£s s ‚â§ ‚áì Id (compute_ùî£s_SPEC s')"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compute_butlast_ùî£s s ‚â§ ‚áì Id (compute_ùî£s s')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compute_butlast_ùî£s_def</span><span> </span><span>compute_ùî£s_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_dref_type</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred</span><span> </span><span>length_greater_0_conv</span><span> </span><span>replicate_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>compute_ùî£s_inner_bounds</span><span> </span><span>nth_butlast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>compute_ùî£s_correct</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπConflation‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπWe replace @{const compute_ùî£s_SPEC} with @{const compute_butlast_ùî£s}‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp2 s t ‚â° do {
  ASSERT (s ‚â† []);
  let i=0;
  let j=0;
  let pos=None;
  ùî£s ‚Üê compute_butlast_ùî£s s;
  (_,_,pos) ‚Üê WHILEIT (I_outer s t) (Œª(i,j,pos). i + length s ‚â§ length t ‚àß pos=None) (Œª(i,j,pos). do {
    ASSERT (i + length s ‚â§ length t ‚àß pos=None);
    (j,pos) ‚Üê WHILEIT (I_in_na s t i) (Œª(j,pos). t!(i+j) = s!j ‚àß pos=None) (Œª(j,pos). do {
      let j=j+1;
      if j=length s then RETURN (j,Some i) else RETURN (j,None)
    }) (j,pos);
    if pos=None then do {
      ASSERT (j &lt; length ùî£s);
      let i = i + (j - ùî£s!j + 1);
      let j = max 0 (ùî£s!j - 1); ‚Äï ‚Äπ‚Äπmax‚Ä∫ not necessary‚Ä∫
      RETURN (i,j,None)
    } else RETURN (i,j,Some i)
  }) (i,j,pos);

  RETURN pos
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπUsing @{thm [source] compute_butlast_ùî£s_refine} (it has attribute @{attribute refine}), the proof is trivial:‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp2_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp2 s t ‚â§ kmp1 s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refine_IdD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kmp2_def</span><span> </span><span>kmp1_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>                  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>                  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp2_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚â† []
  ‚üπ kmp2 s t ‚â§ kmp_SPEC s t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚â† []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp2 s t ‚â§ kmp1 s t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>kmp2_refine</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ‚â§ kmp s t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>kmp1_refine</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ‚â§ kmp_SPEC s t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>kmp_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπs ‚â† []‚Ä∫</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFor convenience, we also remove the precondition:‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp3 s t ‚â° do {
  if s=[] then RETURN (Some 0) else kmp2 s t
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp3_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp3 s t ‚â§ kmp_SPEC s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kmp3_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>kmp2_correct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>kmp_SPEC_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπRefinement to Imperative/HOL‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_id_param</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((=), (=)) ‚àà Id ‚Üí Id ‚Üí Id"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>in_bounds_aux</span><span> </span><span class="delimiter">=</span><span> </span><span>compute_ùî£s_inner_bounds</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"butlast s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>compute_butlast_ùî£s_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>compute_butlast_ùî£s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(arl_assn id_assn)<span class="hidden">‚áß</span><sup>k</sup> ‚Üí<span class="hidden">‚á©</span><sub>a</sub> array_assn nat_assn"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compute_butlast_ùî£s_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>in_bounds_aux</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>eq_id_param</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span>sepref_import_param</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>array_fold_custom_replicate</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>compute_butlast_ùî£s_impl.refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>compute_ùî£s</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp_inner_in_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + length s ‚â§ length t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_in_na s t i (j,None)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + j &lt; length t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>I_in_na_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>kmp_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncurry kmp3"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(arl_assn id_assn)<span class="hidden">‚áß</span><sup>k</sup> *<span class="hidden">‚á©</span><sub>a</sub> (arl_assn id_assn)<span class="hidden">‚áß</span><sup>k</sup> ‚Üí<span class="hidden">‚á©</span><sub>a</sub> option_assn nat_assn"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kmp3_def</span><span> </span><span>kmp2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>max_0L</span><span class="delimiter">)</span><span> </span><span class="comment">‚Äï ‚ÄπAvoid the unneeded @{const max}‚Ä∫</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"WHILEIT (I_in_na _ _ _) ‚åë"</span></span></span><span> </span><span>conj_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"WHILEIT (I_in_na _ _ _) ‚åë"</span></span></span><span> </span><span>short_circuit_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>kmp_inner_in_bound</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>option.splits</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>eq_id_param</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span>sepref_import_param</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>kmp_impl</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML_imp</span><span> </span><span class="keyword2"><span class="keyword">module_name</span></span><span> </span><span>KMP</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp3_correct'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(uncurry kmp3, uncurry kmp_SPEC) ‚àà Id √ó<span class="hidden">‚á©</span><sub>r</sub> Id ‚Üí<span class="hidden">‚á©</span><sub>f</sub> ‚ü®Id‚ü©nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>kmp3_correct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>kmp_impl_correct'</span><span> </span><span class="delimiter">=</span><span> </span><span>kmp_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>kmp3_correct'</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπOverall Correctness Theorem‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe following theorem relates the final Imperative HOL algorithm to its specification,
  using, beyond basic HOL concepts
    ‚ñ™ Hoare triples for Imperative/HOL, provided by the Separation Logic Framework for Imperative/HOL (Theory @{theory Separation_Logic_Imperative_HOL.Sep_Main});
    ‚ñ™ The assertion @{const arl_assn} to specify array-lists, which we use to represent the input strings of the algorithm;
    ‚ñ™ The @{const sublist_at} function that we defined in section \ref{sec:spec}.
  ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>kmp_impl_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt; arl_assn id_assn s si * arl_assn id_assn t ti &gt; 
       kmp_impl si ti 
   &lt;Œªr. arl_assn id_assn s si * arl_assn id_assn t ti * ‚Üë(
      case r of None ‚áí  ‚àÑi. sublist_at s t i
              | Some i ‚áí sublist_at s t i ‚àß (‚àÄii&lt;i. ¬¨ sublist_at s t ii)
    )&gt;<span class="hidden">‚á©</span><sub>t</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> 
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span> </span><span>kmp_SPEC_def</span><span>
</span><span>    </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span>
</span><span>    </span><span>heap</span><span class="delimiter">:</span><span>  </span><span>kmp_impl_correct'</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>hfrefD</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>hn_refineD</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,t)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(si,ti)"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp_string_impl ‚â° kmp_impl :: (char array √ó nat) ‚áí _"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπTests of Generated ML-Code‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  fun str2arl s = (Array.fromList (@{code String.explode} s), @{code nat_of_integer} (String.size s))
  fun kmp s t = map_option @{code integer_of_nat} (@{code kmp_string_impl} (str2arl s) (str2arl t) ())
  
  val test1 = kmp "anas" "bananas"
  val test2 = kmp "" "bananas"
  val test3 = kmp "hide_fact" (File.read @{file ‚Äπ~~/src/HOL/Main.thy‚Ä∫})
  val test4 = kmp "sorry" (File.read @{file ‚Äπ~~/src/HOL/HOL.thy‚Ä∫})  
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>