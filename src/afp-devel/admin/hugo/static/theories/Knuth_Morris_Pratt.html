<div id="KMP">
<div class="head"><h1>Theory KMP</h1>
<span class="command">theory</span> <span class="name">KMP</span><br/>
<span class="keyword">imports</span> <a href="../Sepref_IICF/IICF.html"><span class="name">IICF</span></a> <a href="Sublist.html"><span class="name">Sublist</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>KMP</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Refine_Imperative_HOL.IICF</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Sublist"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>len_greater_imp_nonempty</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span>min_absorb2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>Ref.update</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ := _"</span></span></span><span> </span><span>62</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Specification›</span></span></span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‹\label{sec:spec}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Sublist-predicate with a position check›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Definition›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹One could define›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at' xs ys i ≡ take (length xs) (drop i ys) = xs"</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹However, this doesn't handle out-of-bound indexes uniformly:›</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span class="delimiter">[</span><span>nbe</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at' [] [a] 5"</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span class="delimiter">[</span><span>nbe</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at' [a] [a] 5"</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span class="delimiter">[</span><span>nbe</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at' [] [] 5"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Instead, we use a recursive definition:›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>sublist_at</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a list ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sublist_at (x#xs) (y#ys) 0 ⟷ x=y ∧ sublist_at xs ys 0"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sublist_at xs (y#ys) (Suc i) ⟷ sublist_at xs ys i"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sublist_at [] ys 0 ⟷ True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sublist_at _ [] _ ⟷ False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In the relevant cases, both definitions agree:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ length ys ⟹ sublist_at xs ys i ⟷ sublist_at' xs ys i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sublist_at'_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sublist_at.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹However, the new definition has some reasonable properties:›</span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Properties›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_lengths</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at xs ys i ⟹ i + length xs ≤ length ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sublist_at.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nil_is_sublist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at ([] :: 'x list) ys i ⟷ i ≤ length ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"[] :: 'x list"</span></span></span><span> </span><span>ys</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sublist_at.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Furthermore, we need:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_step</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦i + length xs &lt; length ys; sublist_at xs ys i; ys!(i + length xs) = x⟧ ⟹ sublist_at (xs@[x]) ys i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sublist_at.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sublist_at.elims</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_positions_sublist</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦i + length xs ≤ length ys; ∀jj&lt;length xs. ys!(i+jj) = xs!jj⟧ ⟹ sublist_at xs ys i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Nil_is_sublist</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i + length (xs @ [x]) ≤ length ys›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + length xs ≤ length ys"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀jj&lt;length xs. ys!(i + jj) = xs!jj"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span> </span><span>snoc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at xs ys i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snoc.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snoc.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_all_positions</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at xs ys i ⟹ ∀jj&lt;length xs. ys!(i+jj) = xs!jj"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sublist_at.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_Cons'</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹It also connects well to theory @{theory "HOL-Library.Sublist"} (compare @{thm[source] sublist_def}):›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_at_altdef</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sublist_at xs ys i ⟷ (∃ps ss. ys = ps@xs@ss ∧ i = length ps)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sublist_at.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>ss</span><span> </span><span>t</span><span> </span><span>ts</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at ss (t#ts) (Suc i) ⟷ (∃xs ys. t#ts = xs@ss@ys ∧ Suc i = length xs)"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs ⟷ ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at ss ts i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2.IH"</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ys. ts = xs@ss@ys ∧ i = length xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ys. t#ts = (t#xs)@ss@ys ∧ Suc i = length (t#xs)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ys. t#ts = xs@ss@ys ∧ Suc i = length xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ys. ts = (tl xs)@ss@ys ∧ i = length (tl xs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hd_Cons_tl</span><span> </span><span>length_0_conv</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>nat.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>size_Cons_lem_eq</span><span> </span><span>tl_append2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃xs ys. ts = xs@ss@ys ∧ i = length xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2.IH"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?lhs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>sublist_iff_sublist_at</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Sublist.sublist xs ys ⟷ (∃i. sublist_at xs ys i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sublist_at_altdef</span><span> </span><span>Sublist.sublist_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Sublist-check algorithms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  We use the Isabelle Refinement Framework (Theory @{theory Refine_Monadic.Refine_Monadic}) to
  phrase the specification and the algorithm. 
›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{term s} for "searchword" / "searchlist", @{term t} for "text"›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp_SPEC s t = SPEC (λ
  None ⇒ ∄i. sublist_at s t i |
  Some i ⇒ sublist_at s t i ∧ (∀ii&lt;i. ¬sublist_at s t ii))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_arg_min_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_arg_min id P i ⟷ P i ∧ (∀ii&lt;i. ¬P ii)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_arg_min_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp_result</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp_SPEC s t =
  RETURN (if sublist s t then Some (LEAST i. sublist_at s t i) else None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kmp_SPEC_def</span><span> </span><span>sublist_iff_sublist_at</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>LeastI</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>not_less_Least</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>LeastI</span><span> </span><span>nat_neq_iff</span><span> </span><span>not_less_Least</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>weak_kmp_SPEC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp_SPEC s t ≤ SPEC (λpos. pos≠None ⟷ Sublist.sublist s t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>kmp_result</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>kmp_SPEC_altdefs</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>kmp_SPEC_def</span><span class="delimiter">[</span><span>folded</span><span> </span><span>is_arg_min_id</span><span class="delimiter">]</span><span>
</span><span>  </span><span>kmp_SPEC_def</span><span class="delimiter">[</span><span>folded</span><span> </span><span>sublist_iff_sublist_at</span><span class="delimiter">]</span><span>
</span><span>  </span><span>kmp_result</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Naive algorithm›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Since KMP is a direct advancement of the naive "test-all-starting-positions" approach, we provide it here for comparison:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Invariants›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_out_na s t ≡ λ(i,j,pos).
  (∀ii&lt;i. ¬sublist_at s t ii) ∧
  (case pos of None ⇒ j = 0
    | Some p ⇒ p=i ∧ sublist_at s t i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_in_na s t i ≡ λ(j,pos).
  case pos of None ⇒ j &lt; length s ∧ (∀jj&lt;j. t!(i+jj) = s!(jj))
    | Some p ⇒ sublist_at s t i"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Algorithm›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Algorithm is common knowledge ⟶ remove citation here, move explanations to KMP below?*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The following definition is taken from Helmut Seidl's lecture on algorithms and data structures@{cite GAD} except that we
▪ output the identified position @{term ‹pos :: nat option›} instead of just @{const True}
▪ use @{term ‹pos :: nat option›} as break-flag to support the abort within the loops
▪ rewrite @{prop ‹i ≤ length t - length s›} in the first while-condition to @{prop ‹i + length s ≤ length t›} to avoid having to use @{typ int} for list indexes (or the additional precondition @{prop ‹length s ≤ length t›})
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"naive_algorithm s t ≡ do {
  let i=0;
  let j=0;
  let pos=None;
  (_,_,pos) ← WHILEIT (I_out_na s t) (λ(i,_,pos). i + length s ≤ length t ∧ pos=None) (λ(i,j,pos). do {
    (_,pos) ← WHILEIT (I_in_na s t i) (λ(j,pos). t!(i+j) = s!j ∧ pos=None) (λ(j,_). do {
      let j=j+1;
      if j=length s then RETURN (j,Some i) else RETURN (j,None)
    }) (j,pos);
    if pos=None then do {
      let i = i + 1;
      let j = 0;
      RETURN (i,j,None)
    } else RETURN (i,j,Some i)
  }) (i,j,pos);

  RETURN pos
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The basic lemmas on @{const sublist_at} from the previous chapter together with @{theory Refine_Monadic.Refine_Monadic}'s verification condition generator / solver suffice:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ [] ⟹ naive_algorithm s t ≤ kmp_SPEC s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>naive_algorithm_def</span><span> </span><span>kmp_SPEC_def</span><span> </span><span>I_out_na_def</span><span> </span><span>I_in_na_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span>
</span><span>    </span><span>WHILEIT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"measure (λ(i,_,pos). length t - i + (if pos = None then 1 else 0))"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>WHILEIT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"measure (λ(j,_::nat option). length s - j)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>                 </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>solve</span><span class="delimiter">:</span><span> </span><span>asm_rl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_Suc_right</span><span> </span><span>all_positions_sublist</span><span> </span><span>less_antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_Suc_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_SucE</span><span> </span><span>sublist_all_positions</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sublist_lengths</span><span> </span><span>add_less_cancel_right</span><span> </span><span>leI</span><span> </span><span>le_less_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Note that the precondition cannot be removed without an extra branch: If @{prop ‹s = []›}, the inner while-condition accesses out-of-bound memory. This will apply to KMP, too.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Knuth--Morris--Pratt algorithm›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Just like our templates@{cite KMP77}@{cite GAD}, we first verify the main routine and discuss the computation of the auxiliary values @{term ‹𝔣 s›} only in a later section.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Preliminaries: Borders of lists›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"border xs ys ⟷ prefix xs ys ∧ suffix xs ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border xs ys ⟷ border xs ys ∧ length xs &lt; length ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intrinsic_border ls ≡ ARG_MAX length b. strict_border b ls"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>border_order</span><span class="delimiter">:</span><span> </span><span>order</span><span> </span><span>border</span><span> </span><span>strict_border</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>border_def</span><span> </span><span>suffix_def</span><span> </span><span>strict_border_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>border_bot</span><span class="delimiter">:</span><span> </span><span>order_bot</span><span> </span><span>Nil</span><span> </span><span>border</span><span> </span><span>strict_border</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>border_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>borderE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"border xs ys"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix xs ys"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suffix xs ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>border_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_borderE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border xs ys"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"border xs ys"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs &lt; length ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>strict_border_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_border_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_border xs [] ⟷ False"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_border [] (x # xs) ⟷ True"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>strict_border_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_border_prefix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border xs ys ⟹ strict_prefix xs ys"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>strict_border_suffix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border xs ys ⟹ strict_suffix xs ys"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>strict_border_imp_nonempty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border xs ys ⟹ ys ≠ []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>strict_border_prefix_suffix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border xs ys ⟷ strict_prefix xs ys ∧ strict_suffix xs ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>border_order.order.strict_iff_order</span><span> </span><span>border_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_length_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"border xs ys ⟹ length xs ≤ length ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>border_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prefix_length_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_length_r_less</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*rm*)</span></span></span></span></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀xs. strict_border xs ys ⟶ length xs &lt; length ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>strict_borderE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_positions</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"border xs ys ⟹ ∀i&lt;length xs. ys!i = ys!(length ys - length xs + i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>border_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_add_inverse</span><span> </span><span>diff_add_inverse2</span><span> </span><span>length_append</span><span> </span><span>not_add_less1</span><span> </span><span>nth_append</span><span> </span><span>prefixE</span><span> </span><span>suffixE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_positions_drop_length_take</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦i ≤ length w; i ≤ length x;
  ∀j&lt;i. x ! j = w ! (length w + j - i)⟧
    ⟹ drop (length w - i) w = take i x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i = length x"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>nth_equalityI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_positions_suffix_take</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦i ≤ length w; i ≤ length x;
  ∀j&lt;i. x ! j = w ! (length w + j - i)⟧
    ⟹ suffix (take i x) w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>all_positions_drop_length_take</span><span> </span><span>suffix_drop</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suffix_butlast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"suffix xs ys ⟹ suffix (butlast xs) (butlast ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suffix_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Nil2</span><span> </span><span>butlast.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>butlast_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>positions_border</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j&lt;l. w!j = w!(length w - l + j) ⟹ border (take l w) w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"l &lt; length w"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>border_def</span><span> </span><span>all_positions_suffix_take</span><span> </span><span>take_is_prefix</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>positions_strict_border</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l &lt; length w ⟹ ∀j&lt;l. w!j = w!(length w - l + j) ⟹ strict_border (take l w) w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>positions_border</span><span> </span><span>strict_border_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>intrinsic_borderI</span><span> </span><span class="delimiter">=</span><span> </span><span>arg_max_natI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>border_length_r_less</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>intrinsic_border_def</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>intrinsic_borderI'</span><span> </span><span class="delimiter">=</span><span> </span><span>border_bot.bot.not_eq_extremum</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>intrinsic_borderI</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>intrinsic_border_max</span><span> </span><span class="delimiter">=</span><span> </span><span>arg_max_nat_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>border_length_r_less</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>intrinsic_border_def</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonempty_is_arg_max_ib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ys ≠ [] ⟹ is_arg_max length (λxs. strict_border xs ys) (intrinsic_border ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>intrinsic_borderI'</span><span> </span><span>intrinsic_border_max</span><span> </span><span>is_arg_max_linorder</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intrinsic_border_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w ≠ [] ⟹ length (intrinsic_border w) &lt; length w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>intrinsic_borderI</span><span class="delimiter">[</span><span>of</span><span> </span><span>w</span><span class="delimiter">]</span><span> </span><span>border_length_r_less</span><span> </span><span>intrinsic_borderI'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intrinsic_border_take_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j &gt; 0 ⟹ w ≠ [] ⟹ length (intrinsic_border (take j w)) &lt; length w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>intrinsic_border_less</span><span> </span><span>length_take</span><span> </span><span>less_not_refl2</span><span> </span><span>min_less_iff_conj</span><span> </span><span>take_eq_Nil</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Examples›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_example</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{b. border b ''aabaabaa''} = {'''', ''a'', ''aa'', ''aabaa'', ''aabaabaa''}"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{b. border b ?l} = {?take0, ?take1, ?take2, ?take5, ?l}"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{?take0, ?take1, ?take2, ?take5, ?l} ⊆ {b. border b ?l}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>eval</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬border ''aab'' ?l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬border ''aaba'' ?l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬border ''aabaab'' ?l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬border ''aabaaba'' ?l"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{b. border b ?l} ⊆ set (prefixes ?l)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>border_def</span><span> </span><span>in_set_prefixes</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{b. border b ?l} ⊆ {?take0, ?take1, ?take2, ?take5, ?l}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>strict_border_example</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{b. strict_border b ''aabaabaa''} = {'''', ''a'', ''aa'', ''aabaa''}"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l = ?r"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l ⊆ {b. border b ''aabaabaa''}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = {'''', ''a'', ''aa'', ''aabaa'', ''aabaabaa''}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>border_example</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l ⊆ ?r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?r ⊆ ?l"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>eval</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intrinsic_border ''aabaabaa'' = ''aabaa''"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment">― ‹We later obtain a fast algorithm for that.›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>exhaust</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border b ''aabaabaa'' ⟷ b ∈ {'''', ''a'', ''aa'', ''aabaa''}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>strict_border_example</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬is_arg_max length (λb. strict_border b ''aabaabaa'') ''''"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬is_arg_max length (λb. strict_border b ''aabaabaa'') ''a''"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬is_arg_max length (λb. strict_border b ''aabaabaa'') ''aa''"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_arg_max length (λb. strict_border b ''aabaabaa'') ''aabaa''"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_arg_max_linorder</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (intrinsic_border ''aabaabaa'') ''aabaabaa''"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>intrinsic_borderI'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>exhaust</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.discI</span><span> </span><span>nonempty_is_arg_max_ib</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Main routine›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The following is Seidl's "border"-table@{cite GAD} (values shifted by 1 so we don't need @{typ int}),
or equivalently, "f" from Knuth's, Morris' and Pratt's paper@{cite KMP77} (with indexes starting at 0).›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>𝔣</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ nat ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔣 s 0 = 0"</span></span></span><span> </span><span class="comment">― ‹This increments the compare position while @{prop ‹j=(0::nat)›}›</span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j = length (intrinsic_border (take j s)) + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Note that we use their "next" only implicitly.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Invariants›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_outer s t ≡ λ(i,j,pos).
  (∀ii&lt;i. ¬sublist_at s t ii) ∧
  (case pos of None ⇒ (∀jj&lt;j. t!(i+jj) = s!(jj)) ∧ j &lt; length s
    | Some p ⇒ p=i ∧ sublist_at s t i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For the inner loop, we can reuse @{const I_in_na}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Algorithm›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹First, we use the non-evaluable function @{const 𝔣} directly:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp s t ≡ do {
  ASSERT (s ≠ []);
  let i=0;
  let j=0;
  let pos=None;
  (_,_,pos) ← WHILEIT (I_outer s t) (λ(i,j,pos). i + length s ≤ length t ∧ pos=None) (λ(i,j,pos). do {
    ASSERT (i + length s ≤ length t);
    (j,pos) ← WHILEIT (I_in_na s t i) (λ(j,pos). t!(i+j) = s!j ∧ pos=None) (λ(j,pos). do {
      let j=j+1;
      if j=length s then RETURN (j,Some i) else RETURN (j,None)
    }) (j,pos);
    if pos=None then do {
      ASSERT (j &lt; length s);
      let i = i + (j - 𝔣 s j + 1);
      let j = max 0 (𝔣 s j - 1); ― ‹‹max› not necessary›
      RETURN (i,j,None)
    } else RETURN (i,j,Some i)
  }) (i,j,pos);

  RETURN pos
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔣_eq_0_iff_j_eq_0</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j = 0 ⟷ j = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>j</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>j_le_𝔣_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ length s ⟹ 𝔣 s j ≤ j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_leI</span><span> </span><span>intrinsic_border_less</span><span> </span><span>length_take</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>min.absorb2</span><span> </span><span>nat.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>j_le_𝔣_le'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; j ⟹ j ≤ length s ⟹ 𝔣 s j - 1 &lt; j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_less</span><span> </span><span>j_le_𝔣_le</span><span> </span><span>le_eq_less_or_eq</span><span> </span><span>less_imp_diff_less</span><span> </span><span>less_one</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔣_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ [] ⟹ 𝔣 s j - 1 &lt; length s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>j</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>intrinsic_border_take_less</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  Only needed for run-time analysis
lemma "p576 et seq":
  assumes
    "j ≤ length s" and
    assignments:
    "i' = i + (j + 1 - 𝔣 s j)"
    "j' = max 0 (𝔣 s j - 1)"
  shows
    sum_no_decrease: "i' + j' ≥ i + j" and
    i_increase: "i' &gt; i"
  using assignments by (simp_all add: j_le_𝔣_le[OF assms(1), THEN le_imp_less_Suc])
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reuse_matches</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>j_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ length s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>old_matches</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀jj&lt;j. t ! (i + jj) = s ! jj"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀jj&lt;𝔣 s j - 1. t ! (i + (j - 𝔣 s j + 1) + jj) = s ! jj"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀jj&lt;?j'. t ! (?i' + jj) = s ! jj"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"j&gt;0"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j&gt;0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>𝔣_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j ≤ j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>j_le</span><span> </span><span>j_le_𝔣_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>old_matches</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀jj&lt;?j'. t ! (?i' + jj) = s ! (j - 𝔣 s j + 1 + jj)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ab_semigroup_add_class.add.commute</span><span> </span><span>add.assoc</span><span> </span><span>diff_diff_cancel</span><span> </span><span>less_diff_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (take j s) = j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (intrinsic_border (take j s)) = ?j'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>j_le</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; j›</span></span></span><span> </span><span>diff_add_inverse2</span><span> </span><span>𝔣.elims</span><span> </span><span>nat_neq_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀jj&lt;?j'. take j s ! jj = take j s ! (j - (𝔣 s j - 1) + jj)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>intrinsic_borderI'</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; j›</span></span></span><span> </span><span>border_positions</span><span> </span><span>length_greater_0_conv</span><span> </span><span>strict_border_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀jj&lt;?j'. take j s ! jj = take j s ! (j - 𝔣 s j + 1 + jj)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>𝔣_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀jj&lt;?j'. s ! (j - 𝔣 s j + 1 + jj) = s ! jj"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>𝔣_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>shift_safe</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀ii&lt;i. ¬sublist_at s t ii"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t!(i+j) ≠ s!j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>matches</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀jj&lt;j. t!(i+jj) = s!jj"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span>
</span><span>    </span><span>assignment</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i' ≡ i + (j - 𝔣 s j + 1)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀ii&lt;i'. ¬sublist_at s t ii"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>standard</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ii</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ii &lt; i'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="comment">― ‹The position falls into one of three categories:›</span><span>
</span><span>    </span><span class="delimiter">(</span><span>old</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"ii &lt; i"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="delimiter">(</span><span>current</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"ii = i"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="delimiter">(</span><span>skipped</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"ii &gt; i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬sublist_at s t ii"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>old</span><span> </span><span class="comment">― ‹Old position, use invariant.›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀ii&lt;i. ¬sublist_at s t ii›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>current</span><span> </span><span class="comment">― ‹The mismatch occurred while testing this alignment.›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t!(i+j) ≠ s!j›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sublist_all_positions</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>skipped</span><span> </span><span class="comment">― ‹The skipped positions.›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0&lt;j"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ii &lt; i'›</span></span></span><span> </span><span>assignment</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>less_j</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j + i - ii &lt; j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>le_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j + i - ii ≤ length s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ii &lt; i'›</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>skipped</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>𝔣_le</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>j_le_𝔣_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>less_imp_le</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; 𝔣 s j"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; j›</span></span></span><span> </span><span>𝔣_eq_0_iff_j_eq_0</span><span> </span><span>neq0_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j + i - ii &gt; 𝔣 s j - 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ii &lt; i'›</span></span></span><span> </span><span>assignment</span><span> </span><span>𝔣_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>contradiction_goal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j + i - ii &gt; length (intrinsic_border (take j s))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>𝔣.elims</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; j›</span></span></span><span> </span><span>add_diff_cancel_right'</span><span> </span><span>not_gr_zero</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist_at s t ii"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>sublist_all_positions</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>le_s</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀jj &lt; j+i-ii. t!(ii+jj) = s!jj"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ff1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ii &lt; i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>not_less_iff_gr_or_eq</span><span> </span><span>skipped</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + (ii - i + jj) = ii + jj"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>jj</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.assoc</span><span> </span><span>add_diff_inverse_nat</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ jj &lt; j + i - ii ∨ t ! (ii + jj) = s ! (ii - i + jj)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ii - i + jj &lt; j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>jj</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>ff1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>matches</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ jj &lt; j + i - ii ∨ t ! (ii + jj) = s ! (ii - i + jj)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>jj</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ff1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>matches</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀jj &lt; j+i-ii. t!(ii+jj) = s!(ii-i+jj)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀jj &lt; j+i-ii. s!jj = s!(ii-i+jj)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀jj &lt; j+i-ii. (take j s)!jj = (take j s)!(ii-i+jj)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i&lt;ii›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>positions_strict_border</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"j+i-ii"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take j s"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (take (j+i-ii) s) (take j s)"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>intrinsic_border_max</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>contradiction_goal</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j+i-ii ≤ length s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>le_s</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ []
  ⟹ kmp s t ≤ kmp_SPEC s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kmp_def</span><span> </span><span>kmp_SPEC_def</span><span> </span><span>I_outer_def</span><span> </span><span>I_in_na_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span>
</span><span>    </span><span>WHILEIT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"measure (λ(i,_,pos). length t - i + (if pos = None then 1 else 0))"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>WHILEIT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"measure (λ(j,_::nat option). length s - j)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>                   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>solve</span><span class="delimiter">:</span><span> </span><span>asm_rl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_Suc_right</span><span> </span><span>all_positions_sublist</span><span> </span><span>less_antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span>jout</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>shift_safe</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>j</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span>jout</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reuse_matches</span><span class="delimiter">[</span><span>of</span><span> </span><span>j</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>𝔣_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sublist_lengths</span><span> </span><span>add_less_cancel_right</span><span> </span><span>leI</span><span> </span><span>le_less_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Storing the @{const 𝔣}-values›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We refine the algorithm to compute the @{const 𝔣}-values only once at the start:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>compute_𝔣s_SPEC</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ nat list nres"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"compute_𝔣s_SPEC s ≡ SPEC (λ𝔣s. length 𝔣s = length s + 1 ∧ (∀j≤length s. 𝔣s!j = 𝔣 s j))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp1 s t ≡ do {
  ASSERT (s ≠ []);
  let i=0;
  let j=0;
  let pos=None;
  𝔣s ← compute_𝔣s_SPEC (butlast s); ― ‹At the last char, we abort instead.›
  (_,_,pos) ← WHILEIT (I_outer s t) (λ(i,j,pos). i + length s ≤ length t ∧ pos=None) (λ(i,j,pos). do {
    ASSERT (i + length s ≤ length t);
    (j,pos) ← WHILEIT (I_in_na s t i) (λ(j,pos). t!(i+j) = s!j ∧ pos=None) (λ(j,pos). do {
      let j=j+1;
      if j=length s then RETURN (j,Some i) else RETURN (j,None)
    }) (j,pos);
    if pos=None then do {
      ASSERT (j &lt; length 𝔣s);
      let i = i + (j - 𝔣s!j + 1);
      let j = max 0 (𝔣s!j - 1); ― ‹‹max› not necessary›
      RETURN (i,j,None)
    } else RETURN (i,j,Some i)
  }) (i,j,pos);

  RETURN pos
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔣_butlast</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length s ⟹ 𝔣 (butlast s) j = 𝔣 s j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>j</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>take_butlast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp1_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp1 s t ≤ kmp s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refine_IdD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kmp1_def</span><span> </span><span>kmp_def</span><span> </span><span>Let_def</span><span> </span><span>compute_𝔣s_SPEC_def</span><span> </span><span>nres_monad_laws</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ASSERT_refine_right</span><span> </span><span>ASSERT_refine_left</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Refine_Basic.intro_spec_refine</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vc_solve</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Next, an algorithm that satisfies @{const compute_𝔣s_SPEC}:›</span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Computing @{const 𝔣}›</span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Invariants›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_out_cb s ≡ λ(𝔣s,i,j).
  length s + 1 = length 𝔣s ∧
  (∀jj&lt;j. 𝔣s!jj = 𝔣 s jj) ∧
  𝔣s!(j-1) = i ∧
  0 &lt; j"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_in_cb s j ≡ λi.
  if j=1 then i=0 ― ‹first iteration›
  else
    strict_border (take (i-1) s) (take (j-1) s) ∧
    𝔣 s j ≤ i + 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Algorithm›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Again, we follow Seidl@{cite GAD}, p.582. Apart from the +1-shift, we make another modification:
Instead of directly setting @{term ‹𝔣s!1›}, we let the first loop-iteration (if there is one) do that for us.
This allows us to remove the precondition @{prop ‹s ≠ []›}, as the index bounds are respected even in that corner case.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>compute_𝔣s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ nat list nres"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"compute_𝔣s s = do {
  let 𝔣s=replicate (length s + 1) 0; ― ‹only the first 0 is needed›
  let i=0;
  let j=1;
  (𝔣s,_,_) ← WHILEIT (I_out_cb s) (λ(𝔣s,_,j). j &lt; length 𝔣s) (λ(𝔣s,i,j). do {
    i ← WHILEIT (I_in_cb s j) (λi. i&gt;0 ∧ s!(i-1) ≠ s!(j-1)) (λi. do {
      ASSERT (i-1 &lt; length 𝔣s);
      let i=𝔣s!(i-1);
      RETURN i
    }) i;
    let i=i+1;
    ASSERT (j &lt; length 𝔣s);
    let 𝔣s=𝔣s[j:=i];
    let j=j+1;
    RETURN (𝔣s,i,j)
  }) (𝔣s,i,j);
  
  RETURN 𝔣s
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>take_length_ib</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ length s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take (length (intrinsic_border (take j s))) s = intrinsic_border (take j s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix (intrinsic_border (take j s)) (take j s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>intrinsic_borderI'</span><span> </span><span>border_def</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>neq0_conv</span><span> </span><span>not_less</span><span> </span><span>strict_border_def</span><span> </span><span>take_eq_Nil</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix (take j s) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹j ≤ length s›</span></span></span><span> </span><span>take_is_prefix</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_eq_conv_conj</span><span> </span><span>prefixE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ib_singleton</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"intrinsic_border [z] = []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>intrinsic_border_less</span><span> </span><span>length_Cons</span><span> </span><span>length_greater_0_conv</span><span> </span><span>less_Suc0</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_butlast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"border xs ys ⟹ border (butlast xs) (butlast ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>border_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>butlast_append</span><span> </span><span>prefixE</span><span> </span><span>prefix_order.eq_refl</span><span> </span><span>prefix_prefix</span><span> </span><span>prefixeq_butlast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Sublist.suffix_def</span><span> </span><span>append.right_neutral</span><span> </span><span>butlast.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>butlast_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>strict_border_butlast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs ≠ [] ⟹ strict_border xs ys ⟹ strict_border (butlast xs) (butlast ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>strict_border_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>border_butlast</span><span> </span><span>less_diff_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_take_lengths</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ length s ⟹ border (take i s) (take j s) ⟹ i ≤ j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>border_length_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"border xs ys ⟷ border (xs@[ys!length xs]) (ys@[ys!length xs])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>border_def</span><span> </span><span>suffix_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>append_one_prefix</span><span> </span><span>prefixE</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>append_prefixD</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>strict_border_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border xs ys ⟷ strict_border (xs@[ys!length xs]) (ys@[ys!length xs])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>strict_border_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>border_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ib_butlast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length w ≥ 2 ⟹ length (intrinsic_border w) ≤ length (intrinsic_border (butlast w)) + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length w ≥ 2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (intrinsic_border w) w"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>intrinsic_borderI'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹2 ≤ length w›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (butlast (intrinsic_border w)) (butlast w)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>border_bot.bot.not_eq_extremum</span><span> </span><span>butlast.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>len_greater_imp_nonempty</span><span> </span><span>length_butlast</span><span> </span><span>lessI</span><span> </span><span>less_le_trans</span><span> </span><span>numerals</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>strict_border_butlast</span><span> </span><span>zero_less_diff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (butlast (intrinsic_border w)) ≤ length (intrinsic_border (butlast w))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>intrinsic_border_max</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>𝔣_Suc</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*rm*)</span></span></span></span></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc i ≤ length w ⟹ 𝔣 w (Suc i) ≤ 𝔣 w i + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>take_Suc0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>Suc_to_right</span><span> </span><span>butlast_take</span><span> </span><span>diff_is_0_eq</span><span> </span><span>ib_butlast</span><span> </span><span>length_take</span><span> </span><span>min.absorb2</span><span> </span><span>nat.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>not_less_eq_eq</span><span> </span><span>numerals</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔣_step_bound</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*rm*)</span></span></span></span></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ length w"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 w j ≤ 𝔣 w (j-1) + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>j_le_𝔣_le</span><span class="delimiter">]</span><span> </span><span>𝔣_Suc</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_pred</span><span> </span><span>le_SucI</span><span> </span><span>not_gr_zero</span><span> </span><span>trans_le_add2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>border_take_𝔣</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"border (take (𝔣 s i - 1) s ) (take i s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>intrinsic_borderI'</span><span> </span><span>border_order.eq_iff</span><span> </span><span>border_order.less_imp_le</span><span> </span><span>border_positions</span><span> </span><span>nat.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>nat_le_linear</span><span> </span><span>positions_border</span><span> </span><span>take_all</span><span> </span><span>take_eq_Nil</span><span> </span><span>take_length_ib</span><span> </span><span>zero_less_Suc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>𝔣_strict_borderI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y = 𝔣 s (i-1) ⟹ strict_border (take (i-1) s) (take (j-1) s) ⟹ strict_border (take (y-1) s) (take (j-1) s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>border_order.less_le_not_le</span><span> </span><span>border_order.order.trans</span><span> </span><span>border_take_𝔣</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>strict_border_take_𝔣</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; i ⟹ i ≤ length s ⟹ strict_border (take (𝔣 s i - 1) s ) (take i s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>border_order.less_le_not_le</span><span> </span><span>border_take_𝔣</span><span> </span><span>border_take_lengths</span><span> </span><span>j_le_𝔣_le'</span><span> </span><span>leD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔣_is_max</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ length s ⟹ strict_border b (take j s) ⟹ 𝔣 s j ≥ length b + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>𝔣.elims</span><span> </span><span>add_le_cancel_right</span><span> </span><span>add_less_same_cancel2</span><span> </span><span>border_length_r_less</span><span> </span><span>intrinsic_border_max</span><span> </span><span>length_take</span><span> </span><span>min_absorb2</span><span> </span><span>not_add_less2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>skipping_ok</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>j_bounds</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 &lt; j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ length s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mismatch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s!(i-1) ≠ s!(j-1)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>greater_checked</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j ≤ i + 1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (take (i-1) s) (take (j-1) s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j ≤ 𝔣 s (i-1) + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬𝔣 s j ≤ 𝔣 s (i-1) + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i_bounds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ length s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>greater_checked</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>take_Nil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i_less_j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>border_length_r_less</span><span> </span><span>nz_le_conv_less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬𝔣 s j ≤ 𝔣 s (i-1) + 1›</span></span></span><span> </span><span>greater_checked</span><span> </span><span class="keyword1"><span class="command">consider</span></span><span>
</span><span>    </span><span class="delimiter">(</span><span>tested</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j = i + 1"</span></span></span><span> </span><span class="comment">― ‹This contradicts @{thm mismatch}›</span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="delimiter">(</span><span>skipped</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s (i-1) + 1 &lt; 𝔣 s j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j ≤ i"</span></span></span><span>
</span><span>      </span><span class="comment">― ‹This contradicts @{thm 𝔣_is_max[of "i-1" s]}›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>tested</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j - 1 = i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>border_positions</span><span class="delimiter">[</span><span>OF</span><span> </span><span>border_take_𝔣</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>j</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>this</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take j s ! (i-1) = s!(j-1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_bounds</span><span> </span><span>i_less_j</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; j›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s!(i-1) = s!(j-1)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_imp_diff_less</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mismatch</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>skipped</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?border</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"take (i-1) s"</span></span></span><span>
</span><span>      </span><span class="comment">― ‹This border of @{term ‹take (j-1) s›} could not be extended to a border of @{term ‹take j s›} due to the mismatch.›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?impossible</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"take (𝔣 s j - 2) s"</span></span></span><span>
</span><span>      </span><span class="comment">― ‹A strict border longer than @{term ‹intrinsic_border ?border›}, a contradiction.›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (take j s) = j"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j - 2 &lt; i - 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>skipped</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>less_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j - 2 &lt; length s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i - 1 &lt; length s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; j›</span></span></span><span> </span><span>j_bounds</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>strict</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ?impossible &lt; length ?border"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹𝔣 s j - 2 &lt; i - 1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix ?impossible (take j s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prefix_length_prefix</span><span> </span><span>take_is_prefix</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length (take j s) = j›</span></span></span><span> </span><span>j_bounds</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>diff_le_self</span><span> </span><span>j_le_𝔣_le</span><span> </span><span>length_take</span><span> </span><span>less_s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>min_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix ?border (take j s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length (take j s) = j›</span></span></span><span> </span><span>diff_le_self</span><span> </span><span>i_less_j</span><span> </span><span>le_trans</span><span> </span><span>length_take</span><span> </span><span>less_or_eq_imp_le</span><span> </span><span>less_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>min_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>prefix_length_prefix</span><span> </span><span>take_is_prefix</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix ?impossible ?border"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>strict</span><span> </span><span>less_imp_le_nat</span><span> </span><span>prefix_length_prefix</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suffix (take (𝔣 s j - 1) s) (take j s)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>border_take_𝔣</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>border_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>suffix_butlast</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suffix ?impossible (take (j-1) s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>j_bounds</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>butlast_take</span><span> </span><span>diff_diff_left</span><span> </span><span>𝔣_le</span><span> </span><span>len_greater_imp_nonempty</span><span> </span><span>less_or_eq_imp_le</span><span> </span><span>less_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>one_add_one</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suffix ?impossible (take (j-1) s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suffix ?border (take (j-1) s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>suffix_length_suffix</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>strict</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>less_imp_le</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suffix ?impossible ?border"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border ?impossible ?border"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>strict_border_def</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>border_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>𝔣_is_max</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"i-1"</span></span></span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (take (𝔣 s j - 2) s) + 1 ≤ 𝔣 s (i-1)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_imp_le_nat</span><span> </span><span>less_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j - 1 ≤ 𝔣 s (i-1)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j ≤ 𝔣 s (i-1) + 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_diff_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>skipped</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extend_border</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ length s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s!(i-1) = s!(j-1)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (take (i-1) s) (take (j-1) s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j ≤ i + 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j = i + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>pos_in_range</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i - 1 &lt; length s "</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (take (i-1) s) = i - 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>border_length_r_less</span><span> </span><span>min_less_iff_conj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>strict_border_step</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (take (i-1) s @ [s!(i-1)]) (take (j-1) s @ [s!(i-1)])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>border_length_r_less</span><span> </span><span>length_take</span><span> </span><span>min_less_iff_conj</span><span> </span><span>nth_take</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pos_in_range</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (take i s) (take (j-1) s @ [s!(i-1)])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>Suc_pred</span><span> </span><span>add.left_neutral</span><span> </span><span>border_bot.bot.not_eq_extremum</span><span> </span><span>border_order.less_asym</span><span> </span><span>neq0_conv</span><span> </span><span>take_0</span><span> </span><span>take_Suc_conv_app_nth</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (take i s) (take (j-1) s @ [s!(j-1)])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s!(i-1) = s!(j-1)›</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_border (take i s) (take j s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_pred</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>diff_le_self</span><span> </span><span>less_le_trans</span><span> </span><span>neq0_conv</span><span> </span><span>nz_le_conv_less</span><span> </span><span>strict_border_imp_nonempty</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span>take_eq_Nil</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>𝔣_is_max</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔣 s j ≥ i + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_leI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹𝔣 s j ≤ i + 1›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compute_𝔣s_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"compute_𝔣s s ≤ compute_𝔣s_SPEC s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compute_𝔣s_SPEC_def</span><span> </span><span>compute_𝔣s_def</span><span> </span><span>I_out_cb_def</span><span> </span><span>I_in_cb_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>refine_vcg</span><span>
</span><span>    </span><span>WHILEIT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"measure (λ(𝔣s,i,j). length s + 1 - j)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>WHILEIT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"measure id"</span></span></span><span class="delimiter">]</span><span> </span><span class="comment">― ‹@{term ‹i::nat›} decreases with every iteration.›</span><span>
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>                      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span class="delimiter">,</span><span> </span><span>fold</span><span> </span><span>One_nat_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>strict_border_take_𝔣</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>𝔣_step_bound</span><span> </span><span>less_Suc_eq_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_lessD</span><span> </span><span>Suc_pred</span><span> </span><span>border_length_r_less</span><span> </span><span>𝔣_strict_borderI</span><span> </span><span>length_take</span><span> </span><span>less_Suc_eq</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>min.absorb2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>j</span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_diff_1</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>Suc_leI</span><span> </span><span>border_take_lengths</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>less_antisym</span><span> </span><span>skipping_ok</span><span> </span><span>strict_border_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_diff_1</span><span> </span><span>border_take_lengths</span><span> </span><span>j_le_𝔣_le</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>strict_border_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>j</span><span> </span><span>i</span><span> </span><span>jj</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>Suc_eq_plus1_left</span><span> </span><span>add.right_neutral</span><span> </span><span>extend_border</span><span> </span><span>𝔣_eq_0_iff_j_eq_0</span><span> </span><span>j_le_𝔣_le</span><span> </span><span>le_zero_eq</span><span> </span><span>less_Suc_eq</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>nth_list_update_eq</span><span> </span><span>nth_list_update_neq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Index shift›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹To avoid inefficiencies, we refine @{const compute_𝔣s} to take @{term s}
instead of @{term ‹butlast s›} (it still only uses @{term ‹butlast s›}).›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>compute_butlast_𝔣s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ nat list nres"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"compute_butlast_𝔣s s = do {
  let 𝔣s=replicate (length s) 0;
  let i=0;
  let j=1;
  (𝔣s,_,_) ← WHILEIT (I_out_cb (butlast s)) (λ(b,i,j). j &lt; length b) (λ(𝔣s,i,j). do {
    ASSERT (j &lt; length 𝔣s);
    i ← WHILEIT (I_in_cb (butlast s) j) (λi. i&gt;0 ∧ s!(i-1) ≠ s!(j-1)) (λi. do {
      ASSERT (i-1 &lt; length 𝔣s);
      let i=𝔣s!(i-1);
      RETURN i
    }) i;
    let i=i+1;
    ASSERT (j &lt; length 𝔣s);
    let 𝔣s=𝔣s[j:=i];
    let j=j+1;
    RETURN (𝔣s,i,j)
  }) (𝔣s,i,j);
  
  RETURN 𝔣s
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compute_𝔣s_inner_bounds</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_out_cb s (𝔣s,ix,j)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length 𝔣s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_in_cb s j i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i-1 &lt; length s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j-1 &lt; length s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>I_out_cb_def</span><span> </span><span>I_in_cb_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compute_butlast_𝔣s_refine</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,s') ∈ br butlast ((≠) [])"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compute_butlast_𝔣s s ≤ ⇓ Id (compute_𝔣s_SPEC s')"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compute_butlast_𝔣s s ≤ ⇓ Id (compute_𝔣s s')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compute_butlast_𝔣s_def</span><span> </span><span>compute_𝔣s_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_dref_type</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred</span><span> </span><span>length_greater_0_conv</span><span> </span><span>replicate_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>compute_𝔣s_inner_bounds</span><span> </span><span>nth_butlast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>compute_𝔣s_correct</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Conflation›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We replace @{const compute_𝔣s_SPEC} with @{const compute_butlast_𝔣s}›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp2 s t ≡ do {
  ASSERT (s ≠ []);
  let i=0;
  let j=0;
  let pos=None;
  𝔣s ← compute_butlast_𝔣s s;
  (_,_,pos) ← WHILEIT (I_outer s t) (λ(i,j,pos). i + length s ≤ length t ∧ pos=None) (λ(i,j,pos). do {
    ASSERT (i + length s ≤ length t ∧ pos=None);
    (j,pos) ← WHILEIT (I_in_na s t i) (λ(j,pos). t!(i+j) = s!j ∧ pos=None) (λ(j,pos). do {
      let j=j+1;
      if j=length s then RETURN (j,Some i) else RETURN (j,None)
    }) (j,pos);
    if pos=None then do {
      ASSERT (j &lt; length 𝔣s);
      let i = i + (j - 𝔣s!j + 1);
      let j = max 0 (𝔣s!j - 1); ― ‹‹max› not necessary›
      RETURN (i,j,None)
    } else RETURN (i,j,Some i)
  }) (i,j,pos);

  RETURN pos
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Using @{thm [source] compute_butlast_𝔣s_refine} (it has attribute @{attribute refine}), the proof is trivial:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp2_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp2 s t ≤ kmp1 s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refine_IdD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kmp2_def</span><span> </span><span>kmp1_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>                  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>                  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp2_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ []
  ⟹ kmp2 s t ≤ kmp_SPEC s t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp2 s t ≤ kmp1 s t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>kmp2_refine</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ kmp s t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>kmp1_refine</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ kmp_SPEC s t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>kmp_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ≠ []›</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For convenience, we also remove the precondition:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp3 s t ≡ do {
  if s=[] then RETURN (Some 0) else kmp2 s t
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp3_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp3 s t ≤ kmp_SPEC s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kmp3_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>kmp2_correct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>kmp_SPEC_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Refinement to Imperative/HOL›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_id_param</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((=), (=)) ∈ Id → Id → Id"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>in_bounds_aux</span><span> </span><span class="delimiter">=</span><span> </span><span>compute_𝔣s_inner_bounds</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"butlast s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>compute_butlast_𝔣s_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>compute_butlast_𝔣s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(arl_assn id_assn)<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> array_assn nat_assn"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compute_butlast_𝔣s_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>in_bounds_aux</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>eq_id_param</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span>sepref_import_param</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>array_fold_custom_replicate</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>compute_butlast_𝔣s_impl.refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>compute_𝔣s</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp_inner_in_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + length s ≤ length t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I_in_na s t i (j,None)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + j &lt; length t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>I_in_na_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>kmp_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncurry kmp3"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(arl_assn id_assn)<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> (arl_assn id_assn)<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> option_assn nat_assn"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kmp3_def</span><span> </span><span>kmp2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>max_0L</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹Avoid the unneeded @{const max}›</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"WHILEIT (I_in_na _ _ _) ⌑"</span></span></span><span> </span><span>conj_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"WHILEIT (I_in_na _ _ _) ⌑"</span></span></span><span> </span><span>short_circuit_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>kmp_inner_in_bound</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>option.splits</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>eq_id_param</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span>sepref_import_param</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>kmp_impl</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML_imp</span><span> </span><span class="keyword2"><span class="keyword">module_name</span></span><span> </span><span>KMP</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kmp3_correct'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(uncurry kmp3, uncurry kmp_SPEC) ∈ Id ×<span class="hidden">⇩</span><sub>r</sub> Id →<span class="hidden">⇩</span><sub>f</sub> ⟨Id⟩nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>kmp3_correct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>kmp_impl_correct'</span><span> </span><span class="delimiter">=</span><span> </span><span>kmp_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>kmp3_correct'</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Overall Correctness Theorem›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following theorem relates the final Imperative HOL algorithm to its specification,
  using, beyond basic HOL concepts
    ▪ Hoare triples for Imperative/HOL, provided by the Separation Logic Framework for Imperative/HOL (Theory @{theory Separation_Logic_Imperative_HOL.Sep_Main});
    ▪ The assertion @{const arl_assn} to specify array-lists, which we use to represent the input strings of the algorithm;
    ▪ The @{const sublist_at} function that we defined in section \ref{sec:spec}.
  ›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>kmp_impl_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt; arl_assn id_assn s si * arl_assn id_assn t ti &gt; 
       kmp_impl si ti 
   &lt;λr. arl_assn id_assn s si * arl_assn id_assn t ti * ↑(
      case r of None ⇒  ∄i. sublist_at s t i
              | Some i ⇒ sublist_at s t i ∧ (∀ii&lt;i. ¬ sublist_at s t ii)
    )&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> 
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span> </span><span>kmp_SPEC_def</span><span>
</span><span>    </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span>
</span><span>    </span><span>heap</span><span class="delimiter">:</span><span>  </span><span>kmp_impl_correct'</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>hfrefD</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>hn_refineD</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,t)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(si,ti)"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kmp_string_impl ≡ kmp_impl :: (char array × nat) ⇒ _"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Tests of Generated ML-Code›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  fun str2arl s = (Array.fromList (@{code String.explode} s), @{code nat_of_integer} (String.size s))
  fun kmp s t = map_option @{code integer_of_nat} (@{code kmp_string_impl} (str2arl s) (str2arl t) ())
  
  val test1 = kmp "anas" "bananas"
  val test2 = kmp "" "bananas"
  val test3 = kmp "hide_fact" (File.read @{file ‹~~/src/HOL/Main.thy›})
  val test4 = kmp "sorry" (File.read @{file ‹~~/src/HOL/HOL.thy›})  
›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>