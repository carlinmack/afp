<div id="NDFS_SI_Statistics">
<div class="head"><h1>Theory NDFS_SI_Statistics</h1>
<span class="command">theory</span> <span class="name">NDFS_SI_Statistics</span><br/>
<span class="keyword">imports</span> <a href="../CAVA_Base/CAVA_Base.html"><span class="name">CAVA_Base</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>NDFS_SI_Statistics</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>CAVA_Base.CAVA_Base</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">code_module</span></span><span> </span><span>NDFS_SI_Statistics</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    structure NDFS_SI_Statistics = struct
      val active = Unsynchronized.ref false
      val cur_limit = Unsynchronized.ref 1000000
      val blue_vis = Unsynchronized.ref 0
      val blue_match = Unsynchronized.ref 0
      val red_vis = Unsynchronized.ref 0
      val time = Unsynchronized.ref Time.zeroTime

      fun is_active () = !active
      fun vis_blue () = (
            if !cur_limit &lt; !blue_vis then (
              TextIO.print("*** " ^ IntInf.toString((!cur_limit) div 1000000) ^ "e+06 states\n");
              cur_limit := !cur_limit + 1000000)
            else ();
            blue_vis := !blue_vis + 1)
      fun match_blue () = blue_match := !blue_match + 1
      fun vis_red () = red_vis := !red_vis + 1

      fun start () = (active := true; time := Time.now ())
      fun stop () = (time := Time.- (Time.now (), !time))

      fun to_string () = let
        val t = Time.toReal (!time)
        val states_per_s = real (!blue_vis) / t
        val realStr = Real.fmt (StringCvt.FIX (SOME 2))

      in
        "Required time  : " ^ realStr t ^ "s\n"
      ^ "States per sec : " ^ realStr states_per_s ^ "\n"
      ^ "Blue states (v): " ^ IntInf.toString (!blue_vis) ^ "\n"
      ^ "Blue states (m): " ^ IntInf.toString (!blue_match) ^ "\n"
      ^ "Blue edges     : " ^ IntInf.toString (!blue_match + !blue_vis) ^ "\n"
      ^ "Red states     : " ^ IntInf.toString (!red_vis) ^ "\n"
      end
        
      val _ = Statistics.register_stat ("NDFS",is_active,to_string)
    end
›</span></span></span><span>
</span><span class="keyword1"><span class="command">code_reserved</span></span><span> </span><span>SML</span><span> </span><span>NDFS_SI_Statistics</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹@{code hd}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> 
</span><span>  </span><span>vis_red</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit ⇒ unit"</span></span></span><span>
</span><span>  </span><span>vis_blue</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit ⇒ unit"</span></span></span><span>
</span><span>  </span><span>match_blue</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit ⇒ unit"</span></span></span><span>
</span><span>  </span><span>start</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit ⇒ unit"</span></span></span><span>
</span><span>  </span><span>stop</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit ⇒ unit"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>vis_red</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"NDFS'_SI'_Statistics.vis'_red"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>vis_blue</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"NDFS'_SI'_Statistics.vis'_blue"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>match_blue</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"NDFS'_SI'_Statistics.match'_blue"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>start</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"NDFS'_SI'_Statistics.start"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>stop</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"NDFS'_SI'_Statistics.stop"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(vis_red,vis_red) ∈ unit_rel → unit_rel"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(vis_blue,vis_blue) ∈ unit_rel → unit_rel"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(match_blue,match_blue) ∈ unit_rel → unit_rel"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(start,start) ∈ unit_rel → unit_rel"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(stop,stop) ∈ unit_rel → unit_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vis_red_nres ≡ RETURN (vis_red ())"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vis_blue_nres ≡ RETURN (vis_blue ())"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"match_blue_nres ≡ RETURN (match_blue ())"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"start_nres ≡ RETURN (start ())"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stop_nres ≡ RETURN (stop ())"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>vis_red</span><span> </span><span>vis_blue</span><span> </span><span>match_blue</span><span> </span><span>start</span><span> </span><span>stop</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>vis_red_nres</span><span> </span><span>vis_blue_nres</span><span> </span><span>match_blue_nres</span><span> </span><span>start_nres</span><span> </span><span>stop_nres</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>List.append</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Verification that code-module did 
  not mess up something. *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="NDFS_SI">
<div class="head"><h1>Theory NDFS_SI</h1>
<span class="command">theory</span> <span class="name">NDFS_SI</span><br/>
<span class="keyword">imports</span> <a href="../CAVA_Automata/Automata_Impl.html"><span class="name">Automata_Impl</span></a> <a href="../CAVA_Automata/Lasso.html"><span class="name">Lasso</span></a> <a href="NDFS_SI_Statistics.html"><span class="name">NDFS_SI_Statistics</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**
  Author: Peter Lammich
  Inspired by Rene Neumann's DFS-Framework and Nested DFS formalization
**)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Nested DFS using Standard Invariants Approach›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>NDFS_SI</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>CAVA_Automata.Automata_Impl</span><span>
</span><span>  </span><span>CAVA_Automata.Lasso</span><span>
</span><span>  </span><span>NDFS_SI_Statistics</span><span>
</span><span>  </span><span>CAVA_Base.CAVA_Code_Target</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Implementation of a nested DFS algorithm for accepting cycle detection
  using the refinement framework. The algorithm uses the improvement of 
  Holzmann et al.~\cite{HPY97}, i.e., it reports a cycle if the inner 
  DFS finds a path back to 
  the stack of the outer DFS. Moreover, an early cycle detection optimization is
  implemented~\cite{SE05}, i.e., the outer DFS may already report a cycle on 
  a back-edge involving an accepting node.

  The algorithm returns a witness in case that an accepting cycle is detected.
  
  The design approach to this algorithm is to first establish invariants of a
  generic DFS-Algorithm, which are then used to instantiate the concrete
  nested DFS-algorithm for B\"uchi emptiness check. This formalization can be
  seen as a predecessor of the formalization of 
  Gabow's algorithm~\cite{La14_ITP}, where this technique has been
  further developed.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tools for DFS Algorithms"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Invariants"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U S V u0 ≡
  E``U ⊆ U   ― ‹Upper bound is closed under transitions›
  ∧ finite U ― ‹Upper bound is finite›
  ∧ V ⊆ U    ― ‹Visited set below upper bound›
  ∧ u0 ∈ U   ― ‹Start node in upper bound›
  ∧ E``(V-S) ⊆ V ― ‹Visited nodes closed under reachability, or on stack›
  ∧ u0∉V     ― ‹Start node not yet visited›
  ∧ S ⊆ V    ― ‹Stack is visited›
  ∧ (∀v∈S. (v,u0)∈(E∩S×UNIV)<span class="hidden">⇧</span><sup>*</sup>) ― ‹‹u0› reachable from stack, only over stack›
  "</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_var U ≡ finite_psupset U"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_fe_inv E U S V0 u0 it V brk ≡ 
  (¬brk ⟶ E``(V-S) ⊆ V)  ― ‹Visited set closed under reachability›
  ∧ E``{u0} - it ⊆ V     ― ‹Successors of ‹u0› visited›
  ∧ V0 ⊆ V               ― ‹Visited set increasing›
  ∧ V ⊆ V0 ∪ (E - UNIV×S)<span class="hidden">⇧</span><sup>*</sup> `` (E``{u0} - it - S) ― ‹All visited nodes reachable›
"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_post E U S V0 u0 V brk ≡ 
  (¬brk ⟶ E``(V-S) ⊆ V) ― ‹Visited set closed under reachability›
  ∧ u0 ∈ V               ― ‹‹u0› visited›
  ∧ V0 ⊆ V               ― ‹Visited set increasing›
  ∧ V ⊆ V0 ∪ (E - UNIV×S)<span class="hidden">⇧</span><sup>*</sup> `` {u0} ― ‹All visited nodes reachable›
"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_outer E U V0 it V brk ≡
  V0 ⊆ U      ― ‹Start nodes below upper bound›
  ∧ E``U ⊆ U  ― ‹Upper bound is closed under transitions›
  ∧ finite U ― ‹Upper bound is finite›
  ∧ V ⊆ U    ― ‹Visited set below upper bound›
  ∧ (¬brk ⟶ E``V ⊆ V)  ― ‹Visited set closed under reachability›
  ∧ (V0 - it ⊆ V) ― ‹Start nodes already iterated over are visited›"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Invariant Preservation"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_outer_initial</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (E<span class="hidden">⇧</span><sup>*</sup>``V0)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_outer E (E<span class="hidden">⇧</span><sup>*</sup>``V0) V0 V0 {} brk"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_outer_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rev_ImageI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_pre_initial</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_outer E U V0 it V False"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v0∈U - V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U {} V v0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_pre_def</span><span> </span><span>gen_dfs_outer_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_U_imp_wf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite U"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf (gen_dfs_var U)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_var_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_pre_imp_wf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U S V u0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf (gen_dfs_var U)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_pre_def</span><span> </span><span>gen_dfs_var_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_pre_imp_fin</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U S V u0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (E `` {u0})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>B</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"U"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_pre_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inserted ‹u0› on stack and to visited set›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_pre_imp_fe</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U S V u0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_fe_inv E U (insert u0 S) (insert u0 V) u0 
    (E``{u0}) (insert u0 V) False"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_pre_def</span><span> </span><span>gen_dfs_fe_inv_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_fe_inv_pres_visited</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U S V u0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_fe_inv E U (insert u0 S) (insert u0 V) u0 it V' False"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t∈it"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"it⊆E``{u0}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t∈V'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_fe_inv E U (insert u0 S) (insert u0 V) u0 (it-{t}) V' False"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_fe_inv_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_upper_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y)∈E'<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u0,x)∈E"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u0∈U"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E'⊆E"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E``U ⊆ U"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈U"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_fe_inv_imp_var</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U S V u0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_fe_inv E U (insert u0 S) (insert u0 V) u0 it V' False"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t∈it"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"it⊆E``{u0}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t∉V'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(V',V) ∈ gen_dfs_var U"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_fe_inv_def</span><span> </span><span>gen_dfs_pre_def</span><span> </span><span>gen_dfs_var_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>finite_psupset_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>gen_dfs_upper_aux</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_fe_inv_imp_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U S V u0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_fe_inv E U (insert u0 S) (insert u0 V) u0 it V' False"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t∈it"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"it⊆E``{u0}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t∉V'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U (insert u0 S) V' t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_fe_inv_def</span><span> </span><span>gen_dfs_pre_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>gen_dfs_upper_aux</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtrancl_into_rtrancl</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b</span><span class="delimiter">=</span><span>u0</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rev_subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>rtrancl_mono</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"E ∩ S × UNIV"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_post_imp_fe_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U S V u0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_fe_inv E U (insert u0 S) (insert u0 V) u0 it V' False"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t∈it"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"it⊆E``{u0}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t∉V'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_post E U (insert u0 S) V' t V'' cyc"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_fe_inv E U (insert u0 S) (insert u0 V) u0 (it-{t}) V'' cyc"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_fe_inv_def</span><span> </span><span>gen_dfs_post_def</span><span> </span><span>gen_dfs_pre_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"insert u0 (V ∪ (E - UNIV × insert u0 S)<span class="hidden">⇧</span><sup>*</sup> 
        `` (E `` {u0} - it - insert u0 S))"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>cyc</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_post_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u0,x)∈E"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y)∈(E - UNIV × insert u0 S)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S⊆V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u0, y) ∈ (E - UNIV × S)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u0,x)∈(E - UNIV × S)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y)∈(E - UNIV × S)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>rev_subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>2</span><span> </span><span>rtrancl_mono</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_fe_imp_post_brk</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U S V u0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_fe_inv E U (insert u0 S) (insert u0 V) u0 it V' True"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"it⊆E``{u0}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_post E U S V u0 V' True"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_pre_def</span><span> </span><span>gen_dfs_fe_inv_def</span><span> </span><span>gen_dfs_post_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_post_aux</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_fe_inv_imp_post</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U S V u0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_fe_inv E U (insert u0 S) (insert u0 V) u0 {} V' cyc"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cyc⟶cyc'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_post E U S V u0 V' cyc'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_pre_def</span><span> </span><span>gen_dfs_fe_inv_def</span><span> </span><span>gen_dfs_post_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_post_aux</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_pre_imp_post_brk</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U S V u0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_post E U S V u0 (insert u0 V) True"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_pre_def</span><span> </span><span>gen_dfs_post_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Consequences of Postcondition"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_post_imp_reachable</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U S V0 u0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_post E U S V0 u0 V brk"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ⊆ V0 ∪ E<span class="hidden">⇧</span><sup>*</sup>``{u0}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_post_def</span><span> </span><span>gen_dfs_pre_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rev_subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>rtrancl_mono</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_post_imp_complete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U {} V0 u0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_post E U {} V0 u0 V False"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V0 ∪ E<span class="hidden">⇧</span><sup>*</sup>``{u0} ⊆ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_post_def</span><span> </span><span>gen_dfs_pre_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>Image_closed_trancl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_post_imp_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U {} V0 u0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_post E U {} V0 u0 V False"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V = V0 ∪ E<span class="hidden">⇧</span><sup>*</sup>``{u0}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gen_dfs_post_imp_reachable</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>gen_dfs_post_imp_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_post_imp_below_U</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U S V0 u0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_post E U S V0 u0 V False"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ⊆ U"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_pre_def</span><span> </span><span>gen_dfs_post_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rev_subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>rtrancl_mono</span><span class="delimiter">]</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>Image_closed_trancl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_post_imp_outer</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_outer E U V0 it Vis0 False"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_post E U {} Vis0 v0 Vis False"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v0 ∈ it"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"it ⊆ V0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v0 ∉ Vis0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_outer E U V0 (it - {v0}) Vis False"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v0 ∈ it"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"it ⊆ V0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V0 ⊆ U"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E `` U ⊆ U"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E<span class="hidden">⇧</span><sup>*</sup> `` {v0} ⊆ U"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>empty_subsetI</span><span> </span><span>insert_subset</span><span> </span><span>rtrancl_reachable_induct</span><span> </span><span>subset_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>AUX</span><span class="delimiter">=</span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_outer_def</span><span> </span><span>gen_dfs_post_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AUX</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_dfs_outer_already_vis</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v0 ∈ it"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"it ⊆ V0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v0 ∈ V"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_outer E U V0 it V False"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_outer E U V0 (it - {v0}) V False"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_outer_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Abstract Algorithm"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inner (red) DFS›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A witness of the red algorithm is a node on the stack and a path
  to this node›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'v</span><span> </span><span>red_witness</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v list × 'v) option"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Prepend node to red witness›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>prep_wit_red</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v ⇒ 'v red_witness ⇒ 'v red_witness"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prep_wit_red v None = None"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"prep_wit_red v (Some (p,u)) = Some (v#p,u)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Initial witness for node ‹u› with onstack successor ‹v› 
›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>red_init_witness</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v ⇒ 'v ⇒ 'v red_witness"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"red_init_witness u v = Some ([u],v)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>red_dfs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"red_dfs E onstack V u ≡ 
    REC<span class="hidden">⇩</span><sub>T</sub> (λD (V,u). do {
      let V=insert u V;
      NDFS_SI_Statistics.vis_red_nres;

      ― ‹Check whether we have a successor on stack›
      brk ← FOREACH<span class="hidden">⇩</span><sub>C</sub> (E``{u}) (λbrk. brk=None) 
        (λt _. 
          if t∈onstack then 
            RETURN (red_init_witness u t) 
          else 
          RETURN None
        )
        None;

      ― ‹Recurse for successors›
      case brk of
        None ⇒
          FOREACH<span class="hidden">⇩</span><sub>C</sub> (E``{u}) (λ(V,brk). brk=None)
            (λt (V,_). 
              if t∉V then do {
                (V,brk) ← D (V,t);
                RETURN (V,prep_wit_red u brk)
              } else RETURN (V,None))
            (V,None)
      | _ ⇒ RETURN (V,brk)
    }) (V,u)
  "</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'v</span><span> </span><span>blue_witness</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>NO_CYC</span><span>                    </span><span class="comment">― ‹No cycle detected›</span><span>
</span><span class="delimiter">|</span><span> </span><span>REACH</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'v list"</span></span></span><span>      </span><span class="comment">― ‹Path from current start node to node on 
  stack, path contains accepting node.›</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* REACH u p: u is on stack, p is non-empty path from u0 to u, a node 
  in u or p is accepting *)</span></span></span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>CIRC</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v list"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'v list"</span></span></span><span>  </span><span class="comment">― ‹@{text "CIRI pr pl"}: Lasso found from 
  current start node.›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Prepend node to witness›</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>prep_wit_blue</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v ⇒ 'v blue_witness ⇒ 'v blue_witness"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prep_wit_blue u0 NO_CYC = NO_CYC"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"prep_wit_blue u0 (REACH u p) = (
  if u0=u then
    CIRC [] (u0#p)
  else
    REACH u (u0#p)
  )"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"prep_wit_blue u0 (CIRC pr pl) = CIRC (u0#pr) pl"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Initialize blue witness›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>init_wit_blue</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v ⇒ 'v red_witness ⇒ 'v blue_witness"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"init_wit_blue u0 None = NO_CYC"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"init_wit_blue u0 (Some (p,u)) = (
  if u=u0 then
    CIRC [] p
  else REACH u p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>init_wit_blue_early</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v ⇒ 'v ⇒ 'v blue_witness"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"init_wit_blue_early s t ≡ if s=t then CIRC [] [s] else REACH t [s]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Extract result from witness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span>lasso_ext</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_res cyc 
  ≡ (case cyc of 
      CIRC pr pl ⇒ Some (pr,pl)
     | _ ⇒ None)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Outer (Blue) DFS›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>blue_dfs</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,_) b_graph_rec_scheme ⇒ ('a list × 'a list) option nres"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blue_dfs G ≡ do {
    NDFS_SI_Statistics.start_nres;
    (_,_,cyc) ← FOREACHc (g_V0 G) (λ(_,_,cyc). cyc=NO_CYC) 
      (λv0 (blues,reds,_). do {
        if v0 ∉ blues then do {
          (blues,reds,_,cyc) ← REC<span class="hidden">⇩</span><sub>T</sub> (λD (blues,reds,onstack,s). do {
            let blues=insert s blues;
            let onstack=insert s onstack;
            let s_acc = s ∈ bg_F G;
            NDFS_SI_Statistics.vis_blue_nres;
            (blues,reds,onstack,cyc) ← 
            FOREACH<span class="hidden">⇩</span><sub>C</sub> ((g_E G)``{s}) (λ(_,_,_,cyc). cyc=NO_CYC) 
              (λt (blues,reds,onstack,cyc). 
                if t ∈ onstack ∧ (s_acc ∨ t ∈ bg_F G) then (
                  RETURN (blues,reds,onstack, init_wit_blue_early s t)
                ) else if t∉blues then do {
                  (blues,reds,onstack,cyc) ← D (blues,reds,onstack,t);
                  RETURN (blues,reds,onstack,(prep_wit_blue s cyc))
                } else do {
                  NDFS_SI_Statistics.match_blue_nres;
                  RETURN (blues,reds,onstack,cyc)
                })
              (blues,reds,onstack,NO_CYC);

            (reds,cyc) ← 
            if cyc=NO_CYC ∧ s_acc then do {
              (reds,rcyc) ← red_dfs (g_E G) onstack reds s;
              RETURN (reds, init_wit_blue s rcyc)
            } else RETURN (reds,cyc);

            let onstack=onstack - {s};
            RETURN (blues,reds,onstack,cyc)
          }) (blues,reds,{},v0);
          RETURN (blues, reds, cyc)
        } else do {
          RETURN (blues, reds, NO_CYC)
        }
      }) ({},{},NO_CYC);
    NDFS_SI_Statistics.stop_nres;
    RETURN (extract_res cyc)
  }
  "</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>blue_dfs_fe</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>blue_dfs_def</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blue_dfs G ≡ do {
    NDFS_SI_Statistics.start_nres;
    (_,_,cyc) ← ?FE;
    NDFS_SI_Statistics.stop_nres;
    RETURN (extract_res cyc)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>blue_dfs_body</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>blue_dfs_fe_def</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ≡ FOREACHc (g_V0 G) (λ(_,_,cyc). cyc=NO_CYC) 
    (λv0 (blues,reds,_). do {
      if v0∉blues then do {
        (blues,reds,_,cyc) ← REC<span class="hidden">⇩</span><sub>T</sub> ?B (blues,reds,{},v0);
        RETURN (blues, reds, cyc)
      } else do {RETURN (blues, reds, NO_CYC)}
    }) ({},{},NO_CYC)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>blue_dfs_body_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Correctness"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Additional invariant to be maintained between calls of red dfs›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"red_dfs_inv E U reds onstack ≡ 
  E``U ⊆ U           ― ‹Upper bound is closed under transitions›
  ∧ finite U         ― ‹Upper bound is finite›
  ∧ reds ⊆ U         ― ‹Red set below upper bound›
  ∧ E``reds ⊆ reds   ― ‹Red nodes closed under reachability›
  ∧ E``reds ∩ onstack = {} ― ‹No red node with edge to stack›
"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>red_dfs_inv_initial</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (E<span class="hidden">⇧</span><sup>*</sup>``V0)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"red_dfs_inv E (E<span class="hidden">⇧</span><sup>*</sup>``V0) {} {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>red_dfs_inv_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rev_ImageI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of the red DFS.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>red_dfs_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>v0</span><span> </span><span>u0</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'v</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>PRE</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"red_dfs_inv E U reds onstack"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"u0∈U"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"u0∉reds"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"red_dfs E onstack reds u0 
    ≤ SPEC (λ(reds',cyc). case cyc of
      Some (p,v) ⇒ v∈onstack ∧ p≠[] ∧ path E u0 p v
    | None ⇒ 
        red_dfs_inv E U reds' onstack 
        ∧ u0∈reds' 
        ∧ reds' ⊆ reds ∪ E<span class="hidden">⇧</span><sup>*</sup> `` {u0}
  )"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?dfs_red</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"
    REC<span class="hidden">⇩</span><sub>T</sub> (λD (V,u). do {
      let V=insert u V;
      NDFS_SI_Statistics.vis_red_nres;

      ― ‹Check whether we have a successor on stack›
      brk ← FOREACH<span class="hidden">⇩</span><sub>C</sub> (E``{u}) (λbrk. brk=None) 
        (λt _. if t∈onstack then 
            RETURN (red_init_witness u t) 
          else RETURN None) 
        None;

      ― ‹Recurse for successors›
      case brk of
        None ⇒
          FOREACH<span class="hidden">⇩</span><sub>C</sub> (E``{u}) (λ(V,brk). brk=None)
            (λt (V,_). 
              if t∉V then do {
                (V,brk) ← D (V,t);
                RETURN (V,prep_wit_red u brk)
              } else RETURN (V,None))
            (V,None)
      | _ ⇒ RETURN (V,brk)
    }) (V,u)
"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"REC<span class="hidden">⇩</span><sub>T</sub> ?body ?init"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"?dfs_red"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pre = (λS (V,u0). gen_dfs_pre E U S V u0 ∧ E``V ∩ onstack = {})"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>post</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"post = (λS (V0,u0) (V,cyc). gen_dfs_post E U S V0 u0 V (cyc≠None)
    ∧ (case cyc of None ⇒ E``V ∩ onstack = {}
      | Some (p,v) ⇒ v∈onstack ∧ p≠[] ∧ path E u0 p v))
    "</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>fe_inv</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe_inv = (λS V0 u0 it (V,cyc). 
    gen_dfs_fe_inv E U S V0 u0 it V (cyc≠None)
    ∧ (case cyc of None ⇒ E``V ∩ onstack = {}
      | Some (p,v) ⇒ v∈onstack ∧ p≠[] ∧ path E u0 p v))
    "</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PRE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>GENPRE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_pre E U {} reds u0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>red_dfs_inv_def</span><span> </span><span>gen_dfs_pre_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>PRE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>PRE'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pre {} (reds,u0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pre_def</span><span> </span><span>red_dfs_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IMP_POST</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPEC (post {} (reds,u0)) 
    ≤ SPEC (λ(reds',cyc). case cyc of
      Some (p,v) ⇒ v∈onstack ∧ p≠[] ∧ path E u0 p v
    | None ⇒ 
        red_dfs_inv E U reds' onstack 
        ∧ u0∈reds' 
        ∧ reds' ⊆ reds ∪ E<span class="hidden">⇧</span><sup>*</sup> `` {u0})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>impI</span><span> </span><span>conjI</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>reds'</span><span> </span><span>p</span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"post {} (reds,u0) (reds',Some (p,v))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈onstack"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p≠[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path E u0 p v"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>post_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>reds'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"post {} (reds, u0) (reds', None)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>GPOST</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_post E U {} reds u0 reds' False"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E``reds' ∩ onstack = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>post_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>GPOST</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u0∈reds'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_post_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"red_dfs_inv E U reds' onstack"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>red_dfs_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>GENPRE</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>gen_dfs_pre_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gen_dfs_post_imp_below_U</span><span class="delimiter">[</span><span>OF</span><span> </span><span>GENPRE</span><span> </span><span>GPOST</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>GPOST</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>gen_dfs_post_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>GPOST</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reds' ⊆ reds ∪ E<span class="hidden">⇧</span><sup>*</sup> `` {u0}"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_post_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span> </span><span>S</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>INV0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pre S σ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"REC<span class="hidden">⇩</span><sub>T</sub> ?body σ
      ≤ SPEC (post S σ)"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RECT_rule_arb</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>        </span><span>pre</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"pre"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>V</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"gen_dfs_var U &lt;*lex*&gt; {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>arb</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"S"</span></span></span><span>
</span><span>        </span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_mono</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>INV0</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>pre_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_pre_imp_wf</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>D</span><span> </span><span>S</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* First foreach loop, checking for onstack-successor*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λit cyc. 
        (case cyc of None ⇒ (E``{b} - it) ∩ onstack = {}
          | Some (p,v) ⇒ (v∈onstack ∧ p≠[] ∧ path E b p v))"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>FOREACHc_rule</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>gen_dfs_pre_imp_fin</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>red_init_witness_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>path1</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Second foreach loop, iterating over sucessors *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"fe_inv (insert b S) (insert b a) b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span>
</span><span>        </span><span>FOREACHc_rule</span><span>
</span><span>      </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>gen_dfs_pre_imp_fin</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>fe_inv_def</span><span> </span><span>gen_dfs_pre_imp_fe</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Recursive call *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rprems</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>fe_inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gen_dfs_fe_inv_imp_pre</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">+</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>fe_inv_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_fe_inv_imp_var</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>post_def</span><span> </span><span>fe_inv_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span> </span><span>prod.split_asm</span><span>
</span><span>        </span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_post_imp_fe_inv</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_post_imp_fe_inv</span><span> </span><span>path_prepend</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>post_def</span><span> </span><span>fe_inv_def</span><span> 
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_fe_inv_pres_visited</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>post_def</span><span> </span><span>fe_inv_def</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_fe_inv_imp_post</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>post_def</span><span> </span><span>fe_inv_def</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_fe_imp_post_brk</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>post_def</span><span> </span><span>fe_inv_def</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_pre_imp_post_brk</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>post_def</span><span> </span><span>fe_inv_def</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_pre_imp_post_brk</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>GEN</span><span class="delimiter">=</span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>GEN</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PRE'</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IMP_POST</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>red_dfs_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Main theorem: Correctness of the blue DFS›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>blue_dfs_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v,_) b_graph_rec_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b_graph G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finitely_reachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E G)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blue_dfs G ≤ SPEC (λr. 
    case r of None ⇒ (∀L. ¬b_graph.is_lasso_prpl G L)
  | Some L ⇒ b_graph.is_lasso_prpl G L)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>b_graph</span><span> </span><span>G</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bg_F G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?E</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"g_E G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V0</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"g_V0 G"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?U</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"?E<span class="hidden">⇧</span><sup>*</sup>``?V0"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>add_inv</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"add_inv = (λblues reds onstack. 
    ¬(∃v∈(blues-onstack)∩?A. (v,v)∈?E<span class="hidden">⇧</span><sup>+</sup>)  ― ‹No cycles over finished, accepting states›
    ∧ reds ⊆ blues                     ― ‹Red nodes are also blue›
    ∧ reds ∩ onstack = {}              ― ‹No red nodes on stack›
    ∧ red_dfs_inv ?E ?U reds onstack)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cyc_post</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cyc_post = (λblues reds onstack u0 cyc. (case cyc of 
      NO_CYC ⇒ add_inv blues reds onstack
    | REACH u p ⇒ 
          path ?E u0 p u 
        ∧ u ∈ onstack-{u0} 
        ∧ insert u (set p) ∩ ?A ≠ {}
    | CIRC pr pl ⇒ ∃v. 
          pl≠[] 
        ∧ path ?E v pl v 
        ∧ path ?E u0 pr v 
        ∧ set pl ∩ ?A ≠ {}
    ))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pre = (λ(blues,reds,onstack,u::'v).  
    gen_dfs_pre ?E ?U onstack blues u ∧ add_inv blues reds onstack)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>post</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"post = (λ(blues0,reds0::'v set,onstack0,u0) (blues,reds,onstack,cyc). 
    onstack = onstack0
    ∧ gen_dfs_post ?E ?U onstack0 blues0 u0 blues (cyc≠NO_CYC)
    ∧ cyc_post blues reds onstack u0 cyc)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>fe_inv</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe_inv = (λblues0 u0 onstack0 it (blues,reds,onstack,cyc). 
    onstack=onstack0 
    ∧ gen_dfs_fe_inv ?E ?U onstack0 blues0 u0 it blues (cyc≠NO_CYC)
    ∧ cyc_post blues reds onstack u0 cyc)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>outer_inv</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"outer_inv = (λit (blues,reds,cyc).
    case cyc of 
      NO_CYC ⇒ 
        add_inv blues reds {}
      ∧ gen_dfs_outer ?E ?U ?V0 it blues False
    | CIRC pr pl ⇒ ∃v0∈?V0. ∃v. 
        pl≠[] 
      ∧ path ?E v pl v 
      ∧ path ?E v0 pr v 
      ∧ set pl ∩ ?A ≠ {}
    | _ ⇒ False)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>OUTER_INITIAL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"outer_inv V0 ({}, {}, NO_CYC)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>outer_inv_def</span><span> </span><span>add_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finitely_reachable</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>red_dfs_inv_initial</span><span> </span><span>gen_dfs_outer_initial</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>onstack</span><span> </span><span>blues</span><span> </span><span>u0</span><span> </span><span>reds</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pre (blues,reds,onstack,u0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe_inv (insert u0 blues) u0 (insert u0 onstack) (?E``{u0}) 
      (insert u0 blues,reds,insert u0 onstack,NO_CYC)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fe_inv_def</span><span> </span><span>add_inv_def</span><span> </span><span>cyc_post_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>gen_dfs_pre_imp_fe</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>add_inv_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>add_inv_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>add_inv_def</span><span> </span><span>gen_dfs_pre_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>add_inv_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>pre_def</span><span> </span><span>add_inv_def</span><span> </span><span>red_dfs_inv_def</span><span> </span><span>gen_dfs_pre_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>PRE_IMP_FE</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u cyc. prep_wit_blue u cyc = NO_CYC ⟷ cyc=NO_CYC"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>cyc</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>blues0</span><span> </span><span>reds0</span><span> </span><span>onstack0</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u0</span><span class="delimiter">::</span><span class="tfree">'v</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>blues</span><span> </span><span>reds</span><span> </span><span>onstack</span><span> </span><span>blues'</span><span> </span><span>reds'</span><span> </span><span>onstack'</span><span> 
</span><span>      </span><span>cyc</span><span> </span><span>it</span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>PRE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pre (blues0,reds0,onstack0,u0)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>FEI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe_inv (insert u0 blues0) u0 (insert u0 onstack0) 
        it (blues,reds,onstack,NO_CYC)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>IT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t∈it"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"it⊆?E``{u0}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t∉blues"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>POST</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"post (blues,reds,onstack, t) (blues',reds',onstack',cyc)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>path_simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe_inv (insert u0 blues0) u0 (insert u0 onstack0) (it-{t}) 
      (blues',reds',onstack',prep_wit_blue u0 cyc)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fe_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PRE</span><span> </span><span>FEI</span><span> </span><span>IT</span><span> </span><span>POST</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fe_inv_def</span><span> </span><span>post_def</span><span> </span><span>pre_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_post_imp_fe_inv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cyc_post_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>blue_witness.split_asm</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>path_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>FE_INV_PRES</span><span class="delimiter">=</span><span>this</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>blues</span><span> </span><span>reds</span><span> </span><span>onstack</span><span> </span><span>u0</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pre (blues,reds,onstack,u0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u0∈?E<span class="hidden">⇧</span><sup>*</sup>``?V0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pre_def</span><span> </span><span>gen_dfs_pre_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>PRE_IMP_REACH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>blues0</span><span> </span><span>reds0</span><span> </span><span>onstack0</span><span> </span><span>u0</span><span> </span><span>blues</span><span> </span><span>reds</span><span> </span><span>onstack</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pre (blues0,reds0,onstack0,u0)"</span></span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">"fe_inv (insert u0 blues0) u0 (insert u0 onstack0) 
        {} (blues,reds,onstack,NO_CYC)"</span></span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">"u0∈?A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u0∉reds"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fe_inv_def</span><span> </span><span>add_inv_def</span><span> </span><span>pre_def</span><span> </span><span>cyc_post_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>FE_IMP_RED_PRE</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>blues0</span><span> </span><span>reds0</span><span> </span><span>onstack0</span><span> </span><span>u0</span><span> </span><span>blues</span><span> </span><span>reds</span><span> </span><span>onstack</span><span> </span><span>rcyc</span><span> </span><span>reds'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>PRE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pre (blues0,reds0,onstack0,u0)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>FEI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe_inv (insert u0 blues0) u0 (insert u0 onstack0) 
        {} (blues,reds,onstack,NO_CYC)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ACC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u0∈?A"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>SPECR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"case rcyc of
      Some (p,v) ⇒ v∈onstack ∧ p≠[] ∧ path ?E u0 p v
    | None ⇒ 
        red_dfs_inv ?E ?U reds' onstack 
        ∧ u0∈reds' 
        ∧ reds' ⊆ reds ∪ ?E<span class="hidden">⇧</span><sup>*</sup> `` {u0}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"post (blues0,reds0,onstack0,u0) 
      (blues,reds',onstack - {u0},init_wit_blue u0 rcyc)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>post_def</span><span> </span><span>add_inv_def</span><span> </span><span>cyc_post_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PRE</span><span> </span><span>FEI</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>OS0</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"onstack - {u0} = onstack0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>fe_inv_def</span><span> </span><span>add_inv_def</span><span> </span><span>gen_dfs_pre_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PRE</span><span> </span><span>FEI</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u0∈onstack"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pre_def</span><span> </span><span>gen_dfs_pre_def</span><span> </span><span>fe_inv_def</span><span> </span><span>gen_dfs_fe_inv_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PRE</span><span> </span><span>FEI</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>POST</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_post ?E (?E<span class="hidden">⇧</span><sup>*</sup> `` ?V0) onstack0 blues0 u0 blues 
        (init_wit_blue u0 rcyc ≠ NO_CYC)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>fe_inv_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_fe_inv_imp_post</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>FEI</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"onstack=insert u0 onstack0"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fe_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>FEI</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u0∈blues"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fe_inv_def</span><span> </span><span>gen_dfs_fe_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rcyc</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rcyc=None"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀v∈(blues - (onstack0 - {u0})) ∩ ?A. (v, v) ∉ ?E<span class="hidden">⇧</span><sup>+</sup>) ∧
          reds' ⊆ blues ∧
          reds' ∩ (onstack0 - {u0}) = {} ∧
          red_dfs_inv ?E (?E<span class="hidden">⇧</span><sup>*</sup> `` ?V0) reds' (onstack0 - {u0})"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SPECR</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>RINV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"red_dfs_inv ?E ?U reds' onstack"</span></span></span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u0∈reds'"</span></span></span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>REDS'R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reds' ⊆ reds ∪ ?E<span class="hidden">⇧</span><sup>*</sup>``{u0}"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>RINV</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>            </span><span>RINV'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"red_dfs_inv ?E (?E<span class="hidden">⇧</span><sup>*</sup> `` ?V0) reds' (onstack0 - {u0})"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>red_dfs_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>RINV'</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>red_dfs_inv_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>            </span><span>REDS'CL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?E``reds' ⊆ reds'"</span></span></span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>DJ'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?E `` reds' ∩ (onstack0 - {u0}) = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>RINV</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>red_dfs_inv_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>            </span><span>DJ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?E `` reds' ∩ (onstack) = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reds' ⊆ blues"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈reds'"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>REDS'R</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈reds ∨ (u0,v)∈?E<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈blues"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈reds"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>FEI</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reds⊆blues"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fe_inv_def</span><span> </span><span>add_inv_def</span><span> </span><span>cyc_post_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>POST</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>gen_dfs_post_def</span><span> </span><span>OS0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>                </span><span>CL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?E `` (blues - (onstack0 - {u0})) ⊆ blues"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u0∈blues"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PRE</span><span> </span><span>FEI</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"onstack0 ⊆ blues"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pre_def</span><span> </span><span>fe_inv_def</span><span> </span><span>gen_dfs_pre_def</span><span> </span><span>gen_dfs_fe_inv_def</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u0,v)∈?E<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈blues"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl_last_visit</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"onstack - {u0}"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>no_visit</span><span>
</span><span>                </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈blues"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u0∈blues›</span></span></span><span> </span><span>CL</span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rtranclE</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>last_visit_point</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>uh</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u0,uh)∈?E<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(uh,u)∈?E"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>tranclD2</span><span class="delimiter">)</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>REDS'CL</span><span> </span><span>DJ'</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u0∈reds'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uh∈reds'"</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>Image_closed_trancl</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>DJ'</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(uh,u)∈?E›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ∈ onstack - {u0}›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v∈(blues - (onstack0 - {u0})) ∩ ?A. (v, v) ∉ ?E<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∈ (blues - (onstack0 - {u0})) ∩ ?A"</span></span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,v)∉?E<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"v=u0"</span></span></span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v≠u0"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈(blues - (insert u0 onstack)) ∩ ?A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>FEI</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fe_inv_def</span><span> </span><span>add_inv_def</span><span> </span><span>cyc_post_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v=u0"</span></span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,v)∈?E<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>uh</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u0,uh)∈?E<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(uh,u0)∈?E"</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>tranclD2</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>REDS'CL</span><span> </span><span>DJ</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u0∈reds'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uh∈reds'"</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>Image_closed_trancl</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>DJ</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(uh,u0)∈?E›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u0 ∈ onstack›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reds' ∩ (onstack0 - {u0}) = {}"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reds' ∩ (onstack0 - {u0}) ≠ {}"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈reds'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈onstack0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v≠u0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v∈reds'›</span></span></span><span> </span><span>REDS'R</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈reds ∨ (u0,v)∈?E<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈reds"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>FEI</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>fe_inv_def</span><span> </span><span>add_inv_def</span><span> </span><span>cyc_post_def</span><span class="delimiter">]</span><span> 
</span><span>                </span><span class="cartouche"><span class="delete"><span class="delete">‹v∈onstack0›</span></span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u0,v)∈?E<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v≠u0›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>uh</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u0,uh)∈?E<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(uh,v)∈?E"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rtranclE</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>REDS'CL</span><span> </span><span>DJ</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u0∈reds'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uh∈reds'"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>Image_closed_trancl</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>DJ</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(uh,v)∈?E›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v ∈ onstack0›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span>p</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rcyc = Some (p,u)"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"
          (u = u0 ⟶ p ≠ [] ∧ path ?E u0 p u0 ∧ set p ∩ ?A ≠ {}) ∧
          (u ≠ u0 ⟶ 
              path ?E u0 p u ∧ u ∈ onstack0 ∧ (u ∈ ?A ∨ set p ∩ ?A ≠ {}))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SPECR</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u0∈?A›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"u≠u0 ⟹ u∈onstack0"</span></span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"p≠[]"</span></span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"path ?E u0 p u"</span></span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"u=u0 ⟹ path ?E u0 p u0"</span></span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"set p ∩ F ≠ {}"</span></span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"u ∈ F ∨ set p ∩ F ≠ {}"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>neq_Nil_conv</span><span> </span><span>path_simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>RED_IMP_POST</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>blues0</span><span> </span><span>reds0</span><span> </span><span>onstack0</span><span> </span><span>u0</span><span> </span><span>blues</span><span> </span><span>reds</span><span> </span><span>onstack</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cyc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v blue_witness"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>PRE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pre (blues0,reds0,onstack0,u0)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>FEI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe_inv (insert u0 blues0) u0 (insert u0 onstack0) 
        {} (blues,reds,onstack,NO_CYC)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>FC</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cyc=NO_CYC"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NCOND</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u0∉?A"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PRE</span><span> </span><span>FEI</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>OS0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"onstack0 = onstack - {u0}"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>fe_inv_def</span><span> </span><span>add_inv_def</span><span> </span><span>gen_dfs_pre_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PRE</span><span> </span><span>FEI</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u0∈onstack"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pre_def</span><span> </span><span>gen_dfs_pre_def</span><span> </span><span>fe_inv_def</span><span> </span><span>gen_dfs_fe_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>OS0</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>OS1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"onstack = insert u0 onstack0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"post (blues0,reds0,onstack0,u0) (blues,reds,onstack - {u0},NO_CYC)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>post_def</span><span> </span><span>cyc_post_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>OS0</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PRE</span><span> </span><span>FEI</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>fe_inv_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_fe_inv_imp_post</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FEI</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>fe_inv_def</span><span> </span><span>cyc_post_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NCOND</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>red_dfs_inv_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>NCOND_IMP_POST</span><span class="delimiter">=</span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>blues0</span><span> </span><span>reds0</span><span> </span><span>onstack0</span><span> </span><span>u0</span><span> </span><span>blues</span><span> </span><span>reds</span><span> </span><span>onstack</span><span> </span><span>it</span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cyc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v blue_witness"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>PRE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pre (blues0,reds0,onstack0,u0)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>FEI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe_inv (insert u0 blues0) u0 (insert u0 onstack0) 
        it (blues,reds,onstack,cyc)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cyc≠NO_CYC"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"it⊆?E``{u0}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PRE</span><span> </span><span>FEI</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>OS0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"onstack0 = onstack - {u0}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>fe_inv_def</span><span> </span><span>add_inv_def</span><span> </span><span>gen_dfs_pre_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PRE</span><span> </span><span>FEI</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u0∈onstack"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pre_def</span><span> </span><span>gen_dfs_pre_def</span><span> </span><span>fe_inv_def</span><span> </span><span>gen_dfs_fe_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>OS0</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>OS1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"onstack = insert u0 onstack0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"post (blues0,reds0,onstack0,u0) (blues,reds,onstack - {u0},cyc)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>post_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>OS0</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PRE</span><span> </span><span>FEI</span><span> </span><span>IT</span><span> </span><span>NC</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>fe_inv_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_fe_imp_post_brk</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FEI</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>fe_inv_def</span><span class="delimiter">]</span><span> </span><span>NC</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cyc_post_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>blue_witness.split</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>OS1</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>BREAK_IMP_POST</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>blues0</span><span> </span><span>reds0</span><span> </span><span>onstack0</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u0</span><span class="delimiter">::</span><span class="tfree">'v</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>blues</span><span> </span><span>reds</span><span> </span><span>onstack</span><span> </span><span>cyc</span><span> </span><span>it</span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>PRE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pre (blues0,reds0,onstack0,u0)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>FEI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe_inv (insert u0 blues0) u0 (insert u0 onstack0) 
        it (blues,reds,onstack,NO_CYC)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>IT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"it⊆?E``{u0}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t∈it"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>T_OS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ onstack"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U0ACC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u0∈F ∨ t∈F"</span></span></span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>T_OS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>TIB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ blues"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PRE</span><span> </span><span>FEI</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fe_inv_def</span><span> </span><span>pre_def</span><span> </span><span>gen_dfs_fe_inv_def</span><span> </span><span>gen_dfs_pre_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe_inv (insert u0 blues0) u0 (insert u0 onstack0) (it - {t}) 
      (blues,reds,onstack,init_wit_blue_early u0 t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fe_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>it_step_insert_iff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>IT</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PRE</span><span> </span><span>FEI</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fe_inv_def</span><span> </span><span>pre_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: This is a generic early-break condition. However, it requires
        t ∈ V. Do we really need such a strict invar in case of break? *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FEI</span><span> </span><span>TIB</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fe_inv_def</span><span> </span><span>gen_dfs_fe_inv_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cyc_post_def</span><span> </span><span>init_wit_blue_early_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IT</span><span> </span><span>T_OS</span><span> </span><span>U0ACC</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>path_simps</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>EARLY_DET_OPT</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>INV0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pre σ"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"REC<span class="hidden">⇩</span><sub>T</sub> (blue_dfs_body G) σ ≤ SPEC (post σ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>refine_vcg</span><span>
</span><span>        </span><span>RECT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>pre</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"pre"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"gen_dfs_var ?U &lt;*lex*&gt; {}"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>blue_dfs_body_def</span><span class="delimiter">,</span><span> </span><span>refine_mono</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>fin_U_imp_wf</span><span> </span><span>finitely_reachable</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>INV0</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Body *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm</span><span class="delimiter">)</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>blue_dfs_body_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Foreach loop *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> 
</span><span>        </span><span>I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"fe_inv (insert bb a) bb (insert bb ab)"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>FOREACHc_rule'</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>gen_dfs_pre_imp_fin</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>PRE_IMP_FE</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Early detection of cycles *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>EARLY_DET_OPT</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Recursive call *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rprems</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>fe_inv_def</span><span> </span><span>cyc_post_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gen_dfs_fe_inv_imp_pre</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">+</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>fe_inv_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_fe_inv_imp_var</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>FE_INV_PRES</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_def</span><span> </span><span>post_def</span><span> </span><span>fe_inv_def</span><span> 
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_fe_inv_pres_visited</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Nested DFS call *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>red_dfs_correct</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>U</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"?E<span class="hidden">⇧</span><sup>*</sup> `` ?V0"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fe_inv_def</span><span> </span><span>add_inv_def</span><span> </span><span>cyc_post_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>PRE_IMP_REACH</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>FE_IMP_RED_PRE</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RED_IMP_POST</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">+</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>NCOND_IMP_POST</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BREAK_IMP_POST</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>GEN</span><span class="delimiter">=</span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v0</span><span> </span><span>it</span><span> </span><span>blues</span><span> </span><span>reds</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v0 ∈ it"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"it ⊆ V0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v0 ∉ blues"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"outer_inv it (blues, reds, NO_CYC)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pre (blues, reds, {}, v0)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pre_def</span><span> </span><span>outer_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_pre_initial</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>OUTER_IMP_PRE</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v0</span><span> </span><span>it</span><span> </span><span>blues0</span><span> </span><span>reds0</span><span> </span><span>blues</span><span> </span><span>reds</span><span> </span><span>onstack</span><span> </span><span>cyc</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v0 ∈ it"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"it ⊆ V0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v0 ∉ blues0"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"outer_inv it (blues0, reds0, NO_CYC)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"post (blues0, reds0, {}, v0) (blues, reds, onstack, cyc)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"outer_inv (it - {v0}) (blues, reds, cyc)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>post_def</span><span> </span><span>outer_inv_def</span><span> </span><span>cyc_post_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>blue_witness.split</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_post_imp_outer</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>POST_IMP_OUTER</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v0</span><span> </span><span>it</span><span> </span><span>blues</span><span> </span><span>reds</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v0 ∈ it"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"it ⊆ V0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"outer_inv it (blues, reds, NO_CYC)"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"v0 ∈ blues"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"outer_inv (it - {v0}) (blues, reds, NO_CYC)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>outer_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gen_dfs_outer_already_vis</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>OUTER_ALREX</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>it</span><span> </span><span>blues</span><span> </span><span>reds</span><span> </span><span>cyc</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"outer_inv it (blues, reds, cyc)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cyc ≠ NO_CYC"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"case extract_res cyc of 
        None ⇒ ∀L. ¬ is_lasso_prpl L 
      | Some x ⇒ is_lasso_prpl x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>outer_inv_def</span><span> </span><span>extract_res_def</span><span> </span><span>is_lasso_prpl_def</span><span>
</span><span>        </span><span>is_lasso_prpl_pre_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>cyc</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IMP_POST_CYC</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pr"</span></span></span><span> </span><span>pl</span><span> </span><span>blues</span><span> </span><span>reds</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ADD_INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"add_inv blues reds {}"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>GEN_INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gen_dfs_outer E (E<span class="hidden">⇧</span><sup>*</sup> `` V0) V0 {} blues False"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>LASSO</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_lasso_prpl (pr, pl)"</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>LASSO</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>is_lasso_prpl_def</span><span> </span><span>is_lasso_prpl_pre_def</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v0</span><span> </span><span>va</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"v0∈V0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pl≠[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>PR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"path E v0 pr va"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"path E va pl va"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set pl ∩ F ≠ {}"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>F</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>pl1</span><span> </span><span>vf</span><span> </span><span>pl2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pl=pl1@vf#pl2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vf∈F"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_decomp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PR</span><span> </span><span>PL</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path E v0 (pr@pl1) vf"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path E vf (vf#pl2@pl1) vf"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>path_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v0,vf)∈E<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(vf,vf)∈E<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>path_is_rtrancl</span><span> </span><span>path_is_trancl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>GEN_INV</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v0∈V0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(v0,vf)∈E<span class="hidden">⇧</span><sup>*</sup>›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vf∈blues"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_dfs_outer_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Image_closed_trancl</span><span> </span><span>rev_ImageI</span><span> </span><span>rev_subsetD</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ADD_INV</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>add_inv_def</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹vf∈blues›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹vf∈F›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(vf,vf)∈E<span class="hidden">⇧</span><sup>+</sup>›</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IMP_POST_NOCYC_AUX</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>blues</span><span> </span><span>reds</span><span> </span><span>cyc</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"outer_inv {} (blues, reds, cyc)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"case extract_res cyc of 
        None ⇒ ∀L. ¬ is_lasso_prpl L 
      | Some x ⇒ is_lasso_prpl x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>cyc</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>IMP_POST_CYC</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>outer_inv_def</span><span> </span><span>extract_res_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>IMP_POST_NOCYC_AUX</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IMP_POST_NOCYC</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>blue_dfs_fe.refine</span><span> </span><span>blue_dfs_body.refine</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> 
</span><span>      </span><span>FOREACHc_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>outer_inv</span><span class="delimiter">]</span><span>
</span><span>      </span><span>refine_vcg</span><span>
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>finitely_reachable</span><span> </span><span>finite_V0</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OUTER_INITIAL</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>GEN</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>OUTER_IMP_PRE</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>POST_IMP_OUTER</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>OUTER_ALREX</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>IMP_POST_NOCYC</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>IMP_POST_CYC</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Refinement"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Setup for Custom Datatypes›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This effort can be automated, but currently, such an automation is
  not yet implemented›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"red_wit_rel R ≡ ⟨⟨⟨R⟩list_rel,R⟩prod_rel⟩option_rel"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i_red_wit I ≡ ⟨⟨⟨I⟩<span class="hidden">⇩</span><sub>i</sub>i_list,I⟩<span class="hidden">⇩</span><sub>i</sub>i_prod⟩<span class="hidden">⇩</span><sub>i</sub>i_option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blue_wit_rel ≡ (Id::(_ blue_witness × _) set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>i_blue_wit</span><span> </span><span class="delimiter">::</span><span> </span><span>interface</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>autoref_rel_intf</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>REL_INTFI</span><span class="delimiter">[</span><span>of</span><span> </span><span>blue_wit_rel</span><span> </span><span>i_blue_wit</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span>init_wit_blue_early</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>autoref_itype</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"NO_CYC ::<span class="hidden">⇩</span><sub>i</sub> i_blue_wit"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(=) ::<span class="hidden">⇩</span><sub>i</sub> i_blue_wit →<span class="hidden">⇩</span><sub>i</sub> i_blue_wit →<span class="hidden">⇩</span><sub>i</sub> i_bool"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"init_wit_blue ::<span class="hidden">⇩</span><sub>i</sub> I →<span class="hidden">⇩</span><sub>i</sub> i_red_wit I →<span class="hidden">⇩</span><sub>i</sub> i_blue_wit"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"init_wit_blue_early ::<span class="hidden">⇩</span><sub>i</sub> I →<span class="hidden">⇩</span><sub>i</sub> I →<span class="hidden">⇩</span><sub>i</sub> i_blue_wit"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prep_wit_blue ::<span class="hidden">⇩</span><sub>i</sub> I →<span class="hidden">⇩</span><sub>i</sub> i_blue_wit →<span class="hidden">⇩</span><sub>i</sub> i_blue_wit"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"red_init_witness ::<span class="hidden">⇩</span><sub>i</sub> I →<span class="hidden">⇩</span><sub>i</sub> I →<span class="hidden">⇩</span><sub>i</sub> i_red_wit I"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prep_wit_red ::<span class="hidden">⇩</span><sub>i</sub> I →<span class="hidden">⇩</span><sub>i</sub> i_red_wit I →<span class="hidden">⇩</span><sub>i</sub> i_red_wit I"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"extract_res ::<span class="hidden">⇩</span><sub>i</sub> i_blue_wit →<span class="hidden">⇩</span><sub>i</sub> ⟨⟨⟨I⟩<span class="hidden">⇩</span><sub>i</sub>i_list, ⟨I⟩<span class="hidden">⇩</span><sub>i</sub>i_list⟩<span class="hidden">⇩</span><sub>i</sub>i_prod⟩<span class="hidden">⇩</span><sub>i</sub>i_option"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"red_dfs ::<span class="hidden">⇩</span><sub>i</sub> ⟨I⟩<span class="hidden">⇩</span><sub>i</sub>i_slg →<span class="hidden">⇩</span><sub>i</sub> ⟨I⟩<span class="hidden">⇩</span><sub>i</sub>i_set →<span class="hidden">⇩</span><sub>i</sub> ⟨I⟩<span class="hidden">⇩</span><sub>i</sub>i_set →<span class="hidden">⇩</span><sub>i</sub> I 
    →<span class="hidden">⇩</span><sub>i</sub> ⟨⟨⟨I⟩<span class="hidden">⇩</span><sub>i</sub>i_set, i_red_wit I⟩<span class="hidden">⇩</span><sub>i</sub>i_prod⟩<span class="hidden">⇩</span><sub>i</sub>i_nres"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blue_dfs ::<span class="hidden">⇩</span><sub>i</sub> i_bg i_unit I 
    →<span class="hidden">⇩</span><sub>i</sub> ⟨⟨⟨⟨I⟩<span class="hidden">⇩</span><sub>i</sub>i_list, ⟨I⟩<span class="hidden">⇩</span><sub>i</sub>i_list⟩<span class="hidden">⇩</span><sub>i</sub>i_prod⟩<span class="hidden">⇩</span><sub>i</sub>i_option⟩<span class="hidden">⇩</span><sub>i</sub>i_nres"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>autoref_syn</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>autoref_op_pat</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NO_CYC ≡ OP NO_CYC :::<span class="hidden">⇩</span><sub>i</sub> i_blue_wit"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span>lasso_rel_ext</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>autoref_wit</span><span class="delimiter">[</span><span>autoref_rules_raw</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(NO_CYC,NO_CYC)∈blue_wit_rel"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"((=), (=)) ∈ blue_wit_rel → blue_wit_rel → bool_rel"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀R. PREFER_id R 
    ⟹ (init_wit_blue, init_wit_blue) ∈ R → red_wit_rel R → blue_wit_rel"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀R. PREFER_id R 
    ⟹ (init_wit_blue_early, init_wit_blue_early) ∈ R → R → blue_wit_rel"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀R. PREFER_id R 
    ⟹ (prep_wit_blue,prep_wit_blue)∈R → blue_wit_rel → blue_wit_rel"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀R. PREFER_id R 
    ⟹ (red_init_witness, red_init_witness) ∈ R→R→red_wit_rel R"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀R. PREFER_id R 
    ⟹ (prep_wit_red,prep_wit_red) ∈ R → red_wit_rel R → red_wit_rel R"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀R. PREFER_id R 
    ⟹ (extract_res,extract_res) 
        ∈ blue_wit_rel → ⟨⟨R⟩list_rel×<span class="hidden">⇩</span><sub>r</sub>⟨R⟩list_rel⟩option_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Actual Refinement›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span>red_dfs</span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map2set_rel (rbt_map_rel ord)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span>rbt_set_rel</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>red_dfs_refine_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(?f::?'c, red_dfs::(('a::linorder × _) set⇒_)) ∈ ?R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>autoref_tyrel</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"⟨Id⟩dflt_rs_rel"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>red_dfs_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>autoref</span><span> </span><span class="delimiter">(</span><span>trace</span><span class="delimiter">,</span><span>keep_goal</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>impl_red_dfs</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>red_dfs_refine_aux</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>impl_red_dfs_autoref</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a×'a::linorder) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PREFER_id R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(impl_red_dfs, red_dfs) ∈ 
    ⟨R⟩slg_rel → ⟨R⟩dflt_rs_rel → ⟨R⟩dflt_rs_rel → R 
    → ⟨⟨R⟩dflt_rs_rel ×<span class="hidden">⇩</span><sub>r</sub> red_wit_rel R⟩nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>impl_red_dfs.refine</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>autoref_itype</span><span class="delimiter">(</span><span>1</span><span>-</span><span>10</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>code_red_dfs_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN ?c ≤ impl_red_dfs E onstack V u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>impl_red_dfs_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>refine_transfer</span><span> </span><span class="delimiter">(</span><span>post</span><span class="delimiter">)</span><span> </span><span>the_resI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>code_red_dfs</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>code_red_dfs_aux</span><span>
</span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span>code_red_dfs_def</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>code_red_dfs.refine</span><span class="delimiter">[</span><span>refine_transfer</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>code_red_dfs</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>red_dfs_hash_refine_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(?f::?'c, red_dfs::(('a::hashable × _) set⇒_)) ∈ ?R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>autoref_tyrel</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"⟨Id⟩hs.rel"</span></span></span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>red_dfs_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>autoref</span><span> </span><span class="delimiter">(</span><span>trace</span><span class="delimiter">,</span><span>keep_goal</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>impl_red_dfs_hash</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>red_dfs_hash_refine_aux</span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>impl_red_dfs_hash.refine</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>impl_red_dfs_hash_autoref</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a×'a::hashable) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PREFER_id R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(impl_red_dfs_hash, red_dfs) ∈ 
    ⟨R⟩slg_rel → ⟨R⟩hs.rel → ⟨R⟩hs.rel → R 
    → ⟨⟨R⟩hs.rel ×<span class="hidden">⇩</span><sub>r</sub> red_wit_rel R⟩nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>impl_red_dfs_hash.refine</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>code_red_dfs_hash_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN ?c ≤ impl_red_dfs_hash E onstack V u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>impl_red_dfs_hash_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>refine_transfer</span><span> </span><span class="delimiter">(</span><span>post</span><span class="delimiter">)</span><span> </span><span>the_resI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>code_red_dfs_hash</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>code_red_dfs_hash_aux</span><span>
</span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span>code_red_dfs_hash_def</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>code_red_dfs_hash.refine</span><span class="delimiter">[</span><span>refine_transfer</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>code_red_dfs_hash</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>red_dfs_ahs_refine_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(?f::?'c, red_dfs::(('a::hashable × _) set⇒_)) ∈ ?R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>autoref_tyrel</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a::hashable set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"⟨Id⟩ahs.rel"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>red_dfs_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>autoref</span><span> </span><span class="delimiter">(</span><span>trace</span><span class="delimiter">,</span><span>keep_goal</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>impl_red_dfs_ahs</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>red_dfs_ahs_refine_aux</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>impl_red_dfs_ahs_autoref</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a×'a::hashable) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PREFER_id R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(impl_red_dfs_ahs, red_dfs) ∈ 
    ⟨R⟩slg_rel → ⟨R⟩ahs.rel → ⟨R⟩ahs.rel → R 
    → ⟨⟨R⟩ahs.rel ×<span class="hidden">⇩</span><sub>r</sub> red_wit_rel R⟩nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>impl_red_dfs_ahs.refine</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>code_red_dfs_ahs_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN ?c ≤ impl_red_dfs_ahs E onstack V u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>impl_red_dfs_ahs_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>refine_transfer</span><span> </span><span>the_resI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>code_red_dfs_ahs</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>code_red_dfs_ahs_aux</span><span>
</span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span>code_red_dfs_ahs_def</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>code_red_dfs_ahs.refine</span><span class="delimiter">[</span><span>refine_transfer</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>code_red_dfs_ahs</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*abbreviation "blue_dfs_annot E A u ≡ blue_dfs E (A:::<span class="hidden">⇩</span><sub>r</sub>⟨Id⟩fun_set_rel) u"*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>blue_dfs_refine_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(?f::?'c, blue_dfs::('a::linorder b_graph_rec⇒_)) ∈ ?R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>autoref_tyrel</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Id"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"⟨Id⟩dflt_rs_rel"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>blue_dfs_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>autoref</span><span> </span><span class="delimiter">(</span><span>trace</span><span class="delimiter">,</span><span>keep_goal</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>impl_blue_dfs</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>blue_dfs_refine_aux</span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>impl_blue_dfs.refine</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>impl_blue_dfs_autoref</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'a::linorder) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PREFER_id R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(impl_blue_dfs, blue_dfs) 
  ∈ bg_impl_rel_ext unit_rel R 
   → ⟨⟨⟨R⟩list_rel ×<span class="hidden">⇩</span><sub>r</sub> ⟨R⟩list_rel⟩Relators.option_rel⟩nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>impl_blue_dfs.refine</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>code_blue_dfs_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN ?c ≤ impl_blue_dfs G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>impl_blue_dfs_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_transfer</span><span> </span><span class="delimiter">(</span><span>post</span><span class="delimiter">)</span><span> </span><span>the_resI</span><span>
</span><span>    </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>det_RETURN</span><span> </span><span>code_red_dfs.refine</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>code_blue_dfs</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>code_blue_dfs_aux</span><span>
</span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span>code_blue_dfs_def</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>code_blue_dfs.refine</span><span class="delimiter">[</span><span>refine_transfer</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>code_blue_dfs</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>blue_dfs_hash_refine_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(?f::?'c, blue_dfs::('a::hashable b_graph_rec⇒_)) ∈ ?R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>autoref_tyrel</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Id"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a::hashable set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"⟨Id⟩hs.rel"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>blue_dfs_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>autoref_trace_failed_id</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>autoref</span><span> </span><span class="delimiter">(</span><span>trace</span><span class="delimiter">,</span><span>keep_goal</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>impl_blue_dfs_hash</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>blue_dfs_hash_refine_aux</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>impl_blue_dfs_hash_autoref</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'a::hashable) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PREFER_id R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(impl_blue_dfs_hash, blue_dfs) ∈ bg_impl_rel_ext unit_rel R 
    → ⟨⟨⟨R⟩list_rel ×<span class="hidden">⇩</span><sub>r</sub> ⟨R⟩list_rel⟩Relators.option_rel⟩nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>impl_blue_dfs_hash.refine</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>code_blue_dfs_hash_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN ?c ≤ impl_blue_dfs_hash G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>impl_blue_dfs_hash_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_transfer</span><span> </span><span>the_resI</span><span>
</span><span>    </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>det_RETURN</span><span> </span><span>code_red_dfs_hash.refine</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>code_blue_dfs_hash</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>code_blue_dfs_hash_aux</span><span>
</span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span>code_blue_dfs_hash_def</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>code_blue_dfs_hash.refine</span><span class="delimiter">[</span><span>refine_transfer</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>code_blue_dfs_hash</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>blue_dfs_ahs_refine_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(?f::?'c, blue_dfs::('a::hashable b_graph_rec⇒_)) ∈ ?R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>autoref_tyrel</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Id"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'a::hashable set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"⟨Id⟩ahs.rel"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>blue_dfs_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>autoref</span><span> </span><span class="delimiter">(</span><span>trace</span><span class="delimiter">,</span><span>keep_goal</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>impl_blue_dfs_ahs</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>blue_dfs_ahs_refine_aux</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>impl_blue_dfs_ahs_autoref</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'a::hashable) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"MINOR_PRIO_TAG 5"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PREFER_id R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(impl_blue_dfs_ahs, blue_dfs) ∈ bg_impl_rel_ext unit_rel R 
    → ⟨⟨⟨R⟩list_rel ×<span class="hidden">⇩</span><sub>r</sub> ⟨R⟩list_rel⟩Relators.option_rel⟩nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>impl_blue_dfs_ahs.refine</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>impl_blue_dfs_ahs_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>code_blue_dfs_ahs_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN ?c ≤ impl_blue_dfs_ahs G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>impl_blue_dfs_ahs_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_transfer</span><span> </span><span>the_resI</span><span>
</span><span>    </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>det_RETURN</span><span> </span><span>code_red_dfs_ahs.refine</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>code_blue_dfs_ahs</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>code_blue_dfs_ahs_aux</span><span>
</span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span>code_blue_dfs_ahs_def</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>code_blue_dfs_ahs.refine</span><span class="delimiter">[</span><span>refine_transfer</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>code_blue_dfs_ahs</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness theorem›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>code_blue_dfs_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>G</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b_graph G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E G)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>REL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Gi,G)∈bg_impl_rel_ext unit_rel Id"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN (code_blue_dfs Gi) ≤ SPEC (λr. 
    case r of None ⇒ ∀prpl. ¬b_graph.is_lasso_prpl G prpl
  | Some L ⇒ b_graph.is_lasso_prpl G L)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>code_blue_dfs.refine</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>impl_blue_dfs.refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>REL</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>blue_dfs_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>G</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>code_blue_dfs_correct'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>G</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b_graph G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E G)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>REL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Gi,G)∈bg_impl_rel_ext unit_rel Id"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"case code_blue_dfs Gi of
      None ⇒ ∀prpl. ¬b_graph.is_lasso_prpl G prpl
    | Some L ⇒ b_graph.is_lasso_prpl G L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>code_blue_dfs_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>G</span><span> </span><span>REL</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>code_blue_dfs_hash_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>G</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b_graph G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E G)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>REL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Gi,G)∈bg_impl_rel_ext unit_rel Id"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN (code_blue_dfs_hash Gi) ≤ SPEC (λr.
    case r of None ⇒ ∀prpl. ¬b_graph.is_lasso_prpl G prpl
  | Some L ⇒ b_graph.is_lasso_prpl G L)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>code_blue_dfs_hash.refine</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>impl_blue_dfs_hash.refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>REL</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>blue_dfs_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>G</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>code_blue_dfs_hash_correct'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>G</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b_graph G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E G)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>REL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Gi,G)∈bg_impl_rel_ext unit_rel Id"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"case code_blue_dfs_hash Gi of
      None ⇒ ∀prpl. ¬b_graph.is_lasso_prpl G prpl
    | Some L ⇒ b_graph.is_lasso_prpl G L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>code_blue_dfs_hash_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>G</span><span> </span><span>REL</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>code_blue_dfs_ahs_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>G</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b_graph G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E G)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>REL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Gi,G)∈bg_impl_rel_ext unit_rel Id"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN (code_blue_dfs_ahs Gi) ≤ SPEC (λr. 
    case r of None ⇒ ∀prpl. ¬b_graph.is_lasso_prpl G prpl
  | Some L ⇒ b_graph.is_lasso_prpl G L)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>code_blue_dfs_ahs.refine</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>impl_blue_dfs_ahs.refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>REL</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>blue_dfs_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>G</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>code_blue_dfs_ahs_correct'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>G</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b_graph G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E G)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>REL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Gi,G)∈bg_impl_rel_ext unit_rel Id"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"case code_blue_dfs_ahs Gi of
      None ⇒ ∀prpl. ¬b_graph.is_lasso_prpl G prpl
    | Some L ⇒ b_graph.is_lasso_prpl G L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>code_blue_dfs_ahs_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>G</span><span> </span><span>REL</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Export for benchmarking›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>acc_of_list_impl_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>autoref_tyrel</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"nat set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"⟨nat_rel⟩iam_set_rel"</span></span></span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?f::?'c,λl::nat list. 
    let s=(set l):::<span class="hidden">⇩</span><sub>r</sub>⟨nat_rel⟩iam_set_rel 
    in (λx::nat. x∈s)
  ) ∈ ?R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>autoref</span><span> </span><span class="delimiter">(</span><span>keep_goal</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>acc_of_list_impl_hash</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>acc_of_list_impl_hash</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>acc_of_list_impl_hash</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"code_blue_dfs_nat 
  ≡ code_blue_dfs :: _ ⇒ (nat list × _) option"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"code_blue_dfs_hash_nat 
  ≡ code_blue_dfs_hash :: _ ⇒ (nat list × _) option"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"code_blue_dfs_ahs_nat 
  ≡ code_blue_dfs_ahs :: _ ⇒ (nat list × _) option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ_of_list_impl_int ≡ 
  succ_of_list_impl o map (λ(u,v). (nat_of_integer u, nat_of_integer v))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"acc_of_list_impl_hash_int ≡ 
  acc_of_list_impl_hash o map nat_of_integer"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> 
</span><span>  </span><span>code_blue_dfs_nat</span><span> 
</span><span>  </span><span>code_blue_dfs_hash_nat</span><span>
</span><span>  </span><span>code_blue_dfs_ahs_nat</span><span>
</span><span>  </span><span>succ_of_list_impl_int</span><span>
</span><span>  </span><span>acc_of_list_impl_hash_int</span><span>
</span><span>  </span><span>nat_of_integer</span><span>
</span><span>  </span><span>integer_of_nat</span><span>
</span><span>  </span><span>lasso_ext</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML</span><span> </span><span class="keyword2"><span class="keyword">module_name</span></span><span> </span><span>HPY_new_hash</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹nested_dfs_hash.sml›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="CAVA_Abstract">
<div class="head"><h1>Theory CAVA_Abstract</h1>
<span class="command">theory</span> <span class="name">CAVA_Abstract</span><br/>
<span class="keyword">imports</span> <a href="../CAVA_Automata/Automata.html"><span class="name">Automata</span></a> <a href="../CAVA_Setup/LTL.html"><span class="name">LTL</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Abstract Model-Checker›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CAVA_Abstract</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>CAVA_Base.CAVA_Base</span><span>
</span><span>  </span><span>CAVA_Automata.Automata</span><span>
</span><span>  </span><span>LTL.LTL</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  This theory defines the abstract version of the cava model checker, 
  as well as a generic implementation.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Specification of an LTL Model-Checker›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Abstractly, an LTL model-checker consists of three components:
  \begin{enumerate}
    \item A conversion of LTL-formula to Indexed Generalized Buchi Automata 
      (IGBA) over sets of atomic propositions.       
    \item An intersection construction, which takes a system and an IGBA, and 
      creates an Indexed Generalized Buchi Graph (IGBG) and a projection 
      function to project runs of the IGBG back to runs of the system.
    \item An emptiness check for IGBGs.
  \end{enumerate}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Given an LTL formula, the LTL to Buchi conversion
  returns a Generalized Buchi Automaton that accepts the same language.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ltl_to_gba_spec</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'prop ltlc ⇒ ('q, 'prop set, _) igba_rec_scheme nres"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹Conversion of LTL formula to generalized buchi automaton›</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_to_gba_spec φ ≡ SPEC (λgba. 
    igba.lang gba = language_ltlc φ ∧ igba gba ∧ finite ((g_E gba)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 gba))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inter_spec</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s,'prop set,_) sa_rec_scheme 
  ⇒ ('q,'prop set,_) igba_rec_scheme
  ⇒ (('prod_state,_) igb_graph_rec_scheme × ('prod_state ⇒ 's)) nres"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹Intersection of system and IGBA›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀sys ba. inter_spec sys ba ≡ do {
    ASSERT (sa sys);
    ASSERT (finite ((g_E sys)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 sys));
    ASSERT (igba ba);
    ASSERT (finite ((g_E ba)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 ba));
    SPEC (λ(G,project). igb_graph G ∧ finite ((g_E G)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 G) ∧ (∀r. 
      (∃r'. igb_graph.is_acc_run G r' ∧ r = project o r')
        ⟷ (graph_defs.is_run sys r ∧ sa_L sys o r ∈ igba.lang ba)))
  }"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>find_ce_spec</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('q,_) igb_graph_rec_scheme ⇒ 'q word option option nres"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹Check Generalized Buchi graph for emptiness, with optional counterexample›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"find_ce_spec G ≡ do {
    ASSERT (igb_graph G);
    ASSERT (finite ((g_E G)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 G));
    SPEC (λres. case res of 
      None ⇒ (∀r. ¬igb_graph.is_acc_run G r)
    | Some None ⇒ (∃r. igb_graph.is_acc_run G r)
    | Some (Some r) ⇒ igb_graph.is_acc_run G r
    )}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Using the specifications from above, we can specify the essence
  of the model-checking algorithm: Convert the LTL-formula to a GBA,
  make an intersection with the system and check the result for emptiness.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>abs_model_check</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ba_state itself ⇒ 'ba_more itself 
  ⇒ 'prod_state itself ⇒ 'prod_more itself
  ⇒ ('s,'prop set,_) sa_rec_scheme ⇒ 'prop ltlc 
  ⇒ 's word option option nres"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"abs_model_check _ _ _ _ sys φ ≡ do {
    gba :: ('ba_state,_,'ba_more) igba_rec_scheme 
      ← ltl_to_gba_spec (Not_ltlc φ);
    ASSERT (igba gba);
    ASSERT (sa sys);
    (Gprod::('prod_state,'prod_more)igb_graph_rec_scheme, map_state) 
      ← inter_spec sys gba;
    ASSERT (igb_graph Gprod);
    ce ← find_ce_spec Gprod;

    case ce of
      None ⇒ RETURN None
    | Some None ⇒ RETURN (Some None)
    | Some (Some r) ⇒ RETURN (Some (Some (map_state o r)))
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The main correctness theorem states that our abstract model checker
  really checks whether the system satisfies the formula, and a
  correct counterexample is returned (if any). 
  Note that, if the model does not satisfy the formula, 
  returning a counterexample is optional.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>abs_model_check_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"abs_model_check T1 T2 T3 T4 sys φ ≤ do {
    ASSERT (sa sys);
    ASSERT (finite ((g_E sys)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 sys));
    SPEC (λres. case res of
      None ⇒ sa.lang sys ⊆ language_ltlc φ
    | Some None ⇒ ¬ sa.lang sys ⊆ language_ltlc φ
    | Some (Some r) ⇒ graph_defs.is_run sys r ∧ sa_L sys ∘ r ∉ language_ltlc φ)
  }"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>abs_model_check_def</span><span> </span><span>ltl_to_gba_spec_def</span><span> </span><span>inter_spec_def</span><span> 
</span><span>    </span><span>find_ce_spec_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>refine_vcg</span><span> </span><span>ASSERT_leI</span><span> </span><span>le_ASSERTI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sa.lang_def</span><span>
</span><span>    </span><span>sa.accept_def</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>meta_eq_to_obj_eq</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>ext</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"sa.accept sys"</span></span></span><span class="delimiter">]</span><span> </span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: We really need an extended abs_def attribute, that digests 
      conditional definitions! *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Generic Implementation›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this section, we define a generic implementation of an LTL model checker,
  that is parameterized with implementations of its components.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_rel ≡ Id :: ('a ltlc × _) set"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>impl_model_checker</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="comment">― ‹Assembly of a generic model-checker›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>sa_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('sai × ('s,'prop set,'sa_more) sa_rec_scheme) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>igba_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('igbai × ('q, 'prop set, 'igba_more) igba_rec_scheme) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>igbg_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('igbgi × ('sq, 'igbg_more) igb_graph_rec_scheme) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ce_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('cei × 'sq word) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>mce_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('mcei × 's word) set"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ltl_to_gba_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'cfg_l2b ⇒ 'prop ltlc ⇒ 'igbai"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>inter_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'cfg_int ⇒ 'sai ⇒ 'igbai ⇒ 'igbgi × ('sq ⇒ 's)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>find_ce_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'cfg_ce ⇒ 'igbgi ⇒ 'cei option option"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>map_run_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('sq ⇒ 's) ⇒ 'cei ⇒ 'mcei"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>relator_props</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"single_valued mce_rel"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ltl_to_gba_refine</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀cfg. (ltl_to_gba_impl cfg,ltl_to_gba_spec) 
      ∈ ltl_rel → ⟨igba_rel⟩plain_nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inter_refine</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀cfg. (inter_impl cfg,inter_spec) 
      ∈ sa_rel → igba_rel → ⟨igbg_rel ×<span class="hidden">⇩</span><sub>r</sub> (Id → Id)⟩plain_nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>find_ce_refine</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀cfg. (find_ce_impl cfg,find_ce_spec)
      ∈ igbg_rel → ⟨⟨⟨ce_rel⟩option_rel⟩option_rel⟩plain_nres_rel"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>map_run_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(map_run_impl,(o)) ∈ (Id → Id) → ce_rel → mce_rel"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>cfg_l2b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg_l2b (c1,c2,c3) = c1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>cfg_int</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg_int (c1,c2,c3) = c2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>cfg_ce</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg_ce (c1,c2,c3) = c3"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>impl_model_check</span><span> 
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('cfg_l2b×'cfg_int×'cfg_ce) 
      ⇒ 'sai ⇒ 'prop ltlc ⇒ 'mcei option option"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"impl_model_check cfg sys φ ≡ let
      ba = ltl_to_gba_impl (cfg_l2b cfg) (Not_ltlc φ);
      (G,map_q) = inter_impl (cfg_int cfg) sys ba;
      ce = find_ce_impl (cfg_ce cfg) G
    in
      case ce of
        None ⇒ None
      | Some None ⇒ Some None
      | Some (Some ce) ⇒ Some (Some (map_run_impl map_q ce))"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>impl_model_check_refine</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(impl_model_check cfg,abs_model_check 
        TYPE('q) TYPE('igba_more) TYPE('sq) TYPE('igbg_more)) 
      ∈ sa_rel → ltl_rel → ⟨⟨⟨mce_rel⟩option_rel⟩option_rel⟩plain_nres_rel"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>plain_nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>abs_model_check_def</span><span> </span><span>impl_model_check_def</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>let_to_bind_conv</span><span> </span><span>pull_out_let_conv</span><span> 
</span><span>      </span><span>pull_out_RETURN_case_option</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span>
</span><span>      </span><span>ltl_to_gba_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>plain_nres_relD</span><span class="delimiter">]</span><span>
</span><span>      </span><span>rel_arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Not_ltlc"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>inter_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>plain_nres_relD</span><span class="delimiter">]</span><span>
</span><span>      </span><span>find_ce_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>plain_nres_relD</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>option_relE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>parametricity</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_run_refine</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>impl_model_check_correct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(sysi,sys)∈sa_rel"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sa sys"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E sys)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 sys)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"case impl_model_check cfg sysi φ of
      None 
        ⇒ sa.lang sys ⊆ language_ltlc φ
    | Some None 
        ⇒ ¬ sa.lang sys ⊆ language_ltlc φ
    | Some (Some ri) 
        ⇒ (∃r. (ri,r)∈mce_rel 
           ∧ graph_defs.is_run sys r ∧ sa_L sys o r ∉ language_ltlc φ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>impl_model_check_refine</span><span class="delimiter">[</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cfg</span><span class="delimiter">=</span><span>cfg</span><span class="delimiter">,</span><span>
</span><span>      </span><span>param_fo</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>THEN</span><span> </span><span>plain_nres_relD</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>OF</span><span> </span><span>R</span><span> </span><span>IdI</span><span class="delimiter">[</span><span>of</span><span> </span><span>φ</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>abs_model_check_correct</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>refine_pw_simps</span><span> </span><span>pw_le_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>option_relE</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>impl_model_check_correct_no_ce</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(sysi,sys)∈sa_rel"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sa sys"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E sys)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 sys)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"impl_model_check cfg sysi φ = None 
    ⟷ sa.lang sys ⊆ language_ltlc φ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>impl_model_check_correct</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cfg</span><span class="delimiter">=</span><span>cfg</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>φ</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sa.lang_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SA</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>sa.accept_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SA</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="BoolProgs">
<div class="head"><h1>Theory BoolProgs</h1>
<span class="command">theory</span> <span class="name">BoolProgs</span><br/>
<span class="keyword">imports</span> <a href="../CAVA_Base/CAVA_Base.html"><span class="name">CAVA_Base</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Boolean Programs›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>BoolProgs</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>CAVA_Base.CAVA_Base</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Syntax and Semantics›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>bexp</span><span> </span><span class="delimiter">=</span><span> </span><span>TT</span><span> </span><span class="delimiter">|</span><span> </span><span>FF</span><span> </span><span class="delimiter">|</span><span> </span><span>V</span><span> </span><span>nat</span><span> </span><span class="delimiter">|</span><span> </span><span>Not</span><span> </span><span>bexp</span><span> </span><span class="delimiter">|</span><span> </span><span>And</span><span> </span><span>bexp</span><span> </span><span>bexp</span><span> </span><span class="delimiter">|</span><span> </span><span>Or</span><span> </span><span>bexp</span><span> </span><span>bexp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bitset"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>bval</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bexp ⇒ state ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"bval TT s = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"bval FF s = False"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"bval (V n) s = bs_mem n s"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"bval (Not b) s = (¬ bval b s)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"bval (And b<span class="hidden">⇩</span><sub>1</sub> b<span class="hidden">⇩</span><sub>2</sub>) s = (bval b<span class="hidden">⇩</span><sub>1</sub> s &amp; bval b<span class="hidden">⇩</span><sub>2</sub> s)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"bval (Or b<span class="hidden">⇩</span><sub>1</sub> b<span class="hidden">⇩</span><sub>2</sub>) s = (bval b<span class="hidden">⇩</span><sub>1</sub> s | bval b<span class="hidden">⇩</span><sub>2</sub> s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>instr</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>AssI</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bexp list"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>TestI</span><span> </span><span>bexp</span><span> </span><span>int</span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>ChoiceI</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bexp * int) list"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>GotoI</span><span> </span><span>int</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>config</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat * state"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>bprog</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"instr array"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Semantics Notice:
  To be equivalent in semantics with SPIN, there is no such thing as a
  finite run:
  \begin{itemize}
    \item Deadlocks (i.e. empty Choice) are self-loops
    \item program termination is self-loop
  \end{itemize}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>exec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"instr ⇒ config ⇒ config list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"exec instr (pc,s) = (case instr of
  AssI ns bs ⇒ let bvs = zip ns (map (λb. bval b s) bs) in
               [(pc + 1, foldl (λs (n,bv). set_bit s n bv) s bvs)] |
  TestI b d ⇒ [if bval b s then (pc+1, s) else (nat(int(pc+1)+d), s)] |
  ChoiceI bis ⇒ let succs = [(nat(int(pc+1)+i), s) . (b,i) &lt;- bis, bval b s] 
                in if succs = [] then [(pc,s)] else succs |
  GotoI d ⇒ [(nat(int(pc+1)+d),s)])"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* exec' is merely a stuttering optimization. It summarizes chains of choices
  or jumps, as long as they go forward in the program. The forward-condition is
  to ensure termination. 

  TODO: Make this explicit, and prove stuttering equivalence!
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>exec'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprog ⇒ state ⇒ nat ⇒ nat list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"exec' ins s pc = (
  if pc &lt; array_length ins then (
    case (array_get ins pc) of
      AssI ns bs ⇒ [pc] |
      TestI b d ⇒ (
        if bval b s then exec' ins s (pc+1) 
        else let pc'=(nat(int(pc+1)+d)) in if pc'&gt;pc then exec' ins s pc'
        else [pc']
      ) |
      ChoiceI bis ⇒ let succs = [(nat(int(pc+1)+i)) . (b,i) &lt;- bis, bval b s]
                    in if succs = [] then [pc] else concat (map (λpc'. if pc'&gt;pc then exec' ins s pc' else [pc']) succs) |
      GotoI d ⇒ let pc' = nat(int(pc+1)+d) in (if pc'&gt;pc then exec' ins s pc' else [pc'])
  ) else [pc]
)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (%(ins,s,pc). array_length ins - pc)"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>nexts1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprog ⇒ config ⇒ config list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"nexts1 ins (pc,s) = (
  if pc &lt; array_length ins then 
    exec (array_get ins pc) (pc,s) 
  else 
    [(pc,s)])"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>nexts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprog ⇒ config ⇒ config list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nexts ins (pc,s) = concat (
    map 
      (λ(pc,s). map (λpc. (pc,s)) (exec' ins s pc)) 
      (nexts1 ins (pc,s))
  )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>nexts.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span>
</span><span>  </span><span>com</span><span> </span><span class="delimiter">=</span><span> </span><span>SKIP</span><span>
</span><span>      </span><span class="delimiter">|</span><span> </span><span>Assign</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bexp list"</span></span></span><span>    
</span><span>      </span><span class="delimiter">|</span><span> </span><span>Seq</span><span>    </span><span>com</span><span>  </span><span>com</span><span>         
</span><span>      </span><span class="delimiter">|</span><span> </span><span>GC</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(bexp * com)list"</span></span></span><span>  
</span><span>      </span><span class="delimiter">|</span><span> </span><span>IfTE</span><span>  </span><span>bexp</span><span> </span><span>com</span><span> </span><span>com</span><span>      
</span><span>      </span><span class="delimiter">|</span><span> </span><span>While</span><span>  </span><span>bexp</span><span> </span><span>com</span><span>         
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>BoolProg_Syntax</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">notation</span></span><span> 
</span><span>        </span><span>Assign</span><span>       </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ::= _"</span></span></span><span> </span><span class="delimiter">[</span><span>999</span><span class="delimiter">,</span><span> </span><span>61</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Seq</span><span>          </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_;/ _"</span></span></span><span>  </span><span class="delimiter">[</span><span>60</span><span class="delimiter">,</span><span> </span><span>61</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>GC</span><span>           </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"IF _ FI"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IfTE</span><span>         </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(IF _/ THEN _/ ELSE _)"</span></span></span><span>  </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>61</span><span class="delimiter">,</span><span> </span><span>61</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>While</span><span>        </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(WHILE _/ DO _)"</span></span></span><span>  </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>61</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>BoolProg_Syntax</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>comp'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"com ⇒ instr list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"comp' SKIP = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"comp' (Assign n b) = [AssI n b]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"comp' (c1;c2) = comp' c1 @ comp' c2"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"comp' (IF gcs FI) =
  (let cgcs = map (λ(b,c). (b,comp' c)) gcs in
   let addbc = (λ(b,cc) (bis,ins).
         let cc' = cc @ (if ins = [] then [] else [GotoI (int(length ins))]) in
         let bis' = map (λ(b,i). (b, i + int(length cc'))) bis
         in ((b,0)#bis', cc' @ ins)) in
   let (bis,ins) = foldr addbc cgcs ([],[])
   in ChoiceI bis # ins)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"comp' (IF b THEN c1 ELSE c2) =
  (let ins1 = comp' c1 in let ins2 = comp' c2 in
   let i1 = int(length ins1 + 1) in let i2 = int(length ins2)
   in TestI b i1 # ins1 @ GotoI i2 # ins2)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"comp' (WHILE b DO c) =
  (let ins = comp' c in
   let i = int(length ins + 1)
   in TestI b i # ins @ [GotoI (-(i+1))])"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* a test: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comp' (IF [(V 0, [1,0] ::= [TT, FF]), (V 1, [0] ::= [TT])] FI)"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>comp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"com ⇒ bprog"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comp = array_of_list ∘ comp'"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 
  Optimization

- Gotos: Resolve Goto-Chains: If a Goto referres to another Goto -- add the second offset to the first one. 
                              If a Goto has a negative offset ignore it, to avoid problems with loops.

*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>opt'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"opt' (GotoI d) ys = (let next = λi. (case i of GotoI d ⇒ d + 1 | _ ⇒ 0)
                        in if d &lt; 0 ∨ nat d ≥ length ys then (GotoI d)#ys
                           else let d' = d + next (ys ! nat d)
                           in (GotoI d' # ys))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"opt' x ys = x#ys"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>opt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"instr list ⇒ instr list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"opt instr = foldr opt' instr []"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>optcomp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"com ⇒ bprog"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"optcomp ≡ array_of_list ∘ opt ∘ comp'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finiteness of reachable configurations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>reachable_configs</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bp</span><span> </span><span class="delimiter">::</span><span> </span><span>bprog</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c<span class="hidden">⇩</span><sub>s</sub></span><span> </span><span class="delimiter">::</span><span> </span><span>config</span><span> </span><span class="comment">― ‹start configuration›</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇩</span><sub>s</sub> ∈ reachable_configs bp c<span class="hidden">⇩</span><sub>s</sub>"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"c ∈ reachable_configs bp c<span class="hidden">⇩</span><sub>s</sub> ⟹ x ∈ set (nexts bp c) ⟹ x ∈ reachable_configs bp c<span class="hidden">⇩</span><sub>s</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>reachable_configs_induct</span><span> </span><span class="delimiter">=</span><span> </span><span>reachable_configs.induct</span><span class="delimiter">[</span><span>split_format</span><span class="delimiter">(</span><span>complete</span><span class="delimiter">)</span><span class="delimiter">,</span><span>case_names</span><span> </span><span>0</span><span> </span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>offsets</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"instr ⇒ int set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"offsets (AssI _ _) = {0}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"offsets (TestI _ i) = {0,i}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"offsets (ChoiceI bis) = set(map snd bis) ∪ {0}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"offsets (GotoI i) = {i}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>offsets_is</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"instr list ⇒ int set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"offsets_is ins = (UN instr : set ins. offsets instr)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>max_next_pcs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"instr list ⇒ nat set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"max_next_pcs ins = {nat(int(length ins + 1) + i) |i. i : offsets_is ins}"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_max_next_pcs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite(max_next_pcs bp)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>instr</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (offsets instr)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>instr</span><span class="delimiter">)</span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ins</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"max_next_pcs ins = (UN i : offsets_is ins. {nat(int(length ins + 1) + i)})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_next_pcs_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>offsets_is_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>linorder</span><span class="delimiter">)</span><span> </span><span>le_Max_insertI1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ finite A; x ≤ b ⟧ ⟹ x ≤ Max (insert b A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Max_ge</span><span> </span><span>finite.insertI</span><span> </span><span>insert_iff</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>linorder</span><span class="delimiter">)</span><span> </span><span>le_Max_insertI2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ finite A; A ≠ {}; x ≤ Max A ⟧ ⟹ x ≤ Max (insert b A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_def</span><span> </span><span>not_le</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Max_less_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_next_pcs_not_empty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pc&lt;length bp ⟹ x : set (exec (bp!pc) (pc,s)) ⟹ max_next_pcs bp ≠ {}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>nth_mem</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>max_next_pcs_def</span><span> </span><span>offsets_is_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>instr.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_lem2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pc &lt; length bp"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(pc', s') ∈ set (exec (bp!pc) (pc, s))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pc' ≤ Max (max_next_pcs bp)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"bp ! pc"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ChoiceI</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"pc' = pc"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span>ChoiceI</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Max_ge_iff</span><span> </span><span>max_next_pcs_not_empty</span><span> </span><span>finite_max_next_pcs</span><span class="delimiter">)</span><span> 
</span><span>         </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_next_pcs_def</span><span> </span><span>offsets_is_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>nth_mem</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ChoiceI</span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span>bi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bval b s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(b,i) ∈ set l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pc' = nat(int(pc+1)+i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ChoiceI</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ ⋃(offsets ` (set bp))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>nth_mem</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>bi</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃a. (a ∈ max_next_pcs bp ∧ pc' ≤ a)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_next_pcs_def</span><span> </span><span>offsets_is_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Max_ge_iff</span><span> </span><span>max_next_pcs_not_empty</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>finite_max_next_pcs</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Max_ge_iff</span><span> </span><span>max_next_pcs_not_empty</span><span> </span><span>finite_max_next_pcs</span><span class="delimiter">,</span><span>
</span><span>     </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_next_pcs_def</span><span> </span><span>offsets_is_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>nth_mem</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_lem1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ pc &lt; length bp; (pc', s') ∈ set (exec (bp ! pc) (pc, s))⟧
    ⟹ pc' ≤ Max (insert x (max_next_pcs bp))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>le_Max_insertI2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>finite_max_next_pcs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_next_pcs_not_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Max_lem2</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span>exec.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pc_bound bp ≡ max 
    (Max (max_next_pcs (list_of_array bp)) + 1)
    (array_length bp + 1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>exec'.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (list_of_array a) = array_length a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aux2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pc &lt; array_length ins"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ofs ∈ offsets_is (list_of_array ins)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nat (1 + int pc + ofs) &lt; pc_bound ins"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nat (int (1 + array_length ins) + ofs) 
    ∈ max_next_pcs (list_of_array ins)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_next_pcs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pc_bound_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>max.strict_coboundedI1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Max_ge</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_max_next_pcs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_idx_in_set</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ pc &lt; array_length ins; array_get ins pc = x ⟧ 
  ⟹ x ∈ set (list_of_array ins)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ins</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rcs_aux</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pc &lt; pc_bound bp"</span></span></span><span>    
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pc'∈set (exec' bp s pc)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pc' &lt; pc_bound bp"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>bp</span><span> </span><span>s</span><span> </span><span>pc</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>pc'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>exec'.induct</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>C</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>C</span><span> </span><span>ins</span><span> </span><span>s</span><span> </span><span>pc</span><span> </span><span>pc'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>C.prems</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>exec'.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_split_asm</span><span> </span><span>instr.split_asm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pc_bound_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>C.IH</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pc_bound_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>C.IH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>bexp</span><span> </span><span>int</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"int ∈ offsets_is (list_of_array ins)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>aux2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>offsets_is_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"TestI bexp int"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>bexI</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>array_idx_in_set</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>C.IH</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"ba ∈ offsets_is (list_of_array ins)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>aux2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>offsets_is_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"ChoiceI list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>bexI</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>array_idx_in_set</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>int</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>C.IH</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"int ∈ offsets_is (list_of_array ins)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>aux2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>offsets_is_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"GotoI int"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>bexI</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>array_idx_in_set</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>bexp_vars</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bexp ⇒ nat set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bexp_vars TT = {}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"bexp_vars FF = {}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"bexp_vars (V n) = {n}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"bexp_vars (Not b) = bexp_vars b"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"bexp_vars (And b1 b2) = bexp_vars b1 ∪ bexp_vars b2"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"bexp_vars (Or b1 b2) = bexp_vars b1 ∪ bexp_vars b2"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>instr_vars</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"instr ⇒ nat set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"instr_vars (AssI xs bs) = set xs ∪ ⋃(bexp_vars`set bs)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"instr_vars (TestI b _) = bexp_vars b"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"instr_vars (ChoiceI cs) = ⋃(bexp_vars`fst`set cs)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"instr_vars (GotoI _) = {}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">find_consts</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'a array ⇒ 'a list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bprog_vars</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprog ⇒ nat set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bprog_vars bp = ⋃(instr_vars`set (list_of_array bp))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"state_bound bp s0 
  ≡ {s. bs_α s - bprog_vars bp = bs_α s0 - bprog_vars bp}"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"config_bound bp s0 ≡ {0..&lt; pc_bound bp} × state_bound bp s0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>PCB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pc &lt; array_length bp"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ state_bound bp s0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (exec (array_get bp pc) (pc,s)) ⊆ config_bound bp s0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>exec.simps</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>instrs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>BP_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bp = Array instrs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PCB</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>PCB'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pc &lt; length instrs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>pc'</span><span> </span><span>s'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>STEP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(pc',s') ∈ set (exec (array_get bp pc) (pc,s))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>STEP'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(pc',s') ∈ set (exec (instrs!pc) (pc,s))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pc' &lt; pc_bound bp"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Max_lem2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PCB'</span><span> </span><span>STEP'</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pc_bound_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ state_bound bp s0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>STEP'</span><span> </span><span>SB</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"instrs!pc"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>AssI</span><span> </span><span>xs</span><span> </span><span>vs</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set xs ⊆ instr_vars (instrs!pc)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>AssI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⊆ bprog_vars bp"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bprog_vars_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>PCB'</span><span> </span><span>UN_upper</span><span> </span><span>nth_mem</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>XSB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set xs ⊆ bprog_vars bp"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>s</span><span> </span><span>v</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ bprog_vars bp"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ state_bound bp s0"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SB_CNV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bs_α (set_bit s x v) 
        = (if v then (insert x (bs_α s)) else (bs_α s - {x}))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>bs_insert_def</span><span> </span><span>bs_delete_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bs_correct</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_bit s x v ∈ state_bound bp s0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>state_bound_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SB_CNV</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>aux</span><span class="delimiter">=</span><span>this</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>vs</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"foldl (λs (x, y). set_bit s x y) s (zip xs vs) 
        ∈ state_bound (Array instrs) s0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SB</span><span> </span><span>XSB</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>vs</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>vs</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>aux</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>aux2</span><span class="delimiter">=</span><span>this</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>STEP'</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>AssI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_bound_step</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>exec.simps</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>BOUND</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ config_bound bp s0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>STEP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c'∈set (nexts bp c)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' ∈ config_bound bp s0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BOUND</span><span> </span><span>STEP</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>    </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nexts.simps</span><span> 
</span><span>    </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>exec_bound</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>rcs_aux</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>exec_bound</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>rcs_aux</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachable_configs_in_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"c ∈ config_bound bp s0 ⟹ reachable_configs bp c ⊆ config_bound bp s0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' ∈ reachable_configs bp c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ config_bound bp s0"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' ∈ config_bound bp s0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>induction</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>in_bound_step</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachable_configs_out_of_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(pc',s')∈reachable_configs bp (pc,s) 
  ⟹ ¬ pc &lt; pc_bound bp ⟹ (pc',s') = (pc,s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable_configs_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>pc'</span><span> </span><span>s'</span><span> </span><span>pc''</span><span> </span><span>s''</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pc'=pc"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s'=s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ pc &lt; array_length bp"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pc_bound_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nexts.simps</span><span> </span><span>exec'.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_bexp_vars</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (bexp_vars be)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>be</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_instr_vars</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (instr_vars ins)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ins</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_bprog_vars</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (bprog_vars bp)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bprog_vars_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_state_bound</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (state_bound bp s0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>state_bound_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_imageD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>bs_α</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>B</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. s - bprog_vars bp = bs_α s0 - bprog_vars bp}"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_if_eq_beyond_finite</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inj_onI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>bs_eq_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bs_eq_correct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_config_bound</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (config_bound bp s0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachable_configs_finite</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"finite (reachable_configs bp c)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>pc</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (reachable_configs bp (pc, s))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"pc &lt; pc_bound bp"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>reachable_configs_out_of_bound</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>False</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">=</span><span>s</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable_configs bp (pc, s) ⊆ {(pc,s)}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_subset</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(pc,s) ∈ config_bound bp s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>state_bound_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>reachable_configs_in_bound</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bpc_is_run bpc r ≡ let (bp,c)=bpc in r 0 = c ∧ (∀i. r (Suc i) ∈ set (BoolProgs.nexts bp (r i)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bpc_props c ≡ bs_α (snd c)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bpc_lang bpc ≡ {bpc_props o r | r. bpc_is_run bpc r}"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Printing *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*definition print_list where
  "print_list f sep s = (let f' = (λstr s. if str = [] then f s
                                       else str @ sep @ f s)
                     in ''['' @ (foldl f' [] s) @ '']'')"

fun bool_list_to_prop_list where
  "bool_list_to_prop_list _ [] props = props"
| "bool_list_to_prop_list n (x#xs) props = (let props' = if x then n#props else props 
                                            in bool_list_to_prop_list (Suc n) xs props')"
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>print_config</span><span> </span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ string) ⇒ (bitset ⇒ string) ⇒ config ⇒ string"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"print_config f fx (p,s) = f p @ '' '' @ fx s"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="BoolProgs_Extras">
<div class="head"><h1>Theory BoolProgs_Extras</h1>
<span class="command">theory</span> <span class="name">BoolProgs_Extras</span><br/>
<span class="keyword">imports</span> <a href="BoolProgs.html"><span class="name">BoolProgs</span></a> <a href="../CAVA_Setup/Mapping.html"><span class="name">Mapping</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>BoolProgs_Extras</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>BoolProgs</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Mapping"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>BoolProg_Syntax</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Macros›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Counters ≈ bounded natural numbers›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Vars: offset, number of vars, value *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>set_counter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list ⇒ bexp list ⇒ nat ⇒ nat ⇒ nat ⇒ com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set_counter vs bs _ 0 _ = vs ::= bs"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_counter vs bs pos (Suc l) 0 = set_counter (pos#vs) (FF#bs) (Suc pos) l 0"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_counter vs bs pos (Suc l) (Suc n) = set_counter (pos#vs) (TT#bs) (Suc pos) l n"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Vars: offset, number of vars, value to compare to *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>counter_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ nat ⇒ bexp"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"counter_eq pos m n = (if n &gt; m then FF else
                           let posT = [0..&lt;n] in
                           let posF = [n..&lt;m] in
                           let bexps = (map (λx. V (pos + x)) posT) @ (map (λx. Not (V (pos + x))) posF) in
                           foldl And TT bexps)"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Vars: offset, number of vars *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>inc_counter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list ⇒ bexp list ⇒ nat ⇒ nat ⇒ com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inc_counter vs bs pos 0 = vs ::= bs"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"inc_counter vs bs pos (Suc n) = IF V pos THEN inc_counter vs bs (Suc pos) n ELSE (pos#vs) ::= (TT#bs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dec_counter_toggle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list ⇒ bexp list ⇒ bool ⇒ nat ⇒ com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"dec_counter_toggle vs bs False _ = vs ::= bs"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"dec_counter_toggle vs bs True pos = ((pos - 1)#vs) ::= (FF#bs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dec_counter'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list ⇒ bexp list ⇒ bool ⇒ nat ⇒ nat ⇒ com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dec_counter' vs bs start pos 0 = dec_counter_toggle vs bs start pos"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"dec_counter' vs bs start pos (Suc n) = 
                      IF Not (V pos) THEN (dec_counter_toggle vs bs start pos)
                      ELSE dec_counter' vs bs True (Suc pos) n"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Vars: offset, number of vars *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dec_counter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list ⇒ bexp list ⇒ nat ⇒ nat ⇒ com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dec_counter vs bs = dec_counter' vs bs False"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Array access via run-time variable. Emulated by checking all possible values.
Vars: ctr: function 'nat ⇒ bexp' - returns true if the counter is of a specific value
      act: function 'nat ⇒ com' - action to take with value if counter is value
        m: number of values (checked are [0,m[) *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>array_access</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"array_access ctr act m = foldl (λbexp c. IF ctr c THEN act c ELSE bexp) SKIP [0..&lt;m]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>array_check</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"array_check ctr chk m = foldl (λbexp c. And (Or (Not (ctr c)) (chk c)) (Or (ctr c) bexp)) FF [0..&lt;m]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Gather statistics›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>stat'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"stat' (a,t,c,g) instr = (case instr of
  AssI _ _ ⇒ (Suc a,t,c,g)
| TestI _ _ ⇒ (a,Suc t,c,g)
| ChoiceI _ ⇒ (a,t,Suc c,g)
| GotoI _ ⇒ (a,t,c,Suc g))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>stats</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"stats ls = foldl stat' (0,0,0,0) ls"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Misc›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* this is only used for the code setup in Programs/* *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>const_map</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(String.literal, bexp) mapping"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>fun_map</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(String.literal, nat ⇒ bexp) mapping"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mapping_from_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'b) list ⇒ ('a, 'b) mapping"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mapping_from_list = foldl (λm (k,v). Mapping.update k v m) Mapping.empty"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="BoolProgs_LTL_Conv">
<div class="head"><h1>Theory BoolProgs_LTL_Conv</h1>
<span class="command">theory</span> <span class="name">BoolProgs_LTL_Conv</span><br/>
<span class="keyword">imports</span> <a href="BoolProgs_Extras.html"><span class="name">BoolProgs_Extras</span></a> <a href="../CAVA_Setup/LTL.html"><span class="name">LTL</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>BoolProgs_LTL_Conv</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>BoolProgs_Extras</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Mapping"</span></span></span><span>
</span><span>  </span><span>LTL.LTL</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>b2l</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bexp ⇒ nat ltlc"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"b2l TT = true<span class="hidden">⇩</span><sub>c</sub>"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"b2l FF = false<span class="hidden">⇩</span><sub>c</sub>"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"b2l (bexp.V v) = prop<span class="hidden">⇩</span><sub>c</sub>(v)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"b2l (bexp.Not e) = not<span class="hidden">⇩</span><sub>c</sub> (b2l e)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"b2l (And e1 e2) = b2l e1 and<span class="hidden">⇩</span><sub>c</sub> b2l e2"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"b2l (Or e1 e2) = b2l e1 or<span class="hidden">⇩</span><sub>c</sub> b2l e2"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span>
</span><span>  </span><span>propc</span><span> </span><span class="delimiter">=</span><span> </span><span>CProp</span><span> </span><span>String.literal</span><span> </span><span class="delimiter">|</span><span> </span><span>FProp</span><span> </span><span class="string"><span class="delete"><span class="delete">"String.literal * integer"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ltl_conv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"const_map ⇒ fun_map ⇒ propc ltlc ⇒ (nat ltlc + String.literal)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ltl_conv _ _ True_ltlc = Inl True_ltlc"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_conv _ _ False_ltlc = Inl False_ltlc"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_conv C _ (Prop_ltlc (CProp s)) = (case Mapping.lookup C s of
                                              Some c ⇒ Inl (b2l c)
                                             | None ⇒ Inr (STR ''Unknown constant: '' + s))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_conv _ M (Prop_ltlc (FProp (s, argm))) = (case Mapping.lookup M s of
                                                    Some f ⇒ (Inl ∘ b2l ∘ f ∘ nat_of_integer) argm
                                                  | None ⇒ Inr (STR ''Unknown function: '' + s))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_conv C M (Not_ltlc x) = (case ltl_conv C M x of Inl l ⇒ Inl (Not_ltlc l) | Inr s ⇒ Inr s)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_conv C M (Next_ltlc x) = (case ltl_conv C M x of Inl l ⇒ Inl (Next_ltlc l) | Inr s ⇒ Inr s)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_conv C M (Final_ltlc x) = (case ltl_conv C M x of Inl l ⇒ Inl (Final_ltlc l) | Inr s ⇒ Inr s)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_conv C M (Global_ltlc x) = (case ltl_conv C M x of Inl l ⇒ Inl (Global_ltlc l) | Inr s ⇒ Inr s)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_conv C M (And_ltlc x y) = (case ltl_conv C M x of 
                                    Inr s ⇒ Inr s
                                  | Inl l ⇒ (case ltl_conv C M y of Inl r ⇒ Inl (And_ltlc l r) | Inr s ⇒ Inr s))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_conv C M (Or_ltlc x y) = (case ltl_conv C M x of 
                                    Inr s ⇒ Inr s
                                  | Inl l ⇒ (case ltl_conv C M y of Inl r ⇒ Inl (Or_ltlc l r) | Inr s ⇒ Inr s))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_conv C M (Implies_ltlc x y) = (case ltl_conv C M x of 
                                    Inr s ⇒ Inr s
                                  | Inl l ⇒ (case ltl_conv C M y of Inl r ⇒ Inl (Implies_ltlc l r) | Inr s ⇒ Inr s))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_conv C M (Until_ltlc x y) = (case ltl_conv C M x of 
                                    Inr s ⇒ Inr s
                                  | Inl l ⇒ (case ltl_conv C M y of Inl r ⇒ Inl (Until_ltlc l r) | Inr s ⇒ Inr s))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_conv C M (Release_ltlc x y) = (case ltl_conv C M x of 
                                    Inr s ⇒ Inr s
                                  | Inl l ⇒ (case ltl_conv C M y of Inl r ⇒ Inl (Release_ltlc l r) | Inr s ⇒ Inr s))"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="BoolProgs_Philosophers">
<div class="head"><h1>Theory BoolProgs_Philosophers</h1>
<span class="command">theory</span> <span class="name">BoolProgs_Philosophers</span><br/>
<span class="keyword">imports</span> <a href="BoolProgs_Extras.html"><span class="name">BoolProgs_Extras</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>BoolProgs_Philosophers</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../BoolProgs_Extras"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>BoolProg_Syntax</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eat m i = i"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"one m i = m + i"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"free m i = (2*m) + (i mod m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Eat m i = V(eat m i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Free</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Free m i = V(free m i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>One</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"One m i = V(one m i)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>phil_const</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ const_map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"phil_const n ≡ Mapping.empty"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>phil_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ fun_map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"phil_fun n ≡ mapping_from_list [
              (STR ''eat'', Eat n),
              (STR ''one'', One n),
              (STR ''free'', Free n) ]"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>phil_init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"phil_init n = foldl (λxs i. bs_insert (free n i) xs) (bs_empty ()) [0..&lt;n]"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*definition phil_init :: "nat ⇒ state" where
  "phil_init n = replicate (2 * n) False @ replicate n True"
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dining</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ (bexp × com) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"dining m 0 = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"dining m (Suc i) = [
  (
   And (Not (Eat m i)) (Free m i),
   [one m i, free m i] ::= [TT, FF]
  ), (
   And (One m i) (Free m (i + 1)),
   [one m i, free m (i+1), eat m i] ::= [FF, FF, TT]
  ), (
   Eat m i,
   [free m i, free m (i+1), eat m i] ::= [TT, TT, FF]
  )] @ dining m i"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>philosophers</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">" nat ⇒ bprog × config"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"philosophers n = (optcomp (WHILE TT DO IF dining n n FI), (0, phil_init n))"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span>eat</span><span> </span><span>one</span><span> </span><span>free</span><span> </span><span>Eat</span><span> </span><span>Free</span><span> </span><span>One</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="BoolProgs_ReaderWriter">
<div class="head"><h1>Theory BoolProgs_ReaderWriter</h1>
<span class="command">theory</span> <span class="name">BoolProgs_ReaderWriter</span><br/>
<span class="keyword">imports</span> <a href="BoolProgs_Extras.html"><span class="name">BoolProgs_Extras</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>BoolProgs_ReaderWriter</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"../BoolProgs_Extras"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
   Reader/Writers case study
   adapted from BEEM library (hTTp://anna.fi.muni.cz/models/)
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>BoolProg_Syntax</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* variables *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ready ≡ 0::nat"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"readers_active ≡ 1::nat"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"writers_active ≡ 2::nat"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q_error ≡ 3::nat"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reading r w i ≡ (q_error + 1) + i"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"writing r w i ≡ (reading r w r) + i"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"activeR r w ≡ writing r w w"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_activeR r w v vs bs ≡ set_counter vs bs (activeR r w) r v"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inc_activeR r w vs bs ≡ inc_counter vs bs (activeR r w) r"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dec_activeR r w vs bs ≡ dec_counter vs bs (activeR r w) r"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"activeR_eq r w v ≡ counter_eq (activeR r w) r v"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rw_const</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ const_map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rw_const n ≡ mapping_from_list [
              (STR ''ready'', V ready),
              (STR ''readers_active'', V readers_active),
              (STR ''writers_active'', V writers_active),
              (STR ''q_error'', V q_error) ]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rw_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ fun_map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rw_fun n ≡ mapping_from_list [
             (STR ''reading'', λi. V (reading n n i)),
             (STR ''writing'', λi. V (writing n n i)),
             (STR ''activeR_eq'', activeR_eq n n) ]"</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* init variable list *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rw_init</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rw_init r w ≡ bs_insert ready (bs_empty ())"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* program *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>reader_control</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reader_control r w i ≡ [
     (
      V ready,
      [ready, readers_active] ::= [FF, TT]
     ), (
      And (V readers_active) (Not (V (reading r w i))),
      inc_activeR r w [reading r w i] [TT]
     ), (
      And (V readers_active) (V (reading r w i)),
      dec_activeR r w [reading r w i] [FF]
     ), (
      And (V readers_active) (activeR_eq r w 0),
      [readers_active, ready] ::= [FF, TT]
     )]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>writer_control</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"writer_control r w i ≡ [
     (
      V ready,
      [ready, writers_active, writing r w i] ::= [FF, TT, TT]
     ), (
      And (V readers_active) (V (writing r w i)),
      [readers_active, q_error, writing r w i] ::= [FF,TT,FF]
    ), (
      And (V writers_active) (V (writing r w i)),
      [writers_active, ready, writing r w i] ::= [FF, TT, FF]
    )]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>rw_body</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ nat ⇒ nat ⇒ (bexp × com) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rw_body _ _ 0 0 = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"rw_body r w (Suc r') 0 = reader_control r w r' @ rw_body r w r' 0"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"rw_body r w r' (Suc w') = writer_control r w w' @ rw_body r w r' w'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>reader_writer</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ bprog × config"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reader_writer r w =
     (optcomp(WHILE TT DO IF (rw_body r w r w) FI), (0, rw_init r w))"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
// Interesting property e.g.:
// G (not q_error)

// An "error" can be injected by changing the lines
//  // decrement actvR
//  IF actvR_1 THEN (actvR_0 := TT; actvR_1 := FF);
//  IF actvR_2 THEN (actvR_1 := TT; actvR_2 := FF);
// 
// to 
// (actvR_1 := TT; actvR_0 := FF; actvR_2 := FF)
// (actvR := 1 instead of actvR := actvR - 1)
// With only 2 writers, this is not really an error :)
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="BoolProgs_Simple">
<div class="head"><h1>Theory BoolProgs_Simple</h1>
<span class="command">theory</span> <span class="name">BoolProgs_Simple</span><br/>
<span class="keyword">imports</span> <a href="BoolProgs_Extras.html"><span class="name">BoolProgs_Extras</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>BoolProgs_Simple</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"../BoolProgs_Extras"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>BoolProg_Syntax</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>simple_prog</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ (bexp × com) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"simple_prog _ 0 = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_prog r (Suc n) = (V n, [n] ::= [FF]) # simple_prog r n"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>simple</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ bprog × config"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"simple n = (optcomp 
    (WHILE TT DO IF simple_prog n n FI), 
    (0, foldl (λxs i. bs_insert i xs) (bs_empty ()) [0..&lt;n]))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>simple_const</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ const_map"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"simple_const n ≡ Mapping.empty"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>simple_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ fun_map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"simple_fun n ≡ mapping_from_list [(STR ''var'', λi. V i)]"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="BoolProgs_LeaderFilters">
<div class="head"><h1>Theory BoolProgs_LeaderFilters</h1>
<span class="command">theory</span> <span class="name">BoolProgs_LeaderFilters</span><br/>
<span class="keyword">imports</span> <a href="BoolProgs_Extras.html"><span class="name">BoolProgs_Extras</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>BoolProgs_LeaderFilters</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"../BoolProgs_Extras"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>BoolProg_Syntax</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* variables *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"elected ≡ 0 :: nat"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"error ≡ 1 :: nat"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"turn n i ≡ error + 1 + n*i"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b n i ≡ turn n n + i"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c n i ≡ b n n + i"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>curr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"curr n i ≡ c n n + n * i"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L_1 n i = curr n n + i"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L_2 n i = L_1 n n + i"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L_3 n i = L_2 n n + i"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L_4 n i = L_3 n n + i"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L_5 n i = L_4 n n + i"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L_8 n i = L_5 n n + i"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L_9 n i = L_8 n n + i"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_turn n i v vs bs ≡ set_counter vs bs (turn n i) n v"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inc_turn n i vs bs ≡ inc_counter vs bs (turn n i) n"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dec_turn n i vs bs ≡ dec_counter vs bs (turn n i) n"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"turn_eq n i v ≡ counter_eq (turn n i) n v"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_curr n i v vs bs ≡ set_counter vs bs (curr n i) n v"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inc_curr n i vs bs ≡ inc_counter vs bs (curr n i) n"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dec_curr n i vs bs ≡ dec_counter vs bs (curr n i) n"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"curr_eq n i v ≡ counter_eq (curr n i) n v"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"curr_access n i act ≡ array_access (curr_eq n i) act (n + 1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"curr_check n i chk ≡ array_check (curr_eq n i) chk (n + 1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lf_const</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ const_map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lf_const n ≡ mapping_from_list [
              (STR ''elected'', V elected),
              (STR ''error'', V error)]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lf_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ fun_map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lf_fun n ≡ mapping_from_list [
             (STR ''b'', λi. V (b n i)),
             (STR ''c'', λi. V (c n i))]"</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* init variable list *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lf_init</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lf_init n ≡ foldl 
    (λxs c. bs_insert c xs) (bs_empty ()) [(L_1 n 0)..&lt;(L_1 n n)]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>process</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"process n i = [
     (
       V (L_1 n i),
       curr_access n i (λv. set_turn n v (i+1) [L_1 n i, L_2 n i] [FF, TT])
     ), (
       And (V (L_2 n i)) (curr_check n i (λv. Not (V (b n v)))),
       [L_2 n i, L_3 n i] ::= [FF, TT]
     ), (
       V (L_3 n i),
       curr_access n i (λv. [b n v, L_3 n i, L_4 n i] ::= [TT, FF, TT])
     ), (
       V (L_4 n i),
       curr_access n i (λv. IF Not (turn_eq n v (i+1)) THEN [L_4 n i, L_5 n i] ::= [FF, TT] ELSE [L_4 n i, L_8 n i] ::= [FF, TT])
     ), (
       V (L_5 n i),
       curr_access n i (λv. [c n v, b n v, L_5 n i] ::= [TT, FF, FF])
     ), (
       V (L_8 n i),
       IF curr_eq n i 0 THEN (inc_curr n i [L_8 n i, L_1 n i] [FF, TT])
       ELSE curr_access n i (λv. IF Not (V (c n v)) THEN [L_8 n i, L_9 n i] ::= [FF, TT] ELSE inc_curr n i [L_8 n i, L_1 n i] [FF, TT])
     ), (
       And (V (L_9 n i)) (V elected),
       [error, L_9 n i] ::= [TT, FF]
     ), (
       V (L_9 n i),
       [elected, L_9 n i] ::= [TT, FF]
     )]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>processes</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"processes n = concat (map (process n) [0..&lt;n])"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>leader_filters</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ bprog × config"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"leader_filters n =
     (optcomp(WHILE TT DO IF processes n FI), (0, lf_init n))"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>turn</span><span> </span><span>error</span><span> </span><span>curr</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="BoolProgs_Programs">
<div class="head"><h1>Theory BoolProgs_Programs</h1>
<span class="command">theory</span> <span class="name">BoolProgs_Programs</span><br/>
<span class="keyword">imports</span> <a href="BoolProgs_Philosophers.html"><span class="name">BoolProgs_Philosophers</span></a> <a href="BoolProgs_ReaderWriter.html"><span class="name">BoolProgs_ReaderWriter</span></a> <a href="BoolProgs_Simple.html"><span class="name">BoolProgs_Simple</span></a> <a href="BoolProgs_LeaderFilters.html"><span class="name">BoolProgs_LeaderFilters</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>BoolProgs_Programs</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>BoolProgs_Philosophers</span><span>
</span><span>  </span><span>BoolProgs_ReaderWriter</span><span>
</span><span>  </span><span>BoolProgs_Simple</span><span>
</span><span>  </span><span>BoolProgs_LeaderFilters</span><span>
</span><span>  </span><span>CAVA_Base.Code_String</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*"HOL-Library.List_lexord"*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>progs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(String.literal, String.literal × String.literal × (nat ⇒ (bprog × config) × const_map × fun_map)) mapping"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"progs =  mapping_from_list [
                (STR ''RW'', (STR ''Reader/Writer'', STR ''# Readers and # Writers'', λn. (reader_writer n n, rw_const n, rw_fun n))),
                (STR ''S'', (STR ''Simple Variable Setting'', STR ''# Variables'', λn. (simple n, simple_const n, simple_fun n))),
                (STR ''P'', (STR ''Dining Philosophers'', STR ''# Philosophers'', λn. (philosophers n, phil_const n, phil_fun n))),
                (STR ''LF'', (STR ''Leader Filters'', STR ''# Processes'', λn. (leader_filters n, lf_const n, lf_fun n)))
              ]"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ensure this is an actual key *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"default_prog ≡ STR ''S''"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>keys_of_map</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(String.literal, 'a) mapping ⇒ String.literal list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"keys_of_map ≡ Mapping.ordered_keys"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>chose_prog</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"String.literal ⇒ nat ⇒ String.literal × String.literal × (bprog × config) × const_map × fun_map"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chose_prog P n = (case Mapping.lookup progs P of 
                          Some (descr, ndescr, p) ⇒ (descr, ndescr, p n) 
                        | None ⇒ let (descr, ndescr, p) = the (Mapping.lookup progs default_prog)
                                 in (descr + STR '' (fallback)'', ndescr, p n))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>list_progs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(String.literal × String.literal × String.literal) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_progs ≡ let keys = keys_of_map progs in
                map (λk. let (descr, ndescr, p) = the (Mapping.lookup progs k)
                         in (k, descr, ndescr)) keys"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="CAVA_Impl">
<div class="head"><h1>Theory CAVA_Impl</h1>
<span class="command">theory</span> <span class="name">CAVA_Impl</span><br/>
<span class="keyword">imports</span> <a href="CAVA_Abstract.html"><span class="name">CAVA_Abstract</span></a> <a href="Rewriting.html"><span class="name">Rewriting</span></a> <a href="../CAVA_Setup/LTL_to_GBA_impl.html"><span class="name">LTL_to_GBA_impl</span></a> <a href="../CAVA_Setup/Gabow_GBG_Code.html"><span class="name">Gabow_GBG_Code</span></a> <a href="NDFS_SI.html"><span class="name">NDFS_SI</span></a> <a href="BoolProgs_Programs.html"><span class="name">BoolProgs_Programs</span></a> <a href="BoolProgs_LTL_Conv.html"><span class="name">BoolProgs_LTL_Conv</span></a> <a href="../CAVA_Setup/PromelaLTL.html"><span class="name">PromelaLTL</span></a> <a href="../CAVA_Setup/PromelaLTLConv.html"><span class="name">PromelaLTLConv</span></a> <a href="AList_Mapping.html"><span class="name">AList_Mapping</span></a> <a href="../CAVA_Setup/SM_Wrapup.html"><span class="name">SM_Wrapup</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Actual Implementation of the CAVA Model Checker›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CAVA_Impl</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CAVA_Abstract</span><span>
</span><span>  </span><span>CAVA_Automata.Automata_Impl</span><span>
</span><span>
</span><span>  </span><span>LTL.Rewriting</span><span>
</span><span>
</span><span>  </span><span>LTL_to_GBA.LTL_to_GBA_impl</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* LTL to BA *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span>Gabow_SCC.Gabow_GBG_Code</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Gabow's Algorithm *)</span></span></span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Nested_DFS/NDFS_SI"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Nested-DFS, standard-invars formalization *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"BoolProgs/BoolProgs"</span></span></span><span>                   </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Boolean Programs *)</span></span></span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"BoolProgs/Programs/BoolProgs_Programs"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* the actual programs *)</span></span></span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"BoolProgs/BoolProgs_LTL_Conv"</span></span></span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* LTL parsing setup *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span>Promela.PromelaLTL</span><span>     </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Promela *)</span></span></span></span></span><span>
</span><span>  </span><span>Promela.PromelaLTLConv</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* LTL parsing setup *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.AList_Mapping"</span></span></span><span>
</span><span>  </span><span>CAVA_Base.CAVA_Code_Target</span><span>
</span><span>  </span><span>SM.SM_Wrapup</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>SM_Cfg.cfg</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Miscellaneous Lemmata›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>uint32</span><span> </span><span class="delimiter">::</span><span> </span><span>hashable</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hashcode x = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"def_hashmap_size (T::uint32 itself) ≡ 8"</span></span></span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>intro_classes</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>def_hashmap_size_uint32_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Exporting Graphs›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: frv_export is going to be replaced by more explicit implementation 
  of graphs.
  For the moment, we just keep it here.
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"frv_edge_set G ≡ g_E G ∩ (g_V G × UNIV)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"frv_edge_set_aimpl G ≡ FOREACHi (λit r. r = g_E G ∩ ((g_V G - it) × UNIV))
  (g_V G) 
  (λu r. do {
    let E = (λv. (u,v))`(succ_of_E (g_E G) u);
    ASSERT (E ∩ r = {});
    RETURN (E ∪ r)
  }) 
  {}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>frv_edge_set_aimpl_correct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"finite (g_V G) ⟹ frv_edge_set_aimpl G ≤ SPEC (λr. r = frv_edge_set G)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>frv_edge_set_aimpl_def</span><span> </span><span>frv_edge_set_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>succ_of_E_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>frv_edge_set_impl_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(eq,(=))∈R → R → bool_rel"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>relator_props</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"single_valued R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?c, frv_edge_set_aimpl) ∈ ⟨Rx,R⟩frgv_impl_rel_ext → ⟨⟨R ×<span class="hidden">⇩</span><sub>r</sub> R⟩list_set_rel⟩nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>frv_edge_set_aimpl_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>autoref</span><span> </span><span class="delimiter">(</span><span>trace</span><span class="delimiter">,</span><span>keep_goal</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>frv_edge_set_impl</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>frv_edge_set_impl_aux</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>frv_edge_set_impl.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>GEN_OP_D</span><span> </span><span>PREFER_sv_D</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>frv_edge_set_code_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN ?c ≤ frv_edge_set_impl eq G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>frv_edge_set_impl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>refine_transfer</span><span> </span><span class="delimiter">(</span><span>post</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>frv_edge_set_code</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>eq</span><span> </span><span>G</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>frv_edge_set_code_aux</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>refine_transfer</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>frv_edge_set_code.refine</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>frv_edge_set_autoref</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>EQ</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>autoref_tag_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"GEN_OP eq (=) (R → R → bool_rel)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SV</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>autoref_tag_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"PREFER single_valued R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(frv_edge_set_code eq,frv_edge_set) ∈ ⟨Rx,R⟩frgv_impl_rel_ext → ⟨R ×<span class="hidden">⇩</span><sub>r</sub> R⟩list_set_rel"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Gi</span><span> </span><span>G</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Gr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Gi, G) ∈ ⟨Rx, R⟩frgv_impl_rel_ext"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (g_V G)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>frgv_impl_rel_ext_def</span><span> </span><span>g_impl_rel_ext_def</span><span>
</span><span>      </span><span>gen_g_impl_rel_ext_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_set_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>frv_edge_set_code.refine</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>frv_edge_set_impl.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>EQ</span><span> </span><span>SV</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>fun_relD</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>Gr</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>frv_edge_set_aimpl_correct</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(frv_edge_set_code eq Gi, frv_edge_set G) ∈ ⟨R ×<span class="hidden">⇩</span><sub>r</sub> R⟩list_set_rel"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RETURN_ref_SPECD</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"frv_export G ≡ do {
  nodes ← SPEC (λl. set l = g_V G ∧ distinct l);
  V0 ← SPEC (λl. set l = g_V0 G ∧ distinct l);
  E ← SPEC (λl. set l = frv_edge_set G ∧ distinct l);
  RETURN (nodes,V0,E)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>frv_export_impl_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('vi × 'v) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>autoref_tyrel</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>TYRELI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨R ×<span class="hidden">⇩</span><sub>r</sub> R⟩list_set_rel"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>EQ</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(eq,(=))∈R → R → bool_rel"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SVR</span><span class="delimiter">[</span><span>relator_props</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"single_valued R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?c, frv_export) 
  ∈ ⟨Rx,R⟩frgv_impl_rel_ext 
  → ⟨⟨R⟩list_rel ×<span class="hidden">⇩</span><sub>r</sub> ⟨R⟩list_rel ×<span class="hidden">⇩</span><sub>r</sub> ⟨R ×<span class="hidden">⇩</span><sub>r</sub> R⟩list_rel⟩nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>frv_export_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>autoref_trace_failed_id</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>autoref</span><span> </span><span class="delimiter">(</span><span>keep_goal</span><span class="delimiter">,</span><span> </span><span>trace</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>frv_export_impl</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>eq</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>frv_export_impl_aux</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>frv_export_impl.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>GEN_OP_D</span><span> </span><span>PREFER_sv_D</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>frv_export_code_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN ?c ≤ frv_export_impl eq G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>frv_export_impl_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_transfer</span><span> </span><span class="delimiter">(</span><span>post</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>frv_export_code</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>eq</span><span> </span><span>G</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>frv_export_code_aux</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>refine_transfer</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>frv_export_code.refine</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Setup›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹LTL to GBA conversion›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In the following, we set up the algorithms for LTL to GBA conversion.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_ltl_to_gba_algo</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ltlc ⇒ (nat, 'a ⇒ bool, unit) igbav_impl_scheme) ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹Predicate that must be satisfied by an LTL to GBA conversion›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_ltl_to_gba_algo algo ≡ (algo, ltl_to_gba_spec) 
    ∈ ltl_rel 
    → ⟨igbav_impl_rel_ext unit_rel nat_rel (⟨Id⟩fun_set_rel)⟩plain_nres_rel"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gerth_ltl_to_gba</span><span> 
</span><span>  </span><span class="comment">― ‹Conversion based on Gerth's Algorithm›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gerth_ltl_to_gba φ ≡ create_name_igba (ltln_to_ltlr (simplify Slow (ltlc_to_ltln φ)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gerth_ltl_to_gba_refine</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gerth_ltl_to_gba φ ≤ ⇓Id (ltl_to_gba_spec φ)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ltl_to_gba_spec_def</span><span> </span><span>gerth_ltl_to_gba_def</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>create_name_igba_correct</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SPEC_rule</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>safe</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat, 'a set) igba_rec"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"igba G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>igba</span><span> </span><span>G</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (g_V G)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ ξ. accept ξ ⟷ ξ ⊨<span class="hidden">⇩</span><sub>r</sub> ltln_to_ltlr (simplify Slow (ltlc_to_ltln φ))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lang = language_ltlc φ"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lang_def</span><span> </span><span>language_ltlc_def</span><span> </span><span>ltln_to_ltlr_semantics</span><span> </span><span>simplify_correct</span><span> </span><span>ltlc_to_ltln_semantics</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E G)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 G)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>reachable_V</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gerth_ltl_to_gba_code φ ≡ create_name_igba_code (ltln_to_ltlr (simplify Slow (ltlc_to_ltln φ)))"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gerth_ltl_to_gba_code_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ltl_to_gba_algo gerth_ltl_to_gba_code"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. RETURN (gerth_ltl_to_gba_code φ) 
    ≤ ⇓(igbav_impl_rel_ext unit_rel nat_rel (⟨Id⟩fun_set_rel)) 
      (gerth_ltl_to_gba φ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gerth_ltl_to_gba_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>gerth_ltl_to_gba_code_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>create_name_igba_code.refine</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>create_name_igba_impl.refine</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fun_relD</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>gerth_ltl_to_gba_refine</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_ltl_to_gba_algo_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>plain_nres_relI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We define a function that chooses between the possible conversion 
  algorithms. (Currently there is only one)›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>config_l2b</span><span> </span><span class="delimiter">=</span><span> </span><span>CFG_L2B_GERTHS</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl_to_gba_code cfg 
  ≡ case cfg of CFG_L2B_GERTHS ⇒ gerth_ltl_to_gba_code"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ltl_to_gba_code_refine</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_ltl_to_gba_algo (ltl_to_gba_code cfg)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>cfg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ltl_to_gba_code_def</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gerth_ltl_to_gba_code_refine</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Counterexample Search›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_find_ce_algo</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a, unit)igbg_impl_scheme ⇒ 'a lasso option option) ⇒ bool"</span></span></span><span> 
</span><span>  </span><span class="comment">― ‹Predicate that must be satisfied by counterexample search algorithm›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_find_ce_algo algo ≡ (algo, find_ce_spec) 
    ∈ igbg_impl_rel_ext unit_rel Id 
  → ⟨⟨⟨⟨Id⟩lasso_run_rel⟩Relators.option_rel⟩Relators.option_rel⟩plain_nres_rel"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gabow_find_ce_code</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ 'a::hashable lasso option option"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹Emptiness check based on Gabow's SCC Algorithm›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gabow_find_ce_code
  ≡ map_option (Some o lasso_of_prpl) o Gabow_GBG_Code.find_lasso_tr (=) bounded_hashcode_nat (def_hashmap_size TYPE('a))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gabow_find_ce_code_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_find_ce_algo 
  (gabow_find_ce_code 
    :: ('a::hashable, unit) igbg_impl_scheme ⇒ 'a lasso option option)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AUX_EQ</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀gbgi::('a, unit) igbg_impl_scheme. RETURN (gabow_find_ce_code gbgi)
    = (do {
      l ← RETURN (find_lasso_tr (=) bounded_hashcode_nat (def_hashmap_size TYPE('a)) gbgi);
      RETURN (map_option (Some ∘ lasso_of_prpl) l)
    })"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gabow_find_ce_code_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Clean up this proof! *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_find_ce_algo_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>plain_nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_ce_spec_def</span><span> </span><span>AUX_EQ</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>
</span><span>      </span><span>OF</span><span> </span><span>bind_mono</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Gabow_GBG_Code.find_lasso_tr_correct</span><span> </span><span>order_refl</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>autoref_ga_rules</span><span class="delimiter">;</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>autoref_ga_rules</span><span class="delimiter">;</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>igb_fr_graphI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>igb_graph.find_lasso_spec_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lasso_run_rel_sv</span><span> </span><span>option_rel_sv</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>igb_graph.is_lasso_prpl_of_lasso</span><span> </span><span>igb_graph.accepted_lasso</span><span> 
</span><span>      </span><span>prod.exhaust</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option_rel_def</span><span> </span><span>lasso_run_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>igb_graph.is_lasso_prpl_conv</span><span> </span><span>igb_graph.lasso_accepted</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ndfs_find_ce</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('q::hashable,_) igb_graph_rec_scheme ⇒ 'q lasso option option nres"</span></span></span><span> 
</span><span>  </span><span class="comment">― ‹Emptiness check based on nested DFS›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ndfs_find_ce G ≡ do {
    ASSERT (igb_graph G);
    let G = igb_graph.degeneralize G;
    l ← blue_dfs G;
    case l of
      None ⇒ RETURN None
    | Some l ⇒ do { 
        ASSERT (snd l ≠ []); 
        RETURN (Some (Some (map_lasso fst (lasso_of_prpl l)))) 
      }
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ndfs_find_ce_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(G',G)∈Id ⟹ 
  ndfs_find_ce G' ≤ ⇓(⟨⟨⟨Id⟩lasso_run_rel⟩option_rel⟩option_rel) (find_ce_spec G)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_ce_spec_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>SPEC_refine</span><span> </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"igb_graph G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>igb_graph</span><span> </span><span>G</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>fr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E G)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 G)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b_graph degeneralize"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>degen_invar</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*then interpret bg: b_graph degeneralize .*)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ndfs_find_ce G
    ≤
    (SPEC (λres. ∃res'. 
         (res,res')∈(⟨⟨⟨Id⟩lasso_run_rel⟩Relators.option_rel⟩Relators.option_rel)
       ∧ (case res' of None ⇒ ∀r. ¬ is_acc_run r
         | Some None ⇒ Ex is_acc_run 
         | Some (Some x) ⇒ is_acc_run x)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ndfs_find_ce_def</span><span> </span><span>find_lasso_spec_def</span><span> </span><span>ce_correct_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>refine_vcg</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>blue_dfs_correct</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>degen_finite_reachable</span><span> </span><span>fr</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span>
</span><span>      </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>degen_acc_run_complete</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ_. ()"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>degen.accepted_lasso</span><span class="delimiter">[</span><span>OF</span><span> </span><span>degen_finite_reachable</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fr</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>degen.is_lasso_prpl_of_lasso</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>prpl_of_lasso_def</span><span>
</span><span>      </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>degen.is_lasso_prpl_of_lasso</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>b_graph.is_lasso_prpl_def</span><span> </span><span>graph.is_lasso_prpl_pre_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>degen.is_lasso_prpl_conv</span><span> </span><span>lasso_run_rel_def</span><span> </span><span>br_def</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>degen.lasso_accepted</span><span> </span><span>degen_acc_run_sound</span><span>
</span><span>    </span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>ndfs_find_ce_impl_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(?c, ndfs_find_ce) 
  ∈ igbg_impl_rel_ext Rm Id 
  → ⟨
    ⟨⟨⟨unit_rel,Id::('a::hashable×_) set⟩lasso_rel_ext⟩option_rel⟩option_rel
  ⟩ nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ndfs_find_ce_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>autoref_trace_failed_id</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>autoref</span><span> </span><span class="delimiter">(</span><span>trace</span><span class="delimiter">,</span><span> </span><span>keep_goal</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>ndfs_find_ce_impl</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>ndfs_find_ce_impl_aux</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>ndfs_find_ce_code_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN ?c ≤ ndfs_find_ce_impl G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ndfs_find_ce_impl_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>refine_transfer</span><span> </span><span class="delimiter">(</span><span>post</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>ndfs_find_ce_code</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>ndfs_find_ce_code_aux</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ndfs_find_ce_code_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_find_ce_algo ndfs_find_ce_code"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_find_ce_algo_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>plain_nres_relI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>gbgi</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,unit) igbg_impl_scheme"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gbg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a igb_graph_rec"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(gbgi, gbg) ∈ igbg_impl_rel_ext unit_rel Id"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ndfs_find_ce_code.refine</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ndfs_find_ce_impl.refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>R</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ndfs_find_ce_refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>IdI</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN (ndfs_find_ce_code gbgi)
    ≤ ⇓ (⟨⟨⟨Id⟩lasso_run_rel⟩Relators.option_rel⟩Relators.option_rel) 
      (find_ce_spec gbg)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lasso_rel_ext_id</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We define a function that chooses between the emptiness check 
  algorithms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>config_ce</span><span> </span><span class="delimiter">=</span><span> </span><span>CFG_CE_SCC_GABOW</span><span> </span><span class="delimiter">|</span><span> </span><span>CFG_CE_NDFS</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>find_ce_code</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"find_ce_code cfg ≡ case cfg of 
  CFG_CE_SCC_GABOW ⇒ gabow_find_ce_code
| CFG_CE_NDFS ⇒ ndfs_find_ce_code"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>find_ce_code_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_find_ce_algo (find_ce_code cfg)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>cfg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_ce_code_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gabow_find_ce_code_refine</span><span> </span><span>ndfs_find_ce_code_refine</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>config_ce.split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹System-Agnostic Model-Checker›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this section, we implement the part of the model-checker that does not 
  depend on the language used to describe the system to be checked. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Default Implementation of Lazy Intersection›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>cava_inter_impl_loc</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>igba_sys_prod_precond</span><span> </span><span>G</span><span> </span><span>S</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'l set) sa_rec"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('q,'l set) igba_rec"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Gi</span><span> </span><span>Si</span><span> </span><span>Rq</span><span> </span><span>Rs</span><span> </span><span>Rl</span><span> </span><span>eqq</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(eqq,(=)) ∈ Rq → Rq → bool_rel"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Gi,G) ∈ igbav_impl_rel_ext unit_rel Rq Rl"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Si,S) ∈ sa_impl_rel_ext unit_rel Rs Rl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cava_inter_impl_loc_this</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cava_inter_impl_loc S G Gi Si Rq Rs Rl eqq"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹TODO/FIXME:
    Some black-magic is going on here: The performance of the mc seems to depend on the ordering of states,
    so we do some adjustments of the ordering here.
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prod_impl_aux_alt_cava_reorder</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"prod = (⦇
      g_V = Collect (λ(q,s). q ∈ igba.V ∧ s ∈ sa.V),
      g_E = E_of_succ (λ(q,s). 
        if igba.L q (sa.L s) then     
          (λ(s,q). (q,s))`(LIST_SET_REV_TAG (succ_of_E (sa.E) s) 
           × (succ_of_E (igba.E) q))
        else
          {}
      ),
      g_V0 = igba.V0 × sa.V0,
      igbg_num_acc = igba.num_acc,
      igbg_acc = λ(q,s). if s∈sa.V then igba.acc q else {}
    ⦈)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prod_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>succ_of_E_def</span><span> </span><span>E_of_succ_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>vf_prod_impl_aux_cava_reorder</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?c, prod) ∈ igbg_impl_rel_ext unit_rel (Rq ×<span class="hidden">⇩</span><sub>r</sub> Rs)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prod_impl_aux_alt_cava_reorder</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>autoref_trace_failed_id</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>autoref</span><span> </span><span class="delimiter">(</span><span>trace</span><span class="delimiter">,</span><span> </span><span>keep_goal</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>map_concat_map_map_opt</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"map f (concat (map (λxa. map (f' xa) (l1 xa)) l2)) 
      = List.maps (λxa. map (f o f' xa) (l1 xa)) l2"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"((λ(xd, xe). (xe, xd)) ∘ Pair xa) = (λx. (x,xa))"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹Very specific optimization used in the next refinement›</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l2</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>List.maps_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>gbav_sys_prod_impl_cava_reorder</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>eqq</span><span> </span><span>Gi</span><span> </span><span>Si</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>cava_inter_impl_loc.vf_prod_impl_aux_cava_reorder</span><span class="delimiter">[</span><span>
</span><span>    </span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>map_concat_map_map_opt</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span>gbav_sys_prod_impl_cava_reorder.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cava_inter_impl_loc_this</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>autoref_syn</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* HACK: Overwrite pattern that rewrites outer-level prod, such that
      local rules apply here. *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>autoref_op_pat</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prod ≡ OP prod"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dflt_inter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('q × 's) igb_graph_rec × ('q × 's ⇒ 's)"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dflt_inter ≡ (prod, snd)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dflt_inter_refine</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN dflt_inter ≤ inter_spec S G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inter_spec_def</span><span> </span><span>dflt_inter_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>le_ASSERTI</span><span> </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarsimp_all</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"igb_graph prod"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prod_invar</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (igba.E<span class="hidden">⇧</span><sup>*</sup> `` igba.V0)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E S)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 S)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E prod)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 prod)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod_finite_reachable</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃r'. prod.is_acc_run r' ∧ r = snd ∘ r') ⟷
          (sa.is_run r ∧ sa.L ∘ r ∈ igba.lang)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gsp_correct1</span><span> </span><span>gsp_correct2</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_assoc</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>dflt_inter_impl_aux</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?c, dflt_inter) 
    ∈ igbg_impl_rel_ext unit_rel (Rq ×<span class="hidden">⇩</span><sub>r</sub> Rs) ×<span class="hidden">⇩</span><sub>r</sub> (Rq ×<span class="hidden">⇩</span><sub>r</sub> Rs → Rs)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dflt_inter_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>autoref_trace_failed_id</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>autoref</span><span> </span><span class="delimiter">(</span><span>keep_goal</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>dflt_inter_impl</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>eqq</span><span> </span><span>Si</span><span> </span><span>Gi</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>cava_inter_impl_loc.dflt_inter_impl_aux</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>dflt_inter_impl.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cava_inter_impl_loc_this</span><span class="delimiter">]</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"op_dflt_inter ≡ cava_inter_impl_loc.dflt_inter"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>autoref_op_pat</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cava_inter_impl_loc.dflt_inter ≡ op_dflt_inter"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>autoref_syn</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dflt_inter_autoref</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('q,'l set) igba_rec"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'l set) sa_rec"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Gi</span><span> </span><span>Si</span><span> </span><span>Rq</span><span> </span><span>Rs</span><span> </span><span>Rl</span><span> </span><span>eqq</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SIDE_PRECOND (igba G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SIDE_PRECOND (sa S)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"GEN_OP eqq (=) (Rq → Rq → bool_rel)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Gi,G) ∈ igbav_impl_rel_ext unit_rel Rq Rl"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Si,S) ∈ sa_impl_rel_ext unit_rel Rs Rl"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dflt_inter_impl eqq Si Gi,
    (OP op_dflt_inter 
     ::: sa_impl_rel_ext unit_rel Rs Rl
      → igbav_impl_rel_ext unit_rel Rq Rl 
      → igbg_impl_rel_ext unit_rel (Rq ×<span class="hidden">⇩</span><sub>r</sub> Rs) ×<span class="hidden">⇩</span><sub>r</sub> (Rq ×<span class="hidden">⇩</span><sub>r</sub> Rs → Rs))$S$G
  ) ∈ igbg_impl_rel_ext unit_rel (Rq ×<span class="hidden">⇩</span><sub>r</sub> Rs) ×<span class="hidden">⇩</span><sub>r</sub> (Rq ×<span class="hidden">⇩</span><sub>r</sub> Rs → Rs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>igba</span><span class="delimiter">:</span><span> </span><span>igba</span><span> </span><span>G</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>sa</span><span class="delimiter">:</span><span> </span><span>sa</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>cava_inter_impl_loc</span><span> </span><span>S</span><span> </span><span>G</span><span> </span><span>Gi</span><span> </span><span>Si</span><span> </span><span>Rq</span><span> </span><span>Rs</span><span> </span><span>Rl</span><span> </span><span>eqq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>dflt_inter_impl.refine</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_spec_refineI</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ sa S; igba G ⟧ ⟹ m ≤ ⇓R (inter_spec S G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≤ ⇓R (inter_spec S G)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inter_spec_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dflt_inter_impl_refine</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Rs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('si × 's) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Rq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('qi × 'q) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Rprop</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('pi × 'p) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>relator_props</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"single_valued Rs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Range Rs = UNIV"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"single_valued Rq"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Range Rq = UNIV"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>EQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(eqq,(=)) ∈ Rq → Rq → bool_rel"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dflt_inter_impl eqq, inter_spec)
  ∈ sa_impl_rel_ext unit_rel Rs (⟨Rprop⟩fun_set_rel) →
    igbav_impl_rel_ext unit_rel Rq (⟨Rprop⟩fun_set_rel) →
    ⟨igbg_impl_rel_ext unit_rel (Rq ×<span class="hidden">⇩</span><sub>r</sub> Rs) ×<span class="hidden">⇩</span><sub>r</sub> ((Rq ×<span class="hidden">⇩</span><sub>r</sub> Rs) → Rs)⟩plain_nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>plain_nres_relI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inter_spec_refineI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Si</span><span> </span><span>S</span><span> </span><span>Gi</span><span> </span><span>G</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>R</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(Si,S) ∈ sa_impl_rel_ext unit_rel Rs (⟨Rprop⟩fun_set_rel)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(Gi, G) ∈ igbav_impl_rel_ext unit_rel Rq (⟨Rprop⟩fun_set_rel)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sa S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"igba G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>sa</span><span class="delimiter">:</span><span> </span><span>sa</span><span> </span><span>S</span><span> </span><span class="delimiter">+</span><span> </span><span>igba</span><span class="delimiter">:</span><span> </span><span>igba</span><span> </span><span>G</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>cava_inter_impl_loc</span><span> </span><span>S</span><span> </span><span>G</span><span> </span><span>Gi</span><span> </span><span>Si</span><span> </span><span>Rq</span><span> </span><span>Rs</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨Rprop⟩fun_set_rel"</span></span></span><span> </span><span>eqq</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EQ</span><span> </span><span>R</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>RETURN_refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dflt_inter_impl.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cava_inter_impl_loc_this</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>dflt_inter_refine</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN (dflt_inter_impl eqq Si Gi)
  ≤ ⇓ (igbg_impl_rel_ext unit_rel (Rq ×<span class="hidden">⇩</span><sub>r</sub> Rs) ×<span class="hidden">⇩</span><sub>r</sub> (Rq ×<span class="hidden">⇩</span><sub>r</sub> Rs → Rs))
     (inter_spec S G)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of Model-Checker›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In this section, we instantiate the parametrized model checker
  with the actual implementations.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span>Locale_Code.open_block</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>cava_sys_agn</span><span class="delimiter">:</span><span> </span><span>impl_model_checker</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sa_impl_rel_ext unit_rel Id (⟨Id⟩fun_set_rel)"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"igbav_impl_rel_ext unit_rel Id (⟨Id⟩fun_set_rel)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"igbg_impl_rel_ext unit_rel (Id ×<span class="hidden">⇩</span><sub>r</sub> Id)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟨Id ×<span class="hidden">⇩</span><sub>r</sub> Id⟩lasso_run_rel"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨Id⟩lasso_run_rel"</span></span></span><span>
</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ltl_to_gba_code"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"λ_::unit. dflt_inter_impl (=)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"find_ce_code"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_lasso"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>tagged_solver</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ltl_to_gba_code_refine</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>is_ltl_to_gba_algo_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dflt_inter_impl_refine</span><span class="delimiter">[</span><span>of</span><span> </span><span>Id</span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"(=)"</span></span></span><span> </span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>find_ce_code_refine</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>is_find_ce_algo_def</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_lasso_run_refine</span><span class="delimiter">[</span><span>of</span><span> </span><span>Id</span><span> </span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span>Locale_Code.close_block</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cava_sys_agn ≡ cava_sys_agn.impl_model_check"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The correctness theorem states correctness of the model checker wrt.\ 
  a model given as system automata. In the following sections, we will then 
  refine the model description to Boolean programs and Promela.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cava_sys_agn_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>sysi</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s::hashable, 'p::linorder ⇒ bool, unit) sa_impl_scheme"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sys</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'p set) sa_rec"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>φ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p ltlc"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cfg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"config_l2b × unit × config_ce"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(sysi, sys) ∈ sa_impl_rel_ext unit_rel Id (⟨Id⟩fun_set_rel)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sa sys"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E sys)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 sys)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"case cava_sys_agn cfg sysi φ of
         None ⇒ sa.lang sys ⊆ language_ltlc φ 
         | Some None ⇒ ¬ sa.lang sys ⊆ language_ltlc φ
         | Some (Some L) ⇒ 
             graph_defs.is_run sys (run_of_lasso L) 
           ∧ sa_L sys ∘ (run_of_lasso L) ∉ language_ltlc φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cava_sys_agn.impl_model_check_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>φ</span><span> </span><span>cfg</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cava_sys_agn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lasso_run_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Model Checker for Boolean Programs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bpc_to_sa</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprog × BoolProgs.config ⇒ (BoolProgs.config,nat set) sa_rec"</span></span></span><span> 
</span><span>  </span><span class="comment">― ‹Conversion of a Boolean program to a system automata.›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bpc_to_sa bpc ≡ let (bp,c0)=bpc in
  ⦇
    g_V = UNIV,
    g_E = E_of_succ (set o BoolProgs.nexts bp),
    g_V0 = {c0},
    sa_L = λc. bs_α (snd c)
  ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bpc_to_sa_impl</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprog × BoolProgs.config 
  ⇒ (BoolProgs.config,nat ⇒ bool,unit) sa_impl_scheme"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bpc_to_sa_impl bpc ≡ let (bp,c0)=bpc in
  ⦇ gi_V = λ_. True,
    gi_E = remdups o BoolProgs.nexts bp,
    gi_V0 = [c0],
    sai_L = λc i. bs_mem i (snd c)
  ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bpc_to_sa_impl_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bpc_to_sa_impl bpc, bpc_to_sa bpc) 
  ∈ sa_impl_rel_ext unit_rel Id (⟨nat_rel⟩fun_set_rel)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bpc_to_sa_impl_def</span><span> </span><span>bpc_to_sa_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sa_impl_rel_eext_def</span><span> </span><span>g_impl_rel_ext_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_sa_impl_rel_eext_def</span><span> </span><span>gen_g_impl_rel_ext_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_set_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>E_of_succ_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_set_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_set_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_set_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>bpc_to_sa_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sa (bpc_to_sa bpc)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bpc_to_sa_fr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E (bpc_to_sa bpc))<span class="hidden">⇧</span><sup>*</sup> `` g_V0 (bpc_to_sa bpc))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bp</span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bpc = (bp,c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bpc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sa (bpc_to_sa bpc)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bpc_to_sa_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bpc_to_sa_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E (bpc_to_sa bpc))<span class="hidden">⇧</span><sup>*</sup> `` g_V0 (bpc_to_sa bpc))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bpc_to_sa_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>BoolProgs.reachable_configs_finite</span><span class="delimiter">[</span><span>of</span><span> </span><span>bp</span><span> </span><span>c</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtrancl_reachable_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BoolProgs.reachable_configs.intros</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>E_of_succ_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>bpc_to_sa</span><span class="delimiter">:</span><span> </span><span>sa</span><span> </span><span class="string"><span class="delete"><span class="delete">"bpc_to_sa bpc"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpc_to_sa_invar</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bpc_to_sa_run_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"graph_defs.is_run (bpc_to_sa bpc) = bpc_is_run bpc"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>graph_defs.is_run_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bpc_to_sa_def</span><span> </span><span>bpc_is_run_def</span><span> 
</span><span>    </span><span>ipath_def</span><span> </span><span>E_of_succ_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bpc_to_sa_L_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sa_L (bpc_to_sa bpc) = bpc_props"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bpc_to_sa_def</span><span> </span><span>bpc_props_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>E_of_succ_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bpc_to_sa_lang_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sa.lang (bpc_to_sa bpc) = bpc_lang bpc"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bpc_to_sa.lang_def</span><span> </span><span>bpc_to_sa.accept_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>bpc_lang_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cava_bpc cfg bpc φ ≡ cava_sys_agn cfg (bpc_to_sa_impl bpc) φ"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Correctness theorem for the model checker on boolean programs.
  Note that the semantics of Boolean programs is given 
  by @{const "bpc_lang"}.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cava_bpc_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"case cava_bpc cfg bpc φ of 
    None ⇒ bpc_lang bpc ⊆ language_ltlc φ
  | Some None ⇒ (¬(bpc_lang bpc ⊆ language_ltlc φ))
  | Some (Some ce) ⇒ 
      bpc_is_run bpc (run_of_lasso ce) 
    ∧ bpc_props o run_of_lasso ce ∉ language_ltlc φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cava_sys_agn_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bpc_to_sa_impl_refine</span><span> </span><span>bpc_to_sa_invar</span><span> </span><span>bpc_to_sa_fr</span><span class="delimiter">,</span><span> 
</span><span>    </span><span>of</span><span> </span><span>bpc</span><span> </span><span>φ</span><span> </span><span>cfg</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cava_bpc_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lasso_run_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>cava_bpc</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Model Checker for Promela Programs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>promela_to_sa</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"PromelaDatastructures.program × APs × gState ⇒ (gState, nat set) sa_rec"</span></span></span><span> 
</span><span>  </span><span class="comment">― ‹Conversion of a Promela model to a system automata.›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"promela_to_sa promg ≡ let (prog,APs,g<span class="hidden">⇩</span><sub>0</sub>)=promg in
  ⦇
    g_V = UNIV,
    g_E = E_of_succ (ls.α o Promela.nexts_code prog),
    g_V0 = {g<span class="hidden">⇩</span><sub>0</sub>},
    sa_L = promela_props_ltl APs
  ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>promela_to_sa_impl</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"PromelaDatastructures.program × APs × gState
  ⇒ (gState, nat ⇒ bool, unit) sa_impl_scheme"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"promela_to_sa_impl promg ≡ let (prog,APs,g<span class="hidden">⇩</span><sub>0</sub>)=promg in
  ⦇ gi_V = λ_. True,
    gi_E = ls.to_list o Promela.nexts_code prog,
    gi_V0 = [g<span class="hidden">⇩</span><sub>0</sub>],
    sai_L = propValid APs
  ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>promela_to_sa_impl_refine</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(promela_to_sa_impl promg, promela_to_sa promg) 
  ∈ sa_impl_rel_ext unit_rel Id (⟨nat_rel⟩fun_set_rel)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>promela_to_sa_impl_def</span><span> </span><span>promela_to_sa_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sa_impl_rel_eext_def</span><span> </span><span>g_impl_rel_ext_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_sa_impl_rel_eext_def</span><span> </span><span>gen_g_impl_rel_ext_def</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_set_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>E_of_succ_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_set_rel_def</span><span> </span><span>br_def</span><span> </span><span>ls.correct</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_set_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_set_rel_def</span><span> </span><span>br_def</span><span> </span><span>in_set_member</span><span> </span><span>promela_props_ltl_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cava_promela cfg ast φ ≡ 
  let 
      (promg,φ<span class="hidden">⇩</span><sub>i</sub>) = PromelaLTL.prepare cfg ast φ
  in
     cava_sys_agn (fst cfg) (promela_to_sa_impl promg) φ<span class="hidden">⇩</span><sub>i</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The next theorem states correctness of the Promela model checker.

  The correctness is specified for some AST.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cava_promela_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"case cava_promela cfg ast φ of 
    None ⇒ promela_language ast ⊆ language_ltlc φ
  | Some None ⇒ (¬(promela_language ast ⊆ language_ltlc φ))
  | Some (Some ce) ⇒ promela_is_run ast (run_of_lasso ce) 
    ∧ promela_props o run_of_lasso ce ∉ language_ltlc φ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>APs</span><span> </span><span>φ<span class="hidden">⇩</span><sub>i</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"PromelaLTL.ltl_convert φ = (APs,φ<span class="hidden">⇩</span><sub>i</sub>)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>prod.exhaust</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>prog</span><span> </span><span>g<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Promela.setUp ast = (prog,g<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>prod.exhaust</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?promg</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(prog,APs,g<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>promela_to_sa_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sa (promela_to_sa ?promg)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>promela_to_sa_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>promela_to_sa_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>promela_to_sa_fr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E (promela_to_sa ?promg))<span class="hidden">⇧</span><sup>*</sup> `` g_V0 (promela_to_sa ?promg))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>promela_to_sa_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> 
</span><span>      </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>Promela.reachable_states_finite</span><span class="delimiter">[</span><span>of</span><span> </span><span>prog</span><span> </span><span>g<span class="hidden">⇩</span><sub>0</sub></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtrancl_reachable_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Promela.reachable_states.intros</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>E_of_succ_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>setUp_program_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ast</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>setUp_gState_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ast</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>promela_to_sa</span><span class="delimiter">:</span><span> </span><span>sa</span><span> </span><span class="string"><span class="delete"><span class="delete">"promela_to_sa ?promg"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>promela_to_sa_invar</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>promela_to_sa_run_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"graph_defs.is_run (promela_to_sa ?promg) = promela_is_run_ltl ?promg"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>graph_defs.is_run_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>promela_to_sa_def</span><span> </span><span>promela_is_run_ltl_def</span><span> </span><span>promela_is_run'_def</span><span> </span><span>ipath_def</span><span> </span><span>E_of_succ_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>promela_to_sa_L_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"sa_L (promela_to_sa ?promg) = promela_props_ltl APs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>promela_to_sa_def</span><span> </span><span>promela_props_ltl_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>E_of_succ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>promela_to_sa_lang_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"sa.lang (promela_to_sa ?promg) = promela_language_ltl ?promg"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>promela_to_sa.lang_def</span><span> </span><span>promela_to_sa.accept_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span>promela_language_ltl_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cava_sys_agn_correct</span><span class="delimiter">[</span><span>OF</span><span> 
</span><span>      </span><span>promela_to_sa_impl_refine</span><span> </span><span>promela_to_sa_invar</span><span> </span><span>promela_to_sa_fr</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>φ<span class="hidden">⇩</span><sub>i</sub></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst cfg"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>promela_language_sub_iff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>conv</span><span> </span><span>ast</span><span class="delimiter">]</span><span> </span><span>promela_run_in_language_iff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>conv</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cava_promela_def</span><span> </span><span>PromelaLTL.prepare_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>prod.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lasso_run_rel_def</span><span> </span><span>br_def</span><span> </span><span>conv</span><span> </span><span>ast</span><span> </span><span>promela_is_run_ltl_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>cava_promela</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Model Checker for SM›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>test_aprop_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"exp ⇒ valuation_impl ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"test_aprop_impl e s ≡ case eval_exp_impl e (⦇ local_state_impl.variables = vi_empty ⦈,
    ⦇ global_state_impl.variables = s ⦈) of None ⇒ False | Some v ⇒ bool_of_val_impl v"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sm_to_sa</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"program ⇒ (ident ⇒ bool) ⇒ (pid_global_config_impl,exp set) sa_rec"</span></span></span><span> 
</span><span>  </span><span class="comment">― ‹Conversion of a Boolean program to a system automata.›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sm_to_sa prog is_vis_var ≡ let
    cinf = comp_info_of prog
  in
    ⦇
      g_V = UNIV,
      g_E = E_of_succ (set o impl4_succ_impl prog cinf is_vis_var),
      g_V0 = {pid_init_gc_impl_impl prog cinf},
      sa_L = λv. {e. test_aprop_impl e (global_state_impl.variables (pid_global_config.state v))}
    ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_state_rel</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s', s) ∈ vi_rel"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⦇ local_state_impl.variables = s' ⦈, ⦇ local_state.variables = s ⦈) ∈ local_state_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>vi_rel_rew</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>local_state_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>global_state_rel</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s', s) ∈ vi_rel"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⦇ global_state_impl.variables = s' ⦈, ⦇ global_state.variables = s ⦈) ∈ global_state_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>vi_rel_rew</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>global_state_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_aprop_impl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(test_aprop_impl, test_aprop) ∈ Id → vi_rel → bool_rel"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>s'</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(vi_empty, Map.empty) ∈ (vi_rel :: (valuation_impl × valuation) set)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vi_rel_rew</span><span> </span><span>vi_empty_correct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s', s) ∈ (vi_rel :: (valuation_impl × valuation) set)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(test_aprop_impl e s', test_aprop e s) ∈ bool_rel"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>test_aprop_def</span><span> </span><span>test_aprop_impl_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>parametricity</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eval_exp_impl</span><span> </span><span>bool_of_val_impl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>IdI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>local_state_rel</span><span> </span><span>0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>global_state_rel</span><span> </span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test_aprop_impl e s' ⟷ test_aprop e s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>restrict_parametric</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bi_unique A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((A ===&gt; rel_option B) ===&gt; rel_set A ===&gt; (A ===&gt; rel_option B)) (|`) (|`)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>assms</span><span> </span><span>bi_uniqueDl</span><span> </span><span>bi_uniqueDr</span><span> </span><span>option.rel_intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span>rel_funD</span><span> </span><span>rel_setD1</span><span> </span><span>rel_setD2</span><span> </span><span>restrict_map_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>restrict</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) mapping ⇒ 'a set ⇒ ('a, 'b) mapping"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(|`)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">parametric</span></span><span> </span><span>restrict_parametric</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>vi_restrict</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"valuation_impl ⇒ ident set ⇒ valuation_impl"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(|`) :: valuation ⇒ ident set ⇒ valuation"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>this</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vi_restrict = restrict"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vi_restrict_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vi_α (vi_restrict s A) = vi_α s |` A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vi_α_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Fun.comp_def</span><span> </span><span>option.map_ident</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>pid_test_gc_impl</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pid_global_config_impl ⇒ exp ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pid_test_gc_impl gci ap ≡ test_aprop_impl ap
    ((global_state_impl.variables (pid_global_config.state gci)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sm_to_sa_impl</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"program ⇒ (ident ⇒ bool) 
  ⇒ (pid_global_config_impl,exp ⇒ bool,unit) sa_impl_scheme"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sm_to_sa_impl prog is_vis_var ≡ let
    cinf = comp_info_of prog
  in  
    ⦇ gi_V = λ_. True,
      gi_E = remdups o impl4_succ_impl prog cinf is_vis_var, ― ‹TODO: This remdups is unnecessary!›
      gi_V0 = [pid_init_gc_impl_impl prog cinf],
      sai_L = pid_test_gc_impl  
    ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sm_to_sa_impl_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(sm_to_sa_impl prog is_vis_var, sm_to_sa prog is_vis_var) 
  ∈ sa_impl_rel_ext unit_rel Id (⟨Id⟩fun_set_rel)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sm_to_sa_impl_def</span><span> </span><span>sm_to_sa_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sa_impl_rel_eext_def</span><span> </span><span>g_impl_rel_ext_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_sa_impl_rel_eext_def</span><span> </span><span>gen_g_impl_rel_ext_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_set_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>E_of_succ_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_set_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_set_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_set_rel_def</span><span> </span><span>br_def</span><span> </span><span>pid_test_gc_impl_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>E_of_succ_is_rel_of_succ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E_of_succ = rel_of_succ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>E_of_succ_def</span><span> </span><span>rel_of_succ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vi_γ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"valuation ⇒ valuation_impl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vi_γ v = (Mapping.Mapping (map_option Abs_uint32 ∘ v))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vi_α (vi_γ v) = v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vi_α_def</span><span> </span><span>vi_γ_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Mapping_inverse</span><span> </span><span>option.map_comp</span><span> </span><span>option.map_ident</span><span> </span><span>Abs_uint32_inverse</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vi_γ (vi_α v) = v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vi_α_def</span><span> </span><span>vi_γ_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Mapping.rep_inverse</span><span> </span><span>option.map_comp</span><span> </span><span>option.map_ident</span><span> </span><span>Rep_uint32_inverse</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lsi_α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_state_impl ⇒ local_state"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lsi_α lsi ≡ ⦇ local_state.variables = vi_α (local_state_impl.variables lsi) ⦈"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lsi_γ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_state ⇒ local_state_impl"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lsi_γ lsi ≡ ⦇ local_state_impl.variables = vi_γ (local_state.variables lsi) ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lsi_α (lsi_γ ls) = ls"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lsi_γ (lsi_α lsi) = lsi"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lsi_α_def</span><span> </span><span>lsi_γ_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_state_rel_as_br</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_state_rel = br lsi_α (λ_. True)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>local_state_rel_def</span><span> </span><span>br_def</span><span> </span><span>lsi_α_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gsi_α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"global_state_impl ⇒ global_state"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gsi_α gsi ≡ ⦇ global_state.variables = vi_α (global_state_impl.variables gsi) ⦈"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gsi_γ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"global_state ⇒ global_state_impl"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gsi_γ gs ≡ ⦇ global_state_impl.variables = vi_γ (global_state.variables gs) ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gsi_α (gsi_γ gs) = gs"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gsi_γ (gsi_α gsi) = gsi"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gsi_α_def</span><span> </span><span>gsi_γ_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>global_state_rel_as_br</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"global_state_rel = br gsi_α (λ_. True)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>global_state_rel_def</span><span> </span><span>br_def</span><span> </span><span>gsi_α_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>map_local_config</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a⇒'c) ⇒ ('b⇒'d) ⇒ ('a,'b) Gen_Scheduler.local_config ⇒ ('c,'d) Gen_Scheduler.local_config"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_local_config mc ms ls ≡ ⦇ 
    local_config.command = mc (local_config.command ls),
    local_config.state = ms (local_config.state ls)
    ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_local_config (λx. x) (λx. x) = (λx. x)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_local_config f g (map_local_config f' g' lc) = map_local_config (f o f') (g o g') lc"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_local_config_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>map_pid_global_config</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a⇒'d) ⇒ ('b⇒'e) ⇒ ('c⇒'f) ⇒ ('a,'b,'c) Pid_Scheduler.pid_global_config ⇒ ('d,'e,'f) Pid_Scheduler.pid_global_config"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_pid_global_config mp ml mg gc ≡ ⦇ 
    pid_global_config.processes = map (map_local_config mp ml) (pid_global_config.processes gc),
    pid_global_config.state = mg (pid_global_config.state gc)
    ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_pid_global_config (λx. x) (λx. x) (λx. x) = (λx. x)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_pid_global_config f g h (map_pid_global_config f' g' h' gc) 
  = map_pid_global_config (f o f') (g o g') (h o h') gc"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_pid_global_config_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>lci_α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_config_impl ⇒ local_config"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lci_α ≡ map_local_config (λx. x) lsi_α"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>lci_γ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_config ⇒ local_config_impl"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lci_γ ≡ map_local_config (λx. x) lsi_γ"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>gci_α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pid_global_config_impl ⇒ pid_global_config"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gci_α ≡ map_pid_global_config (λx. x) lsi_α gsi_α"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>gci_γ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pid_global_config ⇒ pid_global_config_impl"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gci_γ ≡ map_pid_global_config (λx. x) lsi_γ gsi_γ"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_config_rel_as_br</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_config_rel = br lci_α (λ_. True)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>local_config_rel_def</span><span> </span><span>br_def</span><span> </span><span>map_local_config_def</span><span> </span><span>local_state_rel_as_br</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>list_all2_induct</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_all2_map_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_all2 (λx y. x=f y) xs ys ⟷ xs = map f ys"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_all2 (λx y. y=f x) ys xs ⟷ xs = map f ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_all2_induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>ys</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_all2_induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>ys</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pid_global_config_rel_as_br</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"global_config_rel = br gci_α (λ_. True)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> 
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>global_config_rel_def</span><span> </span><span>br_def</span><span> </span><span>map_pid_global_config_def</span><span> 
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>global_state_rel_as_br</span><span> </span><span>local_config_rel_as_br</span><span>
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>global_config_rel_inv_sv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"single_valued (global_config_rel¯)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>single_valuedI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pid_global_config_rel_as_br</span><span> </span><span>br_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gci_α x = gci_α y"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gci_γ (gci_α x) = gci_γ (gci_α y)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x=y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pred_of_enex_mono</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"en c ⊆ en' c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred_of_enex (en,ex) c c'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred_of_enex (en',ex) c c'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_ample_reachable</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ty_program prog"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite
     ((E_of_succ ((set ∘∘ impl4_succ_impl prog (comp_info_of prog)) is_vis_var))<span class="hidden">⇧</span><sup>*</sup> ``
      {pid_init_gc_impl_impl prog (comp_info_of prog)})"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ?S"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>visible_prog</span><span> </span><span>prog</span><span> </span><span>is_vis_var</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E_of_succ ((set ∘∘ impl4_succ_impl prog (comp_info_of prog)) is_vis_var) 
    = ample_step_impl4 is_vis_var"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> 
</span><span>          </span><span>add</span><span class="delimiter">:</span><span> </span><span>impl4_succ_pred</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>E_of_succ_is_rel_of_succ</span><span>
</span><span>          </span><span>add</span><span class="delimiter">:</span><span> </span><span>impl4_succ_impl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ample_step_impl4</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E_of_succ ((set ∘∘ impl4_succ_impl prog (comp_info_of prog)) is_vis_var) 
    = ample_step_impl3"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>S_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?S = ample_step_impl3<span class="hidden">⇧</span><sup>*</sup> `` {pid_init_gc_impl}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pid_init_gc_impl_impl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move as sublocale to SM_Ample_Impl in visible_prog-context,
    before interpretation as impl3_sim.b ! *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>impl2</span><span class="delimiter">:</span><span> </span><span>sa</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦇ g_V = UNIV, g_E = ample_step_impl2,
    g_V0 = {pid_init_gc}, sa_L = pid_interp_gc ⦈"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Duplicated from prf of cr_ample_impl2_reduction *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ample_step_impl2 = rel_of_enex (cr_ample_impl1, ga_ex)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ample_step_impl2_def</span><span> </span><span>cr_ample_impl1_def</span><span> </span><span>cr_ample_impl2_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ga_gample_mi2_impl</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>gc</span><span> </span><span class="delimiter">::</span><span> </span><span>pid_global_config</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cr_ample ≤ SPEC (λr. r gc ⊆ ga_en gc)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cr_ample_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>find_fas_init_correct</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sticky_E</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ga_ample sticky_E gc ⊆ ga_en gc"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ga_ample sticky_E gc = ga_en gc"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>ga_ample_neq_en_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span>sticky_E</span><span> </span><span>gc</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ga_gample_subset</span><span class="delimiter">[</span><span>of</span><span> </span><span>sticky_E</span><span> </span><span>gc</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cr_ample_impl1.refine</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cr_ample_impl1 gc ⊆ ga_en gc"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>aux1</span><span class="delimiter">=</span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>simulation</span><span> </span><span>Id</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⦇ g_V = UNIV, g_E = rel_of_enex (cr_ample_impl1,ga_ex), g_V0 = {pid_init_gc} ⦈"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⦇ g_V = UNIV, g_E = ga_step, g_V0 = {pid_init_gc} ⦈"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ga_step_alt</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pred_of_enex_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>cr_ample_impl1</span><span> </span><span>_</span><span> </span><span>ga_en</span><span> </span><span>ga_ex</span><span class="delimiter">,</span><span>OF</span><span> </span><span>aux1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FIN2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (ample_step_impl2<span class="hidden">⇧</span><sup>*</sup> `` {pid_init_gc})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>graph_rec.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reachable_finite_sim</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>graph_rec.simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>jsys.reachable_finite</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable_alt</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>    
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ?S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>impl3_sim.s1.reachable_finite_sim</span><span> </span><span>FIN2</span><span> </span><span>finite_Image_sv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>global_config_rel_inv_sv</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ty_program prog"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>sm_to_sa_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sa (sm_to_sa prog is_vis_var)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm_to_sa_fr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E (sm_to_sa prog is_vis_var))<span class="hidden">⇧</span><sup>*</sup> `` g_V0 (sm_to_sa prog is_vis_var))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sm_to_sa_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mapping_val_hashcode m ≡ ∑((hashcode o Mapping.lookup m)`Mapping.keys m)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>local_config_ext</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>hashable</span><span class="delimiter">,</span><span>hashable</span><span class="delimiter">,</span><span>hashable</span><span class="delimiter">)</span><span>hashable</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hashcode lc ≡ 
      hashcode (local_config.command lc) 
    + hashcode (local_config.state lc)
    + hashcode (local_config.more lc)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"def_hashmap_size (T::('a,'b,'c) local_config_ext itself) ≡ 8"</span></span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>intro_classes</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>def_hashmap_size_local_config_ext_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>Pid_Scheduler.pid_global_config_ext</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>hashable</span><span class="delimiter">,</span><span>hashable</span><span class="delimiter">,</span><span>hashable</span><span class="delimiter">,</span><span>hashable</span><span class="delimiter">)</span><span> </span><span>hashable</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hashcode gc ≡ 
      hashcode (pid_global_config.processes gc)
    + hashcode (pid_global_config.state gc)
    + hashcode (pid_global_config.more gc)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"def_hashmap_size (T::('a,'b,'c,'d) pid_global_config_ext itself) ≡ 8"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>intro_classes</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>def_hashmap_size_pid_global_config_ext_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>local_state_impl_ext</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>hashable</span><span class="delimiter">)</span><span>hashable</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rm.iterate r (λ(k,v) s. hashcode k + hashcode v + s) 0"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Derive sensible hashcode! *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hashcode ls 
    ≡ mapping_val_hashcode (local_state_impl.variables ls) 
     + hashcode (local_state_impl.more ls)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"def_hashmap_size (T::('a) local_state_impl_ext itself) ≡ 8"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>intro_classes</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>def_hashmap_size_local_state_impl_ext_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>global_state_impl_ext</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>hashable</span><span class="delimiter">)</span><span>hashable</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rm.iterate r (λ(k,v) s. hashcode k + hashcode v + s) 0"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Derive sensible hashcode! *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hashcode gs 
    ≡ mapping_val_hashcode (global_state_impl.variables gs)
    + hashcode (global_state_impl.more gs)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"def_hashmap_size (T::('a) global_state_impl_ext itself) ≡ 8"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>intro_classes</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>def_hashmap_size_global_state_impl_ext_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move. TODO: Can we generate a more efficient comparator. 
  Perhaps using code_printing? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">local_setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Comparator_Generator.register_foreign_comparator @{typ String.literal}
    @{term "comparator_of :: String.literal ⇒ _"}
    @{thm comparator_of[where 'a=String.literal]}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>linorder</span><span> </span><span>un_op</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>linorder</span><span> </span><span>bin_op</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>linorder</span><span> </span><span>exp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>sm_result</span><span> </span><span class="delimiter">=</span><span> </span><span>TY_ERR</span><span> </span><span class="delimiter">|</span><span> </span><span>SAT</span><span> </span><span class="delimiter">|</span><span> </span><span>UNSAT</span><span> </span><span class="delimiter">|</span><span> </span><span>UNSAT_CE</span><span> </span><span class="string"><span class="delete"><span class="delete">"pid_global_config_impl lasso"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cava_sm cfg prog φ ≡ 
  let prog = dloc prog in (
  if ty_program prog ∧ ltlc_next_free φ then
    case cava_sys_agn cfg (sm_to_sa_impl prog (λx. x∈vars_of_ltlc φ)) φ of
      None ⇒ SAT
    | Some None ⇒ UNSAT
    | Some (Some ce) ⇒ UNSAT_CE ce
  else TY_ERR)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Relation that relates states of computed counterexample with
  states of actual run in reference point semantics. Unfortunately,
  we cannot exactly recompute the reference point run b/c we cannot undo
  the effect of the locality decider. ›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sm_gc_rel prog ≡ {(gci, gc). map_option dloc_gc gc = Some (cprog.gc_α prog (pidgc_α (gci_α gci)))}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sm_props_of_gc gc ≡ sm_props (global_state.variables (global_config.state (the gc)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lang_eq_on_ss_ltlc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>interp</span><span> </span><span>interp'</span><span> </span><span>P</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L ≡ {w. ∃r. P r ∧ w = interp o r }"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L' ≡ {w. ∃r. P r ∧ w = interp' o r }"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀r. P r ⟹ pw_eq_on (atoms_ltlc φ) (interp o r) (interp' o r)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L ⊆ language_ltlc φ ⟷ L' ⊆ language_ltlc φ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀r. P r ⟹ pw_eq_on (atoms_ltlc φ) (interp' o r) (interp o r)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pw_eq_on_sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_def</span><span> </span><span>L'_def</span><span> </span><span>language_ltlc_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ltlc_eq_on</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>ltlc_eq_on</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>ltlc_eq_on</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness theorem for the model checker on SM programs.›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: variables occurring in the formula but not as global variables in the
  program should also be a type error *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cava_sm_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"case cava_sm config prog φ of 
    TY_ERR ⇒ ¬ty_program (dloc prog) ∨ ¬ltlc_next_free φ
  | SAT ⇒ Collect (ap_accept prog) ⊆ language_ltlc φ
  | UNSAT ⇒ (¬(Collect (ap_accept prog) ⊆ language_ltlc φ))
  | UNSAT_CE ce ⇒ ¬(Collect (ap_accept prog) ⊆ language_ltlc φ) 
    ∧ (∃r. (run_of_lasso ce, r) ∈ run_rel (sm_gc_rel (dloc prog)) ∧ ref_is_run prog r
        ∧ sm_props_of_gc o r ∉ language_ltlc φ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cava_sm_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?is_vis_var</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx. x ∈ vars_of_ltlc φ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?csa</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"cava_sys_agn config (sm_to_sa_impl (dloc prog) ?is_vis_var) φ"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>TY</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty_program (dloc prog)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>visible_prog</span><span> </span><span class="string"><span class="delete"><span class="delete">"(dloc prog)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx. x∈vars_of_ltlc φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>sm_to_sa</span><span class="delimiter">:</span><span> </span><span>sa</span><span> </span><span class="string"><span class="delete"><span class="delete">"(sm_to_sa (dloc prog) ?is_vis_var)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sm_to_sa_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>TY</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>NF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ltlc_next_free φ"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>csa_correct</span><span> </span><span class="delimiter">=</span><span> </span><span>cava_sys_agn_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sm_to_sa_impl_refine</span><span> </span><span>sm_to_sa_invar</span><span> </span><span>sm_to_sa_fr</span><span class="delimiter">,</span><span>
</span><span>      </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(dloc prog)"</span></span></span><span> </span><span class="var">?is_vis_var</span><span> </span><span>φ</span><span> </span><span>config</span><span class="delimiter">]</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>aprop_impl_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀e v. test_aprop_impl e v = test_aprop e (vi_α v)"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>IdD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>parametricity</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>test_aprop_impl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>br_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lang_ss_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sa.lang (sm_to_sa (dloc prog) ?is_vis_var) ⊆ language_ltlc φ
    ⟷ Collect (ample_impl.accept ?is_vis_var) ⊆ language_ltlc φ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sm_to_sa.lang_def</span><span> </span><span>sm_to_sa.accept_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>graph_defs.is_run_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sm_to_sa_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ample_impl.accept_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>graph_defs.is_run_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>impl4_succ_impl</span><span> </span><span>ample_step_impl4_impl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>impl4_succ_pred</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>E_of_succ_is_rel_of_succ</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_commute</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"pid_init_gc_impl_impl (dloc prog) (comp_info_of (dloc prog))"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conj_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Hack *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lang_eq_on_ss_ltlc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_eq_on_def</span><span> </span><span>pid_interp_gc_impl_def</span><span> </span><span>aprop_impl_conv</span><span> </span><span>sm_props_def</span><span> </span><span>test_aprop_vars_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>w</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>N</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?csa=None"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_accept prog w"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>dloc_sim.accept_bisim</span><span class="delimiter">[</span><span>of</span><span> </span><span>prog</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ACC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_accept (dloc prog) w"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_accept_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>csa_correct</span><span> </span><span>N</span><span> </span><span>TY</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sa.lang (sm_to_sa (dloc prog) ?is_vis_var) ⊆ language_ltlc φ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Collect (ample_impl.accept ?is_vis_var) ⊆ language_ltlc φ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lang_ss_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ample_reduction_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>TY</span><span> </span><span>NF</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Collect (ap_accept (dloc prog)) ⊆ language_ltlc φ"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w∈language_ltlc φ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ACC</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>w</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>N</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?csa=Some None"</span></span></span><span> 
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>csa_correct</span><span> </span><span>N</span><span> </span><span>TY</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬sa.lang (sm_to_sa (dloc prog) ?is_vis_var) ⊆ language_ltlc φ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬Collect (ample_impl.accept ?is_vis_var) ⊆ language_ltlc φ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lang_ss_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ample_reduction_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>TY</span><span> </span><span>NF</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬Collect (ap_accept (dloc prog)) ⊆ language_ltlc φ"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Collect (ap_accept prog) ⊆ language_ltlc φ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Collect (ap_accept (dloc prog)) ⊆ language_ltlc φ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dloc_sim.accept_bisim</span><span class="delimiter">[</span><span>of</span><span> </span><span>prog</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_accept_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>w</span><span> </span><span>ce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>N</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?csa=Some (Some ce)"</span></span></span><span> 
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>csa_correct</span><span> </span><span>N</span><span> </span><span>TY</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>R</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"graph_defs.is_run (sm_to_sa (dloc prog) (λx. x ∈ vars_of_ltlc φ)) (run_of_lasso ce)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NL</span><span class="delimiter">:</span><span>  
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(sa_L (sm_to_sa (dloc prog) (λx. x ∈ vars_of_ltlc φ)) ∘ (run_of_lasso ce)) 
        ∉ language_ltlc φ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>R</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_defs.is_run ⦇ g_V = UNIV, g_E = ample_step_impl4_impl (dloc prog)
      (comp_info_of (dloc prog)) ?is_vis_var, g_V0 = {pid_init_gc_impl_impl (dloc prog)
      (comp_info_of (dloc prog))}, sa_L = pid_interp_gc_impl ?is_vis_var ⦈ (run_of_lasso ce)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>graph_defs.is_run_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ipath_def</span><span> </span><span>impl4_succ_pred</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span>sm_to_sa_def</span><span> </span><span>E_of_succ_def</span><span>  </span><span>pid_init_gc_impl_impl</span><span> </span><span>ample_step_impl4_impl</span><span> </span><span>impl4_succ_impl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ample_step_impl4</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>R3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_defs.is_run ⦇ g_V = UNIV,
      g_E = visible_prog.ample_step_impl3 (dloc prog) (λ x. x ∈ vars_of_ltlc φ),
      g_V0 = {cprog.pid_init_gc_impl (dloc prog)},
      sa_L = pid_interp_gc_impl (λ x. x ∈ vars_of_ltlc φ) ⦈ (run_of_lasso ce)"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pid_init_gc_impl_impl</span><span> </span><span>ample_step_impl4_impl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>impl3_sim.br_run_conv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>pid_global_config_rel_as_br</span><span class="delimiter">]</span><span> </span><span>R3</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>R2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_defs.is_run ⦇ g_V = UNIV, g_E = visible_prog.ample_step_impl2 (dloc prog)
      (λ x. x ∈ vars_of_ltlc φ), g_V0 = {cprog.pid_init_gc (dloc prog)},
      sa_L = visible_prog.pid_interp_gc (λ x. x ∈ vars_of_ltlc φ) ⦈ (gci_α o run_of_lasso ce)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: The whole next 100 lines duplicated from finiteness proof *)</span></span></span></span></span><span>  
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Duplicated from prf of cr_ample_impl2_reduction *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ample_step_impl2 = rel_of_enex (cr_ample_impl1, ga_ex)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ample_step_impl2_def</span><span> </span><span>cr_ample_impl1_def</span><span> </span><span>cr_ample_impl2_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ga_gample_mi2_impl</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>gc</span><span> </span><span class="delimiter">::</span><span> </span><span>pid_global_config</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cr_ample ≤ SPEC (λr. r gc ⊆ ga_en gc)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cr_ample_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>find_fas_init_correct</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sticky_E</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ga_ample sticky_E gc ⊆ ga_en gc"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ga_ample sticky_E gc = ga_en gc"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>ga_ample_neq_en_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span>sticky_E</span><span> </span><span>gc</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ga_gample_subset</span><span class="delimiter">[</span><span>of</span><span> </span><span>sticky_E</span><span> </span><span>gc</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cr_ample_impl1.refine</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cr_ample_impl1 gc ⊆ ga_en gc"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>aux1</span><span class="delimiter">=</span><span>this</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>simulation</span><span> </span><span>Id</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"⦇ g_V = UNIV, g_E = ample_step_impl2, g_V0 = {pid_init_gc} ⦈"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"⦇ g_V = UNIV, g_E = ga_step, g_V0 = {pid_init_gc} ⦈"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ga_step_alt</span><span> </span><span>1</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pred_of_enex_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>cr_ample_impl1</span><span> </span><span>_</span><span> </span><span>ga_en</span><span> </span><span>ga_ex</span><span class="delimiter">,</span><span>OF</span><span> </span><span>aux1</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>run_rel_eq_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ a b. (a, b) ∈ run_rel Id ⟷ a = b"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>run_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_defs.is_run ⦇ g_V = UNIV, g_E = ample_step_impl2,
      g_V0 = {pid_init_gc} ⦈ (gci_α o run_of_lasso ce)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>graph_defs.is_run_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_defs.is_run (Pid_Gen_Scheduler_linit.ga_automaton (sl_graph.astep_impl
      (approx_reachable_list (dloc prog)) cfg'_succ_list) la_en' la_ex'
      (cprog.pid_init_gc (dloc prog)) (visible_prog.pid_interp_gc (λ x. x ∈ vars_of_ltlc φ)))
      (gci_α o run_of_lasso ce)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ga_automaton_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>run_sim</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ga_automaton_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>graph_defs.is_run_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ga_run_sim'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ref_is_run (dloc prog) (Some ∘ gc_α ∘ pidgc_α ∘ gci_α o (run_of_lasso ce))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dloc_sim.br_run_conv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>RUN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ref_is_run prog r"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>RR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(run_of_lasso ce, r) ∈ run_rel (sm_gc_rel (dloc prog))"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NL'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pid_interp_gc_impl ?is_vis_var ∘ (run_of_lasso ce) ∉ language_ltlc φ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>run_rel_def</span><span> </span><span>sm_gc_rel_def</span><span> </span><span>fun_eq_iff</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>map_option_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀r. a r ⟹ b r ⟹ c r ⟹ thesis"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>        
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NL</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>language_ltlc_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>ltlc_eq_on</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_eq_on_def</span><span> </span><span>sm_to_sa_def</span><span> </span><span>pid_interp_gc_impl_def</span><span> 
</span><span>        </span><span>aprop_impl_conv</span><span> </span><span>sm_props_def</span><span> </span><span>test_aprop_vars_cong</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pw_eq_on (atoms_ltlc φ) 
      (sm_props_of_gc o r) (pid_interp_gc_impl ?is_vis_var o run_of_lasso ce)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>RR</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_eq_on_def</span><span> </span><span>run_rel_def</span><span> </span><span>sm_gc_rel_def</span><span> </span><span>sm_props_of_gc_def</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pid_interp_gc_impl_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>i</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sm_props_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>z</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dloc_gc_def</span><span> </span><span>gc_α_def</span><span> </span><span>pidgc_α_def</span><span> </span><span>map_pid_global_config_def</span><span> </span><span>gsi_α_def</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>test_aprop_vars_cong</span><span>
</span><span>        </span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>i</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>z</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dloc_gc_def</span><span> </span><span>gc_α_def</span><span> </span><span>pidgc_α_def</span><span> </span><span>map_pid_global_config_def</span><span> </span><span>gsi_α_def</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>test_aprop_vars_cong</span><span>
</span><span>        </span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NL'</span><span> </span><span>ltlc_eq_on</span><span class="delimiter">[</span><span>of</span><span> </span><span>φ</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sm_props_of_gc ∘ r ∉ language_ltlc φ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>language_ltlc_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>RUN</span><span> </span><span>RR</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃r. (run_of_lasso ce, r) ∈ run_rel (sm_gc_rel (dloc prog)) ∧
               ref_is_run prog r ∧
               sm_props_of_gc ∘ r ∉ language_ltlc φ"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>R</span><span> </span><span>NL</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬sa.lang (sm_to_sa (dloc prog) ?is_vis_var) ⊆ language_ltlc φ"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sm_to_sa.lang_def</span><span> </span><span>sm_to_sa.accept_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>csa_correct</span><span> </span><span>N</span><span> </span><span>TY</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬sa.lang (sm_to_sa (dloc prog) ?is_vis_var) ⊆ language_ltlc φ"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sm_to_sa.lang_def</span><span> </span><span>sm_to_sa.accept_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬Collect (ample_impl.accept ?is_vis_var) ⊆ language_ltlc φ"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lang_ss_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ample_reduction_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>TY</span><span> </span><span>NF</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬Collect (ap_accept (dloc prog)) ⊆ language_ltlc φ"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Collect (ap_accept prog) ⊆ language_ltlc φ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Collect (ap_accept (dloc prog)) ⊆ language_ltlc φ"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dloc_sim.accept_bisim</span><span class="delimiter">[</span><span>of</span><span> </span><span>prog</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_accept_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>cava_sm</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Extraction of SML Code›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dflt_cfg ≡ (CFG_L2B_GERTHS,(),CFG_CE_SCC_GABOW)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Cava MC *)</span></span></span></span></span><span>
</span><span>            </span><span>cava_bpc</span><span> </span><span>cava_promela</span><span> </span><span>dflt_cfg</span><span> </span><span>CAVA_Impl.CFG_CE_NDFS</span><span>
</span><span>            
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* BP *)</span></span></span></span></span><span>
</span><span>            </span><span>BoolProgs.print_config</span><span> </span><span>chose_prog</span><span> </span><span>list_progs</span><span>
</span><span>            </span><span>BoolProgs_LTL_Conv.ltl_conv</span><span> </span><span>BoolProgs_LTL_Conv.CProp</span><span> 
</span><span>            </span><span>BoolProgs_Programs.default_prog</span><span> 
</span><span>            </span><span>BoolProgs_Programs.keys_of_map</span><span>
</span><span>            </span><span>BoolProgs_Programs.default_prog</span><span> </span><span>BoolProgs_Programs.keys_of_map</span><span>
</span><span>            
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Promela *)</span></span></span></span></span><span>
</span><span>            </span><span>printProcesses</span><span> </span><span>Promela.printConfigFromAST</span><span> </span><span>lookupLTL</span><span>
</span><span>            </span><span>PromelaLTLConv.ltl_conv</span><span>
</span><span>
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* stat printing *)</span></span></span></span></span><span>
</span><span>            </span><span>frv_export_code</span><span> </span><span>LTL_to_GBA_impl.create_name_gba_code</span><span>
</span><span>
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Lasso *)</span></span></span></span></span><span>
</span><span>            </span><span>lasso_v0</span><span> </span><span>lasso_va</span><span> </span><span>lasso_reach</span><span> </span><span>lasso_cycle</span><span>
</span><span>            
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Arith *)</span></span></span></span></span><span>
</span><span>            </span><span>nat_of_integer</span><span> </span><span>int_of_integer</span><span>
</span><span>            </span><span>integer_of_nat</span><span> </span><span>integer_of_int</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">code_identifier</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">code_module</span></span><span> </span><span>String</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span>HOLString</span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">code_module</span></span><span> </span><span>Code_Target_Int</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span>Code_Target_Int</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Cava MC *)</span></span></span></span></span><span>
</span><span>            </span><span>cava_bpc</span><span> </span><span>cava_promela</span><span> </span><span>dflt_cfg</span><span> </span><span>CAVA_Impl.CFG_CE_NDFS</span><span>
</span><span>            
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* BP *)</span></span></span></span></span><span>
</span><span>            </span><span>BoolProgs.print_config</span><span> </span><span>chose_prog</span><span> </span><span>list_progs</span><span>
</span><span>            </span><span>BoolProgs_LTL_Conv.ltl_conv</span><span> </span><span>BoolProgs_LTL_Conv.CProp</span><span> 
</span><span>            </span><span>BoolProgs_Programs.default_prog</span><span> 
</span><span>            </span><span>BoolProgs_Programs.keys_of_map</span><span>
</span><span>            </span><span>BoolProgs_Programs.default_prog</span><span> </span><span>BoolProgs_Programs.keys_of_map</span><span>
</span><span>            
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Promela *)</span></span></span></span></span><span>
</span><span>            </span><span>printProcesses</span><span> </span><span>Promela.printConfigFromAST</span><span> </span><span>lookupLTL</span><span>
</span><span>            </span><span>PromelaLTLConv.ltl_conv</span><span> </span><span>PromelaLTLConv.CProp</span><span> </span><span>PromelaLTLConv.Eq</span><span> </span><span>PromelaLTLConv.Ident</span><span>
</span><span>
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* stat printing *)</span></span></span></span></span><span>
</span><span>            </span><span>frv_export_code</span><span> </span><span>LTL_to_GBA_impl.create_name_gba_code</span><span>
</span><span>
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Lasso *)</span></span></span></span></span><span>
</span><span>            </span><span>lasso_v0</span><span> </span><span>lasso_va</span><span> </span><span>lasso_reach</span><span> </span><span>lasso_cycle</span><span>
</span><span>            
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Arith *)</span></span></span></span></span><span>
</span><span>            </span><span>nat_of_integer</span><span> </span><span>int_of_integer</span><span>
</span><span>            </span><span>integer_of_nat</span><span> </span><span>integer_of_int</span><span>
</span><span>
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* String *)</span></span></span></span></span><span>
</span><span>            </span><span>String.explode</span><span> </span><span>String.implode</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹code/CAVA_Export.sml›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Mulog">
<div class="head"><h1>Theory Mulog</h1>
<span class="command">theory</span> <span class="name">Mulog</span><br/>
<span class="keyword">imports</span> <a href="CAVA_Impl.html"><span class="name">CAVA_Impl</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Mulog</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../CAVA_Impl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>join</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a ⇒ 'a list"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"join [] a = []"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"join (x # xs) a = x # a # join xs a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>join'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a ⇒ 'a list"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"join' (x # y # xs) a = x # a # join' (y # xs) a"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"join' xs a = xs"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>nat_to_string</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ String.literal"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"nat_to_string 0 = STR ''0''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"nat_to_string (Suc 0) = STR ''1''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"nat_to_string (Suc (Suc 0)) = STR ''2''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"nat_to_string (Suc (Suc (Suc 0))) = STR ''3''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"nat_to_string (Suc (Suc (Suc (Suc n)))) = STR ''many''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>int_to_string</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"int ⇒ String.literal"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"int_to_string i ≡ if i &lt; 0
      then STR ''-'' + nat_to_string (nat (- i))
      else nat_to_string (nat i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>literal_concat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"String.literal list ⇒ String.literal"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"literal_concat xs ≡ foldr (+) xs 0"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_assignments</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"valuation_impl ⇒ String.literal list"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_assignments v ≡ map
      (λ k. k + STR '' = '' + nat_to_string (nat_of_uint32 (the (Mapping.lookup v k))))
      (Mapping.ordered_keys v)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>show_state</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pid_global_config_impl ⇒ String.literal"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"show_state s ≡ let
      gvals = global_state_impl.variables (pid_global_config.state s);
      lvals = map (local_state_impl.variables ∘ local_config.state) (pid_global_config.processes s)
      in literal_concat (join' (concat (map get_assignments (gvals # lvals))) (STR '', ''))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>show_ce</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pid_global_config_impl lasso ⇒ String.literal"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"show_ce ce ≡
      STR ''reach'' +
      String.implode [lf] +
      literal_concat (join' (remdups_adj (map show_state (lasso_reach ce))) (String.implode [lf])) +
      String.implode [lf] +
      STR ''va'' +
      String.implode [lf] +
      show_state (lasso_va ce) +
      String.implode [lf] +
      STR ''cysfx'' +
      String.implode [lf] +
      literal_concat (join' (remdups_adj (map show_state (lasso_cysfx ce))) (String.implode [lf]))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>cmd</span><span> </span><span class="delimiter">=</span><span> </span><span>SM_Syntax.cmd</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>cmd.Seq</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>efalse</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"exp"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"efalse ≡ e_const 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>etrue</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"exp"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"etrue ≡ e_const 1"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ident ⇒ exp"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"var v ≡ e_var v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>assign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ident ⇒ exp ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"assign v e ≡ cmd.Assign etrue v e"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>assignc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"exp ⇒ ident ⇒ exp ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"assignc c v e ≡ cmd.Assign c v e"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wait</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"exp ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wait c ≡ cmd.Test c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>not</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"exp ⇒ exp"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"not e ≡ e_bin bo_eq e (e_const 0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ifelse</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"exp ⇒ cmd ⇒ cmd ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ifelse c c1 c2 ≡ cmd.Or (cmd.Test c; c1) (cmd.Test (not c); c2)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>var_decl_to_promela</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"var_decl ⇒ String.literal"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"var_decl_to_promela var_decl ≡ STR ''int'' + STR '' '' + var_decl"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>bin_op_to_promela</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bin_op ⇒ String.literal"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"bin_op_to_promela bo_plus = STR ''+''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"bin_op_to_promela bo_minus = STR ''-''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"bin_op_to_promela bo_mul = STR ''*''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"bin_op_to_promela bo_div = STR ''/''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"bin_op_to_promela bo_mod = STR ''%''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"bin_op_to_promela bo_less = STR ''&lt;''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"bin_op_to_promela bo_less_eq = STR ''&lt;=''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"bin_op_to_promela bo_eq = STR ''==''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"bin_op_to_promela bo_and = STR ''&amp;''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"bin_op_to_promela bo_or = STR ''|''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"bin_op_to_promela bo_xor = STR ''^''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>un_op_to_promela</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"un_op ⇒ String.literal"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"un_op_to_promela uo_minus = STR ''-''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"un_op_to_promela uo_not = STR ''~''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>exp_to_promela</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"exp ⇒ String.literal"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"exp_to_promela (e_var v) = v"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"exp_to_promela (e_localvar v) = v"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"exp_to_promela (e_globalvar v) = v"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"exp_to_promela (e_const i) = int_to_string i"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"exp_to_promela (e_bin bo e1 e2) = STR ''('' + exp_to_promela e1 + STR '' '' + bin_op_to_promela bo + STR '' '' + exp_to_promela e2 + STR '')''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"exp_to_promela (e_un uo e) = STR ''('' + un_op_to_promela uo + STR '' '' + exp_to_promela e + STR '')''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>cmd_to_promela</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"cmd ⇒ String.literal"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"cmd_to_promela (Assign c v e) = STR ''atomic { '' + exp_to_promela c + STR '' -&gt; '' + v + STR '' = '' + exp_to_promela e + STR '' }''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"cmd_to_promela (Assign_local c v e) = STR ''atomic { '' + exp_to_promela c + STR '' -&gt; '' + v + STR '' = '' + exp_to_promela e + STR '' }''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"cmd_to_promela (Assign_global c v e) = STR ''atomic { '' + exp_to_promela c + STR '' -&gt; '' + v + STR '' = '' + exp_to_promela e + STR '' }''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"cmd_to_promela (Test c) = exp_to_promela c"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"cmd_to_promela (Skip) = STR ''skip''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"cmd_to_promela (Seq c1 c2) = cmd_to_promela c1 + STR ''; '' + cmd_to_promela c2"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"cmd_to_promela (Or c1 c2) = STR ''if'' + STR '' :: '' + cmd_to_promela c1 + STR '' :: '' + cmd_to_promela c2 + STR '' fi''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"cmd_to_promela (Iterate c1 c2) = (
        if c1=c2 then
          STR ''do'' + STR '' :: '' + cmd_to_promela c1 + STR '' od''
        else
          Code.abort (STR ''General iterate not supported by promela translator'') (λ_. undefined)
        )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>proc_decl_to_promela</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"proc_decl ⇒ String.literal"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proc_decl_to_promela proc_decl ≡
      STR ''proctype'' + STR '' '' + name proc_decl + STR ''()'' + STR '' '' + STR ''{ '' +
      literal_concat (join (map var_decl_to_promela (local_vars proc_decl)) (STR ''; '')) +
      cmd_to_promela (body proc_decl) + STR '' }''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>run_process_to_promela</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"proc_decl ⇒ String.literal"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"run_process_to_promela proc_decl ≡ STR ''run'' + STR '' '' + name proc_decl + STR ''()''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>program_to_promela</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"program ⇒ String.literal"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"program_to_promela program ≡
      literal_concat (join (map var_decl_to_promela (global_vars program)) (STR ''; '')) +
      literal_concat (map proc_decl_to_promela (processes program)) +
      STR ''init { '' + literal_concat (join' (map run_process_to_promela (processes program)) (STR ''; '')) + STR '' }''"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lock_lock n ≡ n + STR ''l''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lock_vars n ≡ [lock_lock n]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lock_initialize</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ident ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lock_initialize n ≡ assign (lock_lock n) efalse"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lock_block</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ident ⇒ cmd ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lock_block n c ≡
      assignc (not (var (lock_lock n))) (lock_lock n) etrue;
      c;
      assign (lock_lock n) efalse"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_sender n ≡ n + STR ''s''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_receiver n ≡ n + STR ''r''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_message n ≡ n + STR ''m''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_sent n ≡ n + STR ''n''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_received n ≡ n + STR ''c''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_vars n ≡
    concat (map lock_vars [handshake_sender n, handshake_receiver n]) @
    [handshake_message n, handshake_sent n, handshake_received n]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>handshake_initialize</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ident ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_initialize n ≡
      lock_initialize (handshake_sender n);
      lock_initialize (handshake_receiver n);
      assign (handshake_message n) (e_const 0);
      assign (handshake_sent n) efalse;
      assign (handshake_received n) efalse"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>handshake_waiting</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ident ⇒ exp"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_waiting n ≡ var (handshake_sent n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>handshake_send</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ident ⇒ exp ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_send n m ≡
      lock_block (handshake_sender n)
      (
        assign (handshake_message n) m;
        assign (handshake_sent n) etrue;
        wait (var (handshake_received n));
        assign (handshake_received n) efalse
      )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>handshake_receive</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ident ⇒ ident ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_receive n m ≡
      lock_block (handshake_receiver n)
      (
        wait (var (handshake_sent n));
        assign (handshake_sent n) efalse;
        assign m (var (handshake_message n));
        assign (handshake_received n) etrue
      )"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_processes ≡ [STR ''A'', STR ''B'']"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_process_ids ≡ [1 ..&lt; Suc (length mulog_processes)]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>mulog_process_name</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ident"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"mulog_process_name 0 = STR ''unknown''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"mulog_process_name (Suc i) = mulog_processes ! i"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_handshake i ≡ mulog_process_name i + STR ''h''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_msg i ≡ mulog_process_name i + STR ''m''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_idle i ≡ mulog_process_name i + STR ''i''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_token i ≡ mulog_process_name i + STR ''t''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_requesting i ≡ mulog_process_name i + STR ''r''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_parent i ≡ mulog_process_name i + STR ''p''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_next i ≡ mulog_process_name i + STR ''n''"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>mulog_send_aux</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ exp ⇒ exp ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"mulog_send_aux 0 proc msg = cmd.Skip"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"mulog_send_aux (Suc n) proc msg =
        ifelse (e_bin bo_eq proc (e_const (int (Suc n))))
        (handshake_send (mulog_handshake (Suc n)) msg)
        (mulog_send_aux n proc msg)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mulog_send</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"exp ⇒ exp ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_send ≡ mulog_send_aux (length mulog_processes)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_vars_global i ≡ handshake_vars (mulog_handshake i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_vars_local i ≡ [mulog_msg i, mulog_idle i, mulog_token i, mulog_requesting i,
    mulog_parent i, mulog_next i]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mulog_initialize</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_initialize i ≡
      handshake_initialize (mulog_handshake i);
      assign (mulog_msg i) (e_const 0);
      assign (mulog_idle i) etrue;
      assign (mulog_parent i) (if i = 1 then e_const 0 else e_const 1);
      assign (mulog_next i) (e_const 0);
      assign (mulog_requesting i) efalse;
      assign (mulog_token i) (if i = 1 then etrue else efalse)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mulog_request_token</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_request_token i ≡
      assign (mulog_requesting i) etrue;
      ifelse (e_bin bo_eq (var (mulog_parent i)) (e_const 0))
      cmd.Skip
      (
        mulog_send (var (mulog_parent i)) (e_const (int i));
        assign (mulog_parent i) (e_const 0)
      )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mulog_release_token</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_release_token i ≡
      assign (mulog_requesting i) efalse;
      ifelse (e_bin bo_eq (var (mulog_next i)) (e_const 0))
      cmd.Skip
      (
        assign (mulog_token i) efalse;
        mulog_send (var (mulog_next i)) (e_const 0);
        assign (mulog_next i) (e_const 0)
      )"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mulog_process_cmd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ cmd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_process_cmd i ≡
      mulog_initialize i;
      SM_Syntax.Loop
      (
        ifelse (handshake_waiting (mulog_handshake i))
        (
          handshake_receive (mulog_handshake i) (mulog_msg i);
          ifelse (e_bin bo_eq (var (mulog_msg i)) (e_const 0))
          (assign (mulog_token i) etrue)
          (
            ifelse (e_bin bo_eq (var (mulog_parent i)) (e_const 0))
            (
              ifelse (var (mulog_requesting i))
              (assign (mulog_next i) (var (mulog_msg i)))
              (
                assign (mulog_token i) efalse;
                mulog_send (var (mulog_msg i)) (e_const 0)
              )
            )
            (mulog_send (var (mulog_parent i)) (var (mulog_msg i)));
            assign (mulog_parent i) (var (mulog_msg i))
          )
        )
        (
          ifelse (var (mulog_idle i))
          (
            assign (mulog_idle i) efalse;
            mulog_request_token i
          )
          (
            ifelse (var (mulog_token i))
            (
              assign (STR ''x'') (e_bin bo_plus (var (STR ''x'')) (e_const 1));
              assign (STR ''x'') (e_bin bo_minus (var (STR ''x'')) (e_const 1));
              mulog_release_token i;
              assign (mulog_idle i) etrue
            )
            cmd.Skip
          )
        )
      )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mulog_process</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ proc_decl"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_process i ≡
    ⦇
      name = mulog_process_name i,
      body = mulog_process_cmd i,
      local_vars = mulog_vars_local i
    ⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mulog_program</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"program"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_program ≡
    ⦇
      program.processes = map mulog_process mulog_process_ids,
      program.global_vars = STR ''x'' # List.maps mulog_vars_global mulog_process_ids
    ⦈"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>test1_process_send</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"int ⇒ proc_decl"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test1_process_send i ≡
    ⦇
      name = STR ''test1_process_send'',
      body = handshake_send (STR ''foo'') (e_const i),
      local_vars = []
    ⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>test1_process_receive</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"proc_decl"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test1_process_receive ≡
    ⦇
      name = STR ''test1_process_receive'',
      body = SM_Syntax.Loop
      (
        handshake_receive (STR ''foo'') (STR ''temp'');
        assign (STR ''x'') (e_bin bo_plus (var (STR ''x'')) (var (STR ''temp'')))
      ),
      local_vars = [STR ''temp'']
    ⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>test1_program</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"program"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test1_program ≡
    ⦇
      program.processes = [test1_process_send 1, test1_process_send 2, test1_process_receive],
      program.global_vars = STR ''x'' # handshake_vars (STR ''foo'')
    ⦈"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>test2_process</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"proc_decl"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test2_process ≡
    ⦇
      name = STR ''test2_process'',
      body = lock_block (STR ''foo'')
      (
        assign (STR ''x'') (e_bin bo_plus (var (STR ''x'')) (e_const 1));
        assign (STR ''x'') (e_bin bo_minus (var (STR ''x'')) (e_const 1))
      ),
      local_vars = []
    ⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>test2_program</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"program"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test2_program ≡
    ⦇
      program.processes = [test2_process, test2_process],
      program.global_vars = STR ''x'' # lock_vars (STR ''foo'')
    ⦈"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mulog_property ≡ G<span class="hidden">⇩</span><sub>c</sub> prop<span class="hidden">⇩</span><sub>c</sub>(e_bin bo_less_eq (e_var (STR ''x'')) (e_const 1))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test1_property ≡ F<span class="hidden">⇩</span><sub>c</sub> prop<span class="hidden">⇩</span><sub>c</sub>(e_bin bo_eq (e_var (STR ''x'')) (e_const 3))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test2_property ≡ G<span class="hidden">⇩</span><sub>c</sub> prop<span class="hidden">⇩</span><sub>c</sub>(e_bin bo_less_eq (e_var (STR ''x'')) (e_const 1))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test n ≡ cava_sm dflt_cfg mulog_program mulog_property"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"cmd_to_promela (mulog_initialize 1)"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* value [code] "program_to_promela mulog_program *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">export_code</span></span><span>
</span><span>    </span><span>program_to_promela</span><span> </span><span>mulog_program</span><span>
</span><span>    </span><span>test</span><span> </span><span>show_ce</span><span>
</span><span>    </span><span>TY_ERR</span><span> </span><span>SAT</span><span> </span><span>UNSAT</span><span> </span><span>UNSAT_CE</span><span>
</span><span>    </span><span>lasso_reach</span><span> </span><span>lasso_va</span><span> </span><span>lasso_cysfx</span><span>
</span><span>    </span><span>nat_of_integer</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">module_name</span></span><span> </span><span>Mulog</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../code/examples/mulog/Mulog_Export.sml"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="All_Of_Nested_DFS">
<div class="head"><h1>Theory All_Of_Nested_DFS</h1>
<span class="command">theory</span> <span class="name">All_Of_Nested_DFS</span><br/>
<span class="keyword">imports</span> <a href="NDFS_SI.html"><span class="name">NDFS_SI</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>All_Of_Nested_DFS</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>NDFS_SI_Statistics</span><span>
</span><span>  </span><span>NDFS_SI</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="All_Of_CAVA_LTL_Modelchecker">
<div class="head"><h1>Theory All_Of_CAVA_LTL_Modelchecker</h1>
<span class="command">theory</span> <span class="name">All_Of_CAVA_LTL_Modelchecker</span><br/>
<span class="keyword">imports</span> <a href="All_Of_Nested_DFS.html"><span class="name">All_Of_Nested_DFS</span></a> <a href="CAVA_Impl.html"><span class="name">CAVA_Impl</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>All_Of_CAVA_LTL_Modelchecker</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Nested_DFS/All_Of_Nested_DFS"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"BoolProgs/BoolProgs"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"BoolProgs/BoolProgs_Extras"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BoolProgs/BoolProgs_LTL_Conv"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"BoolProgs/Programs/BoolProgs_Programs"</span></span></span><span>
</span><span>  </span><span>CAVA_Abstract</span><span> </span><span>CAVA_Impl</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div>