<div id="Abstract_Completeness">
<div class="head"><h1>Theory Abstract_Completeness</h1>
<span class="command">theory</span> <span class="name">Abstract_Completeness</span><br/>
<span class="keyword">imports</span> <a href="Locale_Code.html"><span class="name">Locale_Code</span></a> <a href="../../HOL/HOL-Library/FSet.html"><span class="name">FSet</span></a> <a href="../../HOL/HOL-Library/Code_Target_Nat.html"><span class="name">Code_Target_Nat</span></a> <a href="../../HOL/HOL-Library/Linear_Temporal_Logic_on_Streams.html"><span class="name">Linear_Temporal_Logic_on_Streams</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* An abstract completeness theorem *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Abstract_Completeness</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Collections.Locale_Code</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Countable_Set"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.FSet"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Code_Target_Nat"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Linear_Temporal_Logic_on_Streams"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹General Tree Concepts›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">codatatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>tree</span><span> </span><span class="delimiter">=</span><span> </span><span>Node</span><span> </span><span class="delimiter">(</span><span>root</span><span class="delimiter">:</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>cont</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree fset"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>tfinite</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>tfinite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ t'. t' |∈| cont t ⟹ tfinite t') ⟹ tfinite t"</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Infinite paths in trees. *)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">coinductive</span></span><span> </span><span>ipath</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>ipath</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦root t = shd steps; t' |∈| cont t; ipath t' (stl steps)⟧ ⟹ ipath t steps"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Finite trees have no infinite paths. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ftree_no_ipath</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tfinite t ⟹ ¬ ipath t steps"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>steps</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tfinite.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>ipath.cases</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>konig</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"shd (konig t) = root t"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"stl (konig t) = konig (SOME t'. t' |∈| cont t ∧ ¬ tfinite t')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Konig</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ tfinite t ⟹ ipath t (konig t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>tfinite.simps</span><span> </span><span>konig.simps</span><span> </span><span>someI_ex</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Rule Systems›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* A step consists of a pair (s,r) such that the rule r is taken in state s. *)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'state</span><span class="delimiter">,</span><span> </span><span class="tfree">'rule</span><span class="delimiter">)</span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state × 'rule"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* A derivation tree is a tree of steps: *)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'state</span><span class="delimiter">,</span><span> </span><span class="tfree">'rule</span><span class="delimiter">)</span><span> </span><span>dtree</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state, 'rule) step tree"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>RuleSystem_Defs</span><span> </span><span class="delimiter">=</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>eff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'rule ⇒ 'state ⇒ 'state fset ⇒ bool"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The countable set of rules is initially provided as a stream: *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rules</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'rule stream"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R ≡ sset rules"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>countable_R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"countable R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>countableI_type</span><span> </span><span>countable_image</span><span> </span><span>sset_range</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NE_R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UNIV_witness</span><span> </span><span>all_not_in_conv</span><span> </span><span>empty_is_image</span><span> </span><span>sset_range</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled r s ≡ ∃ sl. eff r s sl"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pickEff r s ≡ if enabled r s then (SOME sl. eff r s sl) else the None"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pickEff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled r s ⟹ eff r s (pickEff r s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>enabled_def</span><span> </span><span>pickEff_def</span><span> </span><span>tfl_some</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"effStep step ≡ eff (snd step) (fst step)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabledAtStep r step ≡ enabled r (fst step)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"takenAtStep r step ≡ snd step = r"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Saturation is a very strong notion of fairness:
  If a rule is enabled at some point, it will eventually be taken.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"saturated r ≡ alw (holds (enabledAtStep r) impl ev (holds (takenAtStep r)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Saturated steps ≡ ∀ r ∈ R. saturated r steps"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Well-formed derivation trees *)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">coinductive</span></span><span> </span><span>wf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦snd (root t) ∈ R; effStep (root t) (fimage (fst o root) (cont t));
    ⋀t'. t' |∈| cont t ⟹ wf t'⟧ ⟹ wf t"</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Escape paths *)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">coinductive</span></span><span> </span><span>epath</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>epath</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦snd (shd steps) ∈ R; fst (shd (stl steps)) |∈| sl; effStep (shd steps) sl;
    epath (stl steps)⟧ ⟹ epath steps"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_ipath_epath</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipath t steps"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"epath steps"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀t st. ipath t st ⟹ root t = shd st"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>ipath.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>steps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>epath</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf.cases</span><span class="delimiter">[</span><span>case_product</span><span> </span><span>ipath.cases</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>*</span><span> </span><span>o_apply</span><span> </span><span>fimageI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fair rs ≡ sset rs ⊆ R ∧ (∀ r ∈ R. alw (ev (holds ((=) r))) rs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fair_stl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fair rs ⟹ fair (stl rs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fair_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>alw.simps</span><span> </span><span>subsetD</span><span> </span><span>stl_sset</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sdrop_fair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fair rs ⟹ fair (sdrop m rs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alw_sdrop</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fair_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>alw.coinduct</span><span> </span><span>alw_nxt</span><span> </span><span>fair_def</span><span> </span><span>fair_stl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A Fair Enumeration of the Rules›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The fair enumeration of rules *)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fenum ≡ flat (smap (λn. stake n rules) (fromN 1))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sset_fenum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sset fenum = R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fenum_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sset_flat</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>stream.set_map</span><span> </span><span>in_set_conv_nth</span><span> </span><span>sset_range</span><span class="delimiter">[</span><span>of</span><span> </span><span>rules</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>     </span><span>metis</span><span> </span><span>atLeast_Suc_greaterThan</span><span> </span><span>greaterThan_0</span><span> </span><span>lessI</span><span> </span><span>range_eqI</span><span> </span><span>stake_nth</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fair_fenum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fair fenum"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r ∈ R"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r = rules !! m"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sset_range</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rs</span><span> </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?fenum</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λn. flat (smap (λn. stake n rules) (fromN n))"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"alw (ev (holds ((=) r))) (rs @- ?fenum n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>n</span><span> </span><span>rs</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>alw</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"rs @- ?fenum n"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃n' rs'. stl (rs @- ?fenum n) = rs' @- ?fenum n' ∧ n' &gt; 0"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>rs</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>alw</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>alw</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>n</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ev (holds ((=) r)) (rs @- flat (smap (λn. stake n rules) (fromN n)))"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alw</span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ev_holds_sset</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"m &lt; n"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>stream.set_map</span><span> </span><span>in_set_conv_nth</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fair fenum"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fair_def</span><span> </span><span>sset_fenum</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fenum_def</span><span> </span><span>alw_shift</span><span> </span><span>le_less</span><span> </span><span>zero_less_one</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trim rs s = sdrop_while (λr. Not (enabled r s)) rs"</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The fair tree associated to a stream of rules and a state *)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>mkTree</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"root (mkTree rs s) = (s, (shd (trim rs s)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"cont (mkTree rs s) = fimage (mkTree (stl (trim rs s))) (pickEff (shd (trim rs s)) s)"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* More efficient code equation for mkTree *)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mkTree_unfold</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mkTree rs s =
  (case trim rs s of SCons r s' ⇒ Node (s, r) (fimage (mkTree s') (pickEff r s)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>mkTree.ctr</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>stream.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>RuleSystem</span><span> </span><span class="delimiter">=</span><span> </span><span>RuleSystem_Defs</span><span> </span><span>eff</span><span> </span><span>rules</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>eff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'rule ⇒ 'state ⇒ 'state fset ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rules</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'rule stream"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>eff_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s r sl s'. ⟦s ∈ S; r ∈ R; eff r s sl; s' |∈| sl⟧ ⟹ s' ∈ S"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enabled_R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s. s ∈ S ⟹ ∃ r ∈ R. ∃ sl. eff r s sl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The minimum waiting time in a stream for the enabled rules in a given state: *)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"minWait rs s ≡ LEAST n. enabled (shd (sdrop n rs)) s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trim_alt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fair rs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trim rs s = sdrop (minWait rs s) rs"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>trim_def</span><span> </span><span>minWait_def</span><span> </span><span>sdrop_simps</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>sdrop_while_sdrop_LEAST</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>o_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>enabled_R</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span>sl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ∈ R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eff r s sl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bspec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>conjunct2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rs</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>fair_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>r</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = rs !! m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>atomize_elim</span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>alw.cases</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>ev_holds_sset</span><span> </span><span>sset_range</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r</span><span> </span><span>sl</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃n. enabled (rs !! n) s"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>enabled_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minWait_ex</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fair rs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n. enabled (shd (sdrop n rs)) s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ∈ R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled r s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>enabled_R</span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>enabled_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"shd (sdrop n rs) = r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sdrop_fair</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rs</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>alw_nxt</span><span> </span><span>holds.simps</span><span> </span><span>sdrop.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>fair_def</span><span> </span><span>sdrop_wait</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span> </span><span>e</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fair rs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>trim_in_R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"shd (trim rs s) ∈ R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trim_enabled</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (shd (trim rs s)) s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trim_fair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fair (trim rs s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trim_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>minWait_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>minWait_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>sdrop_fair</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span>conjunct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>fair_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subsetD</span><span> </span><span>snth_sset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minWait_least</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦enabled (shd (sdrop n rs)) s⟧ ⟹ minWait rs s ≤ n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>minWait_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Least_le</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_cont_mkTree</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fair rs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' |∈| cont (mkTree rs s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ sl' s'. s' ∈ S ∧ eff (shd (trim rs s)) s sl' ∧
                 s' |∈| sl' ∧ t' = mkTree (stl (trim rs s)) s'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>sl'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sl' = pickEff (shd (trim rs s)) s"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s' |∈| sl'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t' = mkTree (stl (trim rs s)) s'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t'</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sl'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (shd (trim rs s)) s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trim_enabled</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s</span><span> </span><span>rs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>trim_in_R</span><span> </span><span>pickEff</span><span> </span><span>eff_S</span><span> </span><span>s</span><span> </span><span>rs</span><span> </span><span>s'</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>sl'_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sl'_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pickEff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipath_mkTree_sdrop</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fair rs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipath (mkTree rs s) steps"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n s'. s' ∈ S ∧ ipath (mkTree (sdrop n rs) s') (sdrop m steps)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span> </span><span>rs</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>m</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>steps</span><span> </span><span>rs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span>s'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ S"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipath (mkTree (sdrop n rs) s') (sdrop m steps)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipath ?t _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ip</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"root ?t = shd (sdrop m steps)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' |∈| cont ?t"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipath t' (sdrop (Suc m) steps)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>in_cont_mkTree</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s'</span><span> </span><span>sdrop_fair</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Suc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>t'</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>sl''</span><span> </span><span>s''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eff (shd (trim (sdrop n rs) s')) s' sl''"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>s''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s'' |∈| sl''"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t'_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' = mkTree (stl (trim (sdrop n rs) s')) s''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"shd (trim (sdrop n rs) s') ∈ R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sdrop_fair</span><span> </span><span>Suc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>trim_in_R</span><span> </span><span>s'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>s''</span><span> </span><span>e</span><span> </span><span>s'</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sdrop_stl</span><span> </span><span>t'_def</span><span> </span><span>sdrop_add</span><span> </span><span>add.commute</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>    </span><span>trim_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s'</span><span> </span><span>sdrop_fair</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Suc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"minWait (sdrop n rs) s' + Suc n"</span></span></span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>s''</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eff_S</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_mkTree</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fair rs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf (mkTree rs s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>rs</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>wf</span><span> </span><span>rs</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"mkTree rs s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (root ?t) ∈ R"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trim_in_R</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ∘ root ∘ mkTree (stl (trim rs s)) = id"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"effStep (root ?t) (fimage (fst ∘ root) (cont ?t))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trim_enabled</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pickEff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fair_stl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>trim_fair</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>in_cont_mkTree</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"stl (trim rs s)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The position of a rule in a rule stream *)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pos rs r ≡ LEAST n. shd (sdrop n rs) = r"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦fair rs; r ∈ R⟧ ⟹ shd (sdrop (pos rs r) rs) = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pos_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LeastI_ex</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>alw.cases</span><span> </span><span>fair_def</span><span> </span><span>holds.simps</span><span> </span><span>sdrop_wait</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pos_least</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"shd (sdrop n rs) = r ⟹ pos rs r ≤ n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pos_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>Least_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minWait_le_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦fair rs; r ∈ R; enabled r s⟧ ⟹ minWait rs s ≤ pos rs r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>sdrop_simps</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>minWait_least</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pos</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stake_pos_minWait</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>rs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fair rs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"minWait rs s &lt; pos rs r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ∈ R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pos (stl (trim rs s)) r = pos rs r - Suc (minWait rs s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pos rs r - Suc (minWait rs s) + minWait rs s = pos rs r - Suc 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"shd (stl (sdrop (pos rs r - Suc 0) rs)) = shd (sdrop (pos rs r) rs)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred</span><span> </span><span>gr_implies_not0</span><span> </span><span>m</span><span> </span><span>neq0_conv</span><span> </span><span>sdrop.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>sdrop_stl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pos (stl (trim rs s)) r ≤ pos rs r - Suc (minWait rs s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pos</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rs</span><span> </span><span>r</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span> </span><span>trim_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s</span><span> </span><span>rs</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>pos_least</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pos rs r ≤ pos (stl (trim rs s)) r + Suc (minWait rs s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pos</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sdrop_fair</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fair_stl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rs</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>r</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"minWait rs s"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trim_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s</span><span> </span><span>rs</span><span class="delimiter">]</span><span> </span><span>add.commute</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>pos_least</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pos rs r - Suc (minWait rs s) ≤ pos (stl (trim rs s)) r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipath_mkTree_ev</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fair rs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipath (mkTree rs s) steps"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ∈ R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>alw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"alw (holds (enabledAtStep r)) steps"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ev (holds (takenAtStep r)) steps"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span> </span><span>rs</span><span> </span><span>i</span><span> </span><span>alw</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"pos rs r"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>rs</span><span> </span><span>s</span><span> </span><span>steps</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>less</span><span> </span><span>rs</span><span> </span><span>s</span><span> </span><span>steps</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>s</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ S›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trim_def'</span><span> </span><span class="delimiter">=</span><span> </span><span>trim_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fair rs›</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"mkTree rs s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>less</span><span class="delimiter">(</span><span>4</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>s</span><span> </span><span>in_cont_mkTree</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state, 'rule) step tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>rt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"root ?t = shd steps"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipath (mkTree (stl (trim rs s)) s') (stl steps)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>s'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>cases</span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"pos rs r = minWait rs s"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pos</span><span class="delimiter">[</span><span>OF</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>r</span><span class="delimiter">]</span><span> </span><span>rt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trim_def'</span><span> </span><span>ev.base</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled r s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>rt</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>alw_nxt</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>steps</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span>r</span><span> </span><span>less.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"minWait rs s &lt; pos rs r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>minWait_le_pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?m1</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"pos rs r - Suc (minWait rs s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc ?m1 ≤ pos rs r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?m1 = pos (stl (trim rs s)) r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fair rs›</span></span></span><span> </span><span>2</span><span> </span><span>r</span><span> </span><span>s</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>stake_pos_minWait</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fair (stl (trim rs s))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"alw (holds (enabledAtStep r)) (stl steps)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fair_stl</span><span> </span><span>trim_fair</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>alw.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?thesis"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ev.step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>less.hyps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>s'</span><span> </span><span>_</span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Persistent rules›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"per r ≡
    ∀s r1 sl' s'. s ∈ S ∧ enabled r s ∧ r1 ∈ R - {r} ∧ eff r1 s sl' ∧ s' |∈| sl' ⟶ enabled r s'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>per_alw</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"per r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"epath steps ∧ fst (shd steps) ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"alw (holds (enabledAtStep r) impl
    (holds (takenAtStep r) or nxt (holds (enabledAtStep r)))) steps"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>coinduct</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>alw</span><span> </span><span>steps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (shd steps)"</span></span></span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?r1</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (shd steps)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (shd (stl steps))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled r ?s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?r1 ≠ r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?r1 ∈ R"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alw</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>epath.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>sl'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eff ?r1 ?s sl' ∧ ?s' |∈| sl'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alw</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>epath.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled r ?s'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>per_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>eff_S</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>epath.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context RuleSystem›</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Rule-persistent rule system *)</span></span></span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>PersistentRuleSystem</span><span> </span><span class="delimiter">=</span><span> </span><span>RuleSystem</span><span> </span><span>eff</span><span> </span><span>rules</span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>eff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'rule ⇒ 'state ⇒ 'state fset ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rules</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'rule stream"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>per</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ r. r ∈ R ⟹ per r"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipath_mkTree_saturated</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fair rs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipath (mkTree rs s) steps"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ∈ R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"saturated r steps"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>saturated_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span> </span><span>rs</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>rs</span><span> </span><span>s</span><span> </span><span>steps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>alw</span><span> </span><span>rs</span><span> </span><span>s</span><span> </span><span>steps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>steps</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"holds (enabledAtStep r) steps"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"alw (holds (enabledAtStep r)) steps ∨ ev (holds (takenAtStep r)) steps"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>variance</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>per_alw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>per</span><span class="delimiter">[</span><span>OF</span><span> </span><span>r</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wf_ipath_epath</span><span> </span><span>wf_mkTree</span><span> </span><span>alw</span><span> </span><span>mkTree.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ipath.simps</span><span> </span><span>fst_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ev (holds (takenAtStep r)) steps"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ipath_mkTree_ev</span><span class="delimiter">[</span><span>OF</span><span> </span><span>alw</span><span> </span><span>r</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>alw</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃rs' s' steps'.
      stl steps = steps' ∧ s' ∈ S ∧ fair rs' ∧ ipath (mkTree rs' s') steps'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ipath_mkTree_sdrop</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>1</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>trim_in_R</span><span> </span><span>sdrop_fair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ipath_mkTree_Saturated</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fair rs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipath (mkTree rs s) steps"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Saturated steps"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Saturated_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ipath_mkTree_saturated</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>epath_completeness_Saturated</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∃ t. fst (root t) = s ∧ wf t ∧ tfinite t) ∨
   (∃ steps. fst (shd steps) = s ∧ epath steps ∧ Saturated steps)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?A ∨ ?B"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ?A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ tfinite (mkTree fenum s)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_mkTree</span><span> </span><span>fair_fenum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>steps</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipath (mkTree fenum s) steps"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Konig</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (shd steps) = s ∧ epath steps ∧ Saturated steps"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wf_ipath_epath</span><span> </span><span>ipath.simps</span><span> </span><span>ipath_mkTree_Saturated</span><span>
</span><span>        </span><span>wf_mkTree</span><span> </span><span>fair_fenum</span><span> </span><span>mkTree.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?B</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context PersistentRuleSystem›</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Code generation›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Here we assume a deterministic effect eff': *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>RuleSystem_Code</span><span> </span><span class="delimiter">=</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>eff'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'rule ⇒ 'state ⇒ 'state fset option"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rules</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'rule stream"</span></span></span><span> </span><span class="comment">― ‹countably many rules›</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eff r s sl ≡ eff' r s = Some sl"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context RuleSystem_Code *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"effG eff' r s sl ≡ RuleSystem_Code.eff eff' r s sl"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>RuleSystem_Code</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>RuleSystem_Defs</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>eff</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"effG eff'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rules</span><span> </span><span class="delimiter">=</span><span> </span><span>rules</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>RuleSystem_Code</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>enabled_eff'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled r s ⟷ eff' r s ≠ None"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>enabled_def</span><span> </span><span>effG_def</span><span> </span><span>eff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pickEff_the</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pickEff r s = the (eff' r s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pickEff_def</span><span> </span><span>enabled_def</span><span> </span><span>effG_def</span><span> </span><span>eff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>code_unfold</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>trim_def</span><span> </span><span>enabled_eff'</span><span> </span><span>pickEff_the</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context RuleSystem_Code *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span>Locale_Code.open_block</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span>RuleSystem_Code</span><span> </span><span>eff'</span><span> </span><span>rules</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>eff'</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rules</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>lc_delete</span><span> </span><span class="string"><span class="delete"><span class="delete">"RuleSystem_Defs.mkTree (effG ?eff')"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>lc_delete</span><span> </span><span>RuleSystem_Defs.trim</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>lc_delete</span><span> </span><span>RuleSystem_Defs.enabled</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>lc_delete</span><span> </span><span>RuleSystem_Defs.pickEff</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>lc_add</span><span> </span><span class="string"><span class="delete"><span class="delete">"RuleSystem_Defs.mkTree (effG ?eff')"</span></span></span><span> </span><span>i.mkTree_unfold</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span>Locale_Code.close_block</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>the</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"fromJust"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>Option.is_none</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"isNothing"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>mkTree_effG_uu</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Haskell</span><span> </span><span class="keyword2"><span class="keyword">module_name</span></span><span> </span><span>Tree</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*file "."*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Propositional_Logic">
<div class="head"><h1>Theory Propositional_Logic</h1>
<span class="command">theory</span> <span class="name">Propositional_Logic</span><br/>
<span class="keyword">imports</span> <a href="Abstract_Completeness.html"><span class="name">Abstract_Completeness</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Propositional_Logic</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Abstract_Completeness</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Toy instantiation: Propositional Logic›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">=</span><span> </span><span>Atom</span><span> </span><span>nat</span><span> </span><span class="delimiter">|</span><span> </span><span>Neg</span><span> </span><span>fmla</span><span> </span><span class="delimiter">|</span><span> </span><span>Conj</span><span> </span><span>fmla</span><span> </span><span>fmla</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>max_depth</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"max_depth (Atom _) = 0"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"max_depth (Neg φ) = Suc (max_depth φ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"max_depth (Conj φ ψ) = Suc (max (max_depth φ) (max_depth ψ))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_depth_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"max_depth φ = 0 = (∃n. φ = Atom n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>φ</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_depth_Suc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"max_depth φ = Suc n = ((∃ψ. φ = Neg ψ ∧ max_depth ψ = n) ∨
  (∃ψ1 ψ2. φ = Conj ψ1 ψ2 ∧ max (max_depth ψ1) (max_depth ψ2) = n))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>φ</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"atoms ≡ smap Atom nats"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"depth1 ≡
  sinterleave (smap Neg atoms) (smap (case_prod Conj) (sproduct atoms atoms))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sinterleaves ≡ fold sinterleave"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>extendLevel</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extendLevel (belowN, N) =
  (let Next = sinterleaves
    (map (smap (case_prod Conj)) [sproduct belowN N, sproduct N belowN, sproduct N N])
    (smap Neg N)
  in (sinterleave belowN N, Next))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extendLevel_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦sset belowN = {φ. max_depth φ &lt; n};
    sset N = {φ. max_depth φ = n}; st = (belowN, N)⟧ ⟹
  ∃belowNext Next. extendLevel st = (belowNext, Next) ∧
     sset belowNext = {φ. max_depth φ &lt; Suc n} ∧ sset Next = {φ. max_depth φ = Suc n}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sset_sinterleave</span><span> </span><span>sset_sproduct</span><span> </span><span>stream.set_map</span><span>
</span><span>    </span><span>image_iff</span><span> </span><span>max_depth_Suc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sset_atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sset atoms = {φ. max_depth φ &lt; 1}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>stream.set_map</span><span> </span><span>max_depth_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sset_depth1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sset depth1 = {φ. max_depth φ = 1}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sset_sinterleave</span><span> </span><span>sset_sproduct</span><span> </span><span>stream.set_map</span><span>
</span><span>    </span><span>max_depth_Suc</span><span> </span><span>max_depth_0</span><span> </span><span>max_def</span><span> </span><span>image_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extendLevel_Nsteps</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦sset belowN = {φ. max_depth φ &lt; n}; sset N = {φ. max_depth φ = n}⟧ ⟹
  ∃belowNext Next. (extendLevel ^^ m) (belowN, N) = (belowNext, Next) ∧
     sset belowNext = {φ. max_depth φ &lt; n + m} ∧ sset Next = {φ. max_depth φ = n + m}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>m</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>belowN</span><span> </span><span>N</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>belowNext</span><span> </span><span>Next</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(extendLevel ^^ m) (belowN, N) = (belowNext, Next)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"sset belowNext = {φ. max_depth φ &lt; n + m}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sset Next = {φ. max_depth φ = n + m}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>funpow.simps</span><span> </span><span>o_apply</span><span> </span><span>add_Suc_right</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>extendLevel_step</span><span class="delimiter">[</span><span>of</span><span> </span><span>belowNext</span><span> </span><span>_</span><span> </span><span>Next</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>extendLevel</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃belowNext Next. (extendLevel ^^ m) (atoms, depth1) = (belowNext, Next) ∧
     sset belowNext = {φ. max_depth φ &lt; 1 + m} ∧ sset Next = {φ. max_depth φ = 1 + m}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>extendLevel_Nsteps</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sset_atoms</span><span> </span><span>sset_depth1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fmlas = sinterleave atoms (smerge (smap snd (siterate extendLevel (atoms, depth1))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fmlas_UNIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sset fmlas = (UNIV :: fmla set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>subsetI</span><span> </span><span>UNIV_I</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>φ</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ sset fmlas"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"max_depth φ"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fmlas_def</span><span> </span><span>sset_sinterleave</span><span> </span><span>stream.set_map</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>UnI1</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>max_depth_0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>m</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extendLevel</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fmlas_def</span><span> </span><span>sset_smerge</span><span> </span><span>sset_siterate</span><span> </span><span>sset_sinterleave</span><span> </span><span>stream.set_map</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>UnI2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>rule</span><span> </span><span class="delimiter">=</span><span> </span><span>Idle</span><span> </span><span class="delimiter">|</span><span> </span><span>Ax</span><span> </span><span>nat</span><span> </span><span class="delimiter">|</span><span> </span><span>NegL</span><span> </span><span>fmla</span><span> </span><span class="delimiter">|</span><span> </span><span>NegR</span><span> </span><span>fmla</span><span> </span><span class="delimiter">|</span><span> </span><span>ConjL</span><span> </span><span>fmla</span><span> </span><span>fmla</span><span> </span><span class="delimiter">|</span><span> </span><span>ConjR</span><span> </span><span>fmla</span><span> </span><span>fmla</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mkRules f ≡ smap f fmlas"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mkRulePairs f ≡ smap (case_prod f) (sproduct fmlas fmlas)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rules</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rules = Idle ## 
     sinterleaves [mkRules NegL, mkRules NegR, mkRulePairs ConjL, mkRulePairs ConjR]
     (smap Ax nats)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rules_UNIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sset rules = (UNIV :: rule set)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rules_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sset_sinterleave</span><span> </span><span>sset_sproduct</span><span> </span><span>stream.set_map</span><span>
</span><span>    </span><span>fmlas_UNIV</span><span> </span><span>image_iff</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rule.exhaust</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fmla fset * fmla fset"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>eff'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rule ⇒ state ⇒ state fset option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eff' Idle (Γ, Δ) = Some {|(Γ, Δ)|}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"eff' (Ax n) (Γ, Δ) =
    (if Atom n |∈| Γ ∧ Atom n |∈| Δ then Some {||} else None)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"eff' (NegL φ) (Γ, Δ) =
    (if Neg φ |∈| Γ then Some {|(Γ |-| {| Neg φ |}, finsert φ Δ)|} else None)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"eff' (NegR φ) (Γ, Δ) =
    (if Neg φ |∈| Δ then Some {|(finsert φ Γ, Δ |-| {| Neg φ |})|} else None)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"eff' (ConjL φ ψ) (Γ, Δ) =
    (if Conj φ ψ |∈| Γ
    then Some {|(finsert φ (finsert ψ (Γ |-| {| Conj φ ψ |})), Δ)|}
    else None)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"eff' (ConjR φ ψ) (Γ, Δ) =
    (if Conj φ ψ |∈| Δ
    then Some {|(Γ, finsert φ (Δ |-| {| Conj φ ψ |})), (Γ, finsert ψ (Δ |-| {| Conj φ ψ |}))|}
    else None)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Disj φ ψ ≡ Neg (Conj (Neg φ) (Neg ψ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Imp φ ψ ≡ Disj (Neg φ) ψ"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Iff φ ψ ≡ Conj (Imp φ ψ) (Imp ψ φ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"thm1 ≡ ({|Conj (Atom 0) (Neg (Atom 0))|}, {||})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>Stream.smember_code</span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Stream.smember x (y ## s) = (x = y ∨ Stream.smember x s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Stream.smember_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>RuleSystem</span><span> </span><span class="string"><span class="delete"><span class="delete">"λr s ss. eff' r s = Some ss"</span></span></span><span> </span><span>rules</span><span> </span><span>UNIV</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rules_UNIV</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>Idle</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>PersistentRuleSystem</span><span> </span><span class="string"><span class="delete"><span class="delete">"λr s ss. eff' r s = Some ss"</span></span></span><span> </span><span>rules</span><span> </span><span>UNIV</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>enabled_def</span><span> </span><span>per_def</span><span> </span><span>rules_UNIV</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span>Γ</span><span> </span><span>Δ</span><span> </span><span>ss</span><span> </span><span>r'</span><span> </span><span>Γ'</span><span> </span><span>Δ'</span><span> </span><span>ss'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r' ≠ r"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eff' r (Γ, Δ) = Some ss"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eff' r' (Γ, Δ) = Some ss'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Γ', Δ') |∈| ss'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃sl. eff' r (Γ', Δ') = Some sl"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>r</span><span> </span><span>r'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rule.exhaust</span><span class="delimiter">[</span><span>case_product</span><span> </span><span>rule.exhaust</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rho ≡ i.fenum rules"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"propTree ≡ i.mkTree eff' rho"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>propTree</span><span> </span><span>thm1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Haskell</span><span> </span><span class="keyword2"><span class="keyword">module_name</span></span><span> </span><span>PropInstance</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* file "." *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div>