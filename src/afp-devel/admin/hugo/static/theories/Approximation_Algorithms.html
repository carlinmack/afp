<div id="Approx_VC_Hoare">
<div class="head"><h1>Theory Approx_VC_Hoare</h1>
<span class="command">theory</span> <span class="name">Approx_VC_Hoare</span><br/>
<span class="keyword">imports</span> <a href="Hoare_Logic.html"><span class="name">Hoare_Logic</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vertex Cover"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Approx_VC_Hoare</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Hoare.Hoare_Logic"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The algorithm is classical, the proof is based on and augments the one
by Berghammer and M\"uller-Olm \cite{BerghammerM03}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A graph is simply a set of edges, where an edge is a 2-element set.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vertex_cover</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ 'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"vertex_cover E C = (∀e ∈ E. e ∩ C ≠ {})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>matching</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"matching M ≡ pairwise disjnt M"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_matching_vertex_cover</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ finite C;  matching M;  M ⊆ E;  vertex_cover E C ⟧ ⟹ card M ≤ card C"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>card_le_if_inj_on_rel</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λe v. v ∈ e"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>disjnt_def</span><span> </span><span>disjnt_iff</span><span> </span><span>vertex_cover_def</span><span> </span><span>subsetCE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>disjnt_iff</span><span> </span><span>pairwise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"The Approximation Algorithm"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Formulated using a simple(!) predefined Hoare-logic.
This leads to a streamlined proof based on standard invariant reasoning.

The nondeterministic selection of an element from a set ‹F› is simulated by @{term "SOME x. x ∈ F"}.
The ‹SOME› operator is built into HOL: @{term "SOME x. P x"} denotes some ‹x› that satisfies ‹P›
if such an ‹x› exists; otherwise it denotes an arbitrary element. Note that there is no
actual nondeterminism involved: @{term "SOME x. P x"} is some fixed element
but in general we don't know which one. Proofs about ‹SOME› are notoriously tedious.
Typically it involves showing first that @{prop "∃x. P x"}. Then @{thm someI_ex} implies
@{prop"P (SOME x. P x)"}. There are a number of (more) useful related theorems:
just click on @{thm someI_ex} to be taken there.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Convenient notation for choosing an arbitrary element from a set:›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"some A ≡ SOME x. x ∈ A"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Edges</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>E</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite E"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>edges2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ E ⟹ card e = 2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The invariant:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_matching C F M =
  (matching M ∧ M ⊆ E ∧ card C ≤ 2 * card M ∧ (∀e ∈ M. ∀f ∈ F. e ∩ f = {}))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'a set set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"invar C F = (F ⊆ E ∧ vertex_cover (E-F) C ∧ finite C ∧ (∃M. inv_matching C F M))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preservation of the invariant by the loop body:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar C F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (C ∪ some F) (F - {e' ∈ F. some F ∩ e' ≠ {}})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F ⊆ E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vertex_cover (E-F) C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite C"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"matching M"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ⊆ E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>card</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card C ≤ 2 * card M"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>disj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀e ∈ M. ∀f ∈ F. e ∩ f = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span> </span><span>inv_matching_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?e</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"SOME e. e ∈ F"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?e ∈ F"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ≠ {}›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>some_in_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>fe'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ?e"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ⊆ E›</span></span></span><span> </span><span>edges2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>card_ge_0_finite</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?e ∉ M"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>edges2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?e ∈ F›</span></span></span><span> </span><span>disj</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ⊆ E›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card (C ∪ ?e) ≤ 2 * card (insert ?e M)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?e ∈ F›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?e ∉ M›</span></span></span><span> </span><span>card_Un_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span class="var">?e</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ⊆ E›</span></span></span><span> </span><span>edges2</span><span> </span><span>card</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>m</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>finE</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"M ∪ {?e}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vc'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vertex_cover (E - (F - {e' ∈ F. ?e ∩ e' ≠ {}})) (C ∪ ?e)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vertex_cover_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_matching (C ∪ ?e) (F - {e' ∈ F. ?e ∩ e' ≠ {}}) ?M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m</span><span> </span><span>card'</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ⊆ E›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?e ∈ F›</span></span></span><span> </span><span>disj</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_matching_def</span><span> </span><span>Int_commute</span><span> </span><span>disjnt_def</span><span> </span><span>pairwise_insert</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ⊆ E›</span></span></span><span> </span><span>vc'</span><span> </span><span>fC</span><span> </span><span>fe'</span><span> </span><span>m'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>approx_vertex_cover</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"VARS C F
  {True}
  C := {};
  F := E;
  WHILE F ≠ {}
  INV {invar C F}
  DO C := C ∪ some F;
     F := F - {e' ∈ F. some F ∩ e' ≠ {}}
  OD
  {vertex_cover E C ∧ (∀C'. finite C' ∧ vertex_cover E C' ⟶ card C ≤ 2 * card C')}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>vcg</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>C</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_matching {} E {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_matching_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span> </span><span>vertex_cover_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>C</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invar_step</span><span class="delimiter">[</span><span>of</span><span> </span><span>F</span><span> </span><span>C</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>C</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>post</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vertex_cover E C"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"matching M"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ⊆ E"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card C ≤ 2 * card M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span> </span><span>inv_matching_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>opt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card C ≤ 2 * card C'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>C'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite C'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vertex_cover E C'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>post</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card M ≤ 2 * card C'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_matching_vertex_cover</span><span class="delimiter">[</span><span>OF</span><span> </span><span>C'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>post</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>C'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card C ≤ 2 * card C'"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>post</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>opt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* locale Graph *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Version for Hypergraphs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Almost the same. We assume that the degree of every edge is bounded.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Bounded_Hypergraph</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>E</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>k</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite E"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>edge_bnd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ E ⟹ finite e ∧ card e ≤ k"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>E1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∉ E"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_matching C F M =
  (matching M ∧ M ⊆ E ∧ card C ≤ k * card M ∧ (∀e ∈ M. ∀f ∈ F. e ∩ f = {}))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'a set set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"invar C F = (F ⊆ E ∧ vertex_cover (E-F) C ∧ finite C ∧ (∃M. inv_matching C F M))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar C F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (C ∪ some F) (F - {e' ∈ F. some F ∩ e' ≠ {}})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F ⊆ E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vertex_cover (E-F) C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite C"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"matching M"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ⊆ E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>card</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card C ≤ k * card M"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>disj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀e ∈ M. ∀f ∈ F. e ∩ f = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span> </span><span>inv_matching_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?e</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"SOME e. e ∈ F"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?e ∈ F"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ≠ {}›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>some_in_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>fe'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ?e"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ⊆ E›</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>edge_bnd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?e ∉ M"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>E1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?e ∈ F›</span></span></span><span> </span><span>disj</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ⊆ E›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card (C ∪ ?e) ≤ k * card (insert ?e M)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?e ∈ F›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?e ∉ M›</span></span></span><span> </span><span>card_Un_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span class="var">?e</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ⊆ E›</span></span></span><span> </span><span>edge_bnd</span><span> </span><span>card</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>m</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>finE</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"M ∪ {?e}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vc'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vertex_cover (E - (F - {e' ∈ F. ?e ∩ e' ≠ {}})) (C ∪ ?e)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vertex_cover_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_matching (C ∪ ?e) (F - {e' ∈ F. ?e ∩ e' ≠ {}}) ?M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m</span><span> </span><span>card'</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ⊆ E›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?e ∈ F›</span></span></span><span> </span><span>disj</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_matching_def</span><span> </span><span>Int_commute</span><span> </span><span>disjnt_def</span><span> </span><span>pairwise_insert</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ⊆ E›</span></span></span><span> </span><span>vc'</span><span> </span><span>fC</span><span> </span><span>fe'</span><span> </span><span>m'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>approx_vertex_cover_bnd</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"VARS C F
  {True}
  C := {};
  F := E;
  WHILE F ≠ {}
  INV {invar C F}
  DO C := C ∪ some F;
     F := F - {e' ∈ F. some F ∩ e' ≠ {}}
  OD
  {vertex_cover E C ∧ (∀C'. finite C' ∧ vertex_cover E C' ⟶ card C ≤ k * card C')}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>vcg</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>C</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_matching {} E {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_matching_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span> </span><span>vertex_cover_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>C</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invar_step</span><span class="delimiter">[</span><span>of</span><span> </span><span>F</span><span> </span><span>C</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>C</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>post</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vertex_cover E C"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"matching M"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ⊆ E"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card C ≤ k * card M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span> </span><span>inv_matching_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>opt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card C ≤ k * card C'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>C'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite C'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vertex_cover E C'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>post</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k * card M ≤ k * card C'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_matching_vertex_cover</span><span class="delimiter">[</span><span>OF</span><span> </span><span>C'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>post</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>C'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card C ≤ k * card C'"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>post</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>opt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* locale Bounded_Hypergraph *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Approx_MIS_Hoare">
<div class="head"><h1>Theory Approx_MIS_Hoare</h1>
<span class="command">theory</span> <span class="name">Approx_MIS_Hoare</span><br/>
<span class="keyword">imports</span> <a href="Hoare_Logic.html"><span class="name">Hoare_Logic</span></a> <a href="Disjoint_Sets.html"><span class="name">Disjoint_Sets</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Independent Set"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Approx_MIS_Hoare</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Hoare.Hoare_Logic"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Disjoint_Sets"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The algorithm is classical, the proofs are inspired by the ones
by Berghammer and M\"uller-Olm \cite{BerghammerM03}.
In particular the approximation ratio is improved from ‹Δ+1› to ‹Δ›.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A set set is simply a set of edges, where an edge is a 2-element set.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>independent_vertices</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ 'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"independent_vertices E S ⟷ S ⊆ ⋃E ∧ (∀v1 v2. v1 ∈ S ∧ v2 ∈ S ⟶ {v1, v2} ∉ E)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Graph_E</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>E</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite_E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite E"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>edges2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ E ⟹ card e = 2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>vertices</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ 'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"vertices G = ⋃G"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>V</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"V ≡ vertices E"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>approximation_miv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"approximation_miv n S ⟷ independent_vertices E S ∧ (∀S'. independent_vertices E S' ⟶ card S' ≤ card S * n)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>neighbors</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"neighbors v = {u. {u,v} ∈ E}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>degree_vertex</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"degree_vertex v = card (neighbors v)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Δ</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"Δ ≡ Max{degree_vertex u|u. u ∈ V}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_edges</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ E ⟹ finite e"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_ge_0_finite</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>edges2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_edges</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>finite_E</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_neighbors</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (neighbors u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_V</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rev_finite_subset</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>V</span><span> </span><span class="string"><span class="delete"><span class="delete">"neighbors u"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>independent_vertices_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"independent_vertices E S ⟹ finite S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rev_finite_subset</span><span> </span><span>independent_vertices_def</span><span> </span><span>vertices.simps</span><span> </span><span>finite_V</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edge_ex_vertices</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ E ⟹ ∃u v. u ≠ v ∧ e = {u, v}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ E"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card e = Suc (Suc 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>edges2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃u v. u ≠ v ∧ e = {u, v}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>card_eq_SucD</span><span> </span><span>insertI1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Δ_pos</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E = {} ∨ 0 &lt; Δ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E = {} ∨ 0 &lt; Δ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>edges2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite {degree_vertex u |u. u ∈ V}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_V</span><span> </span><span>finite_imageI</span><span> </span><span>Setcompr_eq_image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ ∈ {degree_vertex u |u. u ∈ V}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Max_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ ≠ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"degree_vertex u = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ e"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>4</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v. {u, v} ≠ e"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_neighbors</span><span> </span><span>insert_absorb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>edge_ex_vertices</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E = {} ∨ 0 &lt; Δ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Δ_max_degree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V ⟹ degree_vertex u ≤ Δ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite {degree_vertex u |u. u ∈ V}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_V</span><span> </span><span>finite_imageI</span><span> </span><span>Setcompr_eq_image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>H</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"degree_vertex u ≤ Δ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Max_ge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Wei's algorithm: ‹(Δ+1)›-approximation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The 'functional' part of the invariant, used to prove that the algorithm produces an independent set of vertices.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv_iv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"inv_iv S X ⟷ independent_vertices E S
            ∧ X ⊆ V
            ∧ (∀v1 ∈ (V - X). ∀v2 ∈ S. {v1, v2} ∉ E)
            ∧ S ⊆ X"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Strenghten the invariant with an approximation ratio ‹r›:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv_approx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'a set ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"inv_approx S X r ⟷ inv_iv S X ∧ card X ≤ card S * r"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preservation of the functional invariant:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_preserv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_iv S X"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ V - X"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_iv (insert x S) (X ∪ neighbors x ∪ {x})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"independent_vertices E S"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ⊆ V"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ⊆ X"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v1 v2. v1 ∈ (V - X) ∧ v2 ∈ S ⟶ {v1, v2} ∉ E"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_iv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finite_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>independent_vertices_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y ∈ S. {x, y} ∉ E"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv4</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ S. ∀y ∈ S. {x, y} ∉ E"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>independent_vertices_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v1 ∈ insert x S ⟹ v2 ∈ insert x S ⟹ {v1, v2} ∉ E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>v1</span><span> </span><span>v2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v1 ∈ insert x S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v2 ∈ insert x S"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">consider</span></span><span>
</span><span>          </span><span class="delimiter">(</span><span>a</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"v1 = x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v2 = x"</span></span></span><span>
</span><span>        </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>b</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"v1 = x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v2 ∈ S"</span></span></span><span>
</span><span>        </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>c</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"v1 ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v2 = x"</span></span></span><span>
</span><span>        </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>d</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"v1 ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v2 ∈ S"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{v1, v2} ∉ E"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>edges2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>doubleton_eq_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>d</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* invariant conjunct 1 *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"independent_vertices E (insert x S)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S3</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>independent_vertices_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* invariant conjunct 2 *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∪ neighbors x ∪ {x} ⊆ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xa</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xa ∈ X ∪ neighbors x ∪ {x}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>a</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"xa ∈ X"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>b</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"xa ∈ neighbors x"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>c</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"xa = x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xa ∈ V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>a</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>c</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* invariant conjunct 3 *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"insert x S ⊆ X ∪ neighbors x ∪ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* invariant conjunct 4 *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v1 ∈ V - (X ∪ neighbors x ∪ {x}) ⟹ v2 ∈ insert x S ⟹ {v1, v2} ∉ E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>v1</span><span> </span><span>v2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v1 ∈ V - (X ∪ neighbors x ∪ {x})"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v2 ∈ insert x S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>a</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"v2 = x"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>b</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"v2 ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{v1, v2} ∉ E"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>a</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>H</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v1 ∉ neighbors v2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>H</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v1 ∈ V - X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv4</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* conclusion *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_iv (insert x S) (X ∪ neighbors x ∪ {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_iv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_approx_preserv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_approx S X (Δ + 1)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ V - X"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_approx (insert x S) (X ∪ neighbors x ∪ {x}) (Δ + 1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finite_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>independent_vertices_finite</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span>inv_iv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Sx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span>inv_iv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* main invariant is preserved *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_iv S X"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_iv (insert x S) (X ∪ neighbors x ∪ {x})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>inv_preserv</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* the approximation ratio is preserved (at most Δ+1 vertices are removed in any iteration) *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (X ∪ neighbors x ∪ {x}) ≤ card (insert x S) * (Δ + 1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"degree_vertex x ≤ Δ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Δ_max_degree</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (neighbors x ∪ {x}) ≤ Δ + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Un_le</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"neighbors x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (X ∪ neighbors x ∪ {x}) ≤ card X + Δ + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Un_le</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>X</span><span> </span><span class="string"><span class="delete"><span class="delete">"neighbors x ∪ {x}"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card S * (Δ + 1) + Δ + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = card (insert x S) * (Δ + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_S</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Sx</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* conclusion *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_approx (insert x S) (X ∪ neighbors x ∪ {x}) (Δ + 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* the antecedent combines inv_approx (for an arbitrary ratio r) and the negated post-condition *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_approx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"independent_vertices E S ⟹ card V ≤ card S * r ⟹ approximation_miv r S"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"independent_vertices E S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card V ≤ card S * r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"independent_vertices E S' ⟹ card S' ≤ card S * r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"independent_vertices E S'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S' ⊆ V"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>independent_vertices_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card S' ≤ card V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_V</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>card_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card S * r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card S' ≤ card S * r"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"approximation_miv r S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>approximation_miv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>wei_approx_Δ_plus_1</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"VARS (S :: 'a set) (X :: 'a set) (x :: 'a)
  { True }
  S := {};
  X := {};
  WHILE X ≠ V
  INV { inv_approx S X (Δ + 1) }
  DO x := (SOME x. x ∈ V - X);
     S := insert x S;
     X := X ∪ neighbors x ∪ {x}
  OD
  { approximation_miv (Δ + 1) S }"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>vcg</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>S</span><span> </span><span>X</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* invariant initially true *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span>inv_iv_def</span><span> </span><span>independent_vertices_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>S</span><span> </span><span>X</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* invariant preserved by loop *)</span></span></span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* definedness of assignment *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(SOME x. x ∈ V - X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V - X ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span>inv_iv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?x ∈ V - X"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>some_in_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_approx_preserv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>S</span><span> </span><span>X</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* invariant implies post-condition *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_approx</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span>inv_iv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Wei's algorithm: ‹Δ›-approximation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The previous approximation uses very little information about the optimal solution (it has at most as many vertices as the set itself). With some extra effort we can improve the ratio to ‹Δ› instead of ‹Δ+1›. In order to do that we must show that among the vertices removed in each iteration, at most ‹Δ› could belong to an optimal solution. This requires carrying around a set ‹P› (via a ghost variable) which records the vertices deleted in each iteration.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv_partition</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'a set ⇒ 'a set set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"inv_partition S X P ⟷ inv_iv S X
                     ∧ ⋃P = X
                     ∧ (∀p ∈ P. ∃s ∈ V. p = {s} ∪ neighbors s)
                     ∧ card P = card S
                     ∧ finite P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_partition_preserv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_partition S X P"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ V - X"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_partition (insert x S) (X ∪ neighbors x ∪ {x}) (insert ({x} ∪ neighbors x) P)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finite_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>independent_vertices_finite</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span>inv_iv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Sx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span>inv_iv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* main invariant is preserved *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_iv S X"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_iv (insert x S) (X ∪ neighbors x ∪ {x})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>inv_preserv</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* conjunct 1 *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃(insert ({x} ∪ neighbors x) P) = X ∪ neighbors x ∪ {x}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* conjunct 2 *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀p∈insert ({x} ∪ neighbors x) P. ∃s ∈ V. p = {s} ∪ neighbors s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* conjunct 3 *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (insert ({x} ∪ neighbors x) P) = card (insert x S)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x_def</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ ⋃P"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x} ∪ neighbors x ∉ P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (insert ({x} ∪ neighbors x) P) = card P + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (insert x S) = card S + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sx</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>finite_S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* conjunct 4 *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (insert ({x} ∪ neighbors x) P)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* conclusion *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_partition (insert x S) (X ∪ neighbors x ∪ {x}) (insert ({x} ∪ neighbors x) P)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_Union_le_sum_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>U</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u ∈ U. finite u"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (⋃U) ≤ sum card U"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite U"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (⋃U) ≤ sum card U"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_eq_0_iff</span><span> </span><span>finite_UnionD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (⋃U) ≤ sum card U"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>U</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>x</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card(⋃(insert x F)) ≤ card(x) + card (⋃F)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Un_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card(x) + sum card F"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insert.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = sum card (insert x F)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.insert_if</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>insert.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* this lemma could be more generally about U :: "nat set", but this makes its application more difficult later *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>U</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀S ∈ U. card S ≤ n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum card U ≤ card U * n"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"infinite U ∨ U = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum card U = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.infinite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum card U ≤ card U * n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(infinite U ∨ U = {})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite U"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U ≠ {}"</span></span></span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀S ∈ U. card S ≤ n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum card U ≤ card U * n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>U</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_ne_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>singleton</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>x</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀S∈insert x F. card S ≤ n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"card x ≤ n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"sum card F ≤ card F * n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insert.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum card (insert x F) = card x + sum card F"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.insert_if</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>insert.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ n + card F * n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = card (insert x F) * n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_insert_if</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>insert.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* among the vertices deleted in each iteration, at most Δ can belong to an independent set of
   vertices: the chosen vertex or (some of) its neighbors *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>x_or_neighbors</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>P</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p∈P. ∃s ∈ V. p = {s} ∪ neighbors s"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ivS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"independent_vertices E S"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p ∈ P. card (S ∩ p) ≤ Δ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ V ∧ p = {s} ∪ neighbors s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (S ∩ p) ≤ Δ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∩ neighbors s = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ivS</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>independent_vertices_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∩ p ⊆ {s}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card (S ∩ p) ≤ 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_singletonD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>a</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"E = {}"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>b</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; Δ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Δ_pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (S ∩ p) ≤ Δ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>a</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ivS</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>independent_vertices_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∉ S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∩ p ⊆ neighbors s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (S ∩ p) ≤ degree_vertex s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_mono</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>finite_neighbors</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (S ∩ p) ≤ Δ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Δ_max_degree</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* the premise combines the invariant and the negated post-condition *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_partition_approx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_partition S V P ⟹ approximation_miv Δ S"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>H1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_partition S V P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"independent_vertices E S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span>inv_iv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"independent_vertices E S' ⟹ card S' ≤ card S * Δ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?I</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{S' ∩ p | p. p ∈ P}"</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* split the optimal solution among the sets of P, which cover V so no element is
       lost. We obtain a cover of S' and show the required bound on its cardinality *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>H2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"independent_vertices E S'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S' ⊆ V"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>independent_vertices_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vertices.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>H1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S' = S' ∩ ⋃P"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S' = (⋃p ∈ P. S' ∩ p)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Int_Union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S' = ⋃?I"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>independent_vertices_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ P ⟹ finite (S' ∩ p)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card S' ≤ sum card ?I"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Union_le_sum_card</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?I</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card ?I * Δ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_or_neighbors</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>P</span><span> </span><span>S'</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sum_card</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?I</span><span> </span><span>Δ</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>H1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>H2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card P * Δ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card ?I ≤ card P"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Setcompr_eq_image</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λp. S' ∩ p"</span></span></span><span> </span><span>P</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>card_image_le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = card S * Δ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card S' ≤ card S * Δ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"approximation_miv Δ S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>approximation_miv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>wei_approx_Δ</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"VARS (S :: 'a set) (X :: 'a set) (x :: 'a)
  { True }
  S := {};
  X := {};
  WHILE X ≠ V
  INV { ∃P. inv_partition S X P }
  DO x := (SOME x. x ∈ V - X);
     S := insert x S;
     X := X ∪ neighbors x ∪ {x}
  OD
  { approximation_miv Δ S }"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>vcg</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>S</span><span> </span><span>X</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* invariant initially true *)</span></span></span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* the invariant is initially true with the ghost variable P := {} *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_partition {} {} {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span>inv_iv_def</span><span> </span><span>independent_vertices_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>S</span><span> </span><span>X</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* invariant preserved by loop *)</span></span></span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* definedness of assignment *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(SOME x. x ∈ V - X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_partition S X P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V - X ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_partition_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?x ∈ V - X"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>some_in_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* show that the invariant is true with the ghost variable P := insert ({?x} ∪ neighbors ?x) P *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_partition (insert ?x S) (X ∪ neighbors ?x ∪ {?x}) (insert ({?x} ∪ neighbors ?x) P)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_partition_preserv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>S</span><span> </span><span>X</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* invariant implies post-condition *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_partition_approx</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Wei's algorithm with dynamically computed approximation ratio"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In this subsection, we augment the algorithm with a variable used to compute the effective approximation ratio of the solution. In addition, the vertex of smallest degree is picked. With this heuristic, the algorithm achieves an approximation ratio of ‹(Δ+2)/3›, but this is not proved here.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vertex_heuristic</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"vertex_heuristic X v = (∀u ∈ V - X. card (neighbors v - X) ≤ card (neighbors u - X))"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* this lemma is needed to show that there exist a vertex to be picked by the heuristic *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ex_min_finite_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ nat"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S ⟹ S ≠ {} ⟹ ∃x. x ∈ S ∧ (∀y ∈ S. f x ≤ f y)"</span></span></span><span>
</span><span>          </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P1 ⟹ ?P2 ⟹ ∃x. ?minf S x"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>S</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_ne_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>singleton</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?minf {x} x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>x</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>insert</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Py</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?minf F y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z. ?minf (insert x F) z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x &lt; f y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?minf (insert x F) x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Py</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬f x &lt; f y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?minf (insert x F) y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Py</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_approx_preserv2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_approx S X s"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ V - X"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_approx (insert x S) (X ∪ neighbors x ∪ {x}) (max (card (neighbors x ∪ {x} - X)) s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finite_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>independent_vertices_finite</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span>inv_iv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Sx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span>inv_iv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* main invariant is preserved *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_iv S X"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_iv (insert x S) (X ∪ neighbors x ∪ {x})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>inv_preserv</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* the approximation ratio is preserved *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (X ∪ neighbors x ∪ {x}) ≤ card (insert x S) * max (card (neighbors x ∪ {x} - X)) s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?N</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"neighbors x ∪ {x} - X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (X ∪ ?N) ≤ card X + card ?N"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Un_le</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>X</span><span> </span><span class="var">?N</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card S * s + card ?N"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card S * max (card ?N) s + card ?N"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card S * max (card ?N) s + max (card ?N) s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = card (insert x S) * max (card ?N) s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sx</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>finite_S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* conclusion *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_approx (insert x S) (X ∪ neighbors x ∪ {x}) (max (card (neighbors x ∪ {x} - X)) s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>wei_approx_min_degree_heuristic</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"VARS (S :: 'a set) (X :: 'a set) (x :: 'a) (r :: nat)
  { True }
  S := {};
  X := {};
  r := 0;
  WHILE X ≠ V
  INV { inv_approx S X r }
  DO x := (SOME x. x ∈ V - X ∧ vertex_heuristic X x);
     S := insert x S;
     r := max (card (neighbors x ∪ {x} - X)) r;
     X := X ∪ neighbors x ∪ {x}
  OD
  { approximation_miv r S }"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>vcg</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>S</span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* invariant initially true *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span>inv_iv_def</span><span> </span><span>independent_vertices_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>S</span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* invariant preserved by loop *)</span></span></span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* definedness of assignment *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(SOME x. x ∈ V - X ∧ vertex_heuristic X x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V - X ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span>inv_iv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (V - X)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>finite_V</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. x ∈ V - X ∧ vertex_heuristic X x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_min_finite_set</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. card (neighbors x - X)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vertex_heuristic_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?x ∈ V - X ∧ vertex_heuristic X ?x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>someI_ex</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. x ∈ V - X ∧ vertex_heuristic X x"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_approx_preserv2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>S</span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_approx</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_approx_def</span><span> </span><span>inv_iv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Approx_LB_Hoare">
<div class="head"><h1>Theory Approx_LB_Hoare</h1>
<span class="command">theory</span> <span class="name">Approx_LB_Hoare</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Complex_Main.html"><span class="name">Complex_Main</span></a> <a href="Hoare_Logic.html"><span class="name">Hoare_Logic</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Load Balancing›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Approx_LB_Hoare</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Complex_Main</span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Hoare.Hoare_Logic"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This is formalization of the load balancing algorithms and proofs
in the book by Kleinberg and Tardos \cite{KleinbergT06}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>sorted</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: mv *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_le_card_Max</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ finite A; A ≠ {} ⟧ ⟹ sum f A ≤ card A * Max (f ` A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>A</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_ne_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>singleton</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>x</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>max_def</span><span> </span><span>order.trans</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"sum f F"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card F * Max (f ` F)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_const</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ finite A; A ≠ {} ⟧ ⟹ Max ((λ_. c) ` A) = c"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Max_in</span><span> </span><span>image_is_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Max<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat set ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"Max<span class="hidden">⇩</span><sub>0</sub> N ≡ (if N={} then 0 else Max N)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>f_Max<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ nat) ⇒ nat ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"f_Max<span class="hidden">⇩</span><sub>0</sub> f 0 = 0"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"f_Max<span class="hidden">⇩</span><sub>0</sub> f (Suc x) = max (f (Suc x)) (f_Max<span class="hidden">⇩</span><sub>0</sub> f x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_Max<span class="hidden">⇩</span><sub>0</sub>_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f_Max<span class="hidden">⇩</span><sub>0</sub> f n = Max<span class="hidden">⇩</span><sub>0</sub> (f ` {1..n})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>not_le</span><span> </span><span>atLeastAtMostSuc_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_Max<span class="hidden">⇩</span><sub>0</sub>_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..m}. T x ≤ f_Max<span class="hidden">⇩</span><sub>0</sub> T m"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"m &gt; 0 ⟹ ∃x ∈ {1..m}. T x = f_Max<span class="hidden">⇩</span><sub>0</sub> T m"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>atLeastAtMost_iff</span><span> </span><span>le_Suc_eq</span><span> </span><span>max.cobounded1</span><span> </span><span>max.coboundedI2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = 0›</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>max_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_Max<span class="hidden">⇩</span><sub>0</sub>_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"y ≤ T x ⟹ f_Max<span class="hidden">⇩</span><sub>0</sub> (T (x := y)) m ≤ f_Max<span class="hidden">⇩</span><sub>0</sub> T m"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"T x ≤ y ⟹ f_Max<span class="hidden">⇩</span><sub>0</sub> T m ≤ f_Max<span class="hidden">⇩</span><sub>0</sub> (T (x := y)) m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>m</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_Max<span class="hidden">⇩</span><sub>0</sub>_out_of_range</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∉ {1..k} ⟹ f_Max<span class="hidden">⇩</span><sub>0</sub> (T (x := y)) k = f_Max<span class="hidden">⇩</span><sub>0</sub> T k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fun_upd_f_Max<span class="hidden">⇩</span><sub>0</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {1..m}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T x ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f_Max<span class="hidden">⇩</span><sub>0</sub> (T (x := y)) m = max y (f_Max<span class="hidden">⇩</span><sub>0</sub> T m)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>m</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>LoadBalancing</span><span> </span><span class="delimiter">=</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Load Balancing *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>m_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m &gt; 0"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Formalization of a Correct Load Balancing›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lb</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ nat) ⇒ (nat ⇒ nat set) ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lb T A j = ((∀x ∈ {1..m}. ∀y ∈ {1..m}. x ≠ y ⟶ A x ∩ A y = {}) ― ‹No job is assigned to more than one machine›
             ∧ (⋃x ∈ {1..m}. A x) = {1..j} ― ‹Every job is assigned›
             ∧ (∀x ∈ {1..m}. (∑j ∈ A x. t j) = T x) ― ‹The processing times sum up to the correct load›)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>makespan</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ nat) ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"makespan T ≡ f_Max<span class="hidden">⇩</span><sub>0</sub> T m"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>makespan_def'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"makespan T = Max (T ` {1..m})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m_gt_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>f_Max<span class="hidden">⇩</span><sub>0</sub>_equiv</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma makespan_correct:
  "∀x ∈ {1..m}. T x ≤ makespan T m"
  "m &gt; 0 ⟹ ∃x ∈ {1..m}. T x = makespan T m"
   apply (induction m)
     apply simp_all
   apply (metis atLeastAtMost_iff le_Suc_eq max.cobounded1 max.coboundedI2)
  subgoal for m by (cases ‹m = 0›) (auto simp: max_def)
  done

lemma no_machines_lb_iff_no_jobs: "lb T A j 0 ⟷ j = 0"
  unfolding lb_def by auto

lemma machines_if_jobs: "⟦ lb T A j m; j &gt; 0 ⟧ ⟹ m &gt; 0"
  using no_machines_lb_iff_no_jobs by (cases m) auto
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>makespan_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..m}. T x ≤ makespan T"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃x ∈ {1..m}. T x = makespan T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_Max<span class="hidden">⇩</span><sub>0</sub>_correct</span><span> </span><span>m_gt_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lbE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..m}. ∀y ∈ {1..m}. x ≠ y ⟶ A x ∩ A y = {}"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"(⋃x ∈ {1..m}. A x) = {1..j}"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..m}. (∑y ∈ A x. t y) = T x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lb_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lbI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..m}. ∀y ∈ {1..m}. x ≠ y ⟶ A x ∩ A y = {}"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"(⋃x ∈ {1..m}. A x) = {1..j}"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..m}. (∑y ∈ A x. t y) = T x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lb_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>A_lb_finite</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {1..m}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (A x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>lbE</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span> </span><span>finite_UN</span><span> </span><span>finite_atLeastAtMost</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹A x› is pairwise disjoint for all ‹x ∈ {1..m}›, then the the sum over the sums of the
      individual ‹A x› is equal to the sum over the union of all ‹A x›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_sum_eq_sum_Un</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..m}. ∀y ∈ {1..m}. x ≠ y ⟶ A x ∩ A y = {}"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..m}. finite (A x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x ∈ {1..m}. (∑y ∈ A x. t y)) = (∑x ∈ (⋃y ∈ {1..m}. A y). t x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FINITE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (⋃x ∈ {1..m}. A x)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (A (Suc m))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..m}. A x ∩ A (Suc m) = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DISJNT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃x ∈ {1..m}. A x) ∩ (A (Suc m)) = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Union_disjoint</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x ∈ (⋃y ∈ {1..m}. A y). t x) + (∑x ∈ A (Suc m). t x)
      = (∑x ∈ ((⋃y ∈ {1..m}. A y) ∪ A (Suc m)). t x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.union_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FINITE</span><span> </span><span>DISJNT</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑x ∈ (⋃y ∈ {1..Suc m}. A y). t x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UN_insert</span><span> </span><span>image_Suc_lessThan</span><span> </span><span>image_insert</span><span> </span><span>inf_sup_aci</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>lessThan_Suc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹T› and ‹A› are a correct load balancing for ‹j› jobs and ‹m› machines, 
      then the sum of the loads has to be equal to the sum of the processing times of the jobs›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lb_impl_job_sum</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x ∈ {1..m}. T x) = (∑x ∈ {1..j}. t x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>lbrules</span><span> </span><span class="delimiter">=</span><span> </span><span>lbE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FINITE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..m}. finite (A x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x ∈ {1..m}. T x) = (∑x ∈ {1..m}. (∑y ∈ A x. t y))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑x ∈ {1..j}. t x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_sum_eq_sum_Un</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>FINITE</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lower Bounds for the Makespan›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹T› and ‹A› are a correct load balancing for ‹j› jobs and ‹m› machines, then the processing time
      of any job ‹x ∈ {1..j}› is a lower bound for the load of some machine ‹y ∈ {1..m}››</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>job_lower_bound_machine</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {1..j}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃y ∈ {1..m}. t x ≤ T y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>lbrules</span><span> </span><span class="delimiter">=</span><span> </span><span>lbE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃y ∈ {1..m}. x ∈ A y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ {1..m}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ A y"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (A y)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>y_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t x ≤ (∑x ∈ A y. t x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>member_le_sum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = T y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>y_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹As the load of any machine is a lower bound for the makespan, the processing time 
      of any job ‹x ∈ {1..j}› has to also be a lower bound for the makespan.
      Follows from @{thm [source] job_lower_bound_machine} and @{thm [source] makespan_correct}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>job_lower_bound_makespan</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {1..j}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t x ≤ makespan T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>job_lower_bound_machine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>makespan_correct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>le_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The makespan over ‹j› jobs is a lower bound for the makespan of any correct load balancing for ‹j› jobs.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_job_lower_bound_makespan</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Max<span class="hidden">⇩</span><sub>0</sub> (t ` {1..j}) ≤ makespan T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>job_lower_bound_makespan</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>job_dist_lower_bound_makespan</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x ∈ {1..j}. t x) / m ≤ makespan T"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x ∈ {1..j}. t x) ≤ m * makespan T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>lb_impl_job_sum</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sum_le_card_Max</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{1..m}"</span></span></span><span class="delimiter">]</span><span> </span><span>m_gt_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>makespan_def'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"real (∑x ∈ {1..j}. t x) ≤ real m * real (makespan T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>of_nat_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>field_simps</span><span> </span><span>m_gt_0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Greedy Approximation Algorithm›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This function will perform a linear scan from ‹k ∈ {1..m}› and return the index of the machine with minimum load assuming ‹m &gt; 0››</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>min<span class="hidden">⇩</span><sub>k</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ nat) ⇒ nat ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"min<span class="hidden">⇩</span><sub>k</sub> T 0 = 1"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"min<span class="hidden">⇩</span><sub>k</sub> T (Suc x) =
   (let k = min<span class="hidden">⇩</span><sub>k</sub> T x
    in if T (Suc x) &lt; T k then (Suc x) else k)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..m}. T (min<span class="hidden">⇩</span><sub>k</sub> T m) ≤ T x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>m</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>le_Suc_eq</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_in_range</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k &gt; 0 ⟹ (min<span class="hidden">⇩</span><sub>k</sub> T k) ∈ {1..k}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_job</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {1..m}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb (T (x := T x + t (Suc j))) (A (x := A x ∪ {Suc j})) (Suc j)"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lb ?T ?A _›</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>lbrules</span><span> </span><span class="delimiter">=</span><span> </span><span>lbE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 1: @{term ?A} pairwise disjoint›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NOTIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i ∈ {1..m}. Suc j ∉ A i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i ∈ {1..m}. i ≠ x ⟶ A i ∩ (A x ∪ {Suc j}) = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..m}. ∀y ∈ {1..m}. x ≠ y ⟶ ?A x ∩ ?A y = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 2: @{term ?A} contains all jobs›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃y ∈ {1..m}. ?A y) = (⋃y ∈ {1..m}. A y) ∪ {Suc j}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>UNION_fun_upd</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = {1..Suc j}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃y ∈ {1..m}. ?A y) = {1..Suc j}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 3: @{term ?A} sums to @{term ?T}›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i ∈ ?A x. t i) = (∑i ∈ A x ∪ {Suc j}. t i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A x ∩ {Suc j} = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOTIN</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (A x)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite {Suc j}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i ∈ ?A x. t i) = (∑i ∈ A x. t i) + (∑i ∈ {Suc j}. t i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.union_disjoint</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = T x + t (Suc j)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i ∈ ?A x. t i) = ?T x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i ∈ {1..m}. (∑j ∈ ?A i. t j) = ?T i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lbI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>makespan_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"y ≤ T x ⟹ makespan (T (x := y)) ≤ makespan T"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"T x ≤ y ⟹ makespan T ≤ makespan (T (x := y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_Max<span class="hidden">⇩</span><sub>0</sub>_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>smaller_optimum</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A (Suc j)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃T' A'. lb T' A' j ∧ makespan T' ≤ makespan T"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>lbrules</span><span> </span><span class="delimiter">=</span><span> </span><span>lbE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x ∈ {1..m}. Suc j ∈ A x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {1..m}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc j ∈ A x"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"T (x := T x - t (Suc j))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"A (x := A x - {Suc j})"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 1: @{term ?A} pairwise disjoint›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i ∈ {1..m}. i ≠ x ⟶ A i ∩ (A x - {Suc j}) = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..m}. ∀y ∈ {1..m}. x ≠ y ⟶ ?A x ∩ ?A y = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 2: @{term ?A} contains all jobs›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NOTIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i ∈ {1..m}. i ≠ x ⟶ Suc j ∉ A i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃y ∈ {1..m}. ?A y) = (⋃y ∈ {1..m}. A y) - {Suc j}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>UNION_fun_upd</span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = {1..j}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃y ∈ {1..m}. ?A y) = {1..j}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 3: @{term ?A} sums to @{term ?T}›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i ∈ A x - {Suc j}. t i) = (∑i ∈ A x. t i) - t (Suc j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_diff1_nat</span><span> </span><span>x_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = T x - t (Suc j)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>x_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i ∈ ?A x. t i) = ?T x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i ∈ {1..m}. (∑j ∈ ?A i. t j) = ?T i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>x_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹@{term makespan} is not larger›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb ?T ?A j ∧ makespan ?T ≤ makespan T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span class="delimiter">]</span><span> </span><span>makespan_mono</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If the processing time ‹y› does not contribute to the makespan, we can ignore it.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_small_job</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"makespan (T (x := T x + y)) ≠ T x + y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"makespan (T (x := T x + y)) = makespan T"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"T (x := T x + y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NOT_X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"makespan ?T ≠ ?T x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i ∈ {1..m}. makespan ?T = ?T i ∧ i ≠ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>makespan_correct</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ {1..m}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"makespan ?T = ?T i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≠ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?T i = T i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOT_X</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"makespan T = T i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>i_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>antisym_conv</span><span> </span><span>le_add1</span><span> </span><span>makespan_mono</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>makespan_correct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>greedy_makespan_no_jobs</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"makespan (λ_. 0) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m_gt_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>makespan_def'</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_avg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m * T (min<span class="hidden">⇩</span><sub>k</sub> T m) ≤ (∑i ∈ {1..m}. T i)"</span></span></span><span>
</span><span>           </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹_ * ?T ≤ ?S›</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑_ ∈ {1..m}. ?T) ≤ ?S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{1..m}›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹λ_. ?T›</span></span></span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>min_correct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ nat) ⇒ (nat ⇒ nat set) ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> T A j = (lb T A j ∧ j ≤ n ∧ (∀T' A'. lb T' A' j ⟶ makespan T ≤ 2 * makespan T'))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> T A j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ n"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"lb T' A' j ⟹ makespan T ≤ 2 * makespan T'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀T' A'. lb T' A' j ⟶ makespan T ≤ 2 * makespan T'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> T A j"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> T A j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> (T ((min<span class="hidden">⇩</span><sub>k</sub> T m) := T (min<span class="hidden">⇩</span><sub>k</sub> T m) + t (Suc j)))
              (A ((min<span class="hidden">⇩</span><sub>k</sub> T m) := A (min<span class="hidden">⇩</span><sub>k</sub> T m) ∪ {Suc j})) (Suc j)"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹inv<span class="hidden">⇩</span><sub>1</sub> ?T ?A _›</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="comment">― ‹Greedy is correct›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lb ?T ?A (Suc j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_job</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>min_in_range</span><span class="delimiter">[</span><span>OF</span><span> </span><span>m_gt_0</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="comment">― ‹Greedy maintains approximation factor›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MK</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀T' A'. lb T' A' (Suc j) ⟶ makespan ?T ≤ 2 * makespan T'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>rule</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>T<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>A<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T<span class="hidden">⇩</span><sub>1</sub> A<span class="hidden">⇩</span><sub>1</sub> (Suc j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>smaller_optimum</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span>A<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T<span class="hidden">⇩</span><sub>0</sub> A<span class="hidden">⇩</span><sub>0</sub> j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"makespan T<span class="hidden">⇩</span><sub>0</sub> ≤ makespan T<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"makespan T ≤ 2 * makespan T<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"makespan ?T ≤ 2 * makespan T<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹makespan ?T = T (min<span class="hidden">⇩</span><sub>k</sub> T m) + t (Suc j)›</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m * T (min<span class="hidden">⇩</span><sub>k</sub> T m) ≤ (∑i ∈ {1..m}. T i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>min_avg</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i ∈ {1..j}. t i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lb_impl_job_sum</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"real m * T (min<span class="hidden">⇩</span><sub>k</sub> T m) ≤ (∑i ∈ {1..j}. t i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>of_nat_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>m_gt_0</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T (min<span class="hidden">⇩</span><sub>k</sub> T m) ≤ (∑i ∈ {1..j}. t i) / m"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T (min<span class="hidden">⇩</span><sub>k</sub> T m) ≤ makespan T<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>job_dist_lower_bound_makespan</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lb T<span class="hidden">⇩</span><sub>0</sub> A<span class="hidden">⇩</span><sub>0</sub> j›</span></span></span><span class="delimiter">]</span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹makespan T<span class="hidden">⇩</span><sub>0</sub> ≤ makespan T<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t (Suc j) ≤ makespan T<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>job_lower_bound_makespan</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lb T<span class="hidden">⇩</span><sub>1</sub> A<span class="hidden">⇩</span><sub>1</sub> (Suc j)›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remove_small_job</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>LB</span><span> </span><span>_</span><span> </span><span>MK</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>simple_greedy_approximation</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"VARS T A i j
{True}
T := (λ_. 0);
A := (λ_. {});
j := 0;
WHILE j &lt; n INV {inv<span class="hidden">⇩</span><sub>1</sub> T A j} DO
  i := min<span class="hidden">⇩</span><sub>k</sub> T m;
  j := (Suc j);
  A := A (i := A(i) ∪ {j});
  T := T (i := T(i) + t j)
OD
{lb T A n ∧ (∀T' A'. lb T' A' n ⟶ makespan T ≤ 2 * makespan T')}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>vcg</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>T</span><span> </span><span>A</span><span> </span><span>i</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lb_def</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>T</span><span> </span><span>A</span><span> </span><span>i</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>T</span><span> </span><span>A</span><span> </span><span>i</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sorted</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sorted j = (∀x ∈ {1..j}. ∀y ∈ {1..x}. t x ≤ t y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_smaller</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ sorted j; j ≥ j' ⟧ ⟹ sorted j'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sorted_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>j_gt_m_pigeonhole</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &gt; m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x ∈ {1..j}. ∃y ∈ {1..j}. ∃z ∈ {1..m}. x ≠ y ∧ x ∈ A z ∧ y ∈ A z"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..j}. ∃y ∈ {1..m}. x ∈ A y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbE</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. ∀x ∈ {1..j}. x ∈ A (f x) ∧ f x ∈ {1..m}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ {1..j}. x ∈ A (f x) ∧ f x ∈ {1..m}"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (f ` {1..j}) ≤ card {1..m}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>card_mono</span><span> </span><span>finite_atLeastAtMost</span><span> </span><span>image_subset_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... &lt; card {1..j}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (f ` {1..j}) &lt; card {1..j}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ inj_on f {1..j}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pigeonhole</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x ∈ {1..j}. ∃y ∈ {1..j}. x ≠ y ∧ f x = f y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inj_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹T› and ‹A› are a correct load balancing for ‹j› jobs and ‹m› machines with ‹j &gt; m›,
      and the jobs are sorted in descending order, then there exists a machine ‹x ∈ {1..m}›
      whose load is at least twice as large as the processing time of job ‹j›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_job_lower_bound_machine</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &gt; m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x ∈ {1..m}. 2 * t j ≤ T x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="comment">― ‹Step 1: Obtaining the jobs›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>lbrules</span><span> </span><span class="delimiter">=</span><span> </span><span>lbE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>j<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>*</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"j<span class="hidden">⇩</span><sub>1</sub> ∈ {1..j}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j<span class="hidden">⇩</span><sub>2</sub> ∈ {1..j}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {1..m}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j<span class="hidden">⇩</span><sub>1</sub> ≠ j<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j<span class="hidden">⇩</span><sub>1</sub> ∈ A x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j<span class="hidden">⇩</span><sub>2</sub> ∈ A x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_gt_m_pigeonhole</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Step 2: Jobs contained in sum›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (A x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>*</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SUM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i ∈ A x. t i) = t j<span class="hidden">⇩</span><sub>1</sub> + t j<span class="hidden">⇩</span><sub>2</sub> + (∑i ∈ A x - {j<span class="hidden">⇩</span><sub>1</sub>} - {j<span class="hidden">⇩</span><sub>2</sub>}. t i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span class="delimiter">(</span><span>4</span><span>-</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum.remove</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Step 3: Proof of lower bound›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t j ≤ t j<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t j ≤ t j<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>*</span><span class="delimiter">(</span><span>1</span><span>-</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sorted_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * t j ≤ t j<span class="hidden">⇩</span><sub>1</sub> + t j<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ (∑i ∈ A x. t i)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SUM</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * t j ≤ T x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbrules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>*</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Reasoning analogous to @{thm [source] job_lower_bound_makespan}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_job_lower_bound_makespan</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &gt; m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * t j ≤ makespan T"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {1..m}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * t j ≤ T x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sorted_job_lower_bound_machine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>makespan_correct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T x ≤ makespan T"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_zero</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {1..k}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T (min<span class="hidden">⇩</span><sub>k</sub> T k) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = Suc k›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T (min<span class="hidden">⇩</span><sub>k</sub> T k) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_zero_index</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {1..k}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min<span class="hidden">⇩</span><sub>k</sub> T k ≤ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = Suc k›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_in_range</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc k"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {1..k}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>min_zero</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Suc.IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ nat) ⇒ (nat ⇒ nat set) ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> T A j = (lb T A j ∧ j ≤ n
                ∧ (∀T' A'. lb T' A' j ⟶ makespan T ≤ 3 / 2 * makespan T') 
                ∧ (∀x &gt; j. T x = 0)
                ∧ (j ≤ m ⟶ makespan T = Max<span class="hidden">⇩</span><sub>0</sub> (t ` {1..j})))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> T A j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ n"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"lb T' A' j ⟹ makespan T ≤ 3 / 2 * makespan T'"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"∀x &gt; j. T x = 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ m ⟹ makespan T = Max<span class="hidden">⇩</span><sub>0</sub> (t ` {1..j})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T A j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ n"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀T' A'. lb T' A' j ⟶ makespan T ≤ 3 / 2 * makespan T'"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀x &gt; j. T x = 0"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"j ≤ m ⟹ makespan T = Max<span class="hidden">⇩</span><sub>0</sub> (t ` {1..j})"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> T A j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> T A j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> (T (min<span class="hidden">⇩</span><sub>k</sub> T m := T(min<span class="hidden">⇩</span><sub>k</sub> T m) + t(Suc j)))
              (A (min<span class="hidden">⇩</span><sub>k</sub> T m := A(min<span class="hidden">⇩</span><sub>k</sub> T m) ∪ {Suc j})) (Suc j)"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹inv<span class="hidden">⇩</span><sub>2</sub> ?T ?A _›</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Suc j &gt; m›</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="comment">― ‹Greedy is correct›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lb ?T ?A (Suc j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_job</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>min_in_range</span><span class="delimiter">[</span><span>OF</span><span> </span><span>m_gt_0</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="comment">― ‹Greedy maintains approximation factor›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MK</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀T' A'. lb T' A' (Suc j) ⟶ makespan ?T ≤ 3 / 2 * makespan T'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>rule</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>T<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>A<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T<span class="hidden">⇩</span><sub>1</sub> A<span class="hidden">⇩</span><sub>1</sub> (Suc j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>smaller_optimum</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span>A<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lb T<span class="hidden">⇩</span><sub>0</sub> A<span class="hidden">⇩</span><sub>0</sub> j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"makespan T<span class="hidden">⇩</span><sub>0</sub> ≤ makespan T<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"makespan T ≤ 3 / 2 * makespan T<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"makespan ?T ≤ 3 / 2 * makespan T<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹makespan ?T = T (min<span class="hidden">⇩</span><sub>k</sub> T m) + t (Suc j)›</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m * T (min<span class="hidden">⇩</span><sub>k</sub> T m) ≤ (∑i ∈ {1..m}. T i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>min_avg</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i ∈ {1..j}. t i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lb_impl_job_sum</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"real m * T (min<span class="hidden">⇩</span><sub>k</sub> T m) ≤ (∑i ∈ {1..j}. t i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>of_nat_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>m_gt_0</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T (min<span class="hidden">⇩</span><sub>k</sub> T m) ≤ (∑i ∈ {1..j}. t i) / m"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T (min<span class="hidden">⇩</span><sub>k</sub> T m) ≤ makespan T<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>job_dist_lower_bound_makespan</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lb T<span class="hidden">⇩</span><sub>0</sub> A<span class="hidden">⇩</span><sub>0</sub> j›</span></span></span><span class="delimiter">]</span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹makespan T<span class="hidden">⇩</span><sub>0</sub> ≤ makespan T<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * t (Suc j) ≤ makespan T<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sorted_job_lower_bound_makespan</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lb T<span class="hidden">⇩</span><sub>1</sub> A<span class="hidden">⇩</span><sub>1</sub> (Suc j)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Suc j &gt; m›</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remove_small_job</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x &gt; Suc j. ?T x = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>min_in_range</span><span class="delimiter">[</span><span>OF</span><span> </span><span>m_gt_0</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>LB</span><span> </span><span>_</span><span> </span><span>MK</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IN_RANGE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc j ∈ {1..m}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T (Suc j) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Greedy is correct›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lb ?T ?A (Suc j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_job</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>min_in_range</span><span class="delimiter">[</span><span>OF</span><span> </span><span>m_gt_0</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Greedy is trivially optimal›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IN_RANGE</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹T (Suc j) = 0›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min<span class="hidden">⇩</span><sub>k</sub> T m ≤ Suc j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_zero_index</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>EMPTY</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x &gt; Suc j. ?T x = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IN_RANGE</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹T (Suc j) = 0›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T (min<span class="hidden">⇩</span><sub>k</sub> T m) = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_zero</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fun_upd_f_Max<span class="hidden">⇩</span><sub>0</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_in_range</span><span class="delimiter">[</span><span>OF</span><span> </span><span>m_gt_0</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>TRIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"makespan ?T = Max<span class="hidden">⇩</span><sub>0</sub> (t ` {1..Suc j})"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_Max<span class="hidden">⇩</span><sub>0</sub>_equiv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MK</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀T' A'. lb T' A' (Suc j) ⟶ makespan ?T ≤ 3 / 2 * makespan T'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>TRIV</span><span class="delimiter">[</span><span>folded</span><span> </span><span>f_Max<span class="hidden">⇩</span><sub>0</sub>_equiv</span><span class="delimiter">]</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>max_job_lower_bound_makespan</span><span class="delimiter">[</span><span>folded</span><span> </span><span>f_Max<span class="hidden">⇩</span><sub>0</sub>_equiv</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>LB</span><span> </span><span>_</span><span> </span><span>MK</span><span> </span><span>EMPTY</span><span> </span><span>TRIV</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_greedy_approximation</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"sorted n ⟹ VARS T A i j
{True}
T := (λ_. 0);
A := (λ_. {});
j := 0;
WHILE j &lt; n INV {inv<span class="hidden">⇩</span><sub>2</sub> T A j} DO
  i := min<span class="hidden">⇩</span><sub>k</sub> T m;
  j := (Suc j);
  A := A (i := A(i) ∪ {j});
  T := T (i := T(i) + t j)
OD
{lb T A n ∧ (∀T' A'. lb T' A' n ⟶ makespan T ≤ 3 / 2 * makespan T')}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>vcg</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>T</span><span> </span><span>A</span><span> </span><span>i</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lb_def</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>T</span><span> </span><span>A</span><span> </span><span>i</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>T</span><span> </span><span>A</span><span> </span><span>i</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* LoadBalancing *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Theory *)</span></span></span></span></span></pre>
</div>
</div><div id="Approx_BP_Hoare">
<div class="head"><h1>Theory Approx_BP_Hoare</h1>
<span class="command">theory</span> <span class="name">Approx_BP_Hoare</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Complex_Main.html"><span class="name">Complex_Main</span></a> <a href="Hoare_Logic.html"><span class="name">Hoare_Logic</span></a> <a href="Disjoint_Sets.html"><span class="name">Disjoint_Sets</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Bin Packing›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Approx_BP_Hoare</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Complex_Main</span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Hoare.Hoare_Logic"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Disjoint_Sets"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The algorithm and proofs are based on the work by Berghammer and Reuter @{cite BerghammerR03}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Formalization of a Correct Bin Packing›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of the unary operator ‹⟦⋅⟧› from the article.
      ‹B› will only be wrapped into a set if it is non-empty.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wrap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'a set set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wrap B = (if B = {} then {} else {B})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wrap_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"card (wrap B) ≤ 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹M› and ‹N› are pairwise disjoint with ‹V› and not yet contained in V,
      then the union of ‹M› and ‹N› is also pairwise disjoint with ‹V›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pairwise_disjnt_Un</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt ({M} ∪ {N} ∪ V)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ∉ V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N ∉ V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt ({M ∪ N} ∪ V)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pairwise_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A Bin Packing Problem is defined like in the article:›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>BinPacking</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>U</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span> </span><span class="comment">― ‹A finite, non-empty set of objects›</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ real"</span></span></span><span> </span><span class="comment">― ‹A mapping from objects to their respective weights (positive real numbers)›</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="comment">― ‹The maximum capacity of a bin (a natural number)›</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span> </span><span class="comment">― ‹The set of ‹small› objects (weight no larger than ‹1/2› of ‹c›)›</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span> </span><span class="comment">― ‹The set of ‹large› objects (weight larger than ‹1/2› of ‹c›)›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>weight</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u ∈ U. 0 &lt; w(u) ∧ w(u) ≤ c"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U_Finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite U"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U_NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U ≠ {}"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S = {u ∈ U. w(u) ≤ c / 2}"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"L = U - S"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In the article, this is defined as ‹w› as well. However, to avoid ambiguity,
      we will abbreviate the weight of a bin as ‹W›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>W</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"W B ≡ (∑u ∈ B. w(u))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹‹P› constitutes as a correct bin packing if ‹P› is a partition of ‹U›
      (as defined in @{thm [source] partition_on_def}) and the weights of
      the bins do not exceed their maximum capacity ‹c›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bp P ⟷ partition_on U P ∧ (∀B ∈ P. W(B) ≤ c)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bpE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∉ P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃P = U"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P. W(B) ≤ c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bp_def</span><span> </span><span>partition_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bpI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∉ P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃P = U"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P. W(B) ≤ c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bp_def</span><span> </span><span>partition_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Although we assume the ‹S› and ‹L› sets as given, manually obtaining them from ‹U› is trivial
      and can be achieved in linear time. Proposed by the article @{cite "BerghammerR03"}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_L_set_generation</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"VARS S L W u
  {True}
  S := {}; L := {}; W := U;
  WHILE W ≠ {}
  INV {W ⊆ U ∧ S = {v ∈ U - W. w(v) ≤ c / 2} ∧ L = {v ∈ U - W. w(v) &gt; c / 2}} DO
    u := (SOME u. u ∈ W);
    IF 2 * w(u) ≤ c
    THEN S := S ∪ {u}
    ELSE L := L ∪ {u} FI;
    W := W - {u}
  OD
  {S = {v ∈ U. w(v) ≤ c / 2} ∧ L = {v ∈ U. w(v) &gt; c / 2}}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>some_in_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Proposed Approximation Algorithm›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Functional Correctness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹According to the article, ‹inv<span class="hidden">⇩</span><sub>1</sub>› holds if ‹P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V}›
      is a correct solution for the bin packing problem @{cite BerghammerR03}. However, various
      assumptions made in the article seem to suggest that more information is demanded from this
      invariant and, indeed, mere correctness (as defined in @{thm [source] bp_def}) does not appear to suffice.
      To amend this, four additional conjuncts have been added to this invariant, whose necessity
      will be explained in the following proofs. It should be noted that there may be other (shorter) ways to amend this invariant.
      This approach, however, makes for rather straight-forward proofs, as these conjuncts can be utilized and proved in relatively few steps.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ 'a set set ⇒ 'a set ⇒ 'a set ⇒ 'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V ⟷ bp (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V}) ― ‹A correct solution to the bin packing problem›
                       ∧ ⋃(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = U - V ― ‹The partial solution does not contain objects that have not yet been assigned›
                       ∧ B<span class="hidden">⇩</span><sub>1</sub> ∉ (P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ― ‹‹B<span class="hidden">⇩</span><sub>1</sub>› is distinct from all the other bins›
                       ∧ B<span class="hidden">⇩</span><sub>2</sub> ∉ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub>) ― ‹‹B<span class="hidden">⇩</span><sub>2</sub>› is distinct from all the other bins›
                       ∧ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) ∩ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = {} ― ‹The first and second partial solutions are disjoint from each other.›"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma "partition_on U (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V}) ⟹ u ∈ V ⟹
partition_on U (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (insert u B<span class="hidden">⇩</span><sub>1</sub>) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ (V-{u})})"
  nitpick*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V})"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = U - V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ∉ (P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ∉ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) ∩ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V})"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = U - V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ∉ (P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ∉ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) ∩ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wrap_Un</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wrap (M ∪ {x}) = {M ∪ {x}}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wrap_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wrap {} = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wrap_not_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M ≠ {} ⟷ wrap M = {M}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹inv<span class="hidden">⇩</span><sub>1</sub>› holds for the current partial solution, and the weight of an object ‹u ∈ V› added to ‹B<span class="hidden">⇩</span><sub>1</sub>› does
      not exceed its capacity, then ‹inv<span class="hidden">⇩</span><sub>1</sub>› also holds if ‹B<span class="hidden">⇩</span><sub>1</sub>› and ‹{u}› are replaced by ‹B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepA</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W(B<span class="hidden">⇩</span><sub>1</sub>) + w(u) ≤ c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) B<span class="hidden">⇩</span><sub>2</sub> (V - {u})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bprules</span><span> </span><span class="delimiter">=</span><span> </span><span>bpE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In the proof for ‹Theorem 3.2› of the article it is erroneously argued that
        if ‹P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V}› is a partition of ‹U›,
        then the same holds if ‹B<span class="hidden">⇩</span><sub>1</sub>› is replaced by ‹B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}›.
        This is, however, not necessarily the case if ‹B<span class="hidden">⇩</span><sub>1</sub>› or ‹{u}› are already contained in the partial solution.
        Suppose ‹P<span class="hidden">⇩</span><sub>1</sub>› contains the non-empty bin ‹B<span class="hidden">⇩</span><sub>1</sub>›, then ‹P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>› would still be pairwise disjoint, provided ‹P<span class="hidden">⇩</span><sub>1</sub>› was pairwise disjoint before, as the union simply ignores the duplicate ‹B<span class="hidden">⇩</span><sub>1</sub>›. Now, if the algorithm modifies ‹B<span class="hidden">⇩</span><sub>1</sub>› by adding an element from ‹V› such that ‹B<span class="hidden">⇩</span><sub>1</sub>› becomes some non-empty ‹B<span class="hidden">⇩</span><sub>1</sub>'› with ‹B<span class="hidden">⇩</span><sub>1</sub> ∩ B<span class="hidden">⇩</span><sub>1</sub>' ≠ ∅› and ‹B<span class="hidden">⇩</span><sub>1</sub>' ∉ P<span class="hidden">⇩</span><sub>1</sub>›, one can see that this property would no longer be preserved.
        To avoid such a situation, we will use the first additional conjunct in ‹inv<span class="hidden">⇩</span><sub>1</sub>› to ensure that ‹{u}›
        is not yet contained in the partial solution, and the second additional conjunct to ensure that ‹B<span class="hidden">⇩</span><sub>1</sub>›
        is not yet contained in the partial solution.›</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 1: Pairwise Disjoint›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NOTIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀M ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}. u ∉ M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{{v} |v. v ∈ V} = {{u}} ∪ {{v} |v. v ∈ V - {u}}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ ({{u}} ∪ {{v} |v. v ∈ V - {u}}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{u}} ∪ P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{u}} ∪ (P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt ({B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}} ∪ (P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>1</sub> = {}›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assm</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt ({B<span class="hidden">⇩</span><sub>1</sub>} ∪ {{u}} ∪ (P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{u} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pairwise_disjnt_Un</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assm</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_Un</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 2: No empty sets›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 3: Union preserved›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{u}} ∪ {{v} |v. v ∈ V - {u}}) = U"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}) = U"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 4: Weights below capacity›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; w u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>U_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>1</sub> = {}›</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ≤ W B<span class="hidden">⇩</span><sub>1</sub> + w u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; w u›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ∈ B<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>insert_absorb</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}). W B ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_Un</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}. W B ≤ c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}. W B ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bpI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bp (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}})"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Auxiliary information is preserved›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ U"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U - (V - {u}) = U - V ∪ {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = ⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ {u}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = U - (V - {u})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ∪ {u} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u})) ∩ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_Un</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span>5</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹inv<span class="hidden">⇩</span><sub>1</sub>› holds for the current partial solution, and the weight of an object ‹u ∈ V› added to ‹B<span class="hidden">⇩</span><sub>2</sub>› does
      not exceed its capacity, then ‹inv<span class="hidden">⇩</span><sub>1</sub>› also holds if ‹B<span class="hidden">⇩</span><sub>2</sub>› and ‹{u}› are replaced by ‹B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepB</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>2</sub> + w u ≤ c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) P<span class="hidden">⇩</span><sub>2</sub> {} (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) (V - {u})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bprules</span><span> </span><span class="delimiter">=</span><span> </span><span>bpE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The argumentation here is similar to the one in @{thm [source] inv<span class="hidden">⇩</span><sub>1</sub>_stepA} with
      ‹B<span class="hidden">⇩</span><sub>1</sub>› replaced with ‹B<span class="hidden">⇩</span><sub>2</sub>› and using the first and third additional conjuncts of ‹inv<span class="hidden">⇩</span><sub>1</sub>›
      to amend the issue, instead of the first and second.›</span></span></span><span>
</span><span>  </span><span class="comment">― ‹Rule 1: Pairwise Disjoint›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NOTIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀M ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}. u ∉ M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{{v} |v. v ∈ V} = {{u}} ∪ {{v} |v. v ∈ V - {u}}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{u}} ∪ {{v} |v. v ∈ V - {u}})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{u}} ∪ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_assoc</span><span> </span><span>Un_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt ({B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}} ∪ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>2</sub> = {}›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assm</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt ({B<span class="hidden">⇩</span><sub>2</sub>} ∪ {{u}} ∪ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{u} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pairwise_disjnt_Un</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assm</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) ∪ {{v} |v. v ∈ V - {u}})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_Un</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 2: No empty sets›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) ∪ {{v} |v. v ∈ V - {u}}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 3: Union preserved›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{u}} ∪ {{v} |v. v ∈ V - {u}}) = U"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) ∪ {{v} |v. v ∈ V - {u}}) = U"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 4: Weights below capacity›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; w u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>U_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>2</sub> = {}›</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) ≤ W B<span class="hidden">⇩</span><sub>2</sub> + w u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; w u›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ∈ B<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>insert_absorb</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}). W B ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_Un</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}. W B ≤ c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) ∪ {{v} |v. v ∈ V - {u}}. W B ≤ c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bpI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bp (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) ∪ {{v} |v. v ∈ V - {u}})"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Auxiliary information is preserved›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ U"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U - (V - {u}) = U - V ∪ {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u})) = ⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ {u}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u})) = U - (V - {u})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ∪ {u} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {}) ∩ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u})) = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_empty</span><span> </span><span>wrap_Un</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span>5</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹inv<span class="hidden">⇩</span><sub>1</sub>› holds for the current partial solution, then ‹inv<span class="hidden">⇩</span><sub>1</sub>› also holds if ‹B<span class="hidden">⇩</span><sub>1</sub>› and ‹B<span class="hidden">⇩</span><sub>2</sub>› are
      added to ‹P<span class="hidden">⇩</span><sub>1</sub>› and ‹P<span class="hidden">⇩</span><sub>2</sub>› respectively, ‹B<span class="hidden">⇩</span><sub>1</sub>› is emptied and ‹B<span class="hidden">⇩</span><sub>2</sub>› initialized with ‹u ∈ V›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) {} {u} (V - {u})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="comment">― ‹Rule 1-4: Correct Bin Packing›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ wrap {u} ∪ {{v} |v. v ∈ V - {u}}
      = P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{u}} ∪ {{v} |v. v ∈ V - {u}}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Un_assoc</span><span> </span><span>Un_empty_right</span><span> </span><span>insert_not_empty</span><span> </span><span>wrap_empty</span><span> </span><span>wrap_not_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>EQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ wrap {u} ∪ {{v} |v. v ∈ V - {u}}
                  = P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bp (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ wrap {u} ∪ {{v} |v. v ∈ V - {u}})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>EQ</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Auxiliary information is preserved›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NOTIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀M ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}. u ∉ M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ U"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U - (V - {u}) = U - V ∪ {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ wrap {u}) = ⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ∪ {u}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ wrap {u}) = U - (V - {u})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ wrap {u}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{u} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {}) ∩ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ wrap {u}) = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span>5</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A simplified version of the bin packing algorithm proposed in the article.
      It serves as an introduction into the approach taken, and, while it does not provide the desired
      approximation factor, it does ensure that ‹P› is a correct solution of the bin packing problem.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>simple_bp_correct</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"VARS P P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V u
  {True}
  P<span class="hidden">⇩</span><sub>1</sub> := {}; P<span class="hidden">⇩</span><sub>2</sub> := {}; B<span class="hidden">⇩</span><sub>1</sub> := {}; B<span class="hidden">⇩</span><sub>2</sub> := {}; V := U;
  WHILE V ∩ S ≠ {} INV {inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V} DO
    u := (SOME u. u ∈ V); V := V - {u};
    IF W(B<span class="hidden">⇩</span><sub>1</sub>) + w(u) ≤ c
    THEN B<span class="hidden">⇩</span><sub>1</sub> := B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}
    ELSE IF W(B<span class="hidden">⇩</span><sub>2</sub>) + w(u) ≤ c
         THEN B<span class="hidden">⇩</span><sub>2</sub> := B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}
         ELSE P<span class="hidden">⇩</span><sub>2</sub> := P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>; B<span class="hidden">⇩</span><sub>2</sub> := {u} FI;
         P<span class="hidden">⇩</span><sub>1</sub> := P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>; B<span class="hidden">⇩</span><sub>1</sub> := {} FI
  OD;
  P := P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} | v. v ∈ V}
  {bp P}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>vcg</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>P</span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>V</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bp_def</span><span> </span><span>partition_on_def</span><span> </span><span>pairwise_def</span><span> </span><span>wrap_def</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>P</span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>V</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(SOME u. u ∈ V) ∈ V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>some_in_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepA</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span> </span><span>IN</span><span class="delimiter">]</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepB</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span> </span><span>IN</span><span class="delimiter">]</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepC</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span> </span><span>IN</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>P</span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>V</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lower Bounds for the Bin Packing Problem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bp_bins_finite</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P. finite B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>U_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Sup_upper</span><span> </span><span>finite_subset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bp_sol_finite</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>U_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>finite_UnionD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹P› is a solution of the bin packing problem, then no bin in ‹P› may contain more than
      one large object.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>only_one_L_per_bin</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∈ P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ B. ∀y ∈ B. x ≠ y ⟶ x ∉ L ∨ y ∉ L"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x∈B. ∃y∈B. x ≠ y ∧ x ∈ L ∧ y ∈ L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ L"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; w x + w y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_def</span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ B - {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B = W (B - {x}) + w x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite B›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum.remove</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = W (B - {x} - {y}) + w x + w y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ B - {x}›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite B›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum.remove</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"W B = W (B - {x} - {y}) + w x + w y"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u ∈ B. 0 &lt; w u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>weight</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ W (B - {x} - {y})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>DiffD1</span><span> </span><span>sum_nonneg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; W B"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c &lt; w x + w y›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹P› is a solution of the bin packing problem, then the amount of large objects
      is a lower bound for the amount of bins in P.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>L_lower_bound_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card L ≤ card P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ L. ∃B ∈ P. x ∈ B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>L_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u ∈ L. u ∈ f u ∧ f u ∈ P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inj_on f L"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inj_on_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>only_one_L_per_bin</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card L = card (f ` L)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` L ⊆ P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (f ` L) ≤ card P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>card_eq</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹P› is a solution of the bin packing problem, then the amount of bins of a subset of P
      in which every bin contains a large object is a lower bound on the amount of large objects.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subset_bp_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ⊆ P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ M. B ∩ L ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card M ≤ card L"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ M. ∃u ∈ L. u ∈ B"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. ∀B ∈ M. f B ∈ L ∧ f B ∈ B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ M. f B ∈ L ∧ f B ∈ B"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inj_on f M"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ inj_on f M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x ∈ M. ∃y ∈ M. x ≠ y ∧ f x = f y"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inj_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ M"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ M"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x = f y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃u. u ∈ x ∧ u ∈ y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∩ y ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt M"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pairwise_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bpE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pairwise_def</span><span> </span><span>disjnt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_def</span><span> </span><span>U_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` M ⊆ L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_inj_on_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹P› is a correct solution of the bin packing problem, ‹inv<span class="hidden">⇩</span><sub>1</sub>› holds for the partial solution,
      and every bin in ‹P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>› contains a large object, then the amount of bins in
      ‹P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ V ∩ L}› is a lower bound for the amount of bins in ‹P›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>L_bins_lower_bound_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. B ∩ L ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ V ∩ L}) ≤ card P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ {{v} |v. v ∈ V ∩ L}. B ∩ L ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ V ∩ L} ⊆ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ V ∩ L}. B ∩ L ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subset_bp_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹P› is a correct solution of the bin packing problem, then the sum of the weights of the
      objects is equal to the sum of the weights of the bins in ‹P›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_Un_eq_sum_sum</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑u ∈ U. w u) = (∑B ∈ P. W B)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FINITE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P. finite B"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DISJNT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀A ∈ P. ∀B ∈ P. A ≠ B ⟶ A ∩ B = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pairwise_def</span><span> </span><span>disjnt_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑u ∈ (⋃P). w u) = (∑B ∈ P. W B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.Union_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FINITE</span><span> </span><span>DISJNT</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹P› is a correct solution of the bin packing problem, then the sum of the weights of the items
      is a lower bound of amount of bins in ‹P› multiplied by their maximum capacity.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_lower_bound_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑u ∈ U. w u) ≤ c * card P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P. 0 &lt; W B ∧ W B ≤ c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>2</span><span>-</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>weight</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UnionI</span><span> </span><span>assms</span><span> </span><span>bp_bins_finite</span><span> </span><span>sum_pos</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑u ∈ U. w u) = (∑B ∈ P. W B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_Un_eq_sum_sum</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ (∑B ∈ P. c)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_mono</span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = c * card P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bp_NE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U_NE</span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_Un_ge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite M"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite N"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ M ∪ N. 0 &lt; f B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum f M ≤ sum f (M ∪ N)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ sum f N - sum f (M ∩ N)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>DiffD1</span><span> </span><span>inf.cobounded2</span><span> </span><span>UnCI</span><span> </span><span>sum_mono2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum f M ≤ sum f M + sum f N - sum f (M ∩ N)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = sum f (M ∪ N)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_Un</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹bij_exists› holds, one can obtain a function which is bijective between the bins in ‹P›
and the objects in ‹V› such that an object returned by the function would cause the bin to
exceed its capacity.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bij_exists</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ 'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bij_exists P V = (∃f. bij_betw f P V ∧ (∀B ∈ P. W B + w (f B) &gt; c))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹P› is a functionally correct solution of the bin packing problem, ‹inv<span class="hidden">⇩</span><sub>1</sub>› holds for the
partial solution, and such a bijective function exists between the bins in ‹P<span class="hidden">⇩</span><sub>1</sub>› and the objects in
@{term "P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>"}, the following strict lower bound can be shown:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub>_lower_bound_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists P<span class="hidden">⇩</span><sub>1</sub> (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card P<span class="hidden">⇩</span><sub>1</sub> + 1 ≤ card P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P<span class="hidden">⇩</span><sub>1</sub> = {}›</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ≤ card P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bp_NE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nat.add_0_right</span><span> </span><span>Suc_diff_1</span><span> </span><span>Suc_le_mono</span><span> </span><span>card_gt_0_iff</span><span> </span><span>le0</span><span> </span><span>mult_Suc_right</span><span> </span><span>nat_mult_1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw f P<span class="hidden">⇩</span><sub>1</sub> (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P<span class="hidden">⇩</span><sub>1</sub>. W B + w (f B) &gt; c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_exists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FINITE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite P<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ V})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>bp_sol_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. finite B"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀A ∈ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. ∀B ∈ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. A ≠ B ⟶ A ∩ B = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pairwise_def</span><span> </span><span>disjnt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sum_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"W (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) = (∑B ∈ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. W B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.Union_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span>F</span><span> </span><span>D</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V}. 0 &lt; W B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>weight</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>UnionI</span><span> </span><span>bp_bins_finite</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>sum_pos</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. W B) ≤ (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ (wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ V}). W B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_Un_ge</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FINITE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>W</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V}. W B)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Un_assoc</span><span> </span><span>Un_commute</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = W U"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_Un_eq_sum_sum</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. W B) ≤ W U"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹This follows from the fourth and final additional conjunct of ‹inv<span class="hidden">⇩</span><sub>1</sub>› and is necessary to combine the sums of the bins
      of the two partial solutions. This does not inherently follow from the union being a correct solution,
      as this need not be the case if ‹P<span class="hidden">⇩</span><sub>1</sub>› and ‹P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>› happened to be equal.›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DISJNT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P<span class="hidden">⇩</span><sub>1</sub> ∩ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹This part of the proof is based on the proof on page 72 of the article @{cite BerghammerR03}.›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c * card P<span class="hidden">⇩</span><sub>1</sub> = (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub>. c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... &lt; (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub>. W B + w (f B))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>sum_strict_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FINITE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub>. W B) + (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub>. w (f B))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Groups_Big.comm_monoid_add_class.sum.distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub>. W B) + W (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum.reindex_bij_betw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>w</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub>. W B) + (∑B ∈ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. W B)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_eq</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. W B)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.union_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FINITE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>DISJNT</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>W</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ (∑u ∈ U. w u)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ c * card P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>discrete</span><span> </span><span>nat_mult_less_cancel_disj</span><span> </span><span>of_nat_less_imp_less</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹As @{thm wrap_card} holds, it follows that the amount of bins in ‹P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>›
      are a lower bound for the amount of bins in ‹P›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub>_B<span class="hidden">⇩</span><sub>1</sub>_lower_bound_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists P<span class="hidden">⇩</span><sub>1</sub> (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) ≤ card P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) ≤ card P<span class="hidden">⇩</span><sub>1</sub> + card (wrap B<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Un_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card P<span class="hidden">⇩</span><sub>1</sub> + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wrap_card</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub>_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹inv<span class="hidden">⇩</span><sub>1</sub>› holds, there are at most half as many bins in ‹P<span class="hidden">⇩</span><sub>2</sub>› as there are objects in ‹P<span class="hidden">⇩</span><sub>2</sub>›, and we can again
      obtain a bijective function between the bins in ‹P<span class="hidden">⇩</span><sub>1</sub>› and the objects of the second partial solution,
      then the amount of bins in the second partial solution are a strict lower bound for half the bins of
      the first partial solution.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub>_B<span class="hidden">⇩</span><sub>2</sub>_lower_bound_P<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card P<span class="hidden">⇩</span><sub>2</sub> ≤ card (⋃P<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists P<span class="hidden">⇩</span><sub>1</sub> (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ≤ card P<span class="hidden">⇩</span><sub>1</sub> + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bprules</span><span> </span><span class="delimiter">=</span><span> </span><span>bpE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>pairwise_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ∉ P<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DISJNT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃P<span class="hidden">⇩</span><sub>2</sub> ∩ B<span class="hidden">⇩</span><sub>2</sub> = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>sup_bot.right_neutral</span><span> </span><span>Un_insert_right</span><span> </span><span>disjnt_iff</span><span> </span><span>mk_disjoint_insert</span><span> </span><span>pairwise_insert</span><span> </span><span>wrap_Un</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (⋃P<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U_Finite</span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bp_bins_finite</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>wrap_not_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite P<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bp_sol_finite</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DISJNT2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P<span class="hidden">⇩</span><sub>2</sub> ∩ wrap B<span class="hidden">⇩</span><sub>2</sub> = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>2</sub> ∉ P<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (wrap B<span class="hidden">⇩</span><sub>2</sub>) ≤ card B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>2</sub> = {}›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ≤ card B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>leI</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite B<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wrap_card</span><span class="delimiter">[</span><span>of</span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹This part of the proof is based on the proof on page 73 of the article @{cite BerghammerR03}.›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card P<span class="hidden">⇩</span><sub>2</sub> + 2 * card (wrap B<span class="hidden">⇩</span><sub>2</sub>) ≤ card (⋃P<span class="hidden">⇩</span><sub>2</sub>) + card (wrap B<span class="hidden">⇩</span><sub>2</sub>) + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wrap_card</span><span class="delimiter">[</span><span>of</span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * (card P<span class="hidden">⇩</span><sub>2</sub> + card (wrap B<span class="hidden">⇩</span><sub>2</sub>)) ≤ card (⋃P<span class="hidden">⇩</span><sub>2</sub>) + card B<span class="hidden">⇩</span><sub>2</sub> + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹card (wrap B<span class="hidden">⇩</span><sub>2</sub>) ≤ card B<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * (card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ≤ card (⋃P<span class="hidden">⇩</span><sub>2</sub> ∪ B<span class="hidden">⇩</span><sub>2</sub>) + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Un_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite (⋃P<span class="hidden">⇩</span><sub>2</sub>)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite B<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span>DISJNT</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>card_Un_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite P<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite (wrap B<span class="hidden">⇩</span><sub>2</sub>)›</span></span></span><span> </span><span>DISJNT2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>argo</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * (card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ≤ card (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>2</sub> = {}›</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * (card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ≤ card P<span class="hidden">⇩</span><sub>1</sub> + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>bij_betw_same_card</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_exists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Proving the Approximation Factor›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We define ‹inv<span class="hidden">⇩</span><sub>2</sub>› as it is defined in the article.
      These conjuncts allow us to prove the desired approximation factor.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ 'a set set ⇒ 'a set ⇒ 'a set ⇒ 'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V ⟷ inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V ― ‹‹inv<span class="hidden">⇩</span><sub>1</sub>› holds for the partial solution›
                       ∧ (V ∩ L ≠ {} ⟶ (∀B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. B ∩ L ≠ {})) ― ‹If there are still large objects left, then every bin of the first partial solution must contain a large object›
                       ∧ bij_exists P<span class="hidden">⇩</span><sub>1</sub> (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ― ‹There exists a bijective function between the bins of the first partial solution and the objects of the second one›
                       ∧ (2 * card P<span class="hidden">⇩</span><sub>2</sub> ≤ card (⋃P<span class="hidden">⇩</span><sub>2</sub>)) ― ‹There are at most twice as many bins in ‹P<span class="hidden">⇩</span><sub>2</sub>› as there are objects in ‹P<span class="hidden">⇩</span><sub>2</sub>››"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∩ L ≠ {} ⟹ ∀B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. B ∩ L ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists P<span class="hidden">⇩</span><sub>1</sub> (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card P<span class="hidden">⇩</span><sub>2</sub> ≤ card (⋃P<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∩ L ≠ {} ⟹ ∀B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. B ∩ L ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists P<span class="hidden">⇩</span><sub>1</sub> (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card P<span class="hidden">⇩</span><sub>2</sub> ≤ card (⋃P<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹P› is a correct solution of the bin packing problem, ‹inv<span class="hidden">⇩</span><sub>2</sub>› holds for the partial solution,
      and there are no more small objects left to be distributed, then the amount of bins of the partial solution
      is no larger than ‹3 / 2› of the amount of bins in ‹P›. This proof strongly follows the proof in
      ‹Theorem 4.1› of the article @{cite BerghammerR03}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_packing_lower_bound_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∩ S = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V}) ≤ 3 / 2 * card P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V = {}›</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V})
           = card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) + card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Un_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card P + card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub>_B<span class="hidden">⇩</span><sub>1</sub>_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card P + card P / 2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub>_B<span class="hidden">⇩</span><sub>2</sub>_lower_bound_P<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub>_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U = S ∪ L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_def</span><span> </span><span>L_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V = V ∩ L"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∩ L ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V})
      = card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ V ∩ L} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span> </span><span>Un_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ V ∩ L}) + card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Un_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ V ∩ L}›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card P + card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_bins_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NE</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card P + card P / 2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub>_B<span class="hidden">⇩</span><sub>2</sub>_lower_bound_P<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub>_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We define ‹inv<span class="hidden">⇩</span><sub>3</sub>› as it is defined in the article.
      This final conjunct allows us to prove that the invariant will be maintained by the algorithm.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ 'a set set ⇒ 'a set ⇒ 'a set ⇒ 'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V ⟷ inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V ∧ B<span class="hidden">⇩</span><sub>2</sub> ⊆ S"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ⊆ S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ⊆ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_init</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> {} {} {} {} U"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> {} {} {} {} U"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bp_def</span><span> </span><span>partition_on_def</span><span> </span><span>pairwise_def</span><span> </span><span>wrap_def</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists {} (⋃ ({} ∪ wrap {}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_betwI'</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_exists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> {} {} {} {} U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹B<span class="hidden">⇩</span><sub>1</sub>› is empty and there are no large objects left, then ‹inv<span class="hidden">⇩</span><sub>3</sub>› will be maintained
      if ‹B<span class="hidden">⇩</span><sub>1</sub>› is initialized with ‹u ∈ V ∩ S›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_stepA</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∩ L = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V ∩ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> {u} B<span class="hidden">⇩</span><sub>2</sub> (V - {u})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>WEIGHT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>1</sub> + w u ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepA</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>this</span><span> </span><span>WEIGHT</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> {u} B<span class="hidden">⇩</span><sub>2</sub> (V - {u})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(V - {u}) ∩ L ≠ {} ⟹ ∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {u}. B ∩ L ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span>invrules</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> {u} B<span class="hidden">⇩</span><sub>2</sub> (V - {u})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹B<span class="hidden">⇩</span><sub>1</sub>› is empty and there are large objects left, then ‹inv<span class="hidden">⇩</span><sub>3</sub>› will be maintained
      if ‹B<span class="hidden">⇩</span><sub>1</sub>› is initialized with ‹u ∈ V ∩ L›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_stepB</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V ∩ L"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> {u} B<span class="hidden">⇩</span><sub>2</sub> (V - {u})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>WEIGHT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>1</sub> + w u ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_def</span><span> </span><span>weight</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepA</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>this</span><span> </span><span>WEIGHT</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> {u} B<span class="hidden">⇩</span><sub>2</sub> (V - {u})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub>. B ∩ L ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(V - {u}) ∩ L ≠ {} ⟹ ∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {u}. B ∩ L ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Int_iff</span><span> </span><span>UnE</span><span> </span><span>empty_iff</span><span> </span><span>insertE</span><span> </span><span>singletonI</span><span> </span><span>wrap_not_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span>invrules</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> {u} B<span class="hidden">⇩</span><sub>2</sub> (V - {u})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹B<span class="hidden">⇩</span><sub>1</sub>› is not empty and ‹u ∈ V ∩ S› does not exceed its maximum capacity, then ‹inv<span class="hidden">⇩</span><sub>3</sub>›
      will be maintained if ‹B<span class="hidden">⇩</span><sub>1</sub>› and ‹{u}› are replaced with ‹B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_stepC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V ∩ S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>1</sub> + w(u) ≤ c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) B<span class="hidden">⇩</span><sub>2</sub> (V - {u})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepA</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>this</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) B<span class="hidden">⇩</span><sub>2</sub> (V - {u})"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(V - {u}) ∩ L ≠ {} ⟹ ∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. B ∩ L ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(V - {u}) ∩ L ≠ {} ⟹ ∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}). B ∩ L ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Int_commute</span><span> </span><span>Un_empty_right</span><span> </span><span>Un_insert_right</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>disjoint_insert</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>insert_iff</span><span> </span><span>wrap_not_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span>invrules</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) B<span class="hidden">⇩</span><sub>2</sub> (V - {u})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹B<span class="hidden">⇩</span><sub>1</sub>› is not empty and ‹u ∈ V ∩ S› does exceed its maximum capacity but not the capacity of ‹B<span class="hidden">⇩</span><sub>2</sub>›,
      then ‹inv<span class="hidden">⇩</span><sub>3</sub>› will be maintained if ‹B<span class="hidden">⇩</span><sub>1</sub>› is added to ‹P<span class="hidden">⇩</span><sub>1</sub>› and emptied, and ‹B<span class="hidden">⇩</span><sub>2</sub>› and ‹{u}› are replaced with ‹B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_stepD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V ∩ S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>1</sub> + w(u) &gt; c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>2</sub> + w(u) ≤ c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) P<span class="hidden">⇩</span><sub>2</sub> {} (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) (V - {u})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepB</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>this</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) P<span class="hidden">⇩</span><sub>2</sub> {} (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) (V - {u})"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(V - {u}) ∩ L ≠ {} ⟹ ∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {}. B ∩ L ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw f P<span class="hidden">⇩</span><sub>1</sub> (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub>. c &lt; W B + w (f B)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_exists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ∉ P<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∉ (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}))) = (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{u}}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Sup_empty</span><span> </span><span>Un_assoc</span><span> </span><span>Union_Un_distrib</span><span> </span><span>ccpo_Sup_singleton</span><span> </span><span>wrap_empty</span><span> </span><span>wrap_not_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ∪ {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>UN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}))) = (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ∪ {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wrap B<span class="hidden">⇩</span><sub>1</sub> = {B<span class="hidden">⇩</span><sub>1</sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wrap_not_empty</span><span class="delimiter">[</span><span>of</span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"f (B<span class="hidden">⇩</span><sub>1</sub> := u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>BIJ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw ?f (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u})))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_empty</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wrap B<span class="hidden">⇩</span><sub>1</sub> = {B<span class="hidden">⇩</span><sub>1</sub>}›</span></span></span><span> </span><span>UN</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>1</sub> ∉ P<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ∉ (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>bij_betw_cong</span><span> </span><span>fun_upd_other</span><span> </span><span>fun_upd_same</span><span> </span><span>notIn_Un_bij_betw3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; W B<span class="hidden">⇩</span><sub>1</sub> + w (?f B<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. c &lt; W B + w (?f B))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wrap B<span class="hidden">⇩</span><sub>1</sub> = {B<span class="hidden">⇩</span><sub>1</sub>}›</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>BIJ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw ?f (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u})))
              ∧ (∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. c &lt; W B + w (?f B))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u})))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_exists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) P<span class="hidden">⇩</span><sub>2</sub> {} (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) (V - {u})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If the maximum capacity of ‹B<span class="hidden">⇩</span><sub>2</sub>› is exceeded by ‹u ∈ V ∩ S›,
      then ‹B<span class="hidden">⇩</span><sub>2</sub>› must contain at least two objects.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub>_at_least_two_objects</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V ∩ S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>2</sub> + w(u) &gt; c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ≤ card B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FINITE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Finite_Set.finite.simps</span><span> </span><span>U_Finite</span><span> </span><span>Union_Un_distrib</span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>ccpo_Sup_singleton</span><span> </span><span>finite_Un</span><span> </span><span>wrap_not_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card B<span class="hidden">⇩</span><sub>2</sub> &lt; 2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>0</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"card B<span class="hidden">⇩</span><sub>2</sub> = 0"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"card B<span class="hidden">⇩</span><sub>2</sub> = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FINITE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> = {v}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_1_singletonE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * w v ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>2</sub> = {v}›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>2</sub> = w v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If ‹B<span class="hidden">⇩</span><sub>1</sub>› is not empty and ‹u ∈ V ∩ S› exceeds the maximum capacity of both ‹B<span class="hidden">⇩</span><sub>1</sub>› and ‹B<span class="hidden">⇩</span><sub>2</sub>›,
      then ‹inv<span class="hidden">⇩</span><sub>3</sub>› will be maintained if ‹B<span class="hidden">⇩</span><sub>1</sub>› and ‹B<span class="hidden">⇩</span><sub>2</sub>› are added to ‹P<span class="hidden">⇩</span><sub>1</sub>› and ‹P<span class="hidden">⇩</span><sub>2</sub>› respectively,
      emptied, and ‹B<span class="hidden">⇩</span><sub>2</sub>› initialized with ‹u›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_stepE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V ∩ S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>1</sub> + w(u) &gt; c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>2</sub> + w(u) &gt; c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) {} {u} (V - {u})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepC</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) {} {u} (V - {u})"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(V - {u}) ∩ L ≠ {} ⟹ ∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {}. B ∩ L ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw f P<span class="hidden">⇩</span><sub>1</sub> (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub>. c &lt; W B + w (f B)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_exists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ∉ P<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∉ (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ wrap {u})) = (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{u}}))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ∪ {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>UN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ wrap {u})) = (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ∪ {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wrap B<span class="hidden">⇩</span><sub>1</sub> = {B<span class="hidden">⇩</span><sub>1</sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wrap_not_empty</span><span class="delimiter">[</span><span>of</span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"f (B<span class="hidden">⇩</span><sub>1</sub> := u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>BIJ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw ?f (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ wrap {u}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_empty</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wrap B<span class="hidden">⇩</span><sub>1</sub> = {B<span class="hidden">⇩</span><sub>1</sub>}›</span></span></span><span> </span><span>UN</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>1</sub> ∉ P<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ∉ (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>bij_betw_cong</span><span> </span><span>fun_upd_other</span><span> </span><span>fun_upd_same</span><span> </span><span>notIn_Un_bij_betw3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; W B<span class="hidden">⇩</span><sub>1</sub> + w (?f B<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. c &lt; W B + w (?f B))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wrap B<span class="hidden">⇩</span><sub>1</sub> = {B<span class="hidden">⇩</span><sub>1</sub>}›</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>BIJ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw ?f (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ wrap {u}))
              ∧ (∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. c &lt; W B + w (?f B))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ wrap {u}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_exists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ≤ card (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>bprules</span><span> </span><span class="delimiter">=</span><span> </span><span>bpE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>pairwise_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ∉ P<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DISJNT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃P<span class="hidden">⇩</span><sub>2</sub> ∩ B<span class="hidden">⇩</span><sub>2</sub> = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>sup_bot.right_neutral</span><span> </span><span>Un_insert_right</span><span> </span><span>disjnt_iff</span><span> </span><span>mk_disjoint_insert</span><span> </span><span>pairwise_insert</span><span> </span><span>wrap_Un</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (⋃P<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U_Finite</span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>bp_bins_finite</span><span> </span><span>wrap_not_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ≤ 2 * (card P<span class="hidden">⇩</span><sub>2</sub> + card (wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Un_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wrap B<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ 2 * card P<span class="hidden">⇩</span><sub>2</sub> + 2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wrap_card</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card (⋃ P<span class="hidden">⇩</span><sub>2</sub>) + 2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card (⋃ P<span class="hidden">⇩</span><sub>2</sub>) + card B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub>_at_least_two_objects</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = card (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ {B<span class="hidden">⇩</span><sub>2</sub>}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DISJNT</span><span> </span><span>card_Un_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite (⋃P<span class="hidden">⇩</span><sub>2</sub>)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite B<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = card (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>2</sub> = {}›</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) {} {u} (V - {u})"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The bin packing algorithm as it is proposed in the article @{cite BerghammerR03}.
      ‹P› will not only be a correct solution of the bin packing problem, but the amount of bins
      will be a lower bound for ‹3 / 2› of the amount of bins of any correct solution ‹Q›, and thus
      guarantee an approximation factor of ‹3 / 2› for the optimum.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bp_approx</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"VARS P P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V u
  {True}
  P<span class="hidden">⇩</span><sub>1</sub> := {}; P<span class="hidden">⇩</span><sub>2</sub> := {}; B<span class="hidden">⇩</span><sub>1</sub> := {}; B<span class="hidden">⇩</span><sub>2</sub> := {}; V := U;
  WHILE V ∩ S ≠ {} INV {inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V} DO 
    IF B<span class="hidden">⇩</span><sub>1</sub> ≠ {}
    THEN u := (SOME u. u ∈ V ∩ S)
    ELSE IF V ∩ L ≠ {}
         THEN u := (SOME u. u ∈ V ∩ L)
         ELSE u := (SOME u. u ∈ V ∩ S) FI FI;
    V := V - {u};
    IF W(B<span class="hidden">⇩</span><sub>1</sub>) + w(u) ≤ c
    THEN B<span class="hidden">⇩</span><sub>1</sub> := B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}
    ELSE IF W(B<span class="hidden">⇩</span><sub>2</sub>) + w(u) ≤ c
         THEN B<span class="hidden">⇩</span><sub>2</sub> := B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}
         ELSE P<span class="hidden">⇩</span><sub>2</sub> := P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>; B<span class="hidden">⇩</span><sub>2</sub> := {u} FI;
         P<span class="hidden">⇩</span><sub>1</sub> := P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>; B<span class="hidden">⇩</span><sub>1</sub> := {} FI
  OD;
  P := P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} | v. v ∈ V}
  {bp P ∧ (∀Q. bp Q ⟶ card P ≤ 3 / 2 * card Q)}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>vcg</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>P</span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>V</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>loop_init</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>P</span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>V</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"SOME u. u ∈ V ∩ S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?l</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"SOME u. u ∈ V ∩ L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∩ L ≠ {} ⟹ ?l ∈ V ∩ L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>some_in_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LWEIGHT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∩ L ≠ {} ⟹ w ?l ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_def</span><span> </span><span>weight</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∩ S ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?s ∈ V ∩ S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>some_in_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w ?s ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LWEIGHT</span><span> </span><span>loop_stepA</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>IN</span><span class="delimiter">]</span><span> </span><span>loop_stepB</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span> </span><span>_</span><span> </span><span>LIN</span><span class="delimiter">]</span><span> </span><span>loop_stepC</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span> </span><span>_</span><span> </span><span>IN</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>loop_stepD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span> </span><span>_</span><span> </span><span>IN</span><span class="delimiter">]</span><span> </span><span>loop_stepE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span> </span><span>_</span><span> </span><span>IN</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>1</sub> = {}›</span></span></span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∩ L = {}›</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>P</span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>V</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>EMPTY</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∩ S = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bin_packing_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>EMPTY</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* BinPacking *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Full Linear Time Version of the Proposed Algorithm›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we prove the Algorithm proposed on page 78 of the article @{cite BerghammerR03}.
      This version generates the S and L sets beforehand and uses them directly to calculate the solution,
      thus removing the need for intersection operations, and ensuring linear time if we can
      perform ‹insertion, removal, and selection of an element, the union of two sets,
      and the emptiness test in constant time› @{cite BerghammerR03}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>BinPacking_Complete</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>U</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span> </span><span class="comment">― ‹A finite, non-empty set of objects›</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ real"</span></span></span><span> </span><span class="comment">― ‹A mapping from objects to their respective weights (positive real numbers)›</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="comment">― ‹The maximum capacity of a bin (as a natural number)›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>weight</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u ∈ U. 0 &lt; w(u) ∧ w(u) ≤ c"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U_Finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite U"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U_NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U ≠ {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The correctness proofs will be identical to the ones of the simplified algorithm.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>W</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"W B ≡ (∑u ∈ B. w(u))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bp P ⟷ partition_on U P ∧ (∀B ∈ P. W(B) ≤ c)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bpE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∉ P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃P = U"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P. W(B) ≤ c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bp_def</span><span> </span><span>partition_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bpI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∉ P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃P = U"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P. W(B) ≤ c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bp_def</span><span> </span><span>partition_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ 'a set set ⇒ 'a set ⇒ 'a set ⇒ 'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V ⟷ bp (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V}) ― ‹A correct solution to the bin packing problem›
                       ∧ ⋃(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = U - V ― ‹The partial solution does not contain objects that have not yet been assigned›
                       ∧ B<span class="hidden">⇩</span><sub>1</sub> ∉ (P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ― ‹‹B<span class="hidden">⇩</span><sub>1</sub>› is distinct from all the other bins›
                       ∧ B<span class="hidden">⇩</span><sub>2</sub> ∉ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub>) ― ‹‹B<span class="hidden">⇩</span><sub>2</sub>› is distinct from all the other bins›
                       ∧ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) ∩ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = {} ― ‹The first and second partial solutions are disjoint from each other.›"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V})"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = U - V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ∉ (P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ∉ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) ∩ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V})"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = U - V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ∉ (P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ∉ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) ∩ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wrap_Un</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wrap (M ∪ {x}) = {M ∪ {x}}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wrap_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wrap {} = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wrap_not_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M ≠ {} ⟷ wrap M = {M}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepA</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W(B<span class="hidden">⇩</span><sub>1</sub>) + w(u) ≤ c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) B<span class="hidden">⇩</span><sub>2</sub> (V - {u})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bprules</span><span> </span><span class="delimiter">=</span><span> </span><span>bpE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 1: Pairwise Disjoint›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NOTIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀M ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}. u ∉ M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{{v} |v. v ∈ V} = {{u}} ∪ {{v} |v. v ∈ V - {u}}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ ({{u}} ∪ {{v} |v. v ∈ V - {u}}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{u}} ∪ P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{u}} ∪ (P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt ({B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}} ∪ (P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>1</sub> = {}›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assm</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt ({B<span class="hidden">⇩</span><sub>1</sub>} ∪ {{u}} ∪ (P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{u} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pairwise_disjnt_Un</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assm</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_Un</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 2: No empty sets›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 3: Union preserved›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{u}} ∪ {{v} |v. v ∈ V - {u}}) = U"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}) = U"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 4: Weights below capacity›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; w u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>U_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>1</sub> = {}›</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ≤ W B<span class="hidden">⇩</span><sub>1</sub> + w u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; w u›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ∈ B<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>insert_absorb</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}). W B ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_Un</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}. W B ≤ c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}. W B ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bpI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bp (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}})"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Auxiliary information is preserved›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ U"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U - (V - {u}) = U - V ∪ {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = ⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ {u}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = U - (V - {u})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ∪ {u} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) ∪ P<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u})) ∩ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_Un</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span>5</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepB</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>2</sub> + w u ≤ c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) P<span class="hidden">⇩</span><sub>2</sub> {} (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) (V - {u})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bprules</span><span> </span><span class="delimiter">=</span><span> </span><span>bpE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NOTIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀M ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}. u ∉ M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{{v} |v. v ∈ V} = {{u}} ∪ {{v} |v. v ∈ V - {u}}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{u}} ∪ {{v} |v. v ∈ V - {u}})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{u}} ∪ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_assoc</span><span> </span><span>Un_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt ({B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}} ∪ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>2</sub> = {}›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assm</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt ({B<span class="hidden">⇩</span><sub>2</sub>} ∪ {{u}} ∪ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{u} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pairwise_disjnt_Un</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assm</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) ∪ {{v} |v. v ∈ V - {u}})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_Un</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 2: No empty sets›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) ∪ {{v} |v. v ∈ V - {u}}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 3: Union preserved›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{u}} ∪ {{v} |v. v ∈ V - {u}}) = U"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) ∪ {{v} |v. v ∈ V - {u}}) = U"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Rule 4: Weights below capacity›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; w u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>U_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>2</sub> = {}›</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) ≤ W B<span class="hidden">⇩</span><sub>2</sub> + w u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; w u›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ∈ B<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>insert_absorb</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}). W B ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_Un</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}. W B ≤ c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) ∪ {{v} |v. v ∈ V - {u}}. W B ≤ c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bpI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bp (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) ∪ {{v} |v. v ∈ V - {u}})"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Auxiliary information is preserved›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ U"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U - (V - {u}) = U - V ∪ {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u})) = ⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ {u}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u})) = U - (V - {u})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ∪ {u} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ P<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {}) ∩ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u})) = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_empty</span><span> </span><span>wrap_Un</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span>5</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) {} {u} (V - {u})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="comment">― ‹Rule 1-4: Correct Bin Packing›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ wrap {u} ∪ {{v} |v. v ∈ V - {u}}
      = P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{u}} ∪ {{v} |v. v ∈ V - {u}}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Un_assoc</span><span> </span><span>Un_empty_right</span><span> </span><span>insert_not_empty</span><span> </span><span>wrap_empty</span><span> </span><span>wrap_not_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>EQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ wrap {u} ∪ {{v} |v. v ∈ V - {u}}
                  = P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bp (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ wrap {u} ∪ {{v} |v. v ∈ V - {u}})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>EQ</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Auxiliary information is preserved›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NOTIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀M ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ V - {u}}. u ∉ M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ U"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U - (V - {u}) = U - V ∪ {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ wrap {u}) = ⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ∪ {u}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ wrap {u}) = U - (V - {u})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ∪ wrap {u}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{u} ∉ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {} ∪ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {}) ∩ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ wrap {u}) = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>NOTIN</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span>5</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹From this point onward, we will require a different approach for proving lower bounds.
      Instead of fixing and assuming the definitions of the ‹S› and ‹L› sets, we will introduce
      the abbreviations ‹S<span class="hidden">⇩</span><sub>U</sub>› and ‹L<span class="hidden">⇩</span><sub>U</sub>› for any occurrences of the original ‹S› and ‹L› sets.
      The union of ‹S› and ‹L› can be interpreted as ‹V›. As a result, occurrences of ‹V ∩ S›
      become ‹(S ∪ L) ∩ S = S›, and ‹V ∩ L› become ‹(S ∪ L) ∩ L = L›.
      Occurrences of these sets will have to be replaced appropriately.›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>S<span class="hidden">⇩</span><sub>U</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"S<span class="hidden">⇩</span><sub>U</sub> ≡ {u ∈ U. w u ≤ c / 2}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>L<span class="hidden">⇩</span><sub>U</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"L<span class="hidden">⇩</span><sub>U</sub> ≡ {u ∈ U. c / 2 &lt; w u}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹As we will remove elements from ‹S› and ‹L›, we will only be able to show that they remain
      subsets of ‹S<span class="hidden">⇩</span><sub>U</sub>› and ‹L<span class="hidden">⇩</span><sub>U</sub>› respectively.›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SL</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"SL S L ≡ S ⊆ S<span class="hidden">⇩</span><sub>U</sub> ∧ L ⊆ L<span class="hidden">⇩</span><sub>U</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bp_bins_finite</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P. finite B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>U_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Sup_upper</span><span> </span><span>finite_subset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bp_sol_finite</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>U_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>finite_UnionD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>only_one_L_per_bin</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∈ P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ B. ∀y ∈ B. x ≠ y ⟶ x ∉ L<span class="hidden">⇩</span><sub>U</sub> ∨ y ∉ L<span class="hidden">⇩</span><sub>U</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x∈B. ∃y∈B. x ≠ y ∧ y ∈ U ∧ x ∈ U ∧ real c &lt; w x * 2 ∧ real c &lt; w y * 2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ L<span class="hidden">⇩</span><sub>U</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ L<span class="hidden">⇩</span><sub>U</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; w x + w y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ B - {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B = W (B - {x}) + w x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite B›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum.remove</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = W (B - {x} - {y}) + w x + w y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ B - {x}›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite B›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum.remove</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"W B = W (B - {x} - {y}) + w x + w y"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u ∈ B. 0 &lt; w u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>weight</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ W (B - {x} - {y})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>DiffD1</span><span> </span><span>sum_nonneg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; W B"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c &lt; w x + w y›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>L_lower_bound_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card L<span class="hidden">⇩</span><sub>U</sub> ≤ card P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ L<span class="hidden">⇩</span><sub>U</sub>. ∃B ∈ P. x ∈ B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u ∈ L<span class="hidden">⇩</span><sub>U</sub>. u ∈ f u ∧ f u ∈ P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inj_on f L<span class="hidden">⇩</span><sub>U</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inj_on_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>only_one_L_per_bin</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card L<span class="hidden">⇩</span><sub>U</sub> = card (f ` L<span class="hidden">⇩</span><sub>U</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` L<span class="hidden">⇩</span><sub>U</sub> ⊆ P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (f ` L<span class="hidden">⇩</span><sub>U</sub>) ≤ card P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>card_eq</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subset_bp_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ⊆ P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ M. B ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card M ≤ card L<span class="hidden">⇩</span><sub>U</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ M. ∃u ∈ L<span class="hidden">⇩</span><sub>U</sub>. u ∈ B"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. ∀B ∈ M. f B ∈ L<span class="hidden">⇩</span><sub>U</sub> ∧ f B ∈ B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ M. f B ∈ L<span class="hidden">⇩</span><sub>U</sub> ∧ f B ∈ B"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inj_on f M"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ inj_on f M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x ∈ M. ∃y ∈ M. x ≠ y ∧ f x = f y"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inj_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ M"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ M"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x = f y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃u. u ∈ x ∧ u ∈ y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∩ y ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt M"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pairwise_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bpE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pairwise_def</span><span> </span><span>disjnt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite L<span class="hidden">⇩</span><sub>U</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` M ⊆ L<span class="hidden">⇩</span><sub>U</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_inj_on_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>L_bins_lower_bound_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> (S ∪ L)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. B ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {}"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SL_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SL S L"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ L}) ≤ card P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ {{v} |v. v ∈ L}. B ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SL_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ L} ⊆ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ S ∪ L}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ L}. B ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subset_bp_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_Un_eq_sum_sum</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑u ∈ U. w u) = (∑B ∈ P. W B)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FINITE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P. finite B"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DISJNT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀A ∈ P. ∀B ∈ P. A ≠ B ⟶ A ∩ B = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pairwise_def</span><span> </span><span>disjnt_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑u ∈ (⋃P). w u) = (∑B ∈ P. W B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.Union_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FINITE</span><span> </span><span>DISJNT</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_lower_bound_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑u ∈ U. w u) ≤ c * card P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P. 0 &lt; W B ∧ W B ≤ c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>2</span><span>-</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>weight</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UnionI</span><span> </span><span>assms</span><span> </span><span>bp_bins_finite</span><span> </span><span>sum_pos</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑u ∈ U. w u) = (∑B ∈ P. W B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_Un_eq_sum_sum</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ (∑B ∈ P. c)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_mono</span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = c * card P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bp_NE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U_NE</span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_Un_ge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite M"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite N"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ M ∪ N. 0 &lt; f B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum f M ≤ sum f (M ∪ N)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ sum f N - sum f (M ∩ N)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>DiffD1</span><span> </span><span>inf.cobounded2</span><span> </span><span>UnCI</span><span> </span><span>sum_mono2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum f M ≤ sum f M + sum f N - sum f (M ∩ N)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = sum f (M ∪ N)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_Un</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bij_exists</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ 'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bij_exists P V = (∃f. bij_betw f P V ∧ (∀B ∈ P. W B + w (f B) &gt; c))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub>_lower_bound_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> (S ∪ L)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists P<span class="hidden">⇩</span><sub>1</sub> (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card P<span class="hidden">⇩</span><sub>1</sub> + 1 ≤ card P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P<span class="hidden">⇩</span><sub>1</sub> = {}›</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ≤ card P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bp_NE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nat.add_0_right</span><span> </span><span>Suc_diff_1</span><span> </span><span>Suc_le_mono</span><span> </span><span>card_gt_0_iff</span><span> </span><span>le0</span><span> </span><span>mult_Suc_right</span><span> </span><span>nat_mult_1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw f P<span class="hidden">⇩</span><sub>1</sub> (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P<span class="hidden">⇩</span><sub>1</sub>. W B + w (f B) &gt; c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_exists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FINITE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite P<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ S ∪ L})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>bp_sol_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B ∈ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. finite B"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀A ∈ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. ∀B ∈ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. A ≠ B ⟶ A ∩ B = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pairwise_def</span><span> </span><span>disjnt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sum_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"W (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) = (∑B ∈ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. W B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.Union_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span>F</span><span> </span><span>D</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ S ∪ L}. 0 &lt; W B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpE</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>weight</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>UnionI</span><span> </span><span>bp_bins_finite</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>sum_pos</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. W B) ≤ (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ (wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ S ∪ L}). W B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_Un_ge</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FINITE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>W</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ S ∪ L}. W B)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Un_assoc</span><span> </span><span>Un_commute</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = W U"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_Un_eq_sum_sum</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. W B) ≤ W U"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DISJNT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P<span class="hidden">⇩</span><sub>1</sub> ∩ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹This part of the proof is based on the proof on page 72 of the article @{cite BerghammerR03}.›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c * card P<span class="hidden">⇩</span><sub>1</sub> = (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub>. c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... &lt; (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub>. W B + w (f B))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>sum_strict_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FINITE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub>. W B) + (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub>. w (f B))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Groups_Big.comm_monoid_add_class.sum.distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub>. W B) + W (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum.reindex_bij_betw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>w</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub>. W B) + (∑B ∈ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. W B)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_eq</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>. W B)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.union_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FINITE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>DISJNT</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>W</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ (∑u ∈ U. w u)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ c * card P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>discrete</span><span> </span><span>nat_mult_less_cancel_disj</span><span> </span><span>of_nat_less_imp_less</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub>_B<span class="hidden">⇩</span><sub>1</sub>_lower_bound_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> (S ∪ L)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists P<span class="hidden">⇩</span><sub>1</sub> (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) ≤ card P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) ≤ card P<span class="hidden">⇩</span><sub>1</sub> + card (wrap B<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Un_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card P<span class="hidden">⇩</span><sub>1</sub> + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wrap_card</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub>_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub>_B<span class="hidden">⇩</span><sub>2</sub>_lower_bound_P<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> (S ∪ L)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card P<span class="hidden">⇩</span><sub>2</sub> ≤ card (⋃P<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists P<span class="hidden">⇩</span><sub>1</sub> (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ≤ card P<span class="hidden">⇩</span><sub>1</sub> + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bprules</span><span> </span><span class="delimiter">=</span><span> </span><span>bpE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>pairwise_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ∉ P<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DISJNT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃P<span class="hidden">⇩</span><sub>2</sub> ∩ B<span class="hidden">⇩</span><sub>2</sub> = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>sup_bot.right_neutral</span><span> </span><span>Un_insert_right</span><span> </span><span>disjnt_iff</span><span> </span><span>mk_disjoint_insert</span><span> </span><span>pairwise_insert</span><span> </span><span>wrap_Un</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (⋃P<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U_Finite</span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bp_bins_finite</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>wrap_not_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite P<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bp_sol_finite</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DISJNT2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P<span class="hidden">⇩</span><sub>2</sub> ∩ wrap B<span class="hidden">⇩</span><sub>2</sub> = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>2</sub> ∉ P<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (wrap B<span class="hidden">⇩</span><sub>2</sub>) ≤ card B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>2</sub> = {}›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ≤ card B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>leI</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite B<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wrap_card</span><span class="delimiter">[</span><span>of</span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹This part of the proof is based on the proof on page 73 of the article @{cite BerghammerR03}.›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card P<span class="hidden">⇩</span><sub>2</sub> + 2 * card (wrap B<span class="hidden">⇩</span><sub>2</sub>) ≤ card (⋃P<span class="hidden">⇩</span><sub>2</sub>) + card (wrap B<span class="hidden">⇩</span><sub>2</sub>) + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wrap_card</span><span class="delimiter">[</span><span>of</span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * (card P<span class="hidden">⇩</span><sub>2</sub> + card (wrap B<span class="hidden">⇩</span><sub>2</sub>)) ≤ card (⋃P<span class="hidden">⇩</span><sub>2</sub>) + card B<span class="hidden">⇩</span><sub>2</sub> + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹card (wrap B<span class="hidden">⇩</span><sub>2</sub>) ≤ card B<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * (card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ≤ card (⋃P<span class="hidden">⇩</span><sub>2</sub> ∪ B<span class="hidden">⇩</span><sub>2</sub>) + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Un_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite (⋃P<span class="hidden">⇩</span><sub>2</sub>)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite B<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span>DISJNT</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>card_Un_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite P<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite (wrap B<span class="hidden">⇩</span><sub>2</sub>)›</span></span></span><span> </span><span>DISJNT2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>argo</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * (card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ≤ card (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>2</sub> = {}›</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * (card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ≤ card P<span class="hidden">⇩</span><sub>1</sub> + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>bij_betw_same_card</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_exists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We add ‹SL S L› to ‹inv<span class="hidden">⇩</span><sub>2</sub>› to ensure that the ‹S› and ‹L› sets only contain objects with correct weights.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ 'a set set ⇒ 'a set ⇒ 'a set ⇒ 'a set ⇒ 'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L ⟷ inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> (S ∪ L) ― ‹‹inv<span class="hidden">⇩</span><sub>1</sub>› holds for the partial solution›
                       ∧ (L ≠ {} ⟶ (∀B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. B ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {})) ― ‹If there are still large objects left, then every bin of the first partial solution must contain a large object›
                       ∧ bij_exists P<span class="hidden">⇩</span><sub>1</sub> (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ― ‹There exists a bijective function between the bins of the first partial solution and the objects of the second one›
                       ∧ (2 * card P<span class="hidden">⇩</span><sub>2</sub> ≤ card (⋃P<span class="hidden">⇩</span><sub>2</sub>)) ― ‹There are at most twice as many bins in ‹P<span class="hidden">⇩</span><sub>2</sub>› as there are objects in ‹P<span class="hidden">⇩</span><sub>2</sub>››
                       ∧ SL S L ― ‹‹S› and ‹L› are subsets of ‹S<span class="hidden">⇩</span><sub>U</sub>› and ‹L<span class="hidden">⇩</span><sub>U</sub>››"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> (S ∪ L)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L ≠ {} ⟹ ∀B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. B ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists P<span class="hidden">⇩</span><sub>1</sub> (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card P<span class="hidden">⇩</span><sub>2</sub> ≤ card (⋃P<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SL S L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> (S ∪ L)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L ≠ {} ⟹ ∀B ∈ P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. B ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists P<span class="hidden">⇩</span><sub>1</sub> (⋃(P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card P<span class="hidden">⇩</span><sub>2</sub> ≤ card (⋃P<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SL S L"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_packing_lower_bound_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ S ∪ L}) ≤ 3 / 2 * card P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹L = {}›</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ S ∪ L})
           = card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) + card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Un_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card P + card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub>_B<span class="hidden">⇩</span><sub>1</sub>_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card P + card P / 2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub>_B<span class="hidden">⇩</span><sub>2</sub>_lower_bound_P<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub>_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ S ∪ L})
      = card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ L} ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span> </span><span>Un_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ L}) + card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Un_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ {{v} |v. v ∈ L}›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card P + card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_bins_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card P + card P / 2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub>_B<span class="hidden">⇩</span><sub>2</sub>_lower_bound_P<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub>_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ 'a set set ⇒ 'a set ⇒ 'a set ⇒ 'a set ⇒ 'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L ⟷ inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L ∧ B<span class="hidden">⇩</span><sub>2</sub> ⊆ S<span class="hidden">⇩</span><sub>U</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ⊆ S<span class="hidden">⇩</span><sub>U</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ⊆ S<span class="hidden">⇩</span><sub>U</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_init</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> {} {} {} {} S<span class="hidden">⇩</span><sub>U</sub> L<span class="hidden">⇩</span><sub>U</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S<span class="hidden">⇩</span><sub>U</sub> ∪ L<span class="hidden">⇩</span><sub>U</sub> = U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> {} {} {} {} (S<span class="hidden">⇩</span><sub>U</sub> ∪ L<span class="hidden">⇩</span><sub>U</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bp_def</span><span> </span><span>partition_on_def</span><span> </span><span>pairwise_def</span><span> </span><span>wrap_def</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists {} (⋃ ({} ∪ wrap {}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_betwI'</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_exists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> {} {} {} {} S<span class="hidden">⇩</span><sub>U</sub> L<span class="hidden">⇩</span><sub>U</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_stepA</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> {u} B<span class="hidden">⇩</span><sub>2</sub> (S - {u}) L"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>WEIGHT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>1</sub> + w u ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ S ∪ L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepA</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>this</span><span> </span><span>WEIGHT</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> {u} B<span class="hidden">⇩</span><sub>2</sub> (S - {u} ∪ L)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"L ≠ {} ⟹ ∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {u}. B ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span>invrules</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> {u} B<span class="hidden">⇩</span><sub>2</sub> (S - {u}) L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_stepB</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ L"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> {u} B<span class="hidden">⇩</span><sub>2</sub> S (L - {u})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>WEIGHT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>1</sub> + w u ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹This observation follows from the fact that the ‹S› and ‹L› sets have to be disjoint from each other,
      and allows us to reuse our proofs of the preservation of ‹inv<span class="hidden">⇩</span><sub>1</sub>› by simply replacing ‹V› with ‹S ∪ L››</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∪ L - {u} = S ∪ (L - {u})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ S ∪ L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepA</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>this</span><span> </span><span>WEIGHT</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> {u} B<span class="hidden">⇩</span><sub>2</sub> (S ∪ (L - {u}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub>. B ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{u} ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"L ≠ {} ⟹ ∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {u}. B ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>Un_iff</span><span> </span><span>empty_iff</span><span> </span><span>insert_iff</span><span> </span><span>wrap_not_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span>invrules</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> {u} B<span class="hidden">⇩</span><sub>2</sub> S (L - {u})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_stepC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>1</sub> + w(u) ≤ c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) B<span class="hidden">⇩</span><sub>2</sub> (S - {u}) L"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Same approach, but removing ‹{u}› from ‹S› instead of ‹L››</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∪ L - {u} = (S - {u}) ∪ L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ S ∪ L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepA</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>this</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) B<span class="hidden">⇩</span><sub>2</sub> (S - {u} ∪ L)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L ≠ {} ⟹ ∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. B ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"L ≠ {} ⟹ ∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}). B ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Int_insert_left</span><span> </span><span>Un_empty_right</span><span> </span><span>Un_iff</span><span> </span><span>Un_insert_right</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>insert_not_empty</span><span> </span><span>singletonD</span><span> </span><span>singletonI</span><span> </span><span>wrap_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span>invrules</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> (B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}) B<span class="hidden">⇩</span><sub>2</sub> (S - {u}) L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_stepD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>1</sub> + w(u) &gt; c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>2</sub> + w(u) ≤ c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) P<span class="hidden">⇩</span><sub>2</sub> {} (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) (S - {u}) L"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∪ L - {u} = (S - {u}) ∪ L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ S ∪ L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepB</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>this</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) P<span class="hidden">⇩</span><sub>2</sub> {} (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) (S - {u} ∪ L)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"L ≠ {} ⟹ ∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {}. B ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw f P<span class="hidden">⇩</span><sub>1</sub> (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub>. c &lt; W B + w (f B)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_exists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ∉ P<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∉ (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}))) = (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{u}}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Sup_empty</span><span> </span><span>Un_assoc</span><span> </span><span>Union_Un_distrib</span><span> </span><span>ccpo_Sup_singleton</span><span> </span><span>wrap_empty</span><span> </span><span>wrap_not_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ∪ {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>UN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}))) = (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ∪ {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wrap B<span class="hidden">⇩</span><sub>1</sub> = {B<span class="hidden">⇩</span><sub>1</sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wrap_not_empty</span><span class="delimiter">[</span><span>of</span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"f (B<span class="hidden">⇩</span><sub>1</sub> := u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>BIJ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw ?f (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u})))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_empty</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wrap B<span class="hidden">⇩</span><sub>1</sub> = {B<span class="hidden">⇩</span><sub>1</sub>}›</span></span></span><span> </span><span>UN</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>1</sub> ∉ P<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ∉ (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>bij_betw_cong</span><span> </span><span>fun_upd_other</span><span> </span><span>fun_upd_same</span><span> </span><span>notIn_Un_bij_betw3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; W B<span class="hidden">⇩</span><sub>1</sub> + w (?f B<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. c &lt; W B + w (?f B))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wrap B<span class="hidden">⇩</span><sub>1</sub> = {B<span class="hidden">⇩</span><sub>1</sub>}›</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>BIJ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw ?f (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u})))
              ∧ (∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. c &lt; W B + w (?f B))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u})))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_exists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) P<span class="hidden">⇩</span><sub>2</sub> {} (B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}) (S - {u}) L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub>_at_least_two_objects</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>2</sub> + w(u) &gt; c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ≤ card B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FINITE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Finite_Set.finite.simps</span><span> </span><span>U_Finite</span><span> </span><span>Union_Un_distrib</span><span> </span><span>bpE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>ccpo_Sup_singleton</span><span> </span><span>finite_Un</span><span> </span><span>wrap_not_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card B<span class="hidden">⇩</span><sub>2</sub> &lt; 2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>0</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"card B<span class="hidden">⇩</span><sub>2</sub> = 0"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"card B<span class="hidden">⇩</span><sub>2</sub> = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FINITE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> = {v}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_1_singletonE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * w v ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>2</sub> = {v}›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>2</sub> = w v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_stepE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>1</sub> + w(u) &gt; c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W B<span class="hidden">⇩</span><sub>2</sub> + w(u) &gt; c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) {} {u} (S - {u}) L"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invrules</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∪ L - {u} = (S - {u}) ∪ L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ S ∪ L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>_stepC</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>1</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) {} {u} (S - {u} ∪ L)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"L ≠ {} ⟹ ∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ wrap {}. B ∩ L<span class="hidden">⇩</span><sub>U</sub> ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw f P<span class="hidden">⇩</span><sub>1</sub> (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀B∈P<span class="hidden">⇩</span><sub>1</sub>. c &lt; W B + w (f B)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_exists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>1</sub> ∉ P<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∉ (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ wrap {u})) = (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{u}}))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ∪ {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>UN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ wrap {u})) = (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)) ∪ {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wrap B<span class="hidden">⇩</span><sub>1</sub> = {B<span class="hidden">⇩</span><sub>1</sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wrap_not_empty</span><span class="delimiter">[</span><span>of</span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"f (B<span class="hidden">⇩</span><sub>1</sub> := u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>BIJ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw ?f (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ wrap {u}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrap_empty</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wrap B<span class="hidden">⇩</span><sub>1</sub> = {B<span class="hidden">⇩</span><sub>1</sub>}›</span></span></span><span> </span><span>UN</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>1</sub> ∉ P<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ∉ (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>bij_betw_cong</span><span> </span><span>fun_upd_other</span><span> </span><span>fun_upd_same</span><span> </span><span>notIn_Un_bij_betw3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; W B<span class="hidden">⇩</span><sub>1</sub> + w (?f B<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. c &lt; W B + w (?f B))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wrap B<span class="hidden">⇩</span><sub>1</sub> = {B<span class="hidden">⇩</span><sub>1</sub>}›</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>BIJ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw ?f (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ wrap {u}))
              ∧ (∀B∈P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>. c &lt; W B + w (?f B))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_exists (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ wrap {u}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_exists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ≤ card (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>bprules</span><span> </span><span class="delimiter">=</span><span> </span><span>bpE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pairwise disjnt (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>pairwise_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B<span class="hidden">⇩</span><sub>2</sub> ∉ P<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DISJNT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃P<span class="hidden">⇩</span><sub>2</sub> ∩ B<span class="hidden">⇩</span><sub>2</sub> = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>sup_bot.right_neutral</span><span> </span><span>Un_insert_right</span><span> </span><span>disjnt_iff</span><span> </span><span>mk_disjoint_insert</span><span> </span><span>pairwise_insert</span><span> </span><span>wrap_Un</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (⋃P<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U_Finite</span><span> </span><span>bprules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>bp_bins_finite</span><span> </span><span>wrap_not_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 * card (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) ≤ 2 * (card P<span class="hidden">⇩</span><sub>2</sub> + card (wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_Un_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wrap B<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ 2 * card P<span class="hidden">⇩</span><sub>2</sub> + 2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wrap_card</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card (⋃ P<span class="hidden">⇩</span><sub>2</sub>) + 2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ card (⋃ P<span class="hidden">⇩</span><sub>2</sub>) + card B<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub>_at_least_two_objects</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = card (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ {B<span class="hidden">⇩</span><sub>2</sub>}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DISJNT</span><span> </span><span>card_Un_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite (⋃P<span class="hidden">⇩</span><sub>2</sub>)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite B<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = card (⋃ (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>2</sub> = {}›</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> (P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>) (P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>) {} {u} (S - {u}) L"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>I</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>invrules</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The bin packing algorithm as it is proposed on page 78 of the article @{cite BerghammerR03}.
      ‹P› will not only be a correct solution of the bin packing problem, but the amount of bins
      will be a lower bound for ‹3 / 2› of the amount of bins of any correct solution ‹Q›, and thus
      guarantee an approximation factor of ‹3 / 2› for the optimum.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bp_approx</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"VARS P P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> V S L u
  {True}
  S := {}; L:= {}; V := U;
  WHILE V ≠ {} INV {V ⊆ U ∧ S = {u ∈ U - V. w(u) ≤ c / 2} ∧ L = {u ∈ U - V. c / 2 &lt; w(u)}} DO
    u := (SOME u. u ∈ V);
    IF w(u) ≤ c / 2
    THEN S := S ∪ {u}
    ELSE L := L ∪ {u} FI;
    V := V - {u}
  OD;
  P<span class="hidden">⇩</span><sub>1</sub> := {}; P<span class="hidden">⇩</span><sub>2</sub> := {}; B<span class="hidden">⇩</span><sub>1</sub> := {}; B<span class="hidden">⇩</span><sub>2</sub> := {};
  WHILE S ≠ {} INV {inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L} DO 
    IF B<span class="hidden">⇩</span><sub>1</sub> ≠ {}
    THEN u := (SOME u. u ∈ S); S := S - {u}
    ELSE IF L ≠ {}
         THEN u := (SOME u. u ∈ L); L := L - {u}
         ELSE u := (SOME u. u ∈ S); S := S - {u} FI FI;
    IF W(B<span class="hidden">⇩</span><sub>1</sub>) + w(u) ≤ c
    THEN B<span class="hidden">⇩</span><sub>1</sub> := B<span class="hidden">⇩</span><sub>1</sub> ∪ {u}
    ELSE IF W(B<span class="hidden">⇩</span><sub>2</sub>) + w(u) ≤ c
         THEN B<span class="hidden">⇩</span><sub>2</sub> := B<span class="hidden">⇩</span><sub>2</sub> ∪ {u}
         ELSE P<span class="hidden">⇩</span><sub>2</sub> := P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>; B<span class="hidden">⇩</span><sub>2</sub> := {u} FI;
         P<span class="hidden">⇩</span><sub>1</sub> := P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub>; B<span class="hidden">⇩</span><sub>1</sub> := {} FI
  OD;
  P := P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub>; V := L;
  WHILE V ≠ {}
  INV {S = {} ∧ inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L ∧ V ⊆ L ∧ P = P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v}|v. v ∈ L - V}} DO
    u := (SOME u. u ∈ V); P := P ∪ {{u}}; V := V - {u}
  OD
  {bp P ∧ (∀Q. bp Q ⟶ card P ≤ 3 / 2 * card Q)}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>vcg</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>P</span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>V</span><span> </span><span>S</span><span> </span><span>L</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>P</span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>V</span><span> </span><span>S</span><span> </span><span>L</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>some_in_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>P</span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>V</span><span> </span><span>S</span><span> </span><span>L</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loop_init</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>4</span><span> </span><span>P</span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>V</span><span> </span><span>S</span><span> </span><span>L</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>3</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"SOME u. u ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?l</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"SOME u. u ∈ L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>SL_def</span><span> </span><span class="delimiter">=</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"L ≠ {} ⟹ ?l ∈ L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>some_in_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LWEIGHT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"L ≠ {} ⟹ w ?l ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight</span><span> </span><span>SL_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>4</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?s ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>some_in_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w ?s ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SL_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LWEIGHT</span><span> </span><span>loop_stepA</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>IN</span><span class="delimiter">]</span><span> </span><span>loop_stepB</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span> </span><span>_</span><span> </span><span>LIN</span><span class="delimiter">]</span><span> </span><span>loop_stepC</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span> </span><span>_</span><span> </span><span>IN</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>loop_stepD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span> </span><span>_</span><span> </span><span>IN</span><span class="delimiter">]</span><span> </span><span>loop_stepE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span> </span><span>_</span><span> </span><span>IN</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B<span class="hidden">⇩</span><sub>1</sub> = {}›</span></span></span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹L = {}›</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>5</span><span> </span><span>P</span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>V</span><span> </span><span>S</span><span> </span><span>L</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>6</span><span> </span><span>P</span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>V</span><span> </span><span>S</span><span> </span><span>L</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(SOME u. u ∈ V) ∈ V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(SOME u. u ∈ V) ∈ L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>some_in_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ L - (V - {SOME u. u ∈ V})}
           = P<span class="hidden">⇩</span><sub>1</sub> ∪ wrap B<span class="hidden">⇩</span><sub>1</sub> ∪ P<span class="hidden">⇩</span><sub>2</sub> ∪ wrap B<span class="hidden">⇩</span><sub>2</sub> ∪ {{v} |v. v ∈ L - V ∪ {SOME u. u ∈ V}}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>6</span><span> </span><span>*</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>7</span><span> </span><span>P</span><span> </span><span>P<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>P<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>B<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>V</span><span> </span><span>S</span><span> </span><span>L</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">⇩</span><sub>2</sub> P<span class="hidden">⇩</span><sub>1</sub> P<span class="hidden">⇩</span><sub>2</sub> B<span class="hidden">⇩</span><sub>1</sub> B<span class="hidden">⇩</span><sub>2</sub> S L"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>3</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv<span class="hidden">⇩</span><sub>1</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv<span class="hidden">⇩</span><sub>2</sub>E</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>7</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bp P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>bin_packing_lower_bound_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>*</span><span class="delimiter">]</span><span> </span><span>7</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* BinPacking_Complete *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Theory *)</span></span></span></span></span></pre>
</div>
</div>