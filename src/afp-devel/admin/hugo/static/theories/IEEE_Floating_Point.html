<div id="IEEE">
<div class="head"><h1>Theory IEEE</h1>
<span class="command">theory</span> <span class="name">IEEE</span><br/>
<span class="keyword">imports</span> <a href="Float.html"><span class="name">Float</span></a> <a href="../Word_Lib/Word_Lemmas.html"><span class="name">Word_Lemmas</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Formalization of IEEE-754 Standard for binary floating-point arithmetic *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Lei Yu, University of Cambridge *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Specification of the IEEE standard›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IEEE</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Float"</span></span></span><span>
</span><span>    </span><span>Word_Lib.Word_Lemmas</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">::</span><span>len</span><span class="delimiter">,</span><span> </span><span class="tfree">'f</span><span class="delimiter">::</span><span>len</span><span class="delimiter">)</span><span> </span><span>float</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV::(1 word × 'e word × 'f word) set"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_float</span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_float"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"type ⇒ type ⇒ type"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'(_, _') float"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹parse ‹('a, 'b) float› as ('a::len, 'b::len) float.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">parse_translation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  let
    fun float t u = Syntax.const @{type_syntax float} $ t $ u;
    fun len_tr u =
      (case Term_Position.strip_positions u of
        v as Free (x, _) =&gt;
          if Lexicon.is_tid x then
            (Syntax.const @{syntax_const "_ofsort"} $ v $
              Syntax.const @{class_syntax len})
          else u
      | _ =&gt; u)
    fun len_float_tr [t, u] =
      float (len_tr t) (len_tr u)
  in
    [(@{syntax_const "_float"}, K len_float_tr)]
  end
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Derived parameters for floating point formats›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wordlength</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float itself ⇒ nat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordlength x = LENGTH('e) + LENGTH('f) + 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bias</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float itself ⇒ nat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bias x = 2^(LENGTH('e) - 1) - 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>emax</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float itself ⇒ nat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emax x = unat(max_word::'e word)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>fracwidth</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float itself ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fracwidth _ ≡ LENGTH('f)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Predicates for the four IEEE formats›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_single</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float itself ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_single x ⟷ LENGTH('e) = 8 ∧ wordlength x = 32"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_double</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float itself ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_double x ⟷ LENGTH('e) = 11 ∧ wordlength x = 64"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_single_extended</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float itself ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_single_extended x ⟷ LENGTH('e) ≥ 11 ∧ wordlength x ≥ 43"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_double_extended</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float itself ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_double_extended x ⟷ LENGTH('e) ≥ 15 ∧ wordlength x ≥ 79"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Extractors for fields›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>sign</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"λ(s::1 word, _::'e word, _::'f word). unat s"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>exponent</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"λ(_, e::'e word, _). unat e"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fraction</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"λ(_, _, f::'f word). unat f"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"real_of_word x ≡ real (unat x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>valof</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float ⇒ real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, e, f).
    let x = (TYPE(('e, 'f) float)) in
    (if e = 0
     then (-1::real)^(unat s) * (2 / (2^bias x)) * (real_of_word f/2^(LENGTH('f)))
     else (-1::real)^(unat s) * ((2^(unat e)) / (2^bias x)) * (1 + real_of_word f/2^LENGTH('f)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Partition of numbers into disjoint classes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_nan</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_nan a ⟷ exponent a = emax TYPE(('e, 'f)float) ∧ fraction a ≠ 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_infinity</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_infinity a ⟷ exponent a = emax TYPE(('e, 'f)float) ∧ fraction a = 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_normal</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_normal a ⟷ 0 &lt; exponent a ∧ exponent a &lt; emax TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_denormal</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_denormal a ⟷ exponent a = 0 ∧ fraction a ≠ 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_zero</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_zero a ⟷ exponent a = 0 ∧ fraction a = 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_finite</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a ⟷ (is_normal a ∨ is_denormal a ∨ is_zero a)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Special values›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>plus_infinity</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"∞"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(0, max_word, 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>topfloat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(0, max_word - 1, 2^LENGTH('f) - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>float</span><span class="delimiter">::</span><span class="delimiter">(</span><span>len</span><span class="delimiter">,</span><span> </span><span>len</span><span class="delimiter">)</span><span> </span><span>zero</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>zero_float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(0, 0, 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Negation operation on floating point values›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>float</span><span class="delimiter">::</span><span class="delimiter">(</span><span>len</span><span class="delimiter">,</span><span> </span><span>len</span><span class="delimiter">)</span><span> </span><span>uminus</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>uminus_float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float ⇒ ('e, 'f) float"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"λ(s, e, f). (1 - s, e, f)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"minus_zero ≡ - (0::('e, 'f)float)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"minus_infinity ≡ - ∞"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"bottomfloat ≡ - topfloat"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Real number valuations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The largest value that can be represented in floating point format.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>largest</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float itself ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"largest x = (2^(emax x - 1) / 2^bias x) * (2 - 1/(2^fracwidth x))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Threshold, used for checking overflow.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>threshold</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float itself ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"threshold x = (2^(emax x - 1) / 2^bias x) * (2 - 1/(2^(Suc(fracwidth x))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Unit of least precision.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>one_lp</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e ,'f) float ⇒ ('e ,'f) float"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, e, f). (0, e::'e word, 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>zero_lp</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e ,'f) float ⇒ ('e ,'f) float"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, e, f). (0, e::'e word, 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ulp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f) float ⇒ real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ulp a = valof (one_lp a) - valof (zero_lp a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Enumerated type for rounding modes.›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>roundmode</span><span> </span><span class="delimiter">=</span><span> </span><span>To_nearest</span><span> </span><span class="delimiter">|</span><span> </span><span>float_To_zero</span><span> </span><span class="delimiter">|</span><span> </span><span>To_pinfinity</span><span> </span><span class="delimiter">|</span><span> </span><span>To_ninfinity</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Characterization of best approximation from a set of abstract values.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_closest v s x a ⟷ a ∈ s ∧ (∀b. b ∈ s ⟶ ¦v a - x¦ ≤ ¦v b - x¦)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Best approximation with a deciding preference for multiple possibilities.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"closest v p s x =
  (SOME a. is_closest v s x a ∧ ((∃b. is_closest v s x b ∧ p b) ⟶ p a))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rounding›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>round</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ real ⇒ ('e ,'f) float"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"round To_nearest y =
   (if y ≤ - threshold TYPE(('e ,'f) float) then minus_infinity
    else if y ≥ threshold TYPE(('e ,'f) float) then plus_infinity
    else closest (valof) (λa. even (fraction a)) {a. is_finite a} y)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"round float_To_zero y =
   (if y &lt; - largest TYPE(('e ,'f) float) then bottomfloat
    else if y &gt; largest TYPE(('e ,'f) float) then topfloat
    else closest (valof) (λa. True) {a. is_finite a ∧ ¦valof a¦ ≤ ¦y¦} y)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"round To_pinfinity y =
   (if y &lt; - largest TYPE(('e ,'f) float) then bottomfloat
    else if y &gt; largest TYPE(('e ,'f) float) then plus_infinity
    else closest (valof) (λa. True) {a. is_finite a ∧ valof a ≥ y} y)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"round To_ninfinity y =
   (if y &lt; - largest TYPE(('e ,'f) float) then minus_infinity
    else if y &gt; largest TYPE(('e ,'f) float) then topfloat
    else closest (valof) (λa. True) {a. is_finite a ∧ valof a ≤ y} y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rounding to integer values in floating point format.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_integral</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e ,'f) float ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_integral a ⟷ is_finite a ∧ (∃n::nat. ¦valof a¦ = real n)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>intround</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ real ⇒ ('e ,'f) float"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"intround To_nearest y =
    (if y ≤ - threshold TYPE(('e ,'f) float) then minus_infinity
     else if y ≥ threshold TYPE(('e ,'f) float) then plus_infinity
     else closest (valof) (λa. (∃n::nat. even n ∧ ¦valof a¦ = real n)) {a. is_integral a} y)"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"intround float_To_zero y =
    (if y &lt; - largest TYPE(('e ,'f) float) then bottomfloat
     else if y &gt; largest TYPE(('e ,'f) float) then topfloat
     else closest (valof) (λx. True) {a. is_integral a ∧ ¦valof a¦ ≤ ¦y¦} y)"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"intround To_pinfinity y =
    (if y &lt; - largest TYPE(('e ,'f) float) then bottomfloat
     else if y &gt; largest TYPE(('e ,'f) float) then plus_infinity
     else closest (valof) (λx. True) {a. is_integral a ∧ valof a ≥ y} y)"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"intround To_ninfinity y =
    (if y &lt; - largest TYPE(('e ,'f) float) then minus_infinity
     else if y &gt; largest TYPE(('e ,'f) float) then topfloat
     else closest (valof) (λx. True) {a. is_integral a ∧ valof a ≥ y} y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Round, choosing between -0.0 or +0.0›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>float_round</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ bool ⇒ real ⇒ ('e, 'f) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"float_round mode toneg r =
      (let x = round mode r in
         if is_zero x
            then if toneg
                    then minus_zero
                 else 0
         else x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Non-standard of NaN.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>some_nan</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e ,'f) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"some_nan = (SOME a. is_nan a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Coercion for signs of zero results.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>zerosign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('e ,'f) float ⇒ ('e ,'f) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"zerosign s a =
    (if is_zero a then (if s = 0 then 0 else - 0) else a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Remainder operation.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rem x y =
    (let n = closest id (λx. ∃n::nat. even n ∧ ¦x¦ = real n) {x. ∃n :: nat. ¦x¦ = real n} (x / y)
     in x - n * y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>frem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ ('e ,'f) float ⇒ ('e ,'f) float ⇒ ('e ,'f) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"frem m a b =
    (if is_nan a ∨ is_nan b ∨ is_infinity a ∨ is_zero b then some_nan
     else zerosign (sign a) (round m (rem (valof a) (valof b))))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definitions of the arithmetic operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fintrnd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ ('e ,'f) float ⇒ ('e ,'f) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fintrnd m a =
    (if is_nan a then (some_nan)
     else if is_infinity a then a
     else zerosign (sign a) (intround m (valof a)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fadd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ ('e ,'f) float ⇒ ('e ,'f) float ⇒ ('e ,'f) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fadd m a b =
    (if is_nan a ∨ is_nan b ∨ (is_infinity a ∧ is_infinity b ∧ sign a ≠ sign b)
     then some_nan
     else if (is_infinity a) then a
     else if (is_infinity b) then b
     else
      zerosign
        (if is_zero a ∧ is_zero b ∧ sign a = sign b then sign a
         else if m = To_ninfinity then 1 else 0)
        (round m (valof a + valof b)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fsub</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ ('e ,'f) float ⇒ ('e ,'f) float ⇒ ('e ,'f) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fsub m a b =
    (if is_nan a ∨ is_nan b ∨ (is_infinity a ∧ is_infinity b ∧ sign a = sign b)
     then some_nan
     else if is_infinity a then a
     else if is_infinity b then - b
     else
      zerosign
        (if is_zero a ∧ is_zero b ∧ sign a ≠ sign b then sign a
         else if m = To_ninfinity then 1 else 0)
        (round m (valof a - valof b)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fmul</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ ('e ,'f) float ⇒ ('e ,'f) float ⇒ ('e ,'f) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fmul m a b =
    (if is_nan a ∨ is_nan b ∨ (is_zero a ∧ is_infinity b) ∨ (is_infinity a ∧ is_zero b)
     then some_nan
     else if is_infinity a ∨ is_infinity b
     then (if sign a = sign b then plus_infinity else minus_infinity)
     else zerosign (if sign a = sign b then 0 else 1 ) (round m (valof a * valof b)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fdiv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ ('e ,'f) float ⇒ ('e ,'f) float ⇒ ('e ,'f) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fdiv m a b =
    (if is_nan a ∨ is_nan b ∨ (is_zero a ∧ is_zero b) ∨ (is_infinity a ∧ is_infinity b)
     then some_nan
     else if is_infinity a ∨ is_zero b
     then (if sign a = sign b then plus_infinity else minus_infinity)
     else if is_infinity b
     then (if sign a = sign b then 0 else - 0)
     else zerosign (if sign a = sign b then 0 else 1) (round m (valof a / valof b)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fsqrt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ ('e ,'f) float ⇒ ('e ,'f) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fsqrt m a =
    (if is_nan a then some_nan
     else if is_zero a ∨ is_infinity a ∧ sign a = 0 then a
     else if sign a = 1 then some_nan
     else zerosign (sign a) (round m (sqrt (valof a))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fmul_add</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ ('t ,'w) float ⇒ ('t ,'w) float ⇒ ('t ,'w) float ⇒ ('t ,'w) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fmul_add mode x y z =
      (let signP = if sign x = sign y then 0 else 1 in
      let infP = is_infinity x  ∨ is_infinity y
      in
         if is_nan x ∨ is_nan y ∨ is_nan z then some_nan
         else if is_infinity x ∧ is_zero y ∨
                 is_zero x ∧ is_infinity y ∨
                 is_infinity z ∧ infP ∧ signP ≠ sign z then
            some_nan
         else if is_infinity z ∧ (sign z = 0) ∨ infP ∧ (signP = 0)
            then plus_infinity
         else if is_infinity z ∧ (sign z = 1) ∨ infP ∧ (signP = 1)
            then minus_infinity
         else
            let r1 = valof x * valof y;
                r2 = valof z
            in
              float_round mode
                (if (r1 = 0) ∧ (r2 = 0) ∧ (signP = sign z) then
                   signP = 1
                 else mode = To_ninfinity) (r1 + r2))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Comparison operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ccode</span><span> </span><span class="delimiter">=</span><span> </span><span>Gt</span><span> </span><span class="delimiter">|</span><span> </span><span>Lt</span><span> </span><span class="delimiter">|</span><span> </span><span>Eq</span><span> </span><span class="delimiter">|</span><span> </span><span>Und</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fcompare</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e ,'f) float ⇒ ('e ,'f) float ⇒ ccode"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fcompare a b =
    (if is_nan a ∨ is_nan b then Und
     else if is_infinity a ∧ sign a = 1
     then (if is_infinity b ∧ sign b = 1 then Eq else Lt)
     else if is_infinity a ∧ sign a = 0
     then (if is_infinity b ∧ sign b = 0 then Eq else Gt)
     else if is_infinity b ∧ sign b = 1 then Gt
     else if is_infinity b ∧ sign b = 0 then Lt
     else if valof a &lt; valof b then Lt
     else if valof a = valof b then Eq
     else Gt)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>flt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e ,'f) float ⇒ ('e ,'f) float ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"flt a b ⟷ fcompare a b = Lt"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e ,'f) float ⇒ ('e ,'f) float ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fle a b ⟷ fcompare a b = Lt ∨ fcompare a b = Eq"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fgt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e ,'f) float ⇒ ('e ,'f) float ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fgt a b ⟷ fcompare a b = Gt"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e ,'f) float ⇒ ('e ,'f) float ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fge a b ⟷ fcompare a b = Gt ∨ fcompare a b = Eq"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>feq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e ,'f) float ⇒ ('e ,'f) float ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"feq a b ⟷ fcompare a b = Eq"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Specify float to be double  precision and round to even›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>float</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>len</span><span class="delimiter">,</span><span> </span><span>len</span><span class="delimiter">)</span><span> </span><span>plus</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>plus_float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) float ⇒ ('a, 'b) float ⇒ ('a, 'b) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a + b = fadd To_nearest a b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>float</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>len</span><span class="delimiter">,</span><span> </span><span>len</span><span class="delimiter">)</span><span> </span><span>minus</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>minus_float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) float ⇒ ('a, 'b) float ⇒ ('a, 'b) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a - b = fsub To_nearest a b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>float</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>len</span><span class="delimiter">,</span><span> </span><span>len</span><span class="delimiter">)</span><span> </span><span>times</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>times_float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) float ⇒ ('a, 'b) float ⇒ ('a, 'b) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a * b = fmul To_nearest a b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>float</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>len</span><span class="delimiter">,</span><span> </span><span>len</span><span class="delimiter">)</span><span> </span><span>one</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>one_float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) float"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(0, 2^(LENGTH('a) - 1) - 1, 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>float</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>len</span><span class="delimiter">,</span><span> </span><span>len</span><span class="delimiter">)</span><span> </span><span>inverse</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>divide_float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) float ⇒ ('a, 'b) float ⇒ ('a, 'b) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a div b = fdiv To_nearest a b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inverse_float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) float ⇒ ('a, 'b) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inverse_float a = fdiv To_nearest 1 a"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>float_rem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) float ⇒ ('a, 'b) float ⇒ ('a, 'b) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"float_rem a b = frem To_nearest a b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>float_sqrt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) float ⇒ ('a, 'b) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"float_sqrt a = fsqrt To_nearest a"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ROUNDFLOAT</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('a, 'b) float ⇒ ('a, 'b) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ROUNDFLOAT a = fintrnd To_nearest a"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>float</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>len</span><span class="delimiter">,</span><span> </span><span>len</span><span class="delimiter">)</span><span> </span><span>ord</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>less_float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) float ⇒ ('a, 'b) float ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &lt; b ⟷ flt a b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>less_eq_float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) float ⇒ ('a, 'b) float ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ b ⟷ fle a b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>float_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) float ⇒ ('a, 'b) float ⇒ bool"</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≐"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"float_eq a b = feq a b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>float</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>len</span><span class="delimiter">,</span><span> </span><span>len</span><span class="delimiter">)</span><span> </span><span>abs</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>abs_float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) float ⇒ ('a, 'b) float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"abs_float a = (if sign a = 0 then a else - a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The ‹1 + ε› property.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>normalizes</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ itself ⇒ real ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"normalizes float_format x =
    (1/ (2::real)^(bias float_format - 1) ≤ ¦x¦ ∧ ¦x¦ &lt; threshold float_format)"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="IEEE_Properties">
<div class="head"><h1>Theory IEEE_Properties</h1>
<span class="command">theory</span> <span class="name">IEEE_Properties</span><br/>
<span class="keyword">imports</span> <a href="IEEE.html"><span class="name">IEEE</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Lei Yu, University of Cambridge
   Author: Fabian Hellauer
           Fabian Immler
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Proofs of Properties about Floating Point Arithmetic›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IEEE_Properties</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>IEEE</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorems derived from definitions›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valof_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valof x =
    (if exponent x = 0
       then (- 1) ^ sign x * (2 / 2 ^ bias TYPE(('a, 'b) float)) *
            (real (fraction x) / 2 ^ LENGTH('b))
       else (- 1) ^ sign x * (2 ^ exponent x / 2 ^ bias TYPE(('a, 'b) float)) *
            (1 + real (fraction x) / 2 ^ LENGTH('b)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('a, 'b) float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bias_def</span><span> </span><span>divide_simps</span><span> </span><span>unat_eq_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exponent_le</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"exponent a ≤ unat (max_word::'a word)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('a, _)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>unat_mono</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_le_nat_alt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span>max_word_le_exponent_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"unat (max_word::'a word) ≤ exponent a ⟷ unat (max_word::'a word) = exponent a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('a, _)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infinity_simps</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sign (plus_infinity::('e, 'f)float) = 0"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sign (minus_infinity::('e, 'f)float) = 1"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"exponent (plus_infinity::('e, 'f)float) = emax TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"exponent (minus_infinity::('e, 'f)float) = emax TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fraction (plus_infinity::('e, 'f)float) = 0"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fraction (minus_infinity::('e, 'f)float) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>emax_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>emax_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_simps</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sign (0::('e, 'f)float) = 0"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sign (- 0::('e, 'f)float) = 1"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"exponent (0::('e, 'f)float) = 0"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"exponent (- 0::('e, 'f)float) = 0"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fraction (0::('e, 'f)float) = 0"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fraction (- 0::('e, 'f)float) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>topfloat_simps</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sign (topfloat::('e, 'f)float) = 0"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"exponent (topfloat::('e, 'f)float) = emax TYPE(('e, 'f)float) - 1"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fraction (topfloat::('e, 'f)float) = 2^fracwidth TYPE(('e, 'f)float) - 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bottomfloat_simps</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sign (bottomfloat::('e, 'f)float) = 1"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"exponent (bottomfloat::('e, 'f)float) = emax TYPE(('e, 'f)float) - 1"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fraction (bottomfloat::('e, 'f)float) = 2^fracwidth TYPE(('e, 'f)float) - 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>emax_def</span><span> </span><span>unat_sub</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>diff_less</span><span> </span><span>lessI</span><span> </span><span>minus_one_norm</span><span> </span><span>minus_one_word</span><span> </span><span>unat_0</span><span> </span><span>unat_lt2p</span><span>
</span><span>        </span><span>unat_of_nat_len</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>emax_def</span><span> </span><span>unat_sub</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>diff_less</span><span> </span><span>lessI</span><span> </span><span>minus_one_norm</span><span> </span><span>minus_one_word</span><span> </span><span>unat_0</span><span> </span><span>unat_lt2p</span><span>
</span><span>        </span><span>unat_of_nat_len</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emax_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"emax x = 2^LENGTH('e) - 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float itself"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bias_def</span><span> </span><span>emax_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>max_word_eq</span><span> </span><span>unat_minus</span><span> </span><span>word_size</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>float_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>is_finite_def</span><span> </span><span>is_infinity_def</span><span> </span><span>is_zero_def</span><span> </span><span>is_nan_def</span><span>
</span><span>  </span><span>is_normal_def</span><span> </span><span>is_denormal_def</span><span> </span><span>valof_eq</span><span>
</span><span>  </span><span>less_eq_float_def</span><span> </span><span>less_float_def</span><span>
</span><span>  </span><span>flt_def</span><span> </span><span>fgt_def</span><span> </span><span>fle_def</span><span> </span><span>fge_def</span><span> </span><span>feq_def</span><span>
</span><span>  </span><span>fcompare_def</span><span>
</span><span>  </span><span>infinity_simps</span><span>
</span><span>  </span><span>zero_simps</span><span>
</span><span>  </span><span>topfloat_simps</span><span>
</span><span>  </span><span>bottomfloat_simps</span><span>
</span><span>  </span><span>float_eq_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_cases</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_nan a ∨ is_infinity a ∨ is_normal a ∨ is_denormal a ∨ is_zero a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>emax_def</span><span> </span><span>float_defs</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_cases_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_nan a ∨ is_infinity a ∨ is_finite a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>float_cases</span><span> </span><span>is_finite_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_zero1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_zero 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>float_defs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_zero2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_zero (- x) ⟷ is_zero x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>float_defs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emax_pos</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; emax x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emax x ≠ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>emax_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The types of floating-point numbers are mutually distinct.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_distinct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ (is_nan a ∧ is_infinity a)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ (is_nan a ∧ is_normal a)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ (is_nan a ∧ is_denormal a)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ (is_nan a ∧ is_zero a)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ (is_infinity a ∧ is_normal a)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ (is_infinity a ∧ is_denormal a)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ (is_infinity a ∧ is_zero a)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ (is_normal a ∧ is_denormal a)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ (is_denormal a ∧ is_zero a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>denormal_imp_not_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_denormal f ⟹ ¬is_zero f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_denormal_def</span><span> </span><span>is_zero_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normal_imp_not_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_normal f ⟹ ¬is_zero f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_normal_def</span><span> </span><span>is_zero_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normal_imp_not_denormal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_normal f ⟹ ¬is_denormal f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_normal_def</span><span> </span><span>is_denormal_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>denormal_zero</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬is_denormal 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬is_denormal minus_zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>denormal_imp_not_zero</span><span> </span><span>float_zero1</span><span> </span><span>float_zero2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normal_zero</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬is_normal 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬is_normal minus_zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal_imp_not_zero</span><span> </span><span>float_zero1</span><span> </span><span>float_zero2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_distinct_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (is_nan a ∧ is_finite a)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(is_infinity a ∧ is_finite a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_infinity</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a ⟹ ¬ is_infinity a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_nan</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a ⟹ ¬ is_nan a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For every real number, the floating-point numbers closest to it always exist.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_closest_exists</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float ⇒ real"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>non_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃a. is_closest v s x a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite</span><span> </span><span>non_empty</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>z</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_closest v (insert z s) x z"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_closest_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_closest v s x a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insert</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦v a - x¦"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦v z - x¦"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>le_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>le</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insert_iff</span><span> </span><span>a</span><span> </span><span>is_closest_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ge</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀b. b ∈ s ⟶ ¦v a - x¦ ≤ ¦v b - x¦"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a</span><span> </span><span>is_closest_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀b. b ∈ insert z s ⟶ ¦v z - x¦ ≤ ¦v b - x¦"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eq_iff</span><span> </span><span>ge</span><span> </span><span>insert_iff</span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_closest_def</span><span> </span><span>a</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insertI1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>closest_is_everything</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float ⇒ real"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>non_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_closest v s x (closest v p s x) ∧
    ((∃b. is_closest v s x b ∧ p b) ⟶ p (closest v p s x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>closest_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>someI_ex</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>is_closest_exists</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>v</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>closest_in_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"closest v p s x ∈ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>closest_is_everything</span><span> </span><span>is_closest_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>closest_is_closest_finite</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_closest v s x (closest v p s x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>closest_is_everything</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>float</span><span class="delimiter">::</span><span class="delimiter">(</span><span>len</span><span class="delimiter">,</span><span> </span><span>len</span><span class="delimiter">)</span><span> </span><span>finite</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_finite_nonempty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{a. is_finite a} ≠ {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ∈ {a. is_finite a}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>float_defs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>empty_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>closest_is_closest</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_closest v s x (closest v p s x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>closest_is_closest_finite</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Properties about ordering and bounding›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lifting of non-exceptional comparisons.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_lt</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &lt; b ⟷ valof a &lt; valof b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a &lt; valof b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>finite_nan</span><span> </span><span>finite_infinity</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fcompare a b = Lt"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_infinity_def</span><span> </span><span>is_nan_def</span><span> </span><span>valof_def</span><span> </span><span>fcompare_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &lt; b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &lt; b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fcompare a b = Lt"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>finite_nan</span><span> </span><span>finite_infinity</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a &lt; valof b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lt</span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcompare_def</span><span> </span><span>is_nan_def</span><span> </span><span>is_infinity_def</span><span> </span><span>valof_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≐ b ⟷ valof a = valof b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a = valof b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>float_distinct_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fcompare a b = Eq"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_infinity_def</span><span> </span><span>is_nan_def</span><span> </span><span>valof_def</span><span> </span><span>fcompare_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≐ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≐ b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fcompare a b = Eq"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>float_distinct_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a = valof b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq</span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcompare_def</span><span> </span><span>is_nan_def</span><span> </span><span>is_infinity_def</span><span> </span><span>valof_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_le</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ b ⟷ valof a ≤ valof b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ b ⟷  a &lt; b ∨ a ≐ b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Reflexivity of equality for non-NaNs.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_eq_refl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≐ a ⟷ ¬ is_nan a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Properties about Ordering.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_lt_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a ⟹ is_finite b ⟹ is_finite c ⟹ a &lt; b ⟹ b &lt; c ⟹ a &lt; c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>le_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_le_less_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a ⟹ is_finite b ⟹ is_finite c ⟹ a ≤ b ⟹ b &lt; c ⟹ a &lt; c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>le_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_le_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a ⟹ is_finite b ⟹ is_finite c ⟹ a ≤ b ⟹ b ≤ c ⟹ a ≤ c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>le_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_le_neg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a ⟹ is_finite b ⟹ ¬ a &lt; b ⟷ b ≤ a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Properties about bounding.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_le_infinity</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan a ⟹ a ≤ plus_infinity"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>float_defs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_le_topfloat</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ topfloat"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"- 0 ≤ topfloat"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span> </span><span>field_simps</span><span> </span><span>power_gt1_lemma</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LENGTH_contr</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Suc 0 &lt; LENGTH('e) ⟹ 2 ^ LENGTH('e::len) ≤ Suc (Suc 0) ⟹ False"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_antisym</span><span> </span><span>len_gt_0</span><span> </span><span>n_less_equal_power_2</span><span> </span><span>not_less_eq</span><span> </span><span>numeral_2_eq_2</span><span> </span><span>one_le_numeral</span><span>
</span><span>      </span><span>self_le_power</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valof_topfloat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (topfloat::('e, 'f)float) = largest TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LENGTH('e) &gt; 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>LENGTH_contr</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>emax_eq</span><span> </span><span>largest_def</span><span> </span><span>divide_simps</span><span> </span><span>float_defs</span><span> </span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_frac_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fraction a ≤ 2^LENGTH('f) - 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>float_defs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_Suc_eq_le</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_exp_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a ⟹ exponent a ≤ emax TYPE(('e, 'f)float) - 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>float_defs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_sign_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(-1::real)^(sign a) = 1 ∨ (-1::real)^(sign a) = -1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>neg_one_even_power</span><span> </span><span>neg_one_odd_power</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exp_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ b ⟹ (2::real)^a ≤ 2^b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ b ∧ c &gt; 0 ⟹ a/c ≤ b/c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::linordered_field"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>divide_le_cancel</span><span> </span><span>less_asym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_topfloat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite topfloat"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>float_defs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>float_leI</span><span> </span><span class="delimiter">=</span><span> </span><span>float_le</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factor_minus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x * a - x = x * (a - 1)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::comm_semiring_1_cancel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>real_le_power_numeral_diff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"real a ≤ numeral b ^ n - 1 ⟷ a ≤ numeral b ^ n - 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>of_nat_1</span><span> </span><span>of_nat_diff</span><span> </span><span>of_nat_le_iff</span><span> </span><span>of_nat_numeral</span><span>
</span><span>      </span><span>one_le_numeral</span><span> </span><span>one_le_power</span><span> </span><span>semiring_1_class.of_nat_power</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>denormal_exponent</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float itself ⇒ int"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"denormal_exponent x = 1 - (int (LENGTH('f)) + int (bias TYPE(('e, 'f)float)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>normal_exponent</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float ⇒ int"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"normal_exponent x = int (exponent x) - int (bias TYPE(('e, 'f)float)) - int (LENGTH('f))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>denormal_mantissa</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float ⇒ int"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"denormal_mantissa x = (-1::int)^sign x * int (fraction x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>normal_mantissa</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float ⇒ int"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"normal_mantissa x = (-1::int)^sign x * (2^LENGTH('f) + int (fraction x))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_one_word_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unat a ≤ Suc 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"1 word"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unat_lt2p</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_word_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"1 word"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_le_nat_alt</span><span> </span><span>unat_one_word_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sign_cases</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>pos</span><span> </span><span>neg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sign x = 0"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"sign x = 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sign x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sign x ≠ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sign x ≤ 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_one_word_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sign x = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sign x ≠ 0›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_infinity_cases</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_infinity x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = plus_infinity"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = minus_infinity"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sign_cases</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sign x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = plus_infinity"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>float_defs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>emax_def</span><span> </span><span>unat_eq_0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sign x = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = minus_infinity"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>float_defs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>emax_def</span><span> </span><span>unat_eq_of_nat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_zero_cases</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_zero x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = 0"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = - 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sign_cases</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sign x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>float_defs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>emax_def</span><span> </span><span>unat_eq_0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sign x = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = minus_zero"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>float_defs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>emax_def</span><span> </span><span>unat_eq_of_nat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minus_minus_float</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"- (-f) = f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sign_minus_float</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sign (-f) = (1 - sign f)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_eq_1</span><span> </span><span>one_word_le</span><span> </span><span>unat_sub</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exponent_uminus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"exponent (- f) = exponent f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fraction_uminus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fraction (- f) = fraction f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_normal_minus_float</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_normal (-f) = is_normal f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_normal_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_denormal_minus_float</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_denormal (-f) = is_denormal f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_denormal_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bitlen_normal_mantissa</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bitlen (abs (normal_mantissa x)) = Suc LENGTH('f)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fraction x &lt; 2 ^ LENGTH('f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>float_frac_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_pred</span><span> </span><span>le_imp_less_Suc</span><span> </span><span>pos2</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"- int (fraction x) ≤ 2 ^ LENGTH('f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>negative_zle_0</span><span> </span><span>order_trans</span><span> </span><span>zero_le_numeral</span><span> </span><span>zero_le_power</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sign_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bitlen_le_iff_power</span><span> </span><span>bitlen_ge_iff_power</span><span> </span><span>nat_add_distrib</span><span>
</span><span>        </span><span>normal_mantissa_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>less_int_natI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nat x &lt; nat y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normal_exponent_bounds_int</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"2 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) ≤ normal_exponent x"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"normal_exponent x ≤ 2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_normal x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normal_exponent_def</span><span> </span><span>is_normal_def</span><span> </span><span>emax_eq</span><span> </span><span>bias_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>zless_nat_conj</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>less_int_natI</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_add_distrib</span><span> </span><span>nat_mult_distrib</span><span> </span><span>nat_power_eq</span><span>
</span><span>      </span><span>power_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>of_int_leI</span><span> </span><span class="delimiter">=</span><span> </span><span>of_int_le_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normal_exponent_bounds_real</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"2 - 2 ^ (LENGTH('e) - 1) - real LENGTH('f) ≤ normal_exponent x"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"normal_exponent x ≤ 2 ^ (LENGTH('e) - 1) - real LENGTH('f) - 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_normal x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>of_int_leI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>normal_exponent_bounds_int</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>of_int_leI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>normal_exponent_bounds_int</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_eqI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sign x = sign y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fraction x = fraction y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exponent x = exponent y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_induct</span><span class="delimiter">[</span><span>induct</span><span> </span><span>type</span><span class="delimiter">:</span><span>float</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>normal</span><span> </span><span>denormal</span><span> </span><span>neg</span><span> </span><span>zero</span><span> </span><span>infinity</span><span> </span><span>nan</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>normal</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀x. is_normal x ⟹ valof x = normal_mantissa x * 2 powr normal_exponent x ⟹ P x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>denormal</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀x. is_denormal x ⟹
      valof x = denormal_mantissa x * 2 powr denormal_exponent TYPE(('e, 'f)float) ⟹
      P x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P minus_zero"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>infty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P plus_infinity"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P minus_infinity"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nan</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. is_nan x ⟹ P x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P a"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>float_cases</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_nan a"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_infinity a"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_normal a"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_denormal a"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_zero a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nan</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = plus_infinity"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = minus_infinity"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>is_infinity_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>cases</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>infty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>hyps</span><span class="delimiter">:</span><span> </span><span>3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a = normal_mantissa a * 2 powr normal_exponent a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sign_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valof_eq</span><span> </span><span>normal_mantissa_def</span><span> </span><span>normal_exponent_def</span><span> </span><span>is_normal_def</span><span>
</span><span>          </span><span>powr_realpow</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>powr_diff</span><span> </span><span>powr_add</span><span> </span><span>divide_simps</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hyps</span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>hyps</span><span class="delimiter">:</span><span> </span><span>4</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a = denormal_mantissa a * 2 powr denormal_exponent TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sign_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valof_eq</span><span> </span><span>denormal_mantissa_def</span><span> </span><span>denormal_exponent_def</span><span> </span><span>is_denormal_def</span><span>
</span><span>          </span><span>powr_realpow</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>powr_diff</span><span> </span><span>powr_add</span><span> </span><span>divide_simps</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hyps</span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>denormal</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>5</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = 0"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = minus_zero"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>is_zero_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>cases</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>zero</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infinite_infinity</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_finite plus_infinity"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_finite minus_infinity"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_finite_def</span><span> </span><span>is_normal_def</span><span> </span><span>infinity_simps</span><span> </span><span>is_denormal_def</span><span> </span><span>is_zero_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nan_not_finite</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_nan x ⟹ ¬ is_finite x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>float_distinct_finite</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valof_nonneg</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valof x ≥ 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sign x = 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valof_eq</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valof_nonpos</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valof x ≤ 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sign x = 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valof_eq</span><span> </span><span>is_finite_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>real_le_intI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"floor x ≤ floor y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ℤ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">::</span><span>real</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ints_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Ints_induct</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>le_floor_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>real_of_int_le_2_powr_bitlenI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"real_of_int x ≤ 2 powr n - 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bitlen (abs x) ≤ m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≤ n"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"real_of_int x ≤ abs (real_of_int x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… &lt; 2 powr (bitlen (abs x))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>abs_real_le_2_powr_bitlen</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"real_of_int x ≤ 2 powr (bitlen (abs x)) - 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>powr_real_of_int</span><span> </span><span>bitlen_nonneg</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>real_le_intI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ 2 powr m - 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ 2 powr n - 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>largest_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"largest TYPE(('e, 'f)float) =
    (2 ^ (LENGTH('f) + 1) - 1) * 2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ^ LENGTH('e) - 1 - 1 = (2::nat) ^ LENGTH('e) - 2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"largest TYPE(('e, 'f)float) =
    (2 ^ (LENGTH('f) + 1) - 1) *
    2 powr (real (2 ^ LENGTH('e) - 2) + 1 - real (2 ^ (LENGTH('e) - 1)) - LENGTH('f))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>largest_def</span><span> </span><span>emax_eq</span><span> </span><span>bias_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>largest_def</span><span> </span><span>powr_realpow</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span>powr_minus</span><span> </span><span>divide_simps</span><span> </span><span>algebra_simps</span><span> </span><span>powr_diff</span><span> </span><span>powr_add</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ^ LENGTH('e) ≥ (2::nat)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>self_le_power</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(real (2 ^ LENGTH('e) - 2) + 1 - real (2 ^ (LENGTH('e) - 1)) - LENGTH('f)) =
    (real (2 ^ LENGTH('e)) - 2 ^ (LENGTH('e) - 1) - LENGTH('f)) - 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"real (2 ^ LENGTH('e)) = 2 ^ LENGTH('e)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(2 ^ LENGTH('e) - 2 ^ (LENGTH('e) - 1) - real LENGTH('f) - 1) =
    real_of_int ((2 ^ (LENGTH('e) - 1) - int (LENGTH('f)) - 1))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>power_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bitlen_denormal_mantissa</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bitlen (abs (denormal_mantissa x)) ≤ LENGTH('f)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fraction x &lt; 2 ^ LENGTH('f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>float_frac_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_pred</span><span> </span><span>le_imp_less_Suc</span><span> </span><span>pos2</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"- int (fraction x) ≤ 2 ^ LENGTH('f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>negative_zle_0</span><span> </span><span>order_trans</span><span> </span><span>zero_le_numeral</span><span> </span><span>zero_le_power</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sign_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bitlen_le_iff_power</span><span> </span><span>denormal_mantissa_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_le_topfloat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LENGTH('e) &gt; 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ topfloat"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>float_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>normal</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>normal</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"real_of_int (normal_mantissa x) * 2 powr real_of_int (normal_exponent x) ≤
    (2 powr (LENGTH('f) + 1) - 1) * 2 powr (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal_exponent_bounds_real</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹is_normal x›</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mult_mono</span><span> </span><span>real_of_int_le_2_powr_bitlenI</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bitlen_normal_mantissa</span><span> </span><span>powr_realpow</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ge_one_powr_ge_zero</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = largest TYPE(('e, 'f) IEEE.float)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>largest_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>powr_realpow</span><span> </span><span>powr_add</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = valof (topfloat::('e, 'f) float)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valof_topfloat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>float_leI</span><span> </span><span>normal</span><span> </span><span>finite_topfloat</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>denormal</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>denormal</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"3 ≤ 2 powr (1 + real (LENGTH('e) - Suc 0))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"3 ≤ 2 powr (2::real)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ 2 powr (1 + real (LENGTH('e) - Suc 0))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>powr_le_cancel_iff</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"real_of_int (denormal_mantissa x) * 2 powr real_of_int (denormal_exponent TYPE(('e, 'f)float)) ≤
    (2 powr (LENGTH('f) + 1) - 1) * 2 powr (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bitlen_denormal_mantissa</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mult_mono</span><span> </span><span>real_of_int_le_2_powr_bitlenI</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bitlen_normal_mantissa</span><span> </span><span>powr_realpow</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ge_one_powr_ge_zero</span><span>
</span><span>        </span><span>denormal_exponent_def</span><span> </span><span>bias_def</span><span> </span><span>powr_mult_base</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ largest TYPE(('e, 'f) IEEE.float)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>largest_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mult_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>powr_realpow</span><span> </span><span>powr_add</span><span> </span><span>power_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>power_Suc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = valof (topfloat::('e, 'f) float)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valof_topfloat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>float_leI</span><span> </span><span>denormal</span><span> </span><span>finite_topfloat</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_val_le_largest</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valof a ≤ largest TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LENGTH('e) &gt; 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>that</span><span> </span><span>finite_topfloat</span><span> </span><span>float_le</span><span> </span><span>float_le_topfloat</span><span> </span><span>valof_topfloat</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_val_lt_threshold</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valof a &lt; threshold TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LENGTH('e) &gt; 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a ≤ largest TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>float_val_le_largest</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… &lt; threshold TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>largest_def</span><span> </span><span>threshold_def</span><span> </span><span>divide_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Algebraic properties about basic arithmetic›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Commutativity of addition.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>float_plus_comm_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a + b = b + a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>float_plus_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (a + b) ⟹ (a + b) ≐ (b + a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>finite_nan</span><span> </span><span>finite_infinity</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a + b = b + a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span> </span><span>fadd_def</span><span> </span><span>plus_float_def</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (a + b) ⟹ (a + b) ≐ (b + a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>float_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The floating-point number a falls into the same category as the negation of ‹a›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_zero_uminus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_zero (- a) ⟷ is_zero a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_zero_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_infinity_uminus</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_infinity (- a) = is_infinity a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_infinity_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_finite_uminus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (- a) ⟷ is_finite a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_finite_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_nan_uminus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_nan (- a) ⟷ is_nan a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_nan_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The sign of a and the sign of a's negation is different.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_neg_sign</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(sign a) ≠ (sign (- a))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sign_cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sign_minus_float</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_neg_sign1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sign a = sign (- b) ⟷ sign a ≠ sign b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>float_neg_sign</span><span> </span><span>sign_cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valof_uminus</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (- a) = - valof a"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = ?R"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sign_cases</span><span class="delimiter">)</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valof_eq</span><span> </span><span>sign_minus_float</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Showing ‹a + (- b) = a - b›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_neg_add</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_finite a ⟹ is_finite b ⟹ is_finite (a - b) ⟹ valof a + valof (- b) = valof a - valof b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valof_uminus</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_plus_minus</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (a - b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a + - b) ≐ (a - b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan (- b)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity (-  b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>finite_nan</span><span> </span><span>finite_infinity</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a - b = (zerosign
        (if is_zero a ∧ is_zero b ∧ sign a ≠ sign b then (sign a) else 0)
        (round To_nearest (valof a - valof b)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nab</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>minus_float_def</span><span> </span><span>fsub_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… =
    (zerosign
        (if is_zero a ∧ is_zero (- b) ∧ sign a = sign (- b) then sign a else 0)
        (round To_nearest (valof a + valof (- b))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>float_neg_sign1</span><span> </span><span>float_neg_add</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = a + - b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nab</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span> </span><span>fadd_def</span><span> </span><span>plus_float_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>float_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_bottomfloat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite bottomfloat"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>finite_topfloat</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bottomfloat_eq_m_largest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (bottomfloat::('e, 'f)float) = - largest TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LENGTH('e) &gt; 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valof_topfloat</span><span> </span><span>valof_uminus</span><span> </span><span>finite_topfloat</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_val_ge_bottomfloat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a ≥ valof (bottomfloat::('e, 'f)float)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LENGTH('e) &gt; 1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e,'f)float"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"- a ≤ topfloat"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>float_le_topfloat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valof_uminus</span><span> </span><span>finite_topfloat</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_ge_bottomfloat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a ⟹ a ≥ bottomfloat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LENGTH('e) &gt; 1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e,'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_bottomfloat</span><span> </span><span>float_le</span><span> </span><span>float_val_ge_bottomfloat</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_val_ge_largest</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e,'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LENGTH('e) &gt; 1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a ≥ - largest TYPE(('e,'f)float)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"- largest TYPE(('e,'f)float) = valof (bottomfloat::('e,'f)float)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bottomfloat_eq_m_largest</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ valof a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>float_val_ge_bottomfloat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_val_gt_threshold</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e,'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LENGTH('e) &gt; 1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a &gt; - threshold TYPE(('e,'f)float)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>largest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a ≥ -largest TYPE(('e,'f)float)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>float_val_ge_largest</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"-largest TYPE(('e,'f)float) &gt; - threshold TYPE(('e,'f)float)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bias_def</span><span> </span><span>threshold_def</span><span> </span><span>largest_def</span><span> </span><span>divide_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>largest</span><span> </span><span>less_le_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Showing ‹abs (- a) = abs a›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_abs</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan a ⟹ abs (- a) = abs a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>IEEE.abs_float_def</span><span> </span><span>float_neg_sign1</span><span> </span><span>minus_minus_float</span><span> </span><span>zero_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>neg_zerosign</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"- (zerosign s a) = zerosign (1 - s) (- a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zerosign_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Properties about Rounding Errors›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>error</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float itself ⇒ real ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"error _ x = valof (round To_nearest x::('e, 'f)float) - x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bound_at_worst_lemma</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>threshold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦x¦ &lt; threshold TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦valof (round To_nearest x::('e, 'f)float) - x¦ ≤ ¦valof a - x¦"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(round To_nearest x::('e,'f)float) =
      closest valof (λa. even (fraction a)) {a. is_finite a} x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>threshold</span><span> </span><span>finite</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_closest (valof) {a. is_finite a} x (round To_nearest x::('e,'f)float)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_finite_nonempty</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>*</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>closest_is_closest</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite</span><span> </span><span>is_closest_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>error_at_worst_lemma</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>threshold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦x¦ &lt; threshold TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦error TYPE(('e, 'f)float) x¦ ≤ ¦valof a - x¦ "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>error_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bound_at_worst_lemma</span><span class="delimiter">;</span><span> </span><span>fact</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>error_is_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 &lt; LENGTH('e)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"error TYPE(('e, 'f)float) (valof a) = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦valof a¦ &lt; threshold TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>abs_less_iff</span><span> </span><span>minus_less_iff</span><span> </span><span>float_val_gt_threshold</span><span> </span><span>float_val_lt_threshold</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>abs_le_zero_iff</span><span> </span><span>abs_zero</span><span> </span><span>diff_self</span><span> </span><span>error_at_worst_lemma</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_finite_zerosign</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (zerosign s a) ⟷ is_finite a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zerosign_def</span><span> </span><span>is_finite_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_finite_closest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (closest (v::_⇒real) p {a. is_finite a} x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closest_is_closest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>is_finite_nonempty</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>v</span><span> </span><span>x</span><span> </span><span>p</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_closest_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>defloat_float_zerosign_round_finite</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>threshold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦x¦ &lt; threshold TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (zerosign s (round To_nearest x::('e, 'f)float))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(round To_nearest x::('e, 'f)float) =
      (closest valof (λa. even (fraction a)) {a. is_finite a} x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>threshold</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>abs_less_iff</span><span> </span><span>leD</span><span> </span><span>le_minus_iff</span><span> </span><span>round.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (round To_nearest x::('e, 'f)float)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>is_finite_closest</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_finite_zerosign</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valof_zero</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof 0 = 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof minus_zero = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zerosign_def</span><span> </span><span>valof_eq</span><span> </span><span>zero_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>signzero_zero</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_zero a ⟹ valof (zerosign s a) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zerosign_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>val_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_zero a ⟹ valof a = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>is_zero_cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_add</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite b"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>threshold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦valof a + valof b¦ &lt; threshold TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>finite_float_add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (a + b)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>error_float_add</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valof (a + b) = valof a + valof b + error TYPE(('e, 'f)float) (valof a + valof b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>float_distinct_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a + b) =
    (zerosign
      (if is_zero a ∧ is_zero b ∧ sign a = sign b then (sign a) else 0)
      (round To_nearest (valof a + valof b)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span> </span><span>fadd_def</span><span> </span><span>plus_float_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite ((a + b))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>threshold</span><span> </span><span>defloat_float_zerosign_round_finite</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>val_ab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (a + b) =
    valof (zerosign
      (if is_zero a ∧ is_zero b ∧ sign a = sign b then (sign a) else 0)
      (round To_nearest (valof a + valof b)::('e, 'f)float))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ab</span><span> </span><span>is_infinity_def</span><span> </span><span>is_nan_def</span><span> </span><span>valof_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (a + b) = valof a + valof b + error TYPE(('e, 'f)float) (valof a + valof b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_zero (round To_nearest (valof a + valof b)::('e, 'f)float)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a + valof b + error TYPE(('e, 'f)float) (valof a + valof b) =
        valof (round To_nearest (valof a + valof b)::('e, 'f)float)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>error_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>True</span><span> </span><span>signzero_zero</span><span> </span><span>val_zero</span><span> </span><span>val_ab</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ab</span><span> </span><span>add.commute</span><span> </span><span>eq_diff_eq'</span><span> </span><span>error_def</span><span> </span><span>zerosign_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_sub</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite b"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>threshold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦valof a - valof b¦ &lt; threshold TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>finite_float_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (a - b)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>error_float_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (a - b) = valof a - valof b + error TYPE(('e, 'f)float) (valof a - valof b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>finite_nan</span><span> </span><span>finite_infinity</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a - b =
    (zerosign
      (if is_zero a ∧ is_zero b ∧ sign a ≠ sign b then sign a else 0)
      (round To_nearest (valof a - valof b)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span> </span><span>fsub_def</span><span> </span><span>minus_float_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (a - b)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>threshold</span><span> </span><span>defloat_float_zerosign_round_finite</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>val_ab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (a - b) =
    valof (zerosign
      (if is_zero a ∧ is_zero b ∧ sign a ≠ sign b then sign a else 0)
      (round To_nearest (valof a - valof b)::('e, 'f)float))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ab</span><span> </span><span>is_infinity_def</span><span> </span><span>is_nan_def</span><span> </span><span>valof_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (a - b) = valof a - valof b + error TYPE(('e, 'f)float) (valof a - valof b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_zero (round To_nearest (valof a - valof b)::('e, 'f)float)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a - valof b + error TYPE(('e, 'f)float) (valof a - valof b) =
        valof (round To_nearest (valof a - valof b)::('e, 'f)float)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>error_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>True</span><span> </span><span>signzero_zero</span><span> </span><span>val_zero</span><span> </span><span>val_ab</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ab</span><span> </span><span>add.commute</span><span> </span><span>eq_diff_eq'</span><span> </span><span>error_def</span><span> </span><span>zerosign_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_mul</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite b"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>threshold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦valof a * valof b¦ &lt; threshold TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>finite_float_mul</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (a * b)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>error_float_mul</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (a * b) = valof a * valof b + error TYPE(('e, 'f)float) (valof a * valof b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>non</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_nan b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_infinity b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>float_distinct_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a * b =
    (zerosign (of_bool (sign a ≠ sign b))
      (round To_nearest (valof a * valof b)::('e, 'f)float))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>float_defs</span><span> </span><span>fmul_def</span><span> </span><span>times_float_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (a * b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>threshold</span><span> </span><span>defloat_float_zerosign_round_finite</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>val_ab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (a * b) =
      valof (zerosign (of_bool (sign a ≠ sign b))
        (round To_nearest (valof a * valof b)::('e, 'f)float))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ab</span><span> </span><span>float_defs</span><span> </span><span>of_bool_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (a * b) = valof a * valof b + error TYPE(('e, 'f)float) (valof a * valof b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_zero (round To_nearest (valof a * valof b)::('e, 'f)float)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a * valof b + error TYPE(('e, 'f)float)  (valof a * valof b) =
        valof (round To_nearest (valof a * valof b)::('e, 'f)float)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>error_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>True</span><span> </span><span>signzero_zero</span><span> </span><span>val_zero</span><span> </span><span>val_ab</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ab</span><span> </span><span>add.commute</span><span> </span><span>eq_diff_eq'</span><span> </span><span>error_def</span><span> </span><span>zerosign_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_div</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite b"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>not_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_zero b"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>threshold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦valof a / valof b¦ &lt; threshold TYPE(('e, 'f)float)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>finite_float_div</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (a / b)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>error_float_div</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (a / b) = valof a / valof b + error TYPE(('e, 'f)float) (valof a / valof b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a / b =
    (zerosign (of_bool (sign a ≠ sign b))
      (round To_nearest (valof a / valof b)))"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>divide_float_def</span><span> </span><span>fdiv_def</span><span> </span><span>finite_infinity</span><span> </span><span>finite_nan</span><span> </span><span>not_zero</span><span> </span><span>float_defs</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (a / b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>threshold</span><span> </span><span>defloat_float_zerosign_round_finite</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>val_ab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (a / b) =
      valof (zerosign (of_bool (sign a ≠ sign b))
        (round To_nearest (valof a / valof b))::('e, 'f)float)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ab</span><span> </span><span>float_defs</span><span> </span><span>of_bool_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (a / b) = valof a / valof b + error TYPE(('e, 'f)float)  (valof a / valof b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_zero (round To_nearest (valof a / valof b)::('e, 'f)float)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof a / valof b + error TYPE(('e, 'f)float) (valof a / valof b) =
        valof (round To_nearest (valof a / valof b)::('e, 'f)float)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>error_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>True</span><span> </span><span>signzero_zero</span><span> </span><span>val_zero</span><span> </span><span>val_ab</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ab</span><span> </span><span>add.commute</span><span> </span><span>eq_diff_eq'</span><span> </span><span>error_def</span><span> </span><span>zerosign_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valof_one</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (1::('e, 'f)float) = (if LENGTH('e) ≤ 1 then 0 else 1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bias_def</span><span> </span><span>unat_sub</span><span> </span><span>word_1_le_power</span><span> </span><span>p2_eq_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="FP64">
<div class="head"><h1>Theory FP64</h1>
<span class="command">theory</span> <span class="name">FP64</span><br/>
<span class="keyword">imports</span> <a href="IEEE.html"><span class="name">IEEE</span></a> <a href="../Word_Lib/Word_Lemmas_64.html"><span class="name">Word_Lemmas_64</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>FP64</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>IEEE</span><span>
</span><span>  </span><span>Word_Lib.Word_Lemmas_64</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Concrete encodings›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Floating point operations defined as operations on words.
  Called ''fixed precision'' (fp) word in HOL4.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>float64</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(11,52)float"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>fp64</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"64 word"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fp64_of_float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"float64 ⇒ fp64"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"λ(s::1 word, e::11 word, f::52 word). word_cat s (word_cat e f::63 word)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>float_of_fp64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fp64 ⇒ float64"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"λx. apsnd word_split (word_split x::1 word * 63 word)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_fp64 ≡ (λx (y::word64). x = float_of_fp64 y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eq_fp64</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"float64 ⇒ float64 ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_fp64 ≡ (=)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_of_fp64_inverse</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fp64_of_float (float_of_fp64 a) = a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fp64_of_float_def</span><span> </span><span>float_of_fp64_def</span><span> </span><span>Abs_float_inverse</span><span> </span><span>apsnd_def</span><span> </span><span>map_prod_def</span><span> </span><span>word_size</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>word_cat_split_alt</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span>
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_of_fp64_inj_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fp64_of_float r = fp64_of_float s ⟷ r = s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Rep_float_inject</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fp64_of_float_def</span><span> </span><span>word_cat_inj</span><span> </span><span>word_size</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fp64_of_float_inverse</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"float_of_fp64 (fp64_of_float a) = a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>float_of_fp64_inj_iff</span><span> </span><span>float_of_fp64_inverse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Quotientfp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Quotient eq_fp64 fp64_of_float float_of_fp64 rel_fp64"</span></span></span><span>
</span><span>  </span><span class="comment">―‹\&lt;^term&gt;‹eq_fp64› is a workaround to prevent a (failing -- TODO: why?)
      code setup in ‹setup_lifting›.›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>QuotientI</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_fp64_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>Quotientfp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fp64_lessThan</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"fp64 ⇒ fp64 ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"flt::float64⇒float64⇒bool"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fp64_lessEqual</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"fp64 ⇒ fp64 ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fle::float64⇒float64⇒bool"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fp64_greaterThan</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"fp64 ⇒ fp64 ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fgt::float64⇒float64⇒bool"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fp64_greaterEqual</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"fp64 ⇒ fp64 ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fge::float64⇒float64⇒bool"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fp64_equal</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"fp64 ⇒ fp64 ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"feq::float64⇒float64⇒bool"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fp64_abs</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"fp64 ⇒ fp64"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"abs::float64⇒float64"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fp64_negate</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"fp64 ⇒ fp64"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uminus::float64⇒float64"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fp64_sqrt</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ fp64 ⇒ fp64"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fsqrt::roundmode⇒float64⇒float64"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fp64_add</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ fp64 ⇒ fp64 ⇒ fp64"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fadd::roundmode⇒float64⇒float64⇒float64"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fp64_sub</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ fp64 ⇒ fp64 ⇒ fp64"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fsub::roundmode⇒float64⇒float64⇒float64"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fp64_mul</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ fp64 ⇒ fp64 ⇒ fp64"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fmul::roundmode⇒float64⇒float64⇒float64"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fp64_div</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ fp64 ⇒ fp64 ⇒ fp64"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fdiv::roundmode⇒float64⇒float64⇒float64"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fp64_mul_add</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"roundmode ⇒ fp64 ⇒ fp64 ⇒ fp64 ⇒ fp64"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fmul_add::roundmode⇒float64⇒float64⇒float64⇒float64"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Conversion_IEEE_Float">
<div class="head"><h1>Theory Conversion_IEEE_Float</h1>
<span class="command">theory</span> <span class="name">Conversion_IEEE_Float</span><br/>
<span class="keyword">imports</span> <a href="IEEE_Properties.html"><span class="name">IEEE_Properties</span></a> <a href="Code_Target_Numeral.html"><span class="name">Code_Target_Numeral</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Fabian Hellauer
           Fabian Immler
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Conversion_IEEE_Float</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Float"</span></span></span><span>
</span><span>    </span><span>IEEE_Properties</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Code_Target_Numeral"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"of_finite (x::('e, 'f)float) =
  (if is_normal x then (Float (normal_mantissa x) (normal_exponent x))
    else if is_denormal x then (Float (denormal_mantissa x) (denormal_exponent TYPE(('e, 'f)float)))
    else 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_val_of_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite x ⟹ of_finite x = valof x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>normal_imp_not_denormal</span><span> </span><span>of_finite_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_normal_Float</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float itself ⇒ Float.float ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_normal_Float x f ⟷
    mantissa f ≠ 0 ∧
    bitlen ¦mantissa f¦ ≤ fracwidth x + 1 ∧
    - int (bias x) - bitlen ¦mantissa f¦ + 1 &lt; Float.exponent f ∧
    Float.exponent f &lt; 2^(LENGTH('e)) - bitlen ¦mantissa f¦ - bias x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_denormal_Float</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float itself ⇒ Float.float ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_denormal_Float x f ⟷
    mantissa f ≠ 0 ∧
    bitlen ¦mantissa f¦ ≤ 1 - Float.exponent f - int (bias x) ∧
    1 - 2^(LENGTH('e) - 1) - int LENGTH('f) &lt; Float.exponent f"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>is_denormal_FloatD</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>is_denormal_Float_def</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span>  </span><span>is_denormal_Float_def</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_finite_Float</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float itself ⇒ Float.float ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_finite_Float x f ⟷ is_normal_Float x f ∨ is_denormal_Float x f ∨ f = 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_finite_Float_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_finite_Float TYPE(('e, 'f)float) f ⟷
    (let e = Float.exponent f; bm = bitlen (abs (mantissa f))
    in bm ≤ Suc LENGTH('f) ∧
     bm ≤ 2 ^ (LENGTH('e) - 1) - e ∧
     1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) &lt; e)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(2::int) ^ (LENGTH('e) - Suc 0) - 1 &lt; 2 ^ LENGTH('e)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_1</span><span> </span><span>diff_le_self</span><span> </span><span>lessI</span><span> </span><span>linorder_not_less</span><span> </span><span>one_less_numeral_iff</span><span>
</span><span>        </span><span>power_strict_increasing_iff</span><span> </span><span>zle_diff1_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 - 2 ^ (LENGTH('e) - Suc 0) &lt; int LENGTH('f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>len_gt_0</span><span> </span><span>of_nat_0_less_iff</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>***</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ^ (LENGTH('e) - 1) + 1 =
    2 ^ LENGTH('e) - int (bias TYPE(('e, 'f) IEEE.float))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bias_def</span><span> </span><span>power_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rewr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ 2 ^ n - e ⟷ x + e &lt; 2 ^ n + 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>int</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span> </span><span>e</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>***</span><span> </span><span>rewr</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>**</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_finite_Float_def</span><span> </span><span>is_normal_Float_def</span><span> </span><span>is_denormal_Float_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>bias_def</span><span> </span><span>mantissa_eq_zero_iff</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>le_less_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>add_right_mono</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>normal_of_Float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"Float.float ⇒ ('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. let m = mantissa x; e = Float.exponent x in
    (if m &gt; 0 then 0 else 1,
      word_of_int (e + int (bias TYPE(('e, 'f)float)) + bitlen ¦m¦ - 1),
      word_of_int (¦m¦ * 2 ^ (Suc LENGTH('f) - nat (bitlen ¦m¦)) - 2 ^ (LENGTH('f))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sign_normal_of_Float</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"sign (normal_of_Float x) = (if x &gt; 0 then 0 else 1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>mantissa_pos_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uints_bitlen_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"uints n = {i. 0 ≤ i ∧ bitlen i ≤ n}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uints_num</span><span> </span><span>bitlen_le_iff_power</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_word_of_int_bitlen_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uint (word_of_int x::'a::len0 word) = x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bitlen x ≤ LENGTH('a)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≥ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>word_uint.Abs_inverse</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uints_bitlen_eq</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fraction_normal_of_Float</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fraction (normal_of_Float x::('e, 'f)float) =
  (nat ¦mantissa x¦ * 2 ^ (Suc LENGTH('f) - nat (bitlen ¦mantissa x¦)) - 2 ^ LENGTH('f))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_normal_Float TYPE(('e, 'f)float) x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bmp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bitlen ¦mantissa x¦ &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>abs_of_nonneg</span><span> </span><span>bitlen_bounds</span><span> </span><span>bitlen_def</span><span> </span><span>is_normal_Float_def</span><span> </span><span>nat_code</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>of_nat_0_le_iff</span><span>
</span><span>        </span><span>power.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>zabs_less_one_iff</span><span> </span><span>zero_less_abs_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mless</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦mantissa x¦ &lt; 2 ^ nat (bitlen ¦mantissa x¦)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bitlen_bounds</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ^ nat (bitlen ¦mantissa x¦ - 1) ≤ ¦mantissa x¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bitlen_bounds</span><span> </span><span>is_normal_Float_def</span><span> </span><span>that</span><span> </span><span>zero_less_abs_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nble</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat (bitlen ¦mantissa x¦) ≤ Suc LENGTH('f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bitlen_bounds</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_normal_Float_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ ¦mantissa x¦ * 2 ^ (Suc LENGTH('f) - nat (bitlen ¦mantissa x¦)) - 2 ^ LENGTH('f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_le_imp_le_diff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mult_right_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lem</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>power_add</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nble</span><span> </span><span>bmp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦mantissa x¦ * 2 ^ (Suc LENGTH('f) - nat (bitlen ¦mantissa x¦)) &lt; 2 * 2 ^ LENGTH('f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>less_le_trans</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mult_strict_right_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mless</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>power_add</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>power_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>power_increasing</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nble</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bitlen (¦mantissa x¦ * 2 ^ (Suc LENGTH('f) - nat (bitlen ¦mantissa x¦)) - 2 ^ LENGTH('f))
    ≤ int LENGTH('f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bitlen_le_iff_power</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span>split_beta'</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>uint_nat</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>unat_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nn</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>uint_word_of_int_bitlen_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_mult_distrib</span><span> </span><span>nat_diff_distrib</span><span> </span><span>nat_power_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exponent_normal_of_Float</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"exponent (normal_of_Float x::('e, 'f)float) =
  nat (Float.exponent x + (bias TYPE(('e, 'f)float)) + bitlen ¦mantissa x¦ - 1)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_normal_Float TYPE(('e, 'f)float) x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_normal_Float_def</span><span> </span><span>bitlen_le_iff_power</span><span> </span><span>uint_word_of_int_bitlen_eq</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span>uint_nat</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>unat_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>denormal_of_Float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"Float.float ⇒ ('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. let m = mantissa x; e = Float.exponent x in
  (if m ≥ 0 then 0 else 1, 0,
    word_of_int (¦m¦ * 2 ^ nat (e + bias TYPE(('e, 'f)float) + fracwidth TYPE(('e, 'f)float) - 1)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sign_denormal_of_Float</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"sign (denormal_of_Float x) = (if x ≥ 0 then 0 else 1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>mantissa_nonneg_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exponent_denormal_of_Float</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"exponent (denormal_of_Float x::('e, 'f)float) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fraction_denormal_of_Float</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fraction (denormal_of_Float x::('e, 'f)float) =
  (nat ¦mantissa x¦ * 2 ^ nat (Float.exponent x + bias TYPE(('e, 'f)float) + LENGTH('f) - 1))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_denormal_Float TYPE(('e, 'f)float) x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mless</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦mantissa x¦ &lt; 2 ^ nat (bitlen ¦mantissa x¦)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bitlen_bounds</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat (bitlen ¦mantissa x¦) +
    nat (Float.exponent x + (2 ^ (LENGTH('e) - Suc 0) + int LENGTH('f)) - 2)
    ≤ LENGTH('f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_denormal_Float_def</span><span> </span><span>nat_diff_distrib'</span><span> </span><span>le_diff_conv</span><span>
</span><span>        </span><span>bitlen_nonneg</span><span> </span><span>nat_le_iff</span><span> </span><span>bias_def</span><span> </span><span>nat_add_distrib</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦mantissa x¦ *  2 ^ nat (Float.exponent x + int (bias TYPE(('e, 'f)float)) +
    LENGTH('f) - 1) &lt; 2 ^ LENGTH('f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>less_le_trans</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mult_strict_right_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mless</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>power_add</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>power_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>power_increasing</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bias_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>*</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_denormal_Float_def</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span>split_beta'</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>uint_nat</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>unat_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>uint_word_of_int_bitlen_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bitlen_le_iff_power</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_mult_distrib</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>of_finite_Float</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"Float.float ⇒ ('e, 'f) float"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"of_finite_Float x = (if is_normal_Float TYPE(('e, 'f)float) x then normal_of_Float x
    else if is_denormal_Float TYPE(('e, 'f)float) x then denormal_of_Float x
    else 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valof_normal_of_Float</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (normal_of_Float x::('e, 'f)float) = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_normal_Float TYPE(('e, 'f)float) x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (normal_of_Float x::('e, 'f)float) =
    (- 1) ^ sign (normal_of_Float x::('e, 'f)float) *
    ((1 + real (nat ¦mantissa x¦ * 2 ^ (Suc LENGTH('f) - nat (bitlen ¦mantissa x¦)) - 2 ^ LENGTH('f)) / 2 ^ LENGTH('f)) *
      2 powr (bitlen ¦mantissa x¦ - 1)) *
    2 powr Float.exponent x"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?s * ?m * ?e"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_normal_Float_def</span><span> </span><span>valof_eq</span><span> </span><span>fraction_normal_of_Float</span><span>
</span><span>        </span><span>powr_realpow</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>exponent_normal_of_Float</span><span> </span><span>powr_diff</span><span> </span><span>powr_add</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦mantissa x¦ &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_normal_Float_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ^ LENGTH('f) ≤ nat ¦mantissa x¦ * 2 ^ (Suc LENGTH('f) - nat (bitlen ¦mantissa x¦))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(2::nat) ^ LENGTH('f) ≤ 2 ^ nat (bitlen ¦mantissa x¦ - 1) * 2 ^ (Suc LENGTH('f) - nat (bitlen ¦mantissa x¦))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>power_add</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ nat ¦mantissa x¦ * 2 ^ (Suc LENGTH('f) - nat (bitlen ¦mantissa x¦))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bitlen_bounds</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦mantissa x¦"</span></span></span><span class="delimiter">]</span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_normal_Float_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?m = abs (mantissa x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>of_nat_diff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bound</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>powr_realpow</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>powr_add</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>is_normal_Float_def</span><span> </span><span>bitlen_nonneg</span><span> </span><span>of_nat_diff</span><span> </span><span>divide_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mantissa_exponent</span><span> </span><span>sign_normal_of_Float</span><span> </span><span>abs_real_def</span><span> </span><span>zero_less_mult_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valof_denormal_of_Float</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (denormal_of_Float x::('e, 'f)float) = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_denormal_Float TYPE(('e, 'f)float) x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; Float.exponent x + (int (bias TYPE(('e, 'f) IEEE.float)) + int LENGTH('f))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_denormal_Float_def</span><span> </span><span>bias_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valof (denormal_of_Float x::('e, 'f)float) =
    ((- 1) ^ sign (denormal_of_Float x::('e, 'f)float) * ¦real_of_int (mantissa x)¦) *
    (2 powr real (nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) + int LENGTH('f) - 1)) /
      (2 powr real (bias TYPE(('e, 'f) IEEE.float)) * 2 powr LENGTH('f)) * 2)"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?m * ?e"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valof_eq</span><span> </span><span>exponent_denormal_of_Float</span><span> </span><span>fraction_denormal_of_Float</span><span> </span><span>that</span><span>
</span><span>        </span><span>mantissa_exponent</span><span> </span><span>powr_realpow</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?m = mantissa x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sign_denormal_of_Float</span><span> </span><span>abs_real_def</span><span> </span><span>mantissa_neg_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?e = 2 powr Float.exponent x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>powr_add</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>divide_simps</span><span> </span><span>powr_mult_base</span><span> </span><span>less</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mantissa_exponent</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valof_of_finite_Float</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_finite_Float (TYPE(('e, 'f) IEEE.float)) x ⟹ valof (of_finite_Float x::('e, 'f)float) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>of_finite_Float_def</span><span> </span><span>is_finite_Float_def</span><span> </span><span>valof_denormal_of_Float</span><span> </span><span>valof_normal_of_Float</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_normal_normal_of_Float</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_normal (normal_of_Float x::('e, 'f)float)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_normal_Float TYPE(('e, 'f)float) x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_normal_def</span><span> </span><span>exponent_normal_of_Float</span><span> </span><span>that</span><span> </span><span>is_normal_Float_def</span><span>
</span><span>      </span><span>emax_eq</span><span> </span><span>nat_less_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_denormal_denormal_of_Float</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_denormal (denormal_of_Float x::('e, 'f)float)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_denormal_Float TYPE(('e, 'f)float) x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_denormal_def</span><span> </span><span>exponent_denormal_of_Float</span><span> </span><span>that</span><span> </span><span>is_denormal_Float_def</span><span>
</span><span>      </span><span>emax_eq</span><span> </span><span>fraction_denormal_of_Float</span><span> </span><span>le_nat_iff</span><span> </span><span>bias_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_finite_of_finite_Float</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite (of_finite_Float x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_finite_def</span><span> </span><span>of_finite_Float_def</span><span> </span><span>is_normal_normal_of_Float</span><span>
</span><span>      </span><span>is_denormal_denormal_of_Float</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Float_eq_zero_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Float m e = 0 ⟷ m = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Float.compute_is_float_zero</span><span> </span><span>Float_0_eq_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bitlen_mantissa_Float</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bitlen ¦mantissa (Float m e)¦ = (if m = 0 then 0 else bitlen ¦m¦ + e) - Float.exponent (Float m e)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bitlen_Float</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>e</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exponent_Float</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Float.exponent (Float m e) = (if m = 0 then 0 else bitlen ¦m¦ + e) - bitlen ¦mantissa (Float m e)¦ "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bitlen_Float</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>e</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_normal_Float_normal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_normal_Float TYPE(('e, 'f)float) (Float (normal_mantissa x) (normal_exponent x))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_normal x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f = Float (normal_mantissa x) (normal_exponent x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ≠ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>f_def</span><span> </span><span>is_normal_def</span><span> </span><span>zero_float_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span>Float_eq_zero_iff</span><span> </span><span>normal_mantissa_def</span><span> </span><span>add_nonneg_eq_0_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>denormalize_shift</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f_def</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"normal_mantissa x = mantissa f * 2 ^ i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"normal_exponent x = Float.exponent f - int i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mantissa f ≠ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ≠ 0›</span></span></span><span> </span><span>i</span><span> </span><span>mantissa_eq_zero_iff</span><span> </span><span>Float_eq_zero_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"normal_exponent x ≤ Float.exponent f"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" bitlen ¦mantissa f¦ ≤ 1 + int LENGTH('f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bitlen_mantissa_Float</span><span> </span><span>bitlen_normal_mantissa</span><span> </span><span>f_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"- int (bias TYPE(('e, 'f)float)) - bitlen ¦mantissa f¦ + 1 &lt; Float.exponent f"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bitlen_mantissa_Float</span><span> </span><span>bitlen_normal_mantissa</span><span> </span><span>f_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mantissa_eq_zero_iff</span><span> </span><span>abs_mult</span><span> </span><span>bias_def</span><span> </span><span>normal_mantissa_def</span><span> </span><span>normal_exponent_def</span><span>
</span><span>        </span><span>is_normal_def</span><span> </span><span>emax_eq</span><span> </span><span>less_diff_conv</span><span> </span><span>add_nonneg_eq_0_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ^ (LENGTH('e) - Suc 0) + - (1::int) * 2 ^ LENGTH('e) ≤ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(2::int) ^ (LENGTH('e) - Suc 0) &lt; 1 + 2 ^ LENGTH('e)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Float.exponent f &lt;
      2 ^ LENGTH('e) - bitlen ¦mantissa f¦ - int (bias TYPE(('e, 'f)float))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal_exponent_bounds_int</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bitlen_mantissa_Float</span><span> </span><span>bitlen_normal_mantissa</span><span> </span><span>f_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bias_def</span><span> </span><span>algebra_simps</span><span> </span><span>power_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>le_less_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>add_right_mono</span><span class="delimiter">]</span><span> </span><span>normal_exponent_bounds_int</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_normal_Float_def</span><span> </span><span>f_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_denormal_Float_denormal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_denormal_Float TYPE(('e, 'f)float)
    (Float (denormal_mantissa x) (denormal_exponent TYPE(('e, 'f)float)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_denormal x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f = Float (denormal_mantissa x) (denormal_exponent TYPE(('e, 'f)float))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ≠ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>f_def</span><span> </span><span>is_denormal_def</span><span> </span><span>zero_float_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span>Float_eq_zero_iff</span><span> </span><span>denormal_mantissa_def</span><span> </span><span>add_nonneg_eq_0_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>denormalize_shift</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f_def</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"denormal_mantissa x = mantissa f * 2 ^ i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"denormal_exponent TYPE(('e, 'f)float) = Float.exponent f - int i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mantissa f ≠ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ≠ 0›</span></span></span><span> </span><span>i</span><span> </span><span>mantissa_eq_zero_iff</span><span> </span><span>Float_eq_zero_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bitlen ¦mantissa f¦ ≤ 1 - Float.exponent f - int (bias TYPE(('e, 'f) IEEE.float))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹mantissa f ≠ 0›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span> </span><span>bitlen_mantissa_Float</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bitlen_denormal_mantissa</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>denormal_exponent_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) ≤ Float.exponent f"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l ≤ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l ≤ denormal_exponent TYPE(('e, 'f)float) + i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_denormal_def</span><span> </span><span>bias_def</span><span> </span><span>denormal_exponent_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = Float.exponent f"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_denormal_Float_def</span><span> </span><span>exponent_Float</span><span> </span><span>f_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_finite_Float_of_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite_Float TYPE(('e, 'f)float) (of_finite x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('e, 'f)float"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_finite_Float_def</span><span> </span><span>of_finite_def</span><span> </span><span>is_normal_Float_normal</span><span>
</span><span>      </span><span>is_denormal_Float_denormal</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Double">
<div class="head"><h1>Theory Double</h1>
<span class="command">theory</span> <span class="name">Double</span><br/>
<span class="keyword">imports</span> <a href="Conversion_IEEE_Float.html"><span class="name">Conversion_IEEE_Float</span></a> <a href="Monad_Syntax.html"><span class="name">Monad_Syntax</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Lei Yu, University of Cambridge *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Code Generation Setup for Floats›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Double</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>Conversion_IEEE_Float</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Monad_Syntax"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Code_Target_Numeral"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A type for code generation to SML/OCaml›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span>double</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV::(11, 52) float set"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_double</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>double</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"{uminus,plus,times,minus,zero,one,abs,ord,inverse}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>uminus_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ double"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>uminus</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>plus_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ double ⇒ double"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>plus</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>times_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ double ⇒ double"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>times</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>divide_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ double ⇒ double"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>divide</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>inverse_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ double"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>inverse</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>minus_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ double ⇒ double"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>minus</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>zero_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>one_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>less_eq_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ double ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>less_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ double ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>eq_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double⇒double⇒bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>float_eq</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>sqrt_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double⇒double"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>float_sqrt</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>plus_infinity</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"∞"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>infinity_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"∞"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>plus_infinity</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>is_normal</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>IEEE.is_normal</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>is_zero</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>IEEE.is_zero</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>is_finite</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>IEEE.is_finite</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>is_nan</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>IEEE.is_nan</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">type_constructor</span></span><span> </span><span>double</span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"float"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 :: double"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"0.0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"0.0"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>zero_double.abs_eq</span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 :: double"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"1.0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"1.0"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>one_double.abs_eq</span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_double :: double ⇒ double ⇒ bool"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Real.== ((_:real), (_))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pervasives.(=)"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>eq_double.abs_eq</span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Orderings.less_eq :: double ⇒ double ⇒ bool"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Real.&lt;= ((_), (_))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pervasives.(&lt;=)"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>less_double_def</span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Orderings.less :: double ⇒ double ⇒ bool"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Real.&lt; ((_), (_))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pervasives.(&lt;)"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>less_eq_double_def</span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(+) :: double ⇒ double ⇒ double"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Real.+ ((_), (_))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pervasives.( +. )"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>plus_double_def</span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(*) :: double ⇒ double ⇒ double"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Real.* ((_), (_))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pervasives.( *. )"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>times_double_def</span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(-) :: double ⇒ double ⇒ double"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Real.- ((_), (_))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pervasives.( -. )"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>minus_double_def</span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uminus :: double ⇒ double"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Real.~"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pervasives.( ~-. )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(/) :: double ⇒ double ⇒ double"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Real.'/ ((_), (_))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pervasives.( '/. )"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>divide_double_def</span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sqrt_double :: double ⇒ double"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Math.sqrt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pervasives.sqrt"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>sqrt_def</span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"infinity_double :: double"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Real.posInf"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>infinity_double.abs_eq</span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_normal :: double ⇒ bool"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Real.isNormal"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>code</span><span> </span><span>drop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_normal"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite :: double ⇒ bool"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Real.isFinite"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>code</span><span> </span><span>drop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_finite"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_nan :: double ⇒ bool"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Real.isNan"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>code</span><span> </span><span>drop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_nan"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Mapping natural numbers to doubles.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>float_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ double"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"float_of 0 = 0"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"float_of (Suc n) = float_of n + 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"float_of 2 &lt; float_of 3 + float_of 4"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>float_of</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Conversion from int›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>double_of_int</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"int ⇒ double"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λi. round To_nearest (real_of_int i)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>integer.lifting</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>double_of_integer</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"integer ⇒ double"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>double_of_int</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>float_of_int</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"double_of_int i = double_of_integer (integer_of_int i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>double_of_integer_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"double_of_integer :: integer ⇒ double"</span></span></span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Real.fromLargeInt"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>code</span><span> </span><span>drop</span><span class="delimiter">:</span><span> </span><span>double_of_integer</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Conversion to and from software floats, extracting information›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Need to trust a lot of code here...›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_finite_double_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_finite_Float TYPE((11, 52)float) f ⟷
    (let e = Float.exponent f; bm = bitlen (abs (mantissa f))
    in (bm ≤ 53 ∧ e + bm &lt; 1025 ∧ - 1075 &lt; e))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_finite_Float_eq</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">code_module</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"IEEE_Mantissa_Exponent"</span></span></span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‹
structure IEEE_Mantissa_Exponent =
struct
fun to_man_exp_double x =
  if Real.isFinite x
  then case Real.toManExp x of {man = m, exp = e} =&gt;
    SOME (Real.floor (Real.* (m, Math.pow (2.0, 53.0))), IntInf.- (e, 53))
  else NONE
fun normfloat (m, e) =
(if m mod 2 = 0 andalso m &lt;&gt; 0 then normfloat (m div 2, e + 1)
 else if m = 0 then (0, 0) else (m, e))
fun bitlen x = (if 0 &lt; x then bitlen (x div 2) + 1 else 0)
fun is_finite_double_eq m e =
  let
    val (m, e) = normfloat (m, e)
    val bm = bitlen (abs m)
  in bm &lt;= 53 andalso e + bm &lt; 1025 andalso e &gt; ~1075 end
fun from_man_exp_double m e =
  if is_finite_double_eq m e
  then SOME (Real.fromManExp {man = Real.fromLargeInt m, exp = e})
  else NONE
end
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>of_finite</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ Float.float"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>Conversion_IEEE_Float.of_finite</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>man_exp_of_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ (integer * integer)option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"man_exp_of_double d = (if is_finite d then let f = of_finite d in
    Some (integer_of_int (mantissa f), integer_of_int (Float.exponent f)) else None)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>of_finite_Float</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"Float.float ⇒ double"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>Conversion_IEEE_Float.of_finite_Float</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>double_of_man_exp</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"integer ⇒ integer ⇒ double option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"double_of_man_exp m e = (let f = Float (int_of_integer m) (int_of_integer e) in
    if is_finite_Float TYPE((11, 52)float) f
    then Some (of_finite_Float f)
    else None)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"man_exp_of_double :: double ⇒ (integer * integer) option"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>    </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"IEEE'_Mantissa'_Exponent.to'_man'_exp'_double"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"double_of_man_exp :: integer ⇒ integer ⇒ double option"</span></span></span><span> </span><span class="delimiter">⇀</span><span>
</span><span>    </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"IEEE'_Mantissa'_Exponent.from'_man'_exp'_double"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>code</span><span> </span><span>drop</span><span class="delimiter">:</span><span> </span><span>man_exp_of_double</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>code</span><span> </span><span>drop</span><span class="delimiter">:</span><span> </span><span>double_of_man_exp</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>Float_of_double</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"double ⇒ Float.float option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"λx. if is_finite x then Some (of_finite x) else None"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>double_of_Float</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"Float.float ⇒ double option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"λx. if is_finite_Float TYPE((11, 52)float) x then Some (of_finite_Float x) else None"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compute_Float_of_double</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Float_of_double x =
    map_option (λ(m, e). Float (int_of_integer m) (int_of_integer e)) (man_exp_of_double x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>man_exp_of_double_def</span><span> </span><span>Let_def</span><span> </span><span>mantissa_exponent</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span>Float_mantissa_exponent</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compute_double_of_Float</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"double_of_Float f = double_of_man_exp (integer_of_int (mantissa f)) (integer_of_int (Float.exponent f))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>double_of_man_exp_def</span><span> </span><span>Let_def</span><span> </span><span>Float_mantissa_exponent</span><span> </span><span>int_of_integer_integer_of_int</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"check_conversion m e =
  (let f = Float (int_of_integer m) (int_of_integer e) in
    do {
      d ← double_of_Float f;
      Float_of_double d
    } = (if is_finite_Float TYPE((11, 52)float) f then Some f else None))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>check_all</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat ⇒ (nat ⇒ bool) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"check_all 0 P ⟷ True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"check_all (Suc i) P ⟷ P i ∧ check_all i P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"check_conversions dm de =
  check_all (nat (2 * de)) (λe. check_all (nat (2 * dm)) (λm.
    check_conversion (integer_of_int (int m - dm)) (integer_of_int (int e - de))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"check_conversions 100 100"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>